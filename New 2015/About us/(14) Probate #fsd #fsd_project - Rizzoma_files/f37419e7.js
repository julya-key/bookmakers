(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",function(require,module,exports,__dirname,__filename,process,global){function filter (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (fn(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length; i >= 0; i--) {
    var last = parts[i];
    if (last == '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Regex to split a filename into [*, dir, basename, ext]
// posix version
var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
var resolvedPath = '',
    resolvedAbsolute = false;

for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
  var path = (i >= 0)
      ? arguments[i]
      : process.cwd();

  // Skip empty and invalid entries
  if (typeof path !== 'string' || !path) {
    continue;
  }

  resolvedPath = path + '/' + resolvedPath;
  resolvedAbsolute = path.charAt(0) === '/';
}

// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)

// Normalize the path
resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
var isAbsolute = path.charAt(0) === '/',
    trailingSlash = path.slice(-1) === '/';

// Normalize the path
path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }
  
  return (isAbsolute ? '/' : '') + path;
};


// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    return p && typeof p === 'string';
  }).join('/'));
};


exports.dirname = function(path) {
  var dir = splitPathRe.exec(path)[1] || '';
  var isWindows = false;
  if (!dir) {
    // No dirname
    return '.';
  } else if (dir.length === 1 ||
      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {
    // It is just a slash or a drive letter with a slash
    return dir;
  } else {
    // It is a full dirname, strip trailing slash
    return dir.substring(0, dir.length - 1);
  }
};


exports.basename = function(path, ext) {
  var f = splitPathRe.exec(path)[2] || '';
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPathRe.exec(path)[3] || '';
};

});

require.define("__browserify_process",function(require,module,exports,__dirname,__filename,process,global){var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
        && window.setImmediate;
    var canPost = typeof window !== 'undefined'
        && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return window.setImmediate;
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'browserify-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('browserify-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    if (name === 'evals') return (require)('vm')
    else throw new Error('No such module. (Possibly not yet loaded)')
};

(function () {
    var cwd = '/';
    var path;
    process.cwd = function () { return cwd };
    process.chdir = function (dir) {
        if (!path) path = require('path');
        cwd = path.resolve(dir, cwd);
    };
})();

});

require.define("/lib/client/client/utils/history_navigation.js",function(require,module,exports,__dirname,__filename,process,global){
/*
Обертка над history.js, разбирает state'ы на waveId, blipId и не вызывает обработчики,
если был сделан replaceLastState
*/

(function() {
  var EMBEDDED_AUTH_URL, EMBEDDED_PREFIX, GDRIVE_PREFIX, IS_EMBEDDED, PREFIX, WAVE_PREFIX, getSkippedId, getUrl, lastProcessedUrl, lastProcessedWaveId, parseUrlParams, processStateChange, processStateChangeWithAnalytics, self, statesToSkip, urlRe,
    __slice = Array.prototype.slice;

  self = module.exports = {};

  PREFIX = window.PREFIX;

  WAVE_PREFIX = window.WAVE_URL_PREFIX;

  EMBEDDED_PREFIX = window.WAVE_EMBEDDED_URL_PREFIX;

  IS_EMBEDDED = PREFIX === EMBEDDED_PREFIX;

  EMBEDDED_AUTH_URL = window.WAVE_EMBEDDED_AUTH_URL;

  GDRIVE_PREFIX = window.WAVE_DRIVE_PREFIX;

  require('./microevent').mixin(module.exports);

  urlRe = new RegExp(("((https?://" + window.HOST + ")?((" + WAVE_PREFIX + "|" + EMBEDDED_PREFIX + "|" + GDRIVE_PREFIX + ")") + "(?:([a-z0-9]{1,32})/?)?)(?:([a-z0-9_]{1,32})/?)?)");

  statesToSkip = {};

  lastProcessedUrl = null;

  lastProcessedWaveId = null;

  getUrl = function(waveId, blipId) {
    var url;
    url = "" + PREFIX + waveId + "/";
    if (blipId) url += "" + blipId + "/";
    url += document.location.search || '';
    return url;
  };

  self.parseUrlParams = parseUrlParams = function(url) {
    var res;
    res = urlRe.exec(url) || [];
    return {
      url: res[0],
      host: res[2],
      waveUrl: res[3],
      waveId: res[5],
      serverBlipId: res[6]
    };
  };

  getSkippedId = function() {
    var id;
    id = Math.random();
    statesToSkip[id] = true;
    return id;
  };

  processStateChange = function(callback, params) {
    var id, serverBlipId, state, url, waveId, _ref;
    state = History.getState();
    id = state.data.id;
    _ref = params || parseUrlParams(state.url), url = _ref.url, waveId = _ref.waveId, serverBlipId = _ref.serverBlipId;
    if (id && statesToSkip[id]) {
      delete statesToSkip[id];
    } else if (lastProcessedUrl !== url) {
      callback(waveId, serverBlipId);
    }
    lastProcessedUrl = url;
    lastProcessedWaveId = waveId;
    return false;
  };

  processStateChangeWithAnalytics = function(callback) {
    var params, track, url, waveId, waveUrl;
    params = parseUrlParams(History.getState().url);
    url = params.url, waveId = params.waveId, waveUrl = params.waveUrl;
    if (!waveId && lastProcessedUrl !== url) {
      track = window.loggedIn ? waveUrl : '/unauthorized' + waveUrl;
      _gaq.push(['_trackPageview', track]);
    }
    return processStateChange(callback, params);
  };

  self.navigateTo = function(waveId, serverBlipId) {
    /*
        Записываем новое состояние в историю браузера
    */
    var oldState, url;
    oldState = History.getState();
    url = getUrl(waveId, serverBlipId);
    if (oldState.url === url) return;
    if (lastProcessedWaveId !== waveId) {
      return History.pushState(null, oldState.title, url);
    } else {
      return History.replaceState(null, oldState.title, url);
    }
  };

  self.changeBlipId = function(serverBlipId) {
    /*
        Переход к другому блипу.
        @param serverBlipId: string, указывается в url
    */
    var lastState, url, waveId;
    lastState = History.getState();
    waveId = parseUrlParams(lastState.url).waveId;
    if (!waveId) return;
    url = getUrl(waveId, serverBlipId);
    return History.replaceState({
      id: getSkippedId()
    }, lastState.title, url);
  };

  self.init = function(callback) {
    /*
        Вызывается, когда код готов обработать последнее состояние от прошлого запуска
    */
    var state;
    state = History.getState();
    processStateChange(callback);
    History.Adapter.bind(window, 'statechange', function() {
      return processStateChangeWithAnalytics(function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return self.emit.apply(self, ['statechange'].concat(__slice.call(args)));
      });
    });
    return History.replaceState(null, state.title, state.url);
  };

  self.setPageTitle = function(title) {
    var lastState, unreadCount;
    if (title == null) title = false;
    if (title) window.title.topicTitle = title;
    unreadCount = window.title.unreadTopicsCount > 0 ? "(" + window.title.unreadTopicsCount + ") " : '';
    title = "" + unreadCount + window.title.topicTitle + (window.title.topicTitle ? ' - ' : '') + window.title.postfix;
    lastState = History.getState();
    return window.History.replaceState({
      id: getSkippedId()
    }, title, lastState.url);
  };

  self.removeAnalytics = function() {
    /*
        Убирает из url метки, необходимые для аналитики
    */
    var state, url;
    self.analyticsRemoved = true;
    state = History.getState();
    url = parseUrlParams(state.url).url;
    return window.History.replaceState({
      id: getSkippedId()
    }, state.title, url);
  };

  self.getCurrentParams = function() {
    return parseUrlParams(History.getState().url);
  };

  self.getUrlParams = function(url) {
    return parseUrlParams(url);
  };

  self.isEmbedded = function() {
    return IS_EMBEDDED;
  };

  self.isGDrive = function() {
    return PREFIX === GDRIVE_PREFIX;
  };

  self.getEmbeddedPrefix = function() {
    return EMBEDDED_PREFIX;
  };

  self.getWavePrefix = function() {
    return WAVE_PREFIX;
  };

  self.getPrefix = function() {
    return PREFIX;
  };

  self.getLoginRedirectUrl = function() {
    var url;
    if (IS_EMBEDDED) return EMBEDDED_AUTH_URL;
    url = document.location.pathname + document.location.hash;
    if (document.location.search.search(/\?notice=/) !== -1) return url;
    return url + document.location.search;
  };

}).call(this);

});

require.define("/lib/client/client/utils/microevent.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var MicroEvent, nextTick,
    __slice = Array.prototype.slice;

  nextTick = (typeof process !== "undefined" && process !== null ? process.nextTick : void 0) || function(fn) {
    return setTimeout(fn, 0);
  };

  MicroEvent = (function() {

    function MicroEvent() {}

    MicroEvent.prototype.on = function(event, fct) {
      var _base;
      this._events || (this._events = {});
      (_base = this._events)[event] || (_base[event] = []);
      this._events[event].push(fct);
      return this;
    };

    MicroEvent.prototype.removeAllListeners = function() {
      return delete this._events;
    };

    MicroEvent.prototype.removeListener = function(event, fct) {
      var i, listeners, _base;
      this._events || (this._events = {});
      listeners = ((_base = this._events)[event] || (_base[event] = []));
      i = 0;
      while (i < listeners.length) {
        if (listeners[i] === fct) listeners[i] = void 0;
        i++;
      }
      nextTick(function() {
        var x;
        return listeners = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = listeners.length; _i < _len; _i++) {
            x = listeners[_i];
            if (x) _results.push(x);
          }
          return _results;
        })();
      });
      return this;
    };

    MicroEvent.prototype.removeListeners = function(event) {
      this._events || (this._events = {});
      if (this._events.hasOwnProperty(event)) delete this._events[event];
      return this;
    };

    MicroEvent.prototype.emit = function() {
      var args, event, fn, _i, _len, _ref, _ref2;
      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (!((_ref = this._events) != null ? _ref[event] : void 0)) return this;
      _ref2 = this._events[event];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        fn = _ref2[_i];
        if (!fn) continue;
        try {
          fn.apply(this, args);
        } catch (e) {
          console.error.apply(console, [e, event].concat(__slice.call(args)));
        }
      }
      return this;
    };

    return MicroEvent;

  })();

  MicroEvent.mixin = function(obj) {
    var proto;
    proto = obj.prototype || obj;
    proto.on = proto['on'] = MicroEvent.prototype.on;
    proto.removeListener = proto['removeListener'] = MicroEvent.prototype.removeListener;
    proto.removeListeners = proto['removeListeners'] = MicroEvent.prototype.removeListeners;
    proto.removeAllListeners = proto['removeAllListeners'] = MicroEvent.prototype.removeAllListeners;
    proto.emit = MicroEvent.prototype.emit;
    return obj;
  };

  if (typeof module !== "undefined" && module !== null ? module.exports : void 0) {
    module.exports = MicroEvent;
  }

}).call(this);

});

require.define("/lib/client/client/app.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var RootRouter, router;

  window.getLogger = function() {
    return console;
  };

  RootRouter = require('./modules/root_router').RootRouter;

  router = new RootRouter();

  module.exports.router = router;

}).call(this);

});

require.define("/lib/client/client/modules/root_router.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ActiveTopicControls, BaseRootRouter, BlipProcessor, Collection, DomUtils, ErrorLogger, PingAnalytics, Playback, RootRouter, SuccessfulMergePopup, TagProcessor,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  DomUtils = require('../utils/dom');

  BaseRootRouter = require('./root_router_base').BaseRootRouter;

  TagProcessor = require('../tag/processor').TagProcessor;

  PingAnalytics = require('../analytics/ping').PingAnalytics;

  BlipProcessor = require('../blip/processor').BlipProcessor;

  SuccessfulMergePopup = require('../account_merge/merge_successful_message').SuccessfulMergePopup;

  Collection = require('../collection/module').Collection;

  ActiveTopicControls = require('../active_topic_controls/module').ActiveTopicControls;

  ErrorLogger = require('../error_logger/module').ErrorLogger;

  Playback = require('../playback/module').Playback;

  RootRouter = (function(_super) {

    __extends(RootRouter, _super);

    /*
        Класс, представляющий корневой роутер. Знает о всех корневых модулях и всех корневых роутерах.
    */

    function RootRouter() {
      var Navigation, PageError, Wave, args, errorLogger, tagProcessor,
        _this = this;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      RootRouter.__super__.constructor.apply(this, args);
      require('../blip/processor').instance = new BlipProcessor(this);
      module.exports.instance = this;
      tagProcessor = require('../tag/processor').instance = new TagProcessor(this);
      require('../analytics/ping').instance = new PingAnalytics(this);
      Wave = require('./wave').Wave;
      Navigation = require('./navigation').Navigation;
      PageError = require('./page_error').PageError;
      this._addModule('pageError', new PageError(this));
      errorLogger = new ErrorLogger(this);
      this._addModule('errorLogger', errorLogger);
      require('../error_logger/module').instance = errorLogger;
      $(document).ready(function() {
        var collection, wave;
        _this.__blockDangerousEvents();
        if (require('../utils/browser_support').isIe()) {
          DomUtils.addClass(document.body, 'ie');
        }
        if (require('../utils/history_navigation').isGDrive()) {
          DomUtils.addClass(document.body, 'gdrive-view');
        }
        wave = require('./wave').instance = new Wave(_this);
        _this._addModule('wave', wave);
        if (window.loggedIn) _this._addModule('navigation', new Navigation(_this));
        collection = new Collection(_this);
        require('../collection/module').instance = collection;
        _this._addModule('collection', collection);
        _this._addModule('activeTopicControls', new ActiveTopicControls(_this));
        _this._addModule('playback', new Playback(_this));
        tagProcessor.requestTags();
        if (window.showSuccessfulMergePopup) {
          return (new SuccessfulMergePopup()).show();
        }
      });
      window.handle = function(method, args) {
        var Request, request;
        try {
          args = JSON.parse(args);
        } catch (e) {
          console.log("Could not parse arguments", args);
          return;
        }
        Request = require('../../share/communication').Request;
        request = new Request(args, function(err, res) {
          return console.log("Server response is", err, res);
        });
        method = "network." + method;
        console.log("Calling " + method + " with args", args);
        return _this.handle(method, request);
      };
    }

    return RootRouter;

  })(BaseRootRouter);

  module.exports = {
    RootRouter: RootRouter,
    instance: null
  };

}).call(this);

});

require.define("/lib/client/client/utils/dom.js",function(require,module,exports,__dirname,__filename,process,global){(function() {

  module.exports = require('../../share/utils/dom');

}).call(this);

});

require.define("/lib/client/share/utils/dom.js",function(require,module,exports,__dirname,__filename,process,global){
/*
Вспомогательные функции для работы с DOM
*/

(function() {
  var IS_CSS_READY, contains, getCursor, getDeepestLastNode, getElementOffsets, getNodeAndNextSiblings, getParentOffset, getRange, getScrollAmount, insertNextTo, insertNodeAt, moveChildNodesNextTo, moveChildNodesToEnd, moveNodesBefore, moveNodesNextTo, moveNodesToEnd, moveNodesToStart, remove, setCursor, setRange;

  exports.BLOCK_TAGS = {
    ADDRESS: null,
    ARTICLE: null,
    ASIDE: null,
    BLOCKQUOTE: null,
    BODY: null,
    CANVAS: null,
    CAPTION: null,
    COL: null,
    COLGROUP: null,
    DD: null,
    DETAILS: null,
    DIV: null,
    DL: null,
    DT: null,
    FIELDSET: null,
    FIGCAPTION: null,
    FIGURE: null,
    FOOTER: null,
    FORM: null,
    H1: null,
    H2: null,
    H3: null,
    H4: null,
    H5: null,
    H6: null,
    HEADER: null,
    HGROUP: null,
    HR: null,
    LEGEND: null,
    LI: null,
    OL: null,
    OUTPUT: null,
    P: null,
    PRE: null,
    PROGRESS: null,
    SECTION: null,
    TABLE: null,
    TBODY: null,
    TFOOT: null,
    TH: null,
    THEAD: null,
    SUMMARY: null,
    TR: null,
    UL: null
  };

  exports.isElement = function(node) {
    return node.nodeType === 1;
  };

  exports.isTextNode = function(node) {
    return node.nodeType === 3;
  };

  exports.isBlockElement = function(element) {
    return element.tagName in exports.BLOCK_TAGS;
  };

  exports.isAnchorElement = function(element) {
    return element.tagName === 'A';
  };

  exports.isButtonElement = function(element) {
    return (element != null ? element.tagName : void 0) === 'BUTTON';
  };

  exports.isBrElement = function(element) {
    return (element != null ? element.tagName : void 0) === 'BR';
  };

  exports.isFrameElement = function(element) {
    return (element != null ? element.tagName : void 0) === 'FRAME' || (element != null ? element.tagName : void 0) === 'IFRAME';
  };

  exports.parseFromString = function(str) {
    var firstChild, fragment, tmpEl;
    tmpEl = document.createElement('span');
    fragment = document.createDocumentFragment();
    tmpEl.innerHTML = str;
    while (firstChild = tmpEl.firstChild) {
      fragment.appendChild(firstChild);
    }
    return fragment;
  };

  exports.remove = remove = function(element) {
    var _ref;
    return (_ref = element.parentNode) != null ? _ref.removeChild(element) : void 0;
  };

  insertNextTo = module.exports.insertNextTo = function(node, nextTo) {
    /*
        Вставляет узел после указанного
        Возвращает вставленный узел
        @param node: HTMLNode
        @param nextTo: HTMLNode
        @return: HTMLNode
    */
    var parentNode, siblingNode;
    parentNode = nextTo.parentNode;
    if (!parentNode) return;
    siblingNode = nextTo != null ? nextTo.nextSibling : void 0;
    if (siblingNode) {
      parentNode.insertBefore(node, siblingNode);
    } else {
      parentNode.appendChild(node);
    }
    return node;
  };

  moveNodesNextTo = module.exports.moveNodesNextTo = function(nodes, nextTo) {
    /*
        Переносит указанные узлы вслед за nextTo
        @param nodes: HTMLNode
        @param nodes: [HTMLNode]
        @param nextTo: HTMLNode
    */
    var node, _i, _len, _results;
    if (!(nodes instanceof Array)) nodes = [nodes];
    _results = [];
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      node = nodes[_i];
      insertNextTo(node, nextTo);
      _results.push(nextTo = node);
    }
    return _results;
  };

  moveChildNodesToEnd = module.exports.moveChildNodesToEnd = function(toNode, fromNode) {
    /*
        Переносит узлы из одной вершины в конец другой
        @param toNode: HTMLNode, узел-приемник
        @param fromNode: [HTMLNode], узел-источник
    */
    var childNode, nextChild, _results;
    childNode = fromNode.firstChild;
    _results = [];
    while (childNode) {
      nextChild = childNode.nextSibling;
      toNode.appendChild(childNode);
      _results.push(childNode = nextChild);
    }
    return _results;
  };

  moveNodesToEnd = module.exports.moveNodesToEnd = function(toNode, nodes) {
    /*
        Переносит указанные узлы в конец указанной вершины
        @param toNode: HTMLNode, узел-приемник
        @param nodes: [HTMLNode], переносимые узлы
    */
    var node, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      node = nodes[_i];
      _results.push(toNode.appendChild(node));
    }
    return _results;
  };

  moveNodesToStart = module.exports.moveNodesToStart = function(toNode, nodes) {
    /*
        Переносит указанные узлы в начало указанной вершины
        @param toNode: HTMLNode, узел-приемни
        @param nodes: [HTMLNode], переносимые узлы
    */
    var firstChild, node, _i, _len, _results;
    firstChild = toNode.firstChild;
    if (!firstChild) {
      moveNodesToEnd(toNode, nodes);
      return;
    }
    _results = [];
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      node = nodes[_i];
      _results.push(toNode.insertBefore(node, firstChild));
    }
    return _results;
  };

  moveChildNodesNextTo = module.exports.moveChildNodesNextTo = function(nextToNode, fromNode) {
    /*
        Вставляет узлы из одной вершины после другой
        @param nextToNode: HTMLNode, узел, после которого вставлять
        @param fromNode: HTMLNode, узел, детей которого переносить
    */
    var curNode, _results;
    _results = [];
    while (fromNode.firstChild) {
      curNode = fromNode.firstChild;
      insertNextTo(fromNode.firstChild, nextToNode);
      _results.push(nextToNode = curNode);
    }
    return _results;
  };

  moveNodesBefore = module.exports.moveNodesBefore = function(nodes, beforeNode) {
    var node, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      node = nodes[_i];
      _results.push(beforeNode.parentNode.insertBefore(node, beforeNode));
    }
    return _results;
  };

  getNodeAndNextSiblings = module.exports.getNodeAndNextSiblings = function(node) {
    /*
        Возвращает всех "правых" соседей ноды (nextSibling)
        @param node: HTMLNode
        @return [HTMLNode]
    */
    var res;
    res = [];
    while (node) {
      res.push(node);
      node = node.nextSibling;
    }
    return res;
  };

  getDeepestLastNode = module.exports.getDeepestLastNode = function(node) {
    /*
        Возвращает самого вложенного из последних наследников указнной ноды
        Возвращает саму ноду, если у нее нет наследников
        Не заходит внутрь нод, у которых contentEditable == false
        @param node: HTMLNode
        @return: HTMLNode
    */    if (node.contentEditable === 'false') return node;
    if (!node.lastChild) return node;
    return getDeepestLastNode(node.lastChild);
  };

  contains = module.exports.contains = function(container, selectedNode) {
    /*
        Возврващает true, если selectedNode содержится внутри container
        @param container: HTMLElement
        @param selectedNode: HTMLElement
        @return: boolean
    */    if (!selectedNode) return false;
    if (!container.compareDocumentPosition) {
      return container.contains(selectedNode);
    }
    return !!(container.compareDocumentPosition(selectedNode) & Node.DOCUMENT_POSITION_CONTAINED_BY);
  };

  getCursor = module.exports.getCursor = function() {
    /*
        Возвращает текущее положение курсора
        @return: [HTMLNode, int]|null
    */
    var range;
    range = getRange();
    if (range === null) return null;
    return [range.startContainer, range.startOffset];
  };

  setCursor = module.exports.setCursor = function(cursor) {
    /*
        Устанавливает положение курсора
        @param cursor: [HTMLNode, int]
    */
    var range;
    range = document.createRange();
    range.setStart(cursor[0], cursor[1]);
    range.setEnd(cursor[0], cursor[1]);
    return setRange(range);
  };

  setRange = module.exports.setRange = function(range, directionForward) {
    var r, selection, startContainer, startOffset;
    if (directionForward == null) directionForward = true;
    /*
        Устанавливает выбранную часть элементов
        @param range: HTMLRange
    */
    selection = window.getSelection();
    selection.removeAllRanges();
    if (directionForward || !(selection.extend != null)) {
      return selection.addRange(range);
    } else {
      r = range.cloneRange();
      startContainer = r.startContainer;
      startOffset = r.startOffset;
      r.collapse(false);
      selection.addRange(r);
      return selection.extend(startContainer, startOffset);
    }
  };

  getRange = module.exports.getRange = function() {
    /*
        Возвращает текущую выбранную часть элементов
        Если ничего не выбрано, возвращает null
        @return HTMLRange|null
    */
    var selection;
    selection = window.getSelection();
    if (selection.rangeCount) {
      return selection.getRangeAt(0);
    } else {
      return null;
    }
  };

  module.exports.findAndBind = function($container, selector, event, handler) {
    var btn;
    btn = $container.find(selector);
    btn.bind(event, handler);
    return btn[0];
  };

  exports.getParentOffset = getParentOffset = function(node) {
    /*
        Возвращает индекс переданной ноды в родильской ноде
        @param node: HTMLNode
        @returns: int
    */
    var child, offset;
    offset = 0;
    child = node.parentNode.firstChild;
    while (child !== node) {
      child = child.nextSibling;
      offset++;
    }
    return offset;
  };

  exports.convertWindowCoordsToRelative = function(coord, relative) {
    /*
        Приводит координаты объекта coord от body к элементу relative
        @param coord: Object {top: int, left: int, bottom: int, right: int}
        @param relative: HtmlElement
    */
    var current, leftWidth, offsetLeft, offsetTop, scrollLeft, scrollTop, style, topWidth;
    offsetTop = offsetLeft = scrollTop = scrollLeft = 0;
    current = relative;
    while (current) {
      if (current.scrollTop) scrollTop += current.scrollTop;
      if (current.scrollLeft) scrollLeft += current.scrollLeft;
      if (current === relative) {
        style = window.getComputedStyle(relative);
        if (relative.offsetTop) offsetTop += relative.offsetTop;
        if (topWidth = parseInt(style.borderTopWidth, 10)) offsetTop += topWidth;
        if (relative.offsetLeft) offsetLeft += relative.offsetLeft;
        if (leftWidth = parseInt(style.borderLeftWidth, 10)) {
          offsetLeft += leftWidth;
        }
        relative = relative.offsetParent;
      }
      current = current.parentNode;
    }
    coord.top -= offsetTop - scrollTop;
    coord.bottom -= offsetTop - scrollTop;
    coord.left -= offsetLeft - scrollLeft;
    return coord.right -= offsetLeft - scrollLeft;
  };

  exports.hasClass = function(el, value) {
    var className;
    if (el.classList) return el.classList.contains(value);
    value = ' ' + value + ' ';
    className = ' ' + el.className + ' ';
    return className.indexOf(value) > -1;
  };

  exports.removeClass = function(el, value) {
    var className;
    if (el.classList) return el.classList.remove(value);
    className = (' ' + el.className + ' ').replace(/[\n\t\r]/g, ' ').replace(' ' + value + ' ', ' ').trim();
    if (className === el.className) return;
    return el.className = className;
  };

  exports.addClass = function(el, value) {
    if (el.classList) return el.classList.add(value);
    if (exports.hasClass(el, value)) return;
    return el.className = ("" + el.className + "  " + value).trim();
  };

  exports.insertNodeAt = insertNodeAt = function(node, parent, parentOffset) {
    /*
        @param node: HTMLNode
        @param parent: HTMLElement
        @param parentOffset: int
    */    switch (parentOffset) {
      case 0:
        return parent.insertBefore(node, parent.firstChild);
      case parent.childNodes.length:
        return parent.appendChild(node);
      default:
        return parent.insertBefore(node, parent.childNodes[parentOffset]);
    }
  };

  exports.getElementOffsets = getElementOffsets = function(element) {
    /*
        Возвращает смещение элемента относительно документа
    */
    var left, top;
    top = 0;
    left = 0;
    while (element) {
      top += element.offsetTop;
      left += element.offsetLeft;
      element = element.offsetParent;
    }
    return {
      top: top,
      left: left
    };
  };

  getScrollAmount = function(view, scrollableTarget, scrollToTop, offset) {
    var targetOffsets, viewOffsets;
    viewOffsets = getElementOffsets(view);
    targetOffsets = getElementOffsets(scrollableTarget);
    return viewOffsets.top - targetOffsets.top + offset;
  };

  exports.scrollTargetIntoView = function(view, scrollableTarget, scrollToTop, offset) {
    var scrollAmount;
    if (offset == null) offset = 0;
    /*
        Скролирует элемент scrollableTarget к элементу view
        @param view: HTMLElement - целевой элемент, который скроллируем
        @param scrollableTarget: HTMLElement - скроллируемый элемент
        @param scrollToTop: boolean - NOT IMPLEMENTED(скроллирует строго к вверху) скролировать к верху или к низу целевому элементу
        @param offset: int - дополнительное смещение
    */
    scrollAmount = getScrollAmount(view, scrollableTarget, scrollToTop, offset);
    if (scrollableTarget === document.body) {
      document.documentElement.scrollTop = scrollAmount;
    }
    return scrollableTarget.scrollTop = scrollAmount;
  };

  exports.scrollTargetIntoViewWithAnimation = function(view, scrollableTarget, scrollToTop, offset) {
    var scrollAmount, target;
    if (offset == null) offset = 0;
    /*
        Скролирует элемент scrollableTarget к элементу view с анимацией
        @param view: HTMLElement - целевой элемент
        @param scrollableTarget: HTMLElement - скроллируемый элемент
        @param scrollToTop: boolean - NOT IMPLEMENTED(скроллирует строго к вверху) скролировать к верху или к низу целевому элементу
        @param offset: int - дополнительное смещение
    */
    scrollAmount = getScrollAmount(view, scrollableTarget, scrollToTop, offset);
    target = [scrollableTarget];
    if (scrollableTarget === document.body) target.push(document.documentElement);
    return $(target).animate({
      scrollTop: scrollAmount
    }, 300);
  };

  exports.empty = function(element) {
    var firstChild;
    while (firstChild = element.firstChild) {
      element.removeChild(firstChild);
    }
    return element;
  };

  exports.includeCssFile = function(href) {
    var head, link;
    head = document.getElementsByTagName('head')[0];
    link = document.createElement('link');
    link.setAttribute('rel', 'stylesheet');
    link.setAttribute('type', 'text/css');
    link.setAttribute('href', href);
    return head.appendChild(link);
  };

  IS_CSS_READY = false;

  exports.isCssReady = function() {
    var display, div, style;
    if (IS_CSS_READY) return IS_CSS_READY;
    div = document.createElement('div');
    div.className = 'fake-element';
    document.body.appendChild(div);
    style = window.getComputedStyle ? window.getComputedStyle(div) : div.currentStyle;
    display = style.display;
    document.body.removeChild(div);
    return IS_CSS_READY = display === 'none';
  };

}).call(this);

});

require.define("/lib/client/client/modules/root_router_base.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var AccountSetupProcessor, BaseRootRouter, BaseRouter, BrowserEvents, ExportProcessor, FileModule, MarketProcessor, MentionsProcessor, NetworkRouter, PublicTopicsProcessor, TasksProcessor, TopicsProcessor, UserProcessor, WaveProcessor, utilsDatetimeInit,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  BaseRouter = require('../../share/base_router').BaseRouter;

  NetworkRouter = require('./network/network_router').NetworkRouter;

  utilsDatetimeInit = require('../../share/utils/datetime').init;

  utilsDatetimeInit('en-Us');

  FileModule = require('../file/module').FileModule;

  WaveProcessor = require('../wave/processor').WaveProcessor;

  UserProcessor = require('../user/processor').UserProcessor;

  TopicsProcessor = require('../search_panel/topic/processor').TopicsProcessor;

  MentionsProcessor = require('../search_panel/mention/processor').MentionsProcessor;

  TasksProcessor = require('../search_panel/task/processor').TasksProcessor;

  PublicTopicsProcessor = require('../search_panel/public_topic/processor').PublicTopicsProcessor;

  MarketProcessor = require('../market_panel/processor').MarketProcessor;

  ExportProcessor = require('../export/processor').ExportProcessor;

  AccountSetupProcessor = require('../account_setup_wizard/processor').AccountSetupProcessor;

  BrowserEvents = require('../utils/browser_events');

  BaseRootRouter = (function(_super) {

    __extends(BaseRootRouter, _super);

    function BaseRootRouter() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      BaseRootRouter.__super__.constructor.apply(this, args);
      module.exports.instance = this;
      require('../wave/processor').instance = new WaveProcessor(this);
      require('../user/processor').instance = new UserProcessor(this);
      require('../search_panel/topic/processor').instance = new TopicsProcessor(this);
      require('../search_panel/mention/processor').instance = new MentionsProcessor(this);
      require('../search_panel/task/processor').instance = new TasksProcessor(this);
      require('../search_panel/public_topic/processor').instance = new PublicTopicsProcessor(this);
      require('../market_panel/processor').instance = new MarketProcessor(this);
      require('../export/processor').instance = new ExportProcessor(this);
      require('../account_setup_wizard/processor').instance = new AccountSetupProcessor(this);
      this._addModule('network', new NetworkRouter(this));
      this._addModule('file', new FileModule(this));
    }

    BaseRootRouter.prototype.__blockDangerousEvents = function() {
      BrowserEvents.addBlocker(document, BrowserEvents.DRAG_ENTER_EVENT);
      BrowserEvents.addBlocker(document, BrowserEvents.DROP_EVENT);
      return document.addEventListener(BrowserEvents.DRAG_OVER_EVENT, function(e) {
        var _ref;
        BrowserEvents.blockEvent(e);
        return (_ref = e.dataTransfer) != null ? _ref.dropEffect = 'none' : void 0;
      }, false);
    };

    BaseRootRouter.prototype.isConnected = function() {
      return this._moduleRegister.network.isConnected();
    };

    return BaseRootRouter;

  })(BaseRouter);

  module.exports = {
    BaseRootRouter: BaseRootRouter,
    instance: null
  };

}).call(this);

});

require.define("/lib/client/share/base_router.js",function(require,module,exports,__dirname,__filename,process,global){
/*
@package: volna
@autor: quark, 2011
*/

(function() {
  var BaseModule, BaseRouter, ModuleNotFoundError, Response,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  BaseModule = require('./base_module').BaseModule;

  ModuleNotFoundError = require('./exceptions').ModuleNotFoundError;

  Response = require('./communication').Response;

  BaseRouter = (function(_super) {

    __extends(BaseRouter, _super);

    /*
        Класс, представляющий базовый роутер.
    */

    function BaseRouter() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      BaseRouter.__super__.constructor.apply(this, args);
      this._moduleRegister = {};
    }

    BaseRouter.prototype.handle = function(procedureName, request) {
      /*
              Находит нужный модуль и вызывает процедуру.
              @param procedureName: string
              @param request: share.communication.Request
      */
      var err, _ref;
      if (!this._executeProcedure(procedureName, request)) {
        err = new ModuleNotFoundError("Module " + procedureName + " not found");
        return request.callback(new Response(err, null, (_ref = request.user) != null ? _ref.id : void 0));
      }
    };

    BaseRouter.prototype.handleBroadcast = function(procedureName, request) {
      /*
              Вызывает процедуру у всех модулей.
              @param procedureName: string
              @param request: Request
      */
      var module, name, _ref, _results;
      _ref = this._moduleRegister;
      _results = [];
      for (name in _ref) {
        module = _ref[name];
        _results.push(module.handle(procedureName, request));
      }
      return _results;
    };

    BaseRouter.prototype._executeProcedure = function(procedureName, request) {
      /*
              Разбирает название процедуры и вызывает ее/передает другому роутеру.
              В случае успеха возвращает true
              @param procedureName: string
              @param request: share.communication.Request
              @return: bool
      */
      var module, parts, prefix;
      parts = procedureName.split('.');
      if (parts.length < 2) return false;
      prefix = parts[0];
      module = this._getModuleByName(prefix);
      if (!module) return;
      this._call(module, this._reduceProcedureName(parts), request);
      return true;
    };

    BaseRouter.prototype._reduceProcedureName = function(parts) {
      return parts.slice(1, parts.length).join('.');
    };

    BaseRouter.prototype._call = function(module, procedureName, request) {
      return module.handle(procedureName, request);
    };

    BaseRouter.prototype._addModule = function(name, module) {
      /*
              Добавляет модуль в реестр.
              @param name: string
              @param module: object
      */      return this._moduleRegister[name] = module;
    };

    BaseRouter.prototype._getModuleByName = function(moduleName) {
      /*
              Возвращает модуль по его имени.
              @param moduleName: string
              @return: object
      */      return this._moduleRegister[moduleName];
    };

    return BaseRouter;

  })(BaseModule);

  module.exports.BaseRouter = BaseRouter;

}).call(this);

});

require.define("/lib/client/share/base_module.js",function(require,module,exports,__dirname,__filename,process,global){
/*
@package: volna
@autor: quark, 2011
*/

(function() {
  var BadParams, BaseModule, PermissionError, ProcedureNotFoundError, Response, VerificationError,
    __slice = Array.prototype.slice;

  ProcedureNotFoundError = require('./exceptions').ProcedureNotFoundError;

  BadParams = require('./exceptions').BadParams;

  PermissionError = require('./exceptions').PermissionError;

  VerificationError = require('./exceptions').VerificationError;

  Response = require('./communication').Response;

  BaseModule = (function() {
    /*
        Класс, представляющий базовый модуль.
    */
    function BaseModule(_rootRouter, _responceClass) {
      this._rootRouter = _rootRouter;
      this._responceClass = _responceClass != null ? _responceClass : Response;
    }

    BaseModule.prototype.handle = function(procedureName, request) {
      /*
              Обрабатывает запрос на выполнение процедуры.
              @param procedureName: string
              @param request: Request
      */
      var err, _ref;
      if (!this._callMethod(procedureName, request)) return;
      err = new ProcedureNotFoundError("Procedure " + procedureName + " not found");
      return request.callback(this._createResponse(err, null, (_ref = request.user) != null ? _ref.id : void 0));
    };

    BaseModule.prototype.v = function(name, expectedArgs, permissions) {
      var procedure;
      if (expectedArgs == null) expectedArgs = [];
      /*
              Устанавливает параметры верификации вызова процедуры.
              @param name: string
              @param expectedArgs: array - список обязательных аргументов
              @param permissions: int - права, требуемые для вызова (по умолчанию не требуются)
      */
      procedure = this[name];
      if (!procedure) return;
      procedure.isVerified = true;
      procedure.expectedArgs = expectedArgs;
      return procedure.permissions = permissions;
    };

    BaseModule.prototype._verifyArgs = function(request, expectedArgs) {
      var arg, notNull, _i, _len;
      if (expectedArgs == null) expectedArgs = [];
      for (_i = 0, _len = expectedArgs.length; _i < _len; _i++) {
        arg = expectedArgs[_i];
        notNull = false;
        if (arg.indexOf('(not_null)')) {
          arg = arg.replace('(not_null)', '');
          notNull = true;
        }
        if (request.args[arg] === void 0) {
          return new BadParams("Expected arg " + arg);
        }
        if (notNull && request.args[arg] === null) {
          return new BadParams("Arg " + arg + " must be not null");
        }
      }
    };

    BaseModule.prototype._verifyPermissions = function(request, permissions) {
      if (!permissions) return;
      if (!request.user.checkPermissions(permissions)) {
        return new PermissionError("Access denied");
      }
    };

    BaseModule.prototype._callMethod = function(name, request) {
      var argsErr, callId, err, listenerId, onRequestProcessed, permissionsErr, procedure, userId, _ref, _ref2,
        _this = this;
      userId = (_ref = request.user) != null ? _ref.id : void 0;
      procedure = this[name];
      if (!procedure) return true;
      argsErr = this._verifyArgs(request, procedure.expectedArgs);
      permissionsErr = this._verifyPermissions(request, procedure.permissions);
      err = argsErr || permissionsErr;
      if (err) {
        request.callback(this._createResponse(err, null, userId));
        return;
      }
      onRequestProcessed = function(err, data) {
        return request.callback(_this._createResponse(err, data, userId));
      };
      callId = (_ref2 = request.args) != null ? _ref2.callId : void 0;
      listenerId = callId ? "" + request.sessionId + callId : null;
      procedure.call(this, request, request.args, onRequestProcessed, listenerId);
    };

    BaseModule.prototype._createResponse = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return typeof result === "object" ? result : child;
      })(this._responceClass, args, function() {});
    };

    return BaseModule;

  })();

  module.exports.BaseModule = BaseModule;

}).call(this);

});

require.define("/lib/client/share/exceptions.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BadParams, BaseError, ModuleNotFoundError, NotImplementedError, PermissionError, ProcedureNotFoundError, VerificationError,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BaseError = (function(_super) {

    __extends(BaseError, _super);

    /*
        Базовый класс исключений.
    */

    function BaseError(message, code) {
      this.message = message;
      this.code = code != null ? code : 0;
      BaseError.__super__.constructor.call(this, this.message);
      if (Error.captureStackTrace) Error.captureStackTrace(this, arguments.callee);
    }

    return BaseError;

  })(Error);

  NotImplementedError = (function(_super) {

    __extends(NotImplementedError, _super);

    /*
        Метод не реализован.
    */

    function NotImplementedError(message, code) {
      if (code == null) code = 0;
      NotImplementedError.__super__.constructor.call(this, message, code);
    }

    return NotImplementedError;

  })(BaseError);

  ModuleNotFoundError = (function(_super) {

    __extends(ModuleNotFoundError, _super);

    /*
        Модуль не найден.
    */

    function ModuleNotFoundError(message, code) {
      if (code == null) code = 0;
      ModuleNotFoundError.__super__.constructor.call(this, message, code);
    }

    return ModuleNotFoundError;

  })(BaseError);

  ProcedureNotFoundError = (function(_super) {

    __extends(ProcedureNotFoundError, _super);

    /*
        Процедура не найдена.
    */

    function ProcedureNotFoundError(message, code) {
      if (code == null) code = 0;
      ProcedureNotFoundError.__super__.constructor.call(this, message, code);
    }

    return ProcedureNotFoundError;

  })(BaseError);

  BadParams = (function(_super) {

    __extends(BadParams, _super);

    /*
        Не верные аргументы вызова.
    */

    function BadParams(message, code) {
      if (code == null) code = 0;
      BadParams.__super__.constructor.call(this, message, code);
    }

    return BadParams;

  })(BaseError);

  PermissionError = (function(_super) {

    __extends(PermissionError, _super);

    /*
        Недотаточно прав для вызова процедуры.
    */

    function PermissionError(message, code) {
      if (code == null) code = 0;
      PermissionError.__super__.constructor.call(this, message, code);
    }

    return PermissionError;

  })(BaseError);

  VerificationError = (function(_super) {

    __extends(VerificationError, _super);

    /*
        Метод не верифицирован.
    */

    function VerificationError(message, code) {
      if (code == null) code = 0;
      VerificationError.__super__.constructor.call(this, message, code);
    }

    return VerificationError;

  })(BaseError);

  module.exports = {
    BaseError: BaseError,
    NotImplementedError: NotImplementedError,
    ModuleNotFoundError: ModuleNotFoundError,
    ProcedureNotFoundError: ProcedureNotFoundError,
    PermissionError: PermissionError,
    VerificationError: VerificationError,
    BadParams: BadParams
  };

}).call(this);

});

require.define("/lib/client/share/communication.js",function(require,module,exports,__dirname,__filename,process,global){
/*
@package: volna
@autor: quark, 2011
Содержит классы rpc-запросов/ответов
*/

(function() {
  var Convertible, Request, Response,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  Convertible = (function() {
    /*
        Базовый класс.
    */
    function Convertible() {
      this._properties = [];
    }

    Convertible.prototype.setProperty = function(name, value) {
      /*
              Добавляет свойство в объект по имени.
      */      this._properties.push(name);
      return this[name] = value;
    };

    Convertible.prototype.serialize = function() {
      /*
              Преобразует инстанс в объект годный для передачи по сети (плоский объект без методов).
              @return: object
      */
      var propertie, result, _i, _len, _ref;
      result = {};
      _ref = this._properties;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        propertie = _ref[_i];
        result[propertie] = this[propertie];
      }
      return result;
    };

    return Convertible;

  })();

  Request = (function(_super) {

    __extends(Request, _super);

    /*
        Класс запроса.
    */

    function Request(args, callback) {
      this.args = args;
      this.callback = callback;
      /*
              @param args: object
              @param callback: function
      */
      Request.__super__.constructor.call(this);
      this._init();
    }

    Request.prototype._init = function() {
      return this._properties = ['args'];
    };

    return Request;

  })(Convertible);

  Response = (function(_super) {

    __extends(Response, _super);

    /*
        Класс ответа.
    */

    function Response(err, data) {
      this.err = err;
      this.data = data;
      /*
              @param data: object - содержимое ответа.
      */
      Response.__super__.constructor.call(this);
      this._init();
    }

    Response.prototype._init = function() {
      return this._properties = ['err', 'data'];
    };

    return Response;

  })(Convertible);

  module.exports = {
    Convertible: Convertible,
    Request: Request,
    Response: Response
  };

}).call(this);

});

require.define("/lib/client/client/modules/network/network_router.js",function(require,module,exports,__dirname,__filename,process,global){
/*
@package: volna
@autor: quark, 2011
*/

(function() {
  var BUSY_DISCONNECT_STATUS_TIMEOUT, BaseModule, BaseRouter, CombinedRemoteModule, IDLE_DISCONNECT_STATUS_TIMEOUT, NetworkRouter, RemoteModule, SockJS, rest,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice,
    __indexOf = Array.prototype.indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  BaseRouter = require('../../../share/base_router').BaseRouter;

  BaseModule = require('../../../share/base_module').BaseModule;

  SockJS = require('./transports/sockjs').SockJS;

  rest = require('./transports/rest');

  BUSY_DISCONNECT_STATUS_TIMEOUT = 10000;

  IDLE_DISCONNECT_STATUS_TIMEOUT = 30000;

  RemoteModule = (function(_super) {

    __extends(RemoteModule, _super);

    /*
        Класс, вызывающий удаленно методы, которых нет у себя.
    
        Обращение к методам происходит через транспорты:
        - SockJS - с у становлением и поддержанием соединения (когда не установлено соединение накапливает обращения
          к методам, при установлении соединения делает вызовы, при реконнекте вызывает незавершившиеся методы)
        - HTTP REST - методы вызываются без предварительного установления соединения (считаем, что транспорт всегда доступен)
    
        При вызове методов у запроса могут быть указаны свойства:
        - recallOnDisconnect - повторять ли запрос после дисконнекта или сетевых ошибок (для транспорта SockJS).
          Значением recallOnDisconnect может быть:
          1) false (при проблемах с соединением будет возвращена ошибка),
          2) true (при дисконнекте/сетевых ошибках запрос будет ожидать в очереди и будет повторно отправлен после реконнекта)
          3) или функция (то же, что и true. Функция будет вызвана при повторной отправке, она должна создать и вернуть
          новый request. Применяется в WaveProcessor.subscribeForWaveData() для указания актуальных версий документов,
          на которые происходит повторная подписка).
        - wait - устанавливается у подписок, на один такой запрос может придти несколько ответов.
        - close-confirm - предупреждать пользователя при закрытии вкладки браузера если ответ на данный запрос ещё не получен.
        - callId - идентификатор запроса для определения на какой запрос получен ответ (устанавливается автоматически,
          используется для транспорта SockJS).
    */

    function RemoteModule() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._hideDisconnected = __bind(this._hideDisconnected, this);
      this._showDisconnected = __bind(this._showDisconnected, this);
      this._updateSynchTimer = __bind(this._updateSynchTimer, this);
      this._sendUnsentCalls = __bind(this._sendUnsentCalls, this);
      this._onTransportReceive = __bind(this._onTransportReceive, this);
      RemoteModule.__super__.constructor.apply(this, args);
      this._callCounter = 0;
      this._calls = {};
      this._initTransport();
      this._showingDisconnected = false;
      this._hasFirstConnect = false;
      this._flushedCallback = null;
    }

    RemoteModule.prototype._hasNoWaitCalls = function() {
      var call, callId, _ref;
      _ref = this._calls;
      for (callId in _ref) {
        call = _ref[callId];
        if (!call.request.wait) return true;
      }
      return false;
    };

    RemoteModule.prototype._getRemoteProcedureName = function(moduleName, procedureName) {
      return "" + moduleName + "." + procedureName;
    };

    RemoteModule.prototype._sendMessage = function(moduleName, procedureName, request) {
      /*
              Отправляет сообщение на сервер
              @param moduleName: string
              @param procedureName: string
              @param request: Request
      */
      var callId, remoteName, transport;
      remoteName = this._getRemoteProcedureName(moduleName, procedureName);
      this._callCounter++;
      callId = "k" + this._callCounter;
      this._calls[callId] = {
        procedureName: remoteName,
        request: request
      };
      request.setProperty('callId', callId);
      transport = this._getTransport(remoteName, request);
      if (transport.isConnected()) {
        return transport.emit(remoteName, request);
      } else {
        if (typeof transport.needEmit === "function") transport.needEmit();
        if (this._hasFirstConnect) return this._processDisconnectedStatus();
      }
    };

    RemoteModule.prototype._getTransport = function(remoteName, request) {
      /*
              Select transport based on remoteName and request parameters
      */      throw "method '_getTransport' is not implemented";
    };

    RemoteModule.prototype._deleteCall = function(id) {
      /*
              Удаляет данные о вызове из списка вызовов и вызывает _flushedCallback,
              если такой установлен и нет вызовов, требующих подтверждения
              пользователя при закрытии
      */
      var hadConfirm;
      hadConfirm = this._calls[id].request['close-confirm'];
      delete this._calls[id];
      if (!this._flushedCallback) return;
      if (!hadConfirm) return;
      if (this.hasCallsToConfirm()) return;
      return this._flushedCallback();
    };

    RemoteModule.prototype._onTransportReceive = function(response) {
      /*
              Вызывается, когда транспорту приходит ответ.
              Находим callback, которуму нужно отдать ответ.
              @param response: object
      */
      var id;
      id = response.callId;
      if (!this._calls[id]) {
        return console.warn("Got response for " + id + ", but it is not present", response);
      }
      this._calls[id].request.callback(response.err, response.data);
      if (!this._calls[id].request.wait) return this._deleteCall(id);
    };

    RemoteModule.prototype._sendUnsentCalls = function() {
      /*
              Отправляет неодноразовые вызовы, которые еще не были отправлены
      */
      var callId, params, transport, _ref, _results;
      _ref = this._calls;
      _results = [];
      for (callId in _ref) {
        params = _ref[callId];
        transport = this._getTransport(params.procedureName, params.request);
        _results.push(transport.emit(params.procedureName, params.request));
      }
      return _results;
    };

    RemoteModule.prototype._processDisconnect = function() {
      /*
              Отменяет одноразовые вызовы, обновляет повторяющиеся
      */
      var callId, params, _ref, _results;
      _ref = this._calls;
      _results = [];
      for (callId in _ref) {
        if (!__hasProp.call(_ref, callId)) continue;
        params = _ref[callId];
        if (params.request.recallOnDisconnect) {
          _results.push(params.request = this._refreshCall(params.request));
        } else {
          this._cancelCall(params.request);
          _results.push(this._deleteCall(callId));
        }
      }
      return _results;
    };

    RemoteModule.prototype._cancelCall = function(request) {
      /*
              Отменяет вызов, вызывает callback с ошибкой
      */
      var err;
      err = {
        code: 0,
        error: 'client',
        message: 'network disconnected'
      };
      return request.callback(err, null);
    };

    RemoteModule.prototype._refreshCall = function(request) {
      /*
              Обновляет вызов для повторной отправки на сервер
              Значением recallOnDisconnect может быть true, false или метод,
              который должен вернуть новый запрос (применяется в WaveProcessor.subscribeForWaveData())
      */
      var res;
      if (request.recallOnDisconnect === true) return request;
      res = request.recallOnDisconnect();
      res.setProperty('callId', request.callId);
      return res;
    };

    RemoteModule.prototype._getSyncBoard = function() {
      if (!(this._syncBoard != null)) {
        this._syncBoard = require('./sync_board').syncBoardInstance;
        this._syncBoard.renderAndInitInContainer(document.body);
        this._syncBoard.getReconnectLink().click(this._reconnectNow);
      }
      return this._syncBoard;
    };

    RemoteModule.prototype._getReconnectionTime = function() {
      throw "method '_getReconnectionTime' is not implemented";
    };

    RemoteModule.prototype._reconnectNow = function() {
      this._getSyncBoard().setReconnectingText();
      clearInterval(this._synchronizingTimer);
      return this._synchronizingTimer = setInterval(this._updateSynchTimer, 1000);
    };

    RemoteModule.prototype._updateSynchTimer = function() {
      var secondsLeft;
      secondsLeft = Math.round((this._getReconnectionTime() - Date.now()) / 1000);
      this._getSyncBoard().setSecondsLeft(secondsLeft);
      if (secondsLeft <= 0) {
        return this._getSyncBoard().setReconnectingText();
      } else {
        return this._getSyncBoard().setTimerText();
      }
    };

    RemoteModule.prototype._showDisconnected = function() {
      this._getSyncBoard().show();
      this._updateSynchTimer();
      this._synchronizingTimer = setInterval(this._updateSynchTimer, 1000);
      this._statusTimeoutHandler = null;
      return this._showingDisconnected = true;
    };

    RemoteModule.prototype._hideDisconnected = function() {
      this._getSyncBoard().hide();
      clearInterval(this._synchronizingTimer);
      this._showingDisconnected = false;
      return this._flushedCallback = null;
    };

    RemoteModule.prototype._processDisconnectedStatus = function() {
      var disconnectionShowTime, timeout;
      if (this._showingDisconnected) return;
      timeout = this._hasNoWaitCalls() ? BUSY_DISCONNECT_STATUS_TIMEOUT : IDLE_DISCONNECT_STATUS_TIMEOUT;
      disconnectionShowTime = Date.now() + timeout;
      if (this._statusTimeoutHandler && disconnectionShowTime > this._disconnectionShowTime) {
        return;
      }
      window.clearTimeout(this._statusTimeoutHandler);
      this._statusTimeoutHandler = window.setTimeout(this._showDisconnected, timeout);
      return this._disconnectionShowTime = disconnectionShowTime;
    };

    RemoteModule.prototype._processConnectedStatus = function() {
      if (this._statusTimeoutHandler != null) {
        window.clearTimeout(this._statusTimeoutHandler);
        this._statusTimeoutHandler = null;
      }
      if (!this._showingDisconnected) return;
      if (this.hasCallsToConfirm()) {
        return this._flushedCallback = this._hideDisconnected;
      } else {
        return this._hideDisconnected();
      }
    };

    RemoteModule.prototype.handle = function(moduleName, procedureName, request) {
      /*
              Обрабатывает запрос на выполнение процедуры.
              @param moduleName: string
              @param procedureName: string
              @param request: Request
      */      if (!this._callMethod(procedureName, request)) return;
      return this._sendMessage(moduleName, procedureName, request);
    };

    RemoteModule.prototype.hasCallsToConfirm = function() {
      /*
              Возвращает true, если у этого транспорта есть неотправленные сообщения,
              которые требуют подтверждения пользователя при закрытии
      */
      var call, callId, _ref;
      _ref = this._calls;
      for (callId in _ref) {
        call = _ref[callId];
        if (call.request['close-confirm']) return true;
      }
      return false;
    };

    RemoteModule.prototype.removeCall = function(request) {
      /*
              Отменяет указанный вызов
              @param request.args.callId: string
      */
      var callId, err;
      callId = request.args.callId;
      if (!(this._calls[callId] != null)) {
        err = new Error("Call " + callId + " is cancelled but it was not called");
        return request.callback(err);
      }
      this._deleteCall(callId);
      return request.callback();
    };

    return RemoteModule;

  })(BaseModule);

  CombinedRemoteModule = (function(_super) {

    __extends(CombinedRemoteModule, _super);

    function CombinedRemoteModule() {
      this._reconnectNow = __bind(this._reconnectNow, this);
      CombinedRemoteModule.__super__.constructor.apply(this, arguments);
    }

    CombinedRemoteModule.prototype._initTransport = function() {
      var settings,
        _this = this;
      settings = {
        url: '/rizzoma'
      };
      this._sockjs = new SockJS(settings, this._onTransportReceive);
      this._sockjs.onConnect(function() {
        _this._hasFirstConnect = true;
        _this._sendUnsentCalls();
        return _this._processConnectedStatus();
      });
      this._sockjs.onDisconnect(function() {
        _this._processDisconnect();
        return _this._processDisconnectedStatus();
      });
      this._restGet = new rest.Rest({}, this._onTransportReceive);
      return this._restPost = new rest.RestPost({}, this._onTransportReceive);
    };

    CombinedRemoteModule.prototype._getReconnectionTime = function() {
      return this._sockjs.getReconnectionTime();
    };

    CombinedRemoteModule.prototype._reconnectNow = function() {
      this._sockjs.reconnectNow();
      return CombinedRemoteModule.__super__._reconnectNow.call(this);
    };

    CombinedRemoteModule.prototype._getTransport = function(remoteName, request) {
      /*
              Select transport based on remoteName and request parameters
      */
      var restGetProcedureList, restPostProcedureList;
      restGetProcedureList = ['wave.searchBlipContent', 'user.getUserContacts', 'gtag.getGTagList', 'message.searchMessageContent', 'wave.searchBlipContentInPublicWaves', 'store.getVisibleItemList', 'team.getTeamTopics', 'task.searchByRecipient', 'task.searchBySender', 'wave.getWaveWithBlips'];
      restPostProcedureList = ['user.getUsersInfo'];
      if (__indexOf.call(restGetProcedureList, remoteName) >= 0) {
        return this._restGet;
      }
      if (__indexOf.call(restPostProcedureList, remoteName) >= 0) {
        return this._restPost;
      }
      return this._sockjs;
    };

    return CombinedRemoteModule;

  })(RemoteModule);

  NetworkRouter = (function(_super) {

    __extends(NetworkRouter, _super);

    /*
        Класс, представляющий сетевой роутер. Знает о модулях, которые занимаются сетью.
    */

    function NetworkRouter() {
      var args, combined, name, _i, _len, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      NetworkRouter.__super__.constructor.apply(this, args);
      combined = new CombinedRemoteModule(this._rootRouter);
      this._transports = [combined];
      _ref = ['wave', 'search', 'message', 'file', 'gtag', 'task', 'user', 'export', 'store', 'team', 'messaging', 'playback'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        this._addModule(name, [name, combined]);
      }
      this._initCloseCheck();
    }

    NetworkRouter.prototype._initCloseCheck = function() {
      /*
              Инициализирует проверки при закрытии страницы. Предупреждает пользователя,
              если есть неотправленные данные
      */
      var _this = this;
      return window.addEventListener('beforeunload', function(e) {
        var msg;
        if (!_this._hasCallsToConfirm()) return;
        msg = 'One or more topics has unsent data';
        e = e || window.event;
        if (e) e.returnValue = msg;
        return msg;
      });
    };

    NetworkRouter.prototype._call = function(modulePair, procedureName, request) {
      var module, name;
      name = modulePair[0], module = modulePair[1];
      return module.handle(name, procedureName, request);
    };

    NetworkRouter.prototype._hasCallsToConfirm = function() {
      var transport, _i, _len, _ref;
      _ref = this._transports;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        transport = _ref[_i];
        if (transport.hasCallsToConfirm()) return true;
      }
      return false;
    };

    NetworkRouter.prototype.isConnected = function() {
      return this._transports[0]._sockjs.isConnected();
    };

    return NetworkRouter;

  })(BaseRouter);

  module.exports.NetworkRouter = NetworkRouter;

}).call(this);

});

require.define("/lib/client/client/modules/network/transports/sockjs.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ClientTransport, DATA_RECEIVE_CHECK_TIME_INTERVAL, INACTIVE_THRESHOLD, RECONNECT_TIMEOUT, Response, SockJS,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  ClientTransport = require('../../../../share/client_transport').ClientTransport;

  Response = require('../../../../share/communication').Response;

  RECONNECT_TIMEOUT = 60 * 1000;

  INACTIVE_THRESHOLD = 10 * 60 * 1000;

  DATA_RECEIVE_CHECK_TIME_INTERVAL = 10 * 1000;

  SockJS = (function(_super) {

    __extends(SockJS, _super);

    /*
        Реализация клиентского транспорта websocket
    */

    function SockJS(_settings, _onmessage) {
      var _this = this;
      this._settings = _settings;
      this._onmessage = _onmessage;
      this._performReconnect = __bind(this._performReconnect, this);
      this._updateDataReceiveTime = __bind(this._updateDataReceiveTime, this);
      this.transportName = 'sockjs';
      this._lastSendTime = 0;
      this._init();
      window.setInterval(function() {
        if (Date.now() - _this._lastDataReceiveTime < window.HEARTBEAT_INTERVAL * 2) {
          return;
        }
        if (!_this.isConnected()) return;
        return _this._sockjs.close();
      }, DATA_RECEIVE_CHECK_TIME_INTERVAL);
    }

    SockJS.prototype._init = function() {
      var _this = this;
      this._sockjs = new window.SockJS(this._settings.url);
      this._sockjs.onmessage = function(message) {
        var data, response;
        data = JSON.parse(message.data);
        response = new Response(data.err, data.data);
        response.setProperty('callId', data.callId);
        if (data.err && data.err.code !== 'wave_anonymous_permission_denied') {
          _gaq.push(['_trackEvent', 'Error', 'Server error', data.err.code]);
        }
        _this._onmessage(response);
        return _this._updateDataReceiveTime();
      };
      this._sockjs.onclose = function() {
        console.log("Network disconnected", new Date());
        if (typeof _this._disconnectCallback === "function") {
          _this._disconnectCallback();
        }
        return _this._reconnect();
      };
      this._sockjs.onopen = function() {
        if (typeof _this._connectCallback === "function") _this._connectCallback();
        return _this._updateDataReceiveTime();
      };
      return this._sockjs.onheartbeat = this._updateDataReceiveTime;
    };

    SockJS.prototype._updateDataReceiveTime = function() {
      return this._lastDataReceiveTime = Date.now();
    };

    SockJS.prototype._performReconnect = function() {
      console.log("Reconnecting right now.", new Date());
      window.clearTimeout(this._reconnectHandler);
      delete this._reconnectHandler;
      return this._init();
    };

    SockJS.prototype._reconnect = function() {
      var delta, timeout;
      if (this._sockjs.readyState !== window.SockJS.CLOSED) return;
      timeout = this._generateReconnectionTime();
      if (this._reconnectHandler) {
        delta = Date.now() + timeout - this._reconnectionTime;
        if (delta > 0) return;
        window.clearTimeout(this._reconnectHandler);
        delete this._reconnectHandler;
      }
      this._reconnectionTime = Date.now() + timeout;
      console.log("Reconnecting in " + timeout);
      return this._reconnectHandler = window.setTimeout(this._performReconnect, timeout);
    };

    SockJS.prototype._generateReconnectionTime = function() {
      /*
              Возвращает рекомендуемое время переподключения. Если пользователь
              не проявлял активности в течение INACTIVE_THRESHOLD, то переподключится
              в промежутке от RECONNECT_TIMEOUT + 5 cек. до RECONNECT_TIMEOUT*2, иначе - в
              течение времени от 5 сек. до RECONNECT_TIMEOUT + 5 сек.
      */
      var delta, timeout;
      timeout = Math.random() * RECONNECT_TIMEOUT + 5000;
      delta = Date.now() - this._lastSendTime;
      if (delta > INACTIVE_THRESHOLD) timeout += RECONNECT_TIMEOUT;
      return timeout;
    };

    SockJS.prototype.onConnect = function(callback) {
      /*
              Устанавливает callback, который будет вызываться при каждом подключении к серверу
      */      return this._connectCallback = callback;
    };

    SockJS.prototype.onDisconnect = function(callback) {
      /*
              Устанавливает callback, который будет вызываться при каждом отключении от сервера
      */      return this._disconnectCallback = callback;
    };

    SockJS.prototype.isConnected = function() {
      /*
              Возвращает true, если транспорт подключен к серверу
      */      return this._sockjs.readyState === window.SockJS.OPEN;
    };

    SockJS.prototype.emit = function(procedureName, request) {
      /*
              Отсылает запрос на сервер.
              @param procedureName: string, имя вызываемой процедуры на сервере
              @param request: Request
      */
      var data;
      data = {
        procedureName: procedureName,
        request: request.serialize(),
        expressSessionId: window.expressSession.id
      };
      this._lastSendTime = Date.now();
      return this._sockjs.send(JSON.stringify(data));
    };

    SockJS.prototype.needEmit = function() {
      /*
              Оповещает отключенный транспорт о том, что нужно отправить данные.
              Заставляет переподключиться как можно быстрее.
      */      this._lastSendTime = Date.now();
      return this._reconnect();
    };

    SockJS.prototype.getReconnectionTime = function() {
      return this._reconnectionTime;
    };

    SockJS.prototype.reconnectNow = function() {
      this._reconnectionTime = Date.now();
      return this._performReconnect();
    };

    return SockJS;

  })(ClientTransport);

  module.exports.SockJS = SockJS;

}).call(this);

});

require.define("/lib/client/share/client_transport.js",function(require,module,exports,__dirname,__filename,process,global){
/*
@package: volna
@autor: quark, 2011
*/

(function() {
  var ClientTransport, NotImplementedError;

  NotImplementedError = require('./exceptions').NotImplementedError;

  ClientTransport = (function() {
    /*
        Базовый класс транспорта для клиента.
    */
    function ClientTransport() {
      this.transportName;
    }

    ClientTransport.prototype.emit = function() {
      /*
              Отправляет данные.
      */      throw new NotImplementedError("Method emit of transport " + this.transportName + " is not implemented");
    };

    ClientTransport.prototype.onConnect = function(callback) {
      /*
              Устанавливает callback, который будет вызываться при каждом подключении к серверу
      */      return this._connectCallback = callback;
    };

    ClientTransport.prototype.onDisconnect = function(callback) {
      /*
              Устанавливает callback, который будет вызываться при каждом отключении от сервера
      */      return this._disconnectCallback = callback;
    };

    ClientTransport.prototype.isConnected = function() {
      /*
              Возвращает true, если транспорт подключен к серверу
      */      throw new NotImplementedError("Method isConnected of transport " + this.transportName + " is not implemented");
    };

    ClientTransport.prototype.needEmit = function() {
      /*
              Оповещает отключенный транспорт о том, что нужно отправить данные.
              Заставляет переподключиться как можно быстрее.
      */      throw new NotImplementedError("Method needEmit of transport " + this.transportName + " is not implemented");
    };

    ClientTransport.prototype.getReconnectionTime = function() {
      throw new NotImplementedError("Method getReconnectionTime of transport " + this.transportName + " is not implemented");
    };

    ClientTransport.prototype.reconnectNow = function() {
      throw new NotImplementedError("Method reconnectNow of transport " + this.transportName + " is not implemented");
    };

    return ClientTransport;

  })();

  module.exports.ClientTransport = ClientTransport;

}).call(this);

});

require.define("/lib/client/client/modules/network/transports/rest.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ClientTransport, DATA_RECEIVE_CHECK_TIME_INTERVAL, INACTIVE_THRESHOLD, RECONNECT_TIMEOUT, Response, Rest, RestPost,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  ClientTransport = require('../../../../share/client_transport').ClientTransport;

  Response = require('../../../../share/communication').Response;

  RECONNECT_TIMEOUT = 60 * 1000;

  INACTIVE_THRESHOLD = 10 * 60 * 1000;

  DATA_RECEIVE_CHECK_TIME_INTERVAL = 10 * 1000;

  Rest = (function(_super) {

    __extends(Rest, _super);

    /*
        Реализация клиентского транспорта websocket
    */

    function Rest(_settings, _onmessage) {
      this._settings = _settings;
      this._onmessage = _onmessage;
      this.emit = __bind(this.emit, this);
      this._apiUrl = "/api/rest/1/";
    }

    Rest.prototype.onConnect = function(callback) {
      /*
              Устанавливает callback, который будет вызываться при каждом подключении к серверу
      */      return this._connectCallback = callback;
    };

    Rest.prototype.onDisconnect = function(callback) {
      /*
              Устанавливает callback, который будет вызываться при каждом отключении от сервера
      */      return this._disconnectCallback = callback;
    };

    Rest.prototype.isConnected = function() {
      /*
              Возвращает true, если транспорт подключен к серверу
      */      return true;
    };

    Rest.prototype._stringifyArgs = function(args) {
      var arg, defVal, res, val;
      res = {};
      for (arg in args) {
        val = args[arg];
        defVal = typeof val === 'number' ? 0 : "";
        res[arg] = val || defVal;
      }
      return res;
    };

    Rest.prototype.emit = function(procedureName, request) {
      /*
              Отсылает запрос на сервер.
              @param procedureName: string, имя вызываемой процедуры на сервере
              @param request: Request
      */
      var args, url,
        _this = this;
      url = this._getProcedureUrl(procedureName);
      args = $.extend({
        "ACCESS_TOKEN": window.expressSession.id || ""
      }, this._stringifyArgs(request.serialize().args));
      return $.get(url, args, function(data, textStatus, jqXHR) {
        var response;
        response = new Response(data.err, data.data);
        response.setProperty('callId', request.callId);
        if (data.err && data.err.code !== 'wave_anonymous_permission_denied') {
          _gaq.push(['_trackEvent', 'Error', 'Server error', data.err.code]);
        }
        return _this._onmessage(response);
      }, "json").error(function(jqXHR, textStatus, errorThrown) {
        var response;
        response = new Response(new Error(errorThrown), null);
        response.setProperty('callId', request.callId);
        return _this._onmessage(response);
      });
    };

    Rest.prototype.needEmit = function() {
      /*
              Оповещает отключенный транспорт о том, что нужно отправить данные.
              Заставляет переподключиться как можно быстрее.
      */
    };

    Rest.prototype.getReconnectionTime = function() {
      return Date.now() + RECONNECT_TIMEOUT;
    };

    Rest.prototype.reconnectNow = function() {};

    Rest.prototype._getProcedureUrl = function(procedureName) {
      return "" + this._apiUrl + (procedureName.replace('.', '/')) + "/";
    };

    return Rest;

  })(ClientTransport);

  RestPost = (function(_super) {

    __extends(RestPost, _super);

    function RestPost() {
      this.emit = __bind(this.emit, this);
      RestPost.__super__.constructor.apply(this, arguments);
    }

    RestPost.prototype.emit = function(procedureName, request) {
      /*
              Отсылает запрос на сервер.
              @param procedureName: string, имя вызываемой процедуры на сервере
              @param request: Request
      */
      var args, url,
        _this = this;
      url = this._getProcedureUrl(procedureName);
      url += "?ACCESS_TOKEN=" + (encodeURIComponent(window.expressSession.id) || "");
      args = this._stringifyArgs(request.serialize().args);
      return $.ajax({
        'type': 'POST',
        'url': url,
        'contentType': 'application/json',
        'data': JSON.stringify(args),
        'dataType': 'json',
        'success': function(data, textStatus, jqXHR) {
          var response;
          response = new Response(data.err, data.data);
          response.setProperty('callId', request.callId);
          if (data.err && data.err.code !== 'wave_anonymous_permission_denied') {
            _gaq.push(['_trackEvent', 'Error', 'Server error', data.err.code]);
          }
          return _this._onmessage(response);
        },
        'error': function(jqXHR, textStatus, errorThrown) {
          var response;
          response = new Response(new Error(errorThrown), null);
          response.setProperty('callId', request.callId);
          return _this._onmessage(response);
        }
      });
    };

    return RestPost;

  })(Rest);

  module.exports = {
    Rest: Rest,
    RestPost: RestPost
  };

}).call(this);

});

require.define("/lib/client/client/modules/network/sync_board.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var SyncBoard, ck, renderSynchronizing;

  ck = window.CoffeeKup;

  renderSynchronizing = ck.compile(function() {
    return div('.js-connection-error-container.connection-error-container', function() {
      return div('.connection-error', function() {
        div('.js-reconnect-timer', function() {
          span("Reconnect in ");
          span('.js-reconnecting-interval.reconnecting-interval', '');
          span(" sec. ");
          a('.js-reconnect-now.reconnect-now', "Click");
          return span(" to try now");
        });
        return div('.js-reconnecting-text', 'Reconnecting right now...');
      });
    });
  });

  SyncBoard = (function() {

    function SyncBoard() {}

    SyncBoard.get = function() {
      var _ref;
      return (_ref = this.instance) != null ? _ref : this.instance = new this;
    };

    SyncBoard.prototype.renderAndInitInContainer = function(container) {
      if (this._container) {
        $(this._container).find('.js-connection-error-container').remove();
      }
      this._container = container;
      $(this._container).append(renderSynchronizing());
      this._$errorContainer = $(this._container).find('.js-connection-error-container');
      this._$reconnectTimerText = this._$errorContainer.find('.js-reconnect-timer');
      this._$reconnectingText = this._$errorContainer.find('.js-reconnecting-text');
      this._$reconnectLink = this._$errorContainer.find('.js-reconnect-now');
      return this._$reconnectIntervalContainer = this._$errorContainer.find('.js-reconnecting-interval');
    };

    SyncBoard.prototype.setSecondsLeft = function(secondsLeft) {
      return this._$reconnectIntervalContainer.text(secondsLeft);
    };

    SyncBoard.prototype.setReconnectingText = function() {
      this._$reconnectTimerText.hide();
      return this._$reconnectingText.show();
    };

    SyncBoard.prototype.setTimerText = function() {
      this._$reconnectTimerText.show();
      return this._$reconnectingText.hide();
    };

    SyncBoard.prototype.show = function() {
      this._$errorContainer.addClass('error-shown');
      return this.setTimerText();
    };

    SyncBoard.prototype.hide = function() {
      return this._$errorContainer.removeClass('error-shown');
    };

    SyncBoard.prototype.getReconnectLink = function() {
      return this._$reconnectLink;
    };

    return SyncBoard;

  })();

  exports.syncBoardInstance = SyncBoard.get();

}).call(this);

});

require.define("/lib/client/share/utils/datetime.js",function(require,module,exports,__dirname,__filename,process,global){
/*
Функции для работы с датой и временем

В коде Datetime - формат времени, приходящий с сервера (кол-во секунд от начала unix timestamp),
DateTime - "дата и время"
*/

(function() {
  var Globalize, LONG_DATE_SHORT_TIME, convertDatetime, formatDate, init, _DATE, _DATE_SHORT, _DATE_TIME_SHORT, _DATE_TIME_WITH_YEAR, _DATE_WITH_YEAR, _EXPORT_TIMESTAMP, _ISO_DATE, _LONG_DATE, _TIME_SHORT, _getFormat;

  if (typeof module !== 'undefined' && module.exports) {
    Globalize = require('globalize');
    require('globalize/globalize.culture.en-US');
  }

  convertDatetime = require('./date_converter').convertDatetime;

  init = exports.init = function(culture) {
    return Globalize.culture(culture);
  };

  _TIME_SHORT = exports._TIME_SHORT = "t";

  _DATE_SHORT = exports._DATE_SHORT = "d MMM";

  _DATE_WITH_YEAR = "d MMM yyyy";

  _DATE_TIME_SHORT = "d MMM h:mm tt";

  _DATE_TIME_WITH_YEAR = "d MMM yyyy h:mm tt";

  _DATE = exports._DATE = "MMM yyyy";

  LONG_DATE_SHORT_TIME = "f";

  _LONG_DATE = 'dddd, MMMM dd, yyyy';

  _ISO_DATE = 'S';

  _EXPORT_TIMESTAMP = 'yyyy-MM-dd(hh-mmtt)';

  _getFormat = exports._getFormat = function(serverDate, clientToday) {
    /*
        @param serverDate: Date - дата пришедшая с сревера;
        @param clientToday: Date - текущая дата на клиенте;
        Приватная функция, экспортируется для тестов
    */    if (serverDate > clientToday) return _TIME_SHORT;
    if (serverDate.getDate() === clientToday.getDate() && serverDate.getMonth() === clientToday.getMonth() && serverDate.getYear() === clientToday.getYear()) {
      return _TIME_SHORT;
    }
    if ((clientToday - serverDate) < 2 * 60 * 60 * 1000) return _TIME_SHORT;
    if ((clientToday - serverDate) < 60 * 24 * 60 * 60 * 1000) return _DATE_SHORT;
    if (serverDate.getYear() === clientToday.getYear()) return _DATE_SHORT;
    return _DATE;
  };

  formatDate = exports.formatDate = function(ts, full) {
    var clientToday, format, serverDate;
    if (full == null) full = false;
    /*
        Форматирует timestamp в читаемую дату
        @param ts: int, unix timestamp
        @return: string
    */
    serverDate = convertDatetime(ts);
    if (full) return Globalize.format(serverDate, LONG_DATE_SHORT_TIME);
    clientToday = new Date();
    format = _getFormat(serverDate, clientToday);
    return Globalize.format(serverDate, format);
  };

  exports.formatAsShortDate = function(date) {
    return Globalize.format(date, _DATE_SHORT);
  };

  exports.formatAsShortTime = function(date) {
    return Globalize.format(date, _TIME_SHORT);
  };

  exports.formatFullDate = function(date) {
    return Globalize.format(date, _LONG_DATE);
  };

  exports.formatAsShortenedDate = function(date) {
    var format;
    if (date.getYear() === (new Date).getYear()) {
      format = _DATE_SHORT;
    } else {
      format = _DATE_WITH_YEAR;
    }
    return Globalize.format(date, format);
  };

  exports.formatAsShortenedDateTime = function(date) {
    var format;
    if (date.getYear() === (new Date).getYear()) {
      format = _DATE_TIME_SHORT;
    } else {
      format = _DATE_TIME_WITH_YEAR;
    }
    return Globalize.format(date, format);
  };

  exports.formatAsISODate = function(ts) {
    return Globalize.format(new Date(ts * 1000), _ISO_DATE);
  };

  exports.formatAsExportTimestamp = function(date) {
    return Globalize.format(date, _EXPORT_TIMESTAMP);
  };

}).call(this);

});

require.define("/node_modules/globalize/index.js",function(require,module,exports,__dirname,__filename,process,global){/*!
 * Globalize
 *
 * http://github.com/jquery/globalize
 *
 * Copyright Software Freedom Conservancy, Inc.
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 */

(function( window, undefined ) {

var Globalize,
	// private variables
	regexHex,
	regexInfinity,
	regexParseFloat,
	regexTrim,
	// private JavaScript utility functions
	arrayIndexOf,
	endsWith,
	extend,
	isArray,
	isFunction,
	isObject,
	startsWith,
	trim,
	truncate,
	zeroPad,
	// private Globalization utility functions
	appendPreOrPostMatch,
	expandFormat,
	formatDate,
	formatNumber,
	getTokenRegExp,
	getEra,
	getEraYear,
	parseExact,
	parseNegativePattern;

// Global variable (Globalize) or CommonJS module (globalize)
Globalize = function( cultureSelector ) {
	return new Globalize.prototype.init( cultureSelector );
};

if ( typeof require !== "undefined"
	&& typeof exports !== "undefined"
	&& typeof module !== "undefined" ) {
	// Assume CommonJS
	module.exports = Globalize;
} else {
	// Export as global variable
	window.Globalize = Globalize;
}

Globalize.cultures = {};

Globalize.prototype = {
	constructor: Globalize,
	init: function( cultureSelector ) {
		this.cultures = Globalize.cultures;
		this.cultureSelector = cultureSelector;

		return this;
	}
};
Globalize.prototype.init.prototype = Globalize.prototype;

// 1.	 When defining a culture, all fields are required except the ones stated as optional.
// 2.	 Each culture should have a ".calendars" object with at least one calendar named "standard"
//		 which serves as the default calendar in use by that culture.
// 3.	 Each culture should have a ".calendar" object which is the current calendar being used,
//		 it may be dynamically changed at any time to one of the calendars in ".calendars".
Globalize.cultures[ "default" ] = {
	// A unique name for the culture in the form <language code>-<country/region code>
	name: "en",
	// the name of the culture in the english language
	englishName: "English",
	// the name of the culture in its own language
	nativeName: "English",
	// whether the culture uses right-to-left text
	isRTL: false,
	// "language" is used for so-called "specific" cultures.
	// For example, the culture "es-CL" means "Spanish, in Chili".
	// It represents the Spanish-speaking culture as it is in Chili,
	// which might have different formatting rules or even translations
	// than Spanish in Spain. A "neutral" culture is one that is not
	// specific to a region. For example, the culture "es" is the generic
	// Spanish culture, which may be a more generalized version of the language
	// that may or may not be what a specific culture expects.
	// For a specific culture like "es-CL", the "language" field refers to the
	// neutral, generic culture information for the language it is using.
	// This is not always a simple matter of the string before the dash.
	// For example, the "zh-Hans" culture is netural (Simplified Chinese).
	// And the "zh-SG" culture is Simplified Chinese in Singapore, whose lanugage
	// field is "zh-CHS", not "zh".
	// This field should be used to navigate from a specific culture to it's
	// more general, neutral culture. If a culture is already as general as it
	// can get, the language may refer to itself.
	language: "en",
	// numberFormat defines general number formatting rules, like the digits in
	// each grouping, the group separator, and how negative numbers are displayed.
	numberFormat: {
		// [negativePattern]
		// Note, numberFormat.pattern has no "positivePattern" unlike percent and currency,
		// but is still defined as an array for consistency with them.
		//   negativePattern: one of "(n)|-n|- n|n-|n -"
		pattern: [ "-n" ],
		// number of decimal places normally shown
		decimals: 2,
		// string that separates number groups, as in 1,000,000
		",": ",",
		// string that separates a number from the fractional portion, as in 1.99
		".": ".",
		// array of numbers indicating the size of each number group.
		// TODO: more detailed description and example
		groupSizes: [ 3 ],
		// symbol used for positive numbers
		"+": "+",
		// symbol used for negative numbers
		"-": "-",
		// symbol used for NaN (Not-A-Number)
		NaN: "NaN",
		// symbol used for Negative Infinity
		negativeInfinity: "-Infinity",
		// symbol used for Positive Infinity
		positiveInfinity: "Infinity",
		percent: {
			// [negativePattern, positivePattern]
			//   negativePattern: one of "-n %|-n%|-%n|%-n|%n-|n-%|n%-|-% n|n %-|% n-|% -n|n- %"
			//   positivePattern: one of "n %|n%|%n|% n"
			pattern: [ "-n %", "n %" ],
			// number of decimal places normally shown
			decimals: 2,
			// array of numbers indicating the size of each number group.
			// TODO: more detailed description and example
			groupSizes: [ 3 ],
			// string that separates number groups, as in 1,000,000
			",": ",",
			// string that separates a number from the fractional portion, as in 1.99
			".": ".",
			// symbol used to represent a percentage
			symbol: "%"
		},
		currency: {
			// [negativePattern, positivePattern]
			//   negativePattern: one of "($n)|-$n|$-n|$n-|(n$)|-n$|n-$|n$-|-n $|-$ n|n $-|$ n-|$ -n|n- $|($ n)|(n $)"
			//   positivePattern: one of "$n|n$|$ n|n $"
			pattern: [ "($n)", "$n" ],
			// number of decimal places normally shown
			decimals: 2,
			// array of numbers indicating the size of each number group.
			// TODO: more detailed description and example
			groupSizes: [ 3 ],
			// string that separates number groups, as in 1,000,000
			",": ",",
			// string that separates a number from the fractional portion, as in 1.99
			".": ".",
			// symbol used to represent currency
			symbol: "$"
		}
	},
	// calendars defines all the possible calendars used by this culture.
	// There should be at least one defined with name "standard", and is the default
	// calendar used by the culture.
	// A calendar contains information about how dates are formatted, information about
	// the calendar's eras, a standard set of the date formats,
	// translations for day and month names, and if the calendar is not based on the Gregorian
	// calendar, conversion functions to and from the Gregorian calendar.
	calendars: {
		standard: {
			// name that identifies the type of calendar this is
			name: "Gregorian_USEnglish",
			// separator of parts of a date (e.g. "/" in 11/05/1955)
			"/": "/",
			// separator of parts of a time (e.g. ":" in 05:44 PM)
			":": ":",
			// the first day of the week (0 = Sunday, 1 = Monday, etc)
			firstDay: 0,
			days: {
				// full day names
				names: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
				// abbreviated day names
				namesAbbr: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
				// shortest day names
				namesShort: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ]
			},
			months: {
				// full month names (13 months for lunar calendards -- 13th month should be "" if not lunar)
				names: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", "" ],
				// abbreviated month names
				namesAbbr: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "" ]
			},
			// AM and PM designators in one of these forms:
			// The usual view, and the upper and lower case versions
			//   [ standard, lowercase, uppercase ]
			// The culture does not use AM or PM (likely all standard date formats use 24 hour time)
			//   null
			AM: [ "AM", "am", "AM" ],
			PM: [ "PM", "pm", "PM" ],
			eras: [
				// eras in reverse chronological order.
				// name: the name of the era in this culture (e.g. A.D., C.E.)
				// start: when the era starts in ticks (gregorian, gmt), null if it is the earliest supported era.
				// offset: offset in years from gregorian calendar
				{
					"name": "A.D.",
					"start": null,
					"offset": 0
				}
			],
			// when a two digit year is given, it will never be parsed as a four digit
			// year greater than this year (in the appropriate era for the culture)
			// Set it as a full year (e.g. 2029) or use an offset format starting from
			// the current year: "+19" would correspond to 2029 if the current year 2010.
			twoDigitYearMax: 2029,
			// set of predefined date and time patterns used by the culture
			// these represent the format someone in this culture would expect
			// to see given the portions of the date that are shown.
			patterns: {
				// short date pattern
				d: "M/d/yyyy",
				// long date pattern
				D: "dddd, MMMM dd, yyyy",
				// short time pattern
				t: "h:mm tt",
				// long time pattern
				T: "h:mm:ss tt",
				// long date, short time pattern
				f: "dddd, MMMM dd, yyyy h:mm tt",
				// long date, long time pattern
				F: "dddd, MMMM dd, yyyy h:mm:ss tt",
				// month/day pattern
				M: "MMMM dd",
				// month/year pattern
				Y: "yyyy MMMM",
				// S is a sortable format that does not vary by culture
				S: "yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss"
			}
			// optional fields for each calendar:
			/*
			monthsGenitive:
				Same as months but used when the day preceeds the month.
				Omit if the culture has no genitive distinction in month names.
				For an explaination of genitive months, see http://blogs.msdn.com/michkap/archive/2004/12/25/332259.aspx
			convert:
				Allows for the support of non-gregorian based calendars. This convert object is used to
				to convert a date to and from a gregorian calendar date to handle parsing and formatting.
				The two functions:
					fromGregorian( date )
						Given the date as a parameter, return an array with parts [ year, month, day ]
						corresponding to the non-gregorian based year, month, and day for the calendar.
					toGregorian( year, month, day )
						Given the non-gregorian year, month, and day, return a new Date() object
						set to the corresponding date in the gregorian calendar.
			*/
		}
	},
	// For localized strings
	messages: {}
};

Globalize.cultures[ "default" ].calendar = Globalize.cultures[ "default" ].calendars.standard;

Globalize.cultures[ "en" ] = Globalize.cultures[ "default" ];

Globalize.cultureSelector = "en";

//
// private variables
//

regexHex = /^0x[a-f0-9]+$/i;
regexInfinity = /^[+-]?infinity$/i;
regexParseFloat = /^[+-]?\d*\.?\d*(e[+-]?\d+)?$/;
regexTrim = /^\s+|\s+$/g;

//
// private JavaScript utility functions
//

arrayIndexOf = function( array, item ) {
	if ( array.indexOf ) {
		return array.indexOf( item );
	}
	for ( var i = 0, length = array.length; i < length; i++ ) {
		if ( array[i] === item ) {
			return i;
		}
	}
	return -1;
};

endsWith = function( value, pattern ) {
	return value.substr( value.length - pattern.length ) === pattern;
};

extend = function( deep ) {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction(target) ) {
		target = {};
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( isObject(copy) || (copyIsArray = isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && isArray(src) ? src : [];

					} else {
						clone = src && isObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

isArray = Array.isArray || function( obj ) {
	return Object.prototype.toString.call( obj ) === "[object Array]";
};

isFunction = function( obj ) {
	return Object.prototype.toString.call( obj ) === "[object Function]";
};

isObject = function( obj ) {
	return Object.prototype.toString.call( obj ) === "[object Object]";
};

startsWith = function( value, pattern ) {
	return value.indexOf( pattern ) === 0;
};

trim = function( value ) {
	return ( value + "" ).replace( regexTrim, "" );
};

truncate = function( value ) {
	if ( isNaN( value ) ) {
		return NaN;
	}
	return Math[ value < 0 ? "ceil" : "floor" ]( value );
};

zeroPad = function( str, count, left ) {
	var l;
	for ( l = str.length; l < count; l += 1 ) {
		str = ( left ? ("0" + str) : (str + "0") );
	}
	return str;
};

//
// private Globalization utility functions
//

appendPreOrPostMatch = function( preMatch, strings ) {
	// appends pre- and post- token match strings while removing escaped characters.
	// Returns a single quote count which is used to determine if the token occurs
	// in a string literal.
	var quoteCount = 0,
		escaped = false;
	for ( var i = 0, il = preMatch.length; i < il; i++ ) {
		var c = preMatch.charAt( i );
		switch ( c ) {
			case "\'":
				if ( escaped ) {
					strings.push( "\'" );
				}
				else {
					quoteCount++;
				}
				escaped = false;
				break;
			case "\\":
				if ( escaped ) {
					strings.push( "\\" );
				}
				escaped = !escaped;
				break;
			default:
				strings.push( c );
				escaped = false;
				break;
		}
	}
	return quoteCount;
};

expandFormat = function( cal, format ) {
	// expands unspecified or single character date formats into the full pattern.
	format = format || "F";
	var pattern,
		patterns = cal.patterns,
		len = format.length;
	if ( len === 1 ) {
		pattern = patterns[ format ];
		if ( !pattern ) {
			throw "Invalid date format string \'" + format + "\'.";
		}
		format = pattern;
	}
	else if ( len === 2 && format.charAt(0) === "%" ) {
		// %X escape format -- intended as a custom format string that is only one character, not a built-in format.
		format = format.charAt( 1 );
	}
	return format;
};

formatDate = function( value, format, culture ) {
	var cal = culture.calendar,
		convert = cal.convert;

	if ( !format || !format.length || format === "i" ) {
		var ret;
		if ( culture && culture.name.length ) {
			if ( convert ) {
				// non-gregorian calendar, so we cannot use built-in toLocaleString()
				ret = formatDate( value, cal.patterns.F, culture );
			}
			else {
				var eraDate = new Date( value.getTime() ),
					era = getEra( value, cal.eras );
				eraDate.setFullYear( getEraYear(value, cal, era) );
				ret = eraDate.toLocaleString();
			}
		}
		else {
			ret = value.toString();
		}
		return ret;
	}

	var eras = cal.eras,
		sortable = format === "s";
	format = expandFormat( cal, format );

	// Start with an empty string
	ret = [];
	var hour,
		zeros = [ "0", "00", "000" ],
		foundDay,
		checkedDay,
		dayPartRegExp = /([^d]|^)(d|dd)([^d]|$)/g,
		quoteCount = 0,
		tokenRegExp = getTokenRegExp(),
		converted;

	function padZeros( num, c ) {
		var r, s = num + "";
		if ( c > 1 && s.length < c ) {
			r = ( zeros[c - 2] + s);
			return r.substr( r.length - c, c );
		}
		else {
			r = s;
		}
		return r;
	}

	function hasDay() {
		if ( foundDay || checkedDay ) {
			return foundDay;
		}
		foundDay = dayPartRegExp.test( format );
		checkedDay = true;
		return foundDay;
	}

	function getPart( date, part ) {
		if ( converted ) {
			return converted[ part ];
		}
		switch ( part ) {
			case 0: return date.getFullYear();
			case 1: return date.getMonth();
			case 2: return date.getDate();
		}
	}

	if ( !sortable && convert ) {
		converted = convert.fromGregorian( value );
	}

	for ( ; ; ) {
		// Save the current index
		var index = tokenRegExp.lastIndex,
			// Look for the next pattern
			ar = tokenRegExp.exec( format );

		// Append the text before the pattern (or the end of the string if not found)
		var preMatch = format.slice( index, ar ? ar.index : format.length );
		quoteCount += appendPreOrPostMatch( preMatch, ret );

		if ( !ar ) {
			break;
		}

		// do not replace any matches that occur inside a string literal.
		if ( quoteCount % 2 ) {
			ret.push( ar[0] );
			continue;
		}

		var current = ar[ 0 ],
			clength = current.length;

		switch ( current ) {
			case "ddd":
				//Day of the week, as a three-letter abbreviation
			case "dddd":
				// Day of the week, using the full name
				var names = ( clength === 3 ) ? cal.days.namesAbbr : cal.days.names;
				ret.push( names[value.getDay()] );
				break;
			case "d":
				// Day of month, without leading zero for single-digit days
			case "dd":
				// Day of month, with leading zero for single-digit days
				foundDay = true;
				ret.push(
					padZeros( getPart(value, 2), clength )
				);
				break;
			case "MMM":
				// Month, as a three-letter abbreviation
			case "MMMM":
				// Month, using the full name
				var part = getPart( value, 1 );
				ret.push(
					( cal.monthsGenitive && hasDay() )
					?
					cal.monthsGenitive[ clength === 3 ? "namesAbbr" : "names" ][ part ]
					:
					cal.months[ clength === 3 ? "namesAbbr" : "names" ][ part ]
				);
				break;
			case "M":
				// Month, as digits, with no leading zero for single-digit months
			case "MM":
				// Month, as digits, with leading zero for single-digit months
				ret.push(
					padZeros( getPart(value, 1) + 1, clength )
				);
				break;
			case "y":
				// Year, as two digits, but with no leading zero for years less than 10
			case "yy":
				// Year, as two digits, with leading zero for years less than 10
			case "yyyy":
				// Year represented by four full digits
				part = converted ? converted[ 0 ] : getEraYear( value, cal, getEra(value, eras), sortable );
				if ( clength < 4 ) {
					part = part % 100;
				}
				ret.push(
					padZeros( part, clength )
				);
				break;
			case "h":
				// Hours with no leading zero for single-digit hours, using 12-hour clock
			case "hh":
				// Hours with leading zero for single-digit hours, using 12-hour clock
				hour = value.getHours() % 12;
				if ( hour === 0 ) hour = 12;
				ret.push(
					padZeros( hour, clength )
				);
				break;
			case "H":
				// Hours with no leading zero for single-digit hours, using 24-hour clock
			case "HH":
				// Hours with leading zero for single-digit hours, using 24-hour clock
				ret.push(
					padZeros( value.getHours(), clength )
				);
				break;
			case "m":
				// Minutes with no leading zero for single-digit minutes
			case "mm":
				// Minutes with leading zero for single-digit minutes
				ret.push(
					padZeros( value.getMinutes(), clength )
				);
				break;
			case "s":
				// Seconds with no leading zero for single-digit seconds
			case "ss":
				// Seconds with leading zero for single-digit seconds
				ret.push(
					padZeros( value.getSeconds(), clength )
				);
				break;
			case "t":
				// One character am/pm indicator ("a" or "p")
			case "tt":
				// Multicharacter am/pm indicator
				part = value.getHours() < 12 ? ( cal.AM ? cal.AM[0] : " " ) : ( cal.PM ? cal.PM[0] : " " );
				ret.push( clength === 1 ? part.charAt(0) : part );
				break;
			case "f":
				// Deciseconds
			case "ff":
				// Centiseconds
			case "fff":
				// Milliseconds
				ret.push(
					padZeros( value.getMilliseconds(), 3 ).substr( 0, clength )
				);
				break;
			case "z":
				// Time zone offset, no leading zero
			case "zz":
				// Time zone offset with leading zero
				hour = value.getTimezoneOffset() / 60;
				ret.push(
					( hour <= 0 ? "+" : "-" ) + padZeros( Math.floor(Math.abs(hour)), clength )
				);
				break;
			case "zzz":
				// Time zone offset with leading zero
				hour = value.getTimezoneOffset() / 60;
				ret.push(
					( hour <= 0 ? "+" : "-" ) + padZeros( Math.floor(Math.abs(hour)), 2 )
					// Hard coded ":" separator, rather than using cal.TimeSeparator
					// Repeated here for consistency, plus ":" was already assumed in date parsing.
					+ ":" + padZeros( Math.abs(value.getTimezoneOffset() % 60), 2 )
				);
				break;
			case "g":
			case "gg":
				if ( cal.eras ) {
					ret.push(
						cal.eras[ getEra(value, eras) ].name
					);
				}
				break;
		case "/":
			ret.push( cal["/"] );
			break;
		default:
			throw "Invalid date format pattern \'" + current + "\'.";
			break;
		}
	}
	return ret.join( "" );
};

// formatNumber
(function() {
	var expandNumber;

	expandNumber = function( number, precision, formatInfo ) {
		var groupSizes = formatInfo.groupSizes,
			curSize = groupSizes[ 0 ],
			curGroupIndex = 1,
			factor = Math.pow( 10, precision ),
			rounded = Math.round( number * factor ) / factor;

		if ( !isFinite(rounded) ) {
			rounded = number;
		}
		number = rounded;

		var numberString = number+"",
			right = "",
			split = numberString.split( /e/i ),
			exponent = split.length > 1 ? parseInt( split[1], 10 ) : 0;
		numberString = split[ 0 ];
		split = numberString.split( "." );
		numberString = split[ 0 ];
		right = split.length > 1 ? split[ 1 ] : "";

		var l;
		if ( exponent > 0 ) {
			right = zeroPad( right, exponent, false );
			numberString += right.slice( 0, exponent );
			right = right.substr( exponent );
		}
		else if ( exponent < 0 ) {
			exponent = -exponent;
			numberString = zeroPad( numberString, exponent + 1 );
			right = numberString.slice( -exponent, numberString.length ) + right;
			numberString = numberString.slice( 0, -exponent );
		}

		if ( precision > 0 ) {
			right = formatInfo[ "." ] +
				( (right.length > precision) ? right.slice(0, precision) : zeroPad(right, precision) );
		}
		else {
			right = "";
		}

		var stringIndex = numberString.length - 1,
			sep = formatInfo[ "," ],
			ret = "";

		while ( stringIndex >= 0 ) {
			if ( curSize === 0 || curSize > stringIndex ) {
				return numberString.slice( 0, stringIndex + 1 ) + ( ret.length ? (sep + ret + right) : right );
			}
			ret = numberString.slice( stringIndex - curSize + 1, stringIndex + 1 ) + ( ret.length ? (sep + ret) : "" );

			stringIndex -= curSize;

			if ( curGroupIndex < groupSizes.length ) {
				curSize = groupSizes[ curGroupIndex ];
				curGroupIndex++;
			}
		}

		return numberString.slice( 0, stringIndex + 1 ) + sep + ret + right;
	};

	formatNumber = function( value, format, culture ) {
		if ( !isFinite(value) ) {
			if ( value === Infinity ) {
				return culture.numberFormat.positiveInfinity;
			}
			if ( value === -Infinity ) {
				return culture.numberFormat.negativeInfinity;
			}
			return culture.numberFormat.NaN;
		}
		if ( !format || format === "i" ) {
			return culture.name.length ? value.toLocaleString() : value.toString();
		}
		format = format || "D";

		var nf = culture.numberFormat,
			number = Math.abs( value ),
			precision = -1,
			pattern;
		if ( format.length > 1 ) precision = parseInt( format.slice(1), 10 );

		var current = format.charAt( 0 ).toUpperCase(),
			formatInfo;

		switch ( current ) {
			case "D":
				pattern = "n";
				number = truncate( number );
				if ( precision !== -1 ) {
					number = zeroPad( "" + number, precision, true );
				}
				if ( value < 0 ) number = "-" + number;
				break;
			case "N":
				formatInfo = nf;
				// fall through
			case "C":
				formatInfo = formatInfo || nf.currency;
				// fall through
			case "P":
				formatInfo = formatInfo || nf.percent;
				pattern = value < 0 ? formatInfo.pattern[ 0 ] : ( formatInfo.pattern[1] || "n" );
				if ( precision === -1 ) precision = formatInfo.decimals;
				number = expandNumber( number * (current === "P" ? 100 : 1), precision, formatInfo );
				break;
			default:
				throw "Bad number format specifier: " + current;
		}

		var patternParts = /n|\$|-|%/g,
			ret = "";
		for ( ; ; ) {
			var index = patternParts.lastIndex,
				ar = patternParts.exec( pattern );

			ret += pattern.slice( index, ar ? ar.index : pattern.length );

			if ( !ar ) {
				break;
			}

			switch ( ar[0] ) {
				case "n":
					ret += number;
					break;
				case "$":
					ret += nf.currency.symbol;
					break;
				case "-":
					// don't make 0 negative
					if ( /[1-9]/.test(number) ) {
						ret += nf[ "-" ];
					}
					break;
				case "%":
					ret += nf.percent.symbol;
					break;
			}
		}

		return ret;
	};

}());

getTokenRegExp = function() {
	// regular expression for matching date and time tokens in format strings.
	return /\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g;
};

getEra = function( date, eras ) {
	if ( !eras ) return 0;
	var start, ticks = date.getTime();
	for ( var i = 0, l = eras.length; i < l; i++ ) {
		start = eras[ i ].start;
		if ( start === null || ticks >= start ) {
			return i;
		}
	}
	return 0;
};

getEraYear = function( date, cal, era, sortable ) {
	var year = date.getFullYear();
	if ( !sortable && cal.eras ) {
		// convert normal gregorian year to era-shifted gregorian
		// year by subtracting the era offset
		year -= cal.eras[ era ].offset;
	}
	return year;
};

// parseExact
(function() {
	var expandYear,
		getDayIndex,
		getMonthIndex,
		getParseRegExp,
		outOfRange,
		toUpper,
		toUpperArray;

	expandYear = function( cal, year ) {
		// expands 2-digit year into 4 digits.
		if ( year < 100 ) {
			var now = new Date(),
				era = getEra( now ),
				curr = getEraYear( now, cal, era ),
				twoDigitYearMax = cal.twoDigitYearMax;
			twoDigitYearMax = typeof twoDigitYearMax === "string" ? new Date().getFullYear() % 100 + parseInt( twoDigitYearMax, 10 ) : twoDigitYearMax;
			year += curr - ( curr % 100 );
			if ( year > twoDigitYearMax ) {
				year -= 100;
			}
		}
		return year;
	};

	getDayIndex = function	( cal, value, abbr ) {
		var ret,
			days = cal.days,
			upperDays = cal._upperDays;
		if ( !upperDays ) {
			cal._upperDays = upperDays = [
				toUpperArray( days.names ),
				toUpperArray( days.namesAbbr ),
				toUpperArray( days.namesShort )
			];
		}
		value = toUpper( value );
		if ( abbr ) {
			ret = arrayIndexOf( upperDays[1], value );
			if ( ret === -1 ) {
				ret = arrayIndexOf( upperDays[2], value );
			}
		}
		else {
			ret = arrayIndexOf( upperDays[0], value );
		}
		return ret;
	};

	getMonthIndex = function( cal, value, abbr ) {
		var months = cal.months,
			monthsGen = cal.monthsGenitive || cal.months,
			upperMonths = cal._upperMonths,
			upperMonthsGen = cal._upperMonthsGen;
		if ( !upperMonths ) {
			cal._upperMonths = upperMonths = [
				toUpperArray( months.names ),
				toUpperArray( months.namesAbbr )
			];
			cal._upperMonthsGen = upperMonthsGen = [
				toUpperArray( monthsGen.names ),
				toUpperArray( monthsGen.namesAbbr )
			];
		}
		value = toUpper( value );
		var i = arrayIndexOf( abbr ? upperMonths[1] : upperMonths[0], value );
		if ( i < 0 ) {
			i = arrayIndexOf( abbr ? upperMonthsGen[1] : upperMonthsGen[0], value );
		}
		return i;
	};

	getParseRegExp = function( cal, format ) {
		// converts a format string into a regular expression with groups that
		// can be used to extract date fields from a date string.
		// check for a cached parse regex.
		var re = cal._parseRegExp;
		if ( !re ) {
			cal._parseRegExp = re = {};
		}
		else {
			var reFormat = re[ format ];
			if ( reFormat ) {
				return reFormat;
			}
		}

		// expand single digit formats, then escape regular expression characters.
		var expFormat = expandFormat( cal, format ).replace( /([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, "\\\\$1" ),
			regexp = [ "^" ],
			groups = [],
			index = 0,
			quoteCount = 0,
			tokenRegExp = getTokenRegExp(),
			match;

		// iterate through each date token found.
		while ( (match = tokenRegExp.exec(expFormat)) !== null ) {
			var preMatch = expFormat.slice( index, match.index );
			index = tokenRegExp.lastIndex;

			// don't replace any matches that occur inside a string literal.
			quoteCount += appendPreOrPostMatch( preMatch, regexp );
			if ( quoteCount % 2 ) {
				regexp.push( match[0] );
				continue;
			}

			// add a regex group for the token.
			var m = match[ 0 ],
				len = m.length,
				add;
			switch ( m ) {
				case "dddd": case "ddd":
				case "MMMM": case "MMM":
				case "gg": case "g":
					add = "(\\D+)";
					break;
				case "tt": case "t":
					add = "(\\D*)";
					break;
				case "yyyy":
				case "fff":
				case "ff":
				case "f":
					add = "(\\d{" + len + "})";
					break;
				case "dd": case "d":
				case "MM": case "M":
				case "yy": case "y":
				case "HH": case "H":
				case "hh": case "h":
				case "mm": case "m":
				case "ss": case "s":
					add = "(\\d\\d?)";
					break;
				case "zzz":
					add = "([+-]?\\d\\d?:\\d{2})";
					break;
				case "zz": case "z":
					add = "([+-]?\\d\\d?)";
					break;
				case "/":
					add = "(\\" + cal[ "/" ] + ")";
					break;
				default:
					throw "Invalid date format pattern \'" + m + "\'.";
					break;
			}
			if ( add ) {
				regexp.push( add );
			}
			groups.push( match[0] );
		}
		appendPreOrPostMatch( expFormat.slice(index), regexp );
		regexp.push( "$" );

		// allow whitespace to differ when matching formats.
		var regexpStr = regexp.join( "" ).replace( /\s+/g, "\\s+" ),
			parseRegExp = { "regExp": regexpStr, "groups": groups };

		// cache the regex for this format.
		return re[ format ] = parseRegExp;
	};

	outOfRange = function( value, low, high ) {
		return value < low || value > high;
	};

	toUpper = function( value ) {
		// "he-IL" has non-breaking space in weekday names.
		return value.split( "\u00A0" ).join( " " ).toUpperCase();
	};

	toUpperArray = function( arr ) {
		var results = [];
		for ( var i = 0, l = arr.length; i < l; i++ ) {
			results[ i ] = toUpper( arr[i] );
		}
		return results;
	};

	parseExact = function( value, format, culture ) {
		// try to parse the date string by matching against the format string
		// while using the specified culture for date field names.
		value = trim( value );
		var cal = culture.calendar,
			// convert date formats into regular expressions with groupings.
			// use the regexp to determine the input format and extract the date fields.
			parseInfo = getParseRegExp( cal, format ),
			match = new RegExp( parseInfo.regExp ).exec( value );
		if ( match === null ) {
			return null;
		}
		// found a date format that matches the input.
		var groups = parseInfo.groups,
			era = null, year = null, month = null, date = null, weekDay = null,
			hour = 0, hourOffset, min = 0, sec = 0, msec = 0, tzMinOffset = null,
			pmHour = false;
		// iterate the format groups to extract and set the date fields.
		for ( var j = 0, jl = groups.length; j < jl; j++ ) {
			var matchGroup = match[ j + 1 ];
			if ( matchGroup ) {
				var current = groups[ j ],
					clength = current.length,
					matchInt = parseInt( matchGroup, 10 );
				switch ( current ) {
					case "dd": case "d":
						// Day of month.
						date = matchInt;
						// check that date is generally in valid range, also checking overflow below.
						if ( outOfRange(date, 1, 31) ) return null;
						break;
					case "MMM": case "MMMM":
						month = getMonthIndex( cal, matchGroup, clength === 3 );
						if ( outOfRange(month, 0, 11) ) return null;
						break;
					case "M": case "MM":
						// Month.
						month = matchInt - 1;
						if ( outOfRange(month, 0, 11) ) return null;
						break;
					case "y": case "yy":
					case "yyyy":
						year = clength < 4 ? expandYear( cal, matchInt ) : matchInt;
						if ( outOfRange(year, 0, 9999) ) return null;
						break;
					case "h": case "hh":
						// Hours (12-hour clock).
						hour = matchInt;
						if ( hour === 12 ) hour = 0;
						if ( outOfRange(hour, 0, 11) ) return null;
						break;
					case "H": case "HH":
						// Hours (24-hour clock).
						hour = matchInt;
						if ( outOfRange(hour, 0, 23) ) return null;
						break;
					case "m": case "mm":
						// Minutes.
						min = matchInt;
						if ( outOfRange(min, 0, 59) ) return null;
						break;
					case "s": case "ss":
						// Seconds.
						sec = matchInt;
						if ( outOfRange(sec, 0, 59) ) return null;
						break;
					case "tt": case "t":
						// AM/PM designator.
						// see if it is standard, upper, or lower case PM. If not, ensure it is at least one of
						// the AM tokens. If not, fail the parse for this format.
						pmHour = cal.PM && ( matchGroup === cal.PM[0] || matchGroup === cal.PM[1] || matchGroup === cal.PM[2] );
						if (
							!pmHour && (
								!cal.AM || ( matchGroup !== cal.AM[0] && matchGroup !== cal.AM[1] && matchGroup !== cal.AM[2] )
							)
						) return null;
						break;
					case "f":
						// Deciseconds.
					case "ff":
						// Centiseconds.
					case "fff":
						// Milliseconds.
						msec = matchInt * Math.pow( 10, 3 - clength );
						if ( outOfRange(msec, 0, 999) ) return null;
						break;
					case "ddd":
						// Day of week.
					case "dddd":
						// Day of week.
						weekDay = getDayIndex( cal, matchGroup, clength === 3 );
						if ( outOfRange(weekDay, 0, 6) ) return null;
						break;
					case "zzz":
						// Time zone offset in +/- hours:min.
						var offsets = matchGroup.split( /:/ );
						if ( offsets.length !== 2 ) return null;
						hourOffset = parseInt( offsets[0], 10 );
						if ( outOfRange(hourOffset, -12, 13) ) return null;
						var minOffset = parseInt( offsets[1], 10 );
						if ( outOfRange(minOffset, 0, 59) ) return null;
						tzMinOffset = ( hourOffset * 60 ) + ( startsWith(matchGroup, "-") ? -minOffset : minOffset );
						break;
					case "z": case "zz":
						// Time zone offset in +/- hours.
						hourOffset = matchInt;
						if ( outOfRange(hourOffset, -12, 13) ) return null;
						tzMinOffset = hourOffset * 60;
						break;
					case "g": case "gg":
						var eraName = matchGroup;
						if ( !eraName || !cal.eras ) return null;
						eraName = trim( eraName.toLowerCase() );
						for ( var i = 0, l = cal.eras.length; i < l; i++ ) {
							if ( eraName === cal.eras[i].name.toLowerCase() ) {
								era = i;
								break;
							}
						}
						// could not find an era with that name
						if ( era === null ) return null;
						break;
				}
			}
		}
		var result = new Date(), defaultYear, convert = cal.convert;
		defaultYear = convert ? convert.fromGregorian( result )[ 0 ] : result.getFullYear();
		if ( year === null ) {
			year = defaultYear;
		}
		else if ( cal.eras ) {
			// year must be shifted to normal gregorian year
			// but not if year was not specified, its already normal gregorian
			// per the main if clause above.
			year += cal.eras[( era || 0 )].offset;
		}
		// set default day and month to 1 and January, so if unspecified, these are the defaults
		// instead of the current day/month.
		if ( month === null ) {
			month = 0;
		}
		if ( date === null ) {
			date = 1;
		}
		// now have year, month, and date, but in the culture's calendar.
		// convert to gregorian if necessary
		if ( convert ) {
			result = convert.toGregorian( year, month, date );
			// conversion failed, must be an invalid match
			if ( result === null ) return null;
		}
		else {
			// have to set year, month and date together to avoid overflow based on current date.
			result.setFullYear( year, month, date );
			// check to see if date overflowed for specified month (only checked 1-31 above).
			if ( result.getDate() !== date ) return null;
			// invalid day of week.
			if ( weekDay !== null && result.getDay() !== weekDay ) {
				return null;
			}
		}
		// if pm designator token was found make sure the hours fit the 24-hour clock.
		if ( pmHour && hour < 12 ) {
			hour += 12;
		}
		result.setHours( hour, min, sec, msec );
		if ( tzMinOffset !== null ) {
			// adjust timezone to utc before applying local offset.
			var adjustedMin = result.getMinutes() - ( tzMinOffset + result.getTimezoneOffset() );
			// Safari limits hours and minutes to the range of -127 to 127.	 We need to use setHours
			// to ensure both these fields will not exceed this range.	adjustedMin will range
			// somewhere between -1440 and 1500, so we only need to split this into hours.
			result.setHours( result.getHours() + parseInt(adjustedMin / 60, 10), adjustedMin % 60 );
		}
		return result;
	};
}());

parseNegativePattern = function( value, nf, negativePattern ) {
	var neg = nf[ "-" ],
		pos = nf[ "+" ],
		ret;
	switch ( negativePattern ) {
		case "n -":
			neg = " " + neg;
			pos = " " + pos;
			// fall through
		case "n-":
			if ( endsWith(value, neg) ) {
				ret = [ "-", value.substr(0, value.length - neg.length) ];
			}
			else if ( endsWith(value, pos) ) {
				ret = [ "+", value.substr(0, value.length - pos.length) ];
			}
			break;
		case "- n":
			neg += " ";
			pos += " ";
			// fall through
		case "-n":
			if ( startsWith(value, neg) ) {
				ret = [ "-", value.substr(neg.length) ];
			}
			else if ( startsWith(value, pos) ) {
				ret = [ "+", value.substr(pos.length) ];
			}
			break;
		case "(n)":
			if ( startsWith(value, "(") && endsWith(value, ")") ) {
				ret = [ "-", value.substr(1, value.length - 2) ];
			}
			break;
	}
	return ret || [ "", value ];
};

//
// public instance functions
//

Globalize.prototype.findClosestCulture = function( cultureSelector ) {
	return Globalize.findClosestCulture.call( this, cultureSelector );
};

Globalize.prototype.format = function( value, format, cultureSelector ) {
	return Globalize.format.call( this, value, format, cultureSelector );
};

Globalize.prototype.localize = function( key, cultureSelector ) {
	return Globalize.localize.call( this, key, cultureSelector );
};

Globalize.prototype.parseInt = function( value, radix, cultureSelector ) {
	return Globalize.parseInt.call( this, value, radix, cultureSelector );
};

Globalize.prototype.parseFloat = function( value, radix, cultureSelector ) {
	return Globalize.parseFloat.call( this, value, radix, cultureSelector );
};

Globalize.prototype.culture = function( cultureSelector ) {
	return Globalize.culture.call( this, cultureSelector );
};

//
// public singleton functions
//

Globalize.addCultureInfo = function( cultureName, baseCultureName, info ) {

	var base = {},
		isNew = false;

	if ( typeof cultureName !== "string" ) {
		// cultureName argument is optional string. If not specified, assume info is first
		// and only argument. Specified info deep-extends current culture.
		info = cultureName;
		cultureName = this.culture().name;
		base = this.cultures[ cultureName ];
	} else if ( typeof baseCultureName !== "string" ) {
		// baseCultureName argument is optional string. If not specified, assume info is second
		// argument. Specified info deep-extends specified culture.
		// If specified culture does not exist, create by deep-extending default
		info = baseCultureName;
		isNew = ( this.cultures[ cultureName ] == null );
		base = this.cultures[ cultureName ] || this.cultures[ "default" ];
	} else {
		// cultureName and baseCultureName specified. Assume a new culture is being created
		// by deep-extending an specified base culture
		isNew = true;
		base = this.cultures[ baseCultureName ];
	}

	this.cultures[ cultureName ] = extend(true, {},
		base,
		info
	);
	// Make the standard calendar the current culture if it's a new culture
	if ( isNew ) {
		this.cultures[ cultureName ].calendar = this.cultures[ cultureName ].calendars.standard;
	}
};

Globalize.findClosestCulture = function( name ) {
	var match;
	if ( !name ) {
		return this.findClosestCulture( this.cultureSelector ) || this.cultures[ "default" ];
	}
	if ( typeof name === "string" ) {
		name = name.split( "," );
	}
	if ( isArray(name) ) {
		var lang,
			cultures = this.cultures,
			list = name,
			i, l = list.length,
			prioritized = [];
		for ( i = 0; i < l; i++ ) {
			name = trim( list[i] );
			var pri, parts = name.split( ";" );
			lang = trim( parts[0] );
			if ( parts.length === 1 ) {
				pri = 1;
			}
			else {
				name = trim( parts[1] );
				if ( name.indexOf("q=") === 0 ) {
					name = name.substr( 2 );
					pri = parseFloat( name );
					pri = isNaN( pri ) ? 0 : pri;
				}
				else {
					pri = 1;
				}
			}
			prioritized.push({ lang: lang, pri: pri });
		}
		prioritized.sort(function( a, b ) {
			return a.pri < b.pri ? 1 : -1;
		});

		// exact match
		for ( i = 0; i < l; i++ ) {
			lang = prioritized[ i ].lang;
			match = cultures[ lang ];
			if ( match ) {
				return match;
			}
		}

		// neutral language match
		for ( i = 0; i < l; i++ ) {
			lang = prioritized[ i ].lang;
			do {
				var index = lang.lastIndexOf( "-" );
				if ( index === -1 ) {
					break;
				}
				// strip off the last part. e.g. en-US => en
				lang = lang.substr( 0, index );
				match = cultures[ lang ];
				if ( match ) {
					return match;
				}
			}
			while ( 1 );
		}

		// last resort: match first culture using that language
		for ( i = 0; i < l; i++ ) {
			lang = prioritized[ i ].lang;
			for ( var cultureKey in cultures ) {
				var culture = cultures[ cultureKey ];
				if ( culture.language == lang ) {
					return culture;
				}
			}
		}
	}
	else if ( typeof name === "object" ) {
		return name;
	}
	return match || null;
};

Globalize.format = function( value, format, cultureSelector ) {
	culture = this.findClosestCulture( cultureSelector );
	if ( value instanceof Date ) {
		value = formatDate( value, format, culture );
	}
	else if ( typeof value === "number" ) {
		value = formatNumber( value, format, culture );
	}
	return value;
};

Globalize.localize = function( key, cultureSelector ) {
	return this.findClosestCulture( cultureSelector ).messages[ key ] ||
		this.cultures[ "default" ].messages[ key ];
};

Globalize.parseDate = function( value, formats, culture ) {
	culture = this.findClosestCulture( culture );

	var date, prop, patterns;
	if ( formats ) {
		if ( typeof formats === "string" ) {
			formats = [ formats ];
		}
		if ( formats.length ) {
			for ( var i = 0, l = formats.length; i < l; i++ ) {
				var format = formats[ i ];
				if ( format ) {
					date = parseExact( value, format, culture );
					if ( date ) {
						break;
					}
				}
			}
		}
	} else {
		patterns = culture.calendar.patterns;
		for ( prop in patterns ) {
			date = parseExact( value, patterns[prop], culture );
			if ( date ) {
				break;
			}
		}
	}

	return date || null;
};

Globalize.parseInt = function( value, radix, cultureSelector ) {
	return truncate( Globalize.parseFloat(value, radix, cultureSelector) );
};

Globalize.parseFloat = function( value, radix, cultureSelector ) {
	// radix argument is optional
	if ( typeof radix !== "number" ) {
		cultureSelector = radix;
		radix = 10;
	}

	var culture = this.findClosestCulture( cultureSelector );
	var ret = NaN,
		nf = culture.numberFormat;

	if ( value.indexOf(culture.numberFormat.currency.symbol) > -1 ) {
		// remove currency symbol
		value = value.replace( culture.numberFormat.currency.symbol, "" );
		// replace decimal seperator
		value = value.replace( culture.numberFormat.currency["."], culture.numberFormat["."] );
	}

	// trim leading and trailing whitespace
	value = trim( value );

	// allow infinity or hexidecimal
	if ( regexInfinity.test(value) ) {
		ret = parseFloat( value );
	}
	else if ( !radix && regexHex.test(value) ) {
		ret = parseInt( value, 16 );
	}
	else {

		// determine sign and number
		var signInfo = parseNegativePattern( value, nf, nf.pattern[0] ),
			sign = signInfo[ 0 ],
			num = signInfo[ 1 ];

		// #44 - try parsing as "(n)"
		if ( sign === "" && nf.pattern[0] !== "(n)" ) {
			signInfo = parseNegativePattern( value, nf, "(n)" );
			sign = signInfo[ 0 ];
			num = signInfo[ 1 ];
		}

		// try parsing as "-n"
		if ( sign === "" && nf.pattern[0] !== "-n" ) {
			signInfo = parseNegativePattern( value, nf, "-n" );
			sign = signInfo[ 0 ];
			num = signInfo[ 1 ];
		}

		sign = sign || "+";

		// determine exponent and number
		var exponent,
			intAndFraction,
			exponentPos = num.indexOf( "e" );
		if ( exponentPos < 0 ) exponentPos = num.indexOf( "E" );
		if ( exponentPos < 0 ) {
			intAndFraction = num;
			exponent = null;
		}
		else {
			intAndFraction = num.substr( 0, exponentPos );
			exponent = num.substr( exponentPos + 1 );
		}
		// determine decimal position
		var integer,
			fraction,
			decSep = nf[ "." ],
			decimalPos = intAndFraction.indexOf( decSep );
		if ( decimalPos < 0 ) {
			integer = intAndFraction;
			fraction = null;
		}
		else {
			integer = intAndFraction.substr( 0, decimalPos );
			fraction = intAndFraction.substr( decimalPos + decSep.length );
		}
		// handle groups (e.g. 1,000,000)
		var groupSep = nf[ "," ];
		integer = integer.split( groupSep ).join( "" );
		var altGroupSep = groupSep.replace( /\u00A0/g, " " );
		if ( groupSep !== altGroupSep ) {
			integer = integer.split( altGroupSep ).join( "" );
		}
		// build a natively parsable number string
		var p = sign + integer;
		if ( fraction !== null ) {
			p += "." + fraction;
		}
		if ( exponent !== null ) {
			// exponent itself may have a number patternd
			var expSignInfo = parseNegativePattern( exponent, nf, "-n" );
			p += "e" + ( expSignInfo[0] || "+" ) + expSignInfo[ 1 ];
		}
		if ( regexParseFloat.test(p) ) {
			ret = parseFloat( p );
		}
	}
	return ret;
};

Globalize.culture = function( cultureSelector ) {
	// setter
	if ( typeof cultureSelector !== "undefined" ) {
		this.cultureSelector = cultureSelector;
	}
	// getter
	return this.findClosestCulture( cultureSelector ) || this.culture[ "default" ];
};

}( this ));

});

require.define("/node_modules/globalize/globalize.culture.en-US.js",function(require,module,exports,__dirname,__filename,process,global){/*
 * Globalize Culture en-US
 *
 * http://github.com/jquery/globalize
 *
 * Copyright Software Freedom Conservancy, Inc.
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * This file was generated by the Globalize Culture Generator
 * Translation: bugs found in this file need to be fixed in the generator
 */

(function( window, undefined ) {

var Globalize;

if ( typeof require !== "undefined"
	&& typeof exports !== "undefined"
	&& typeof module !== "undefined" ) {
	// Assume CommonJS
	Globalize = require( "globalize" );
} else {
	// Global variable
	Globalize = window.Globalize;
}

Globalize.addCultureInfo( "en-US", "default", {
	name: "en-US",
	englishName: "English (United States)"
});

}( this ));

});

require.define("/lib/client/share/utils/date_converter.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var convertDate, convertDatetime, dateRegexp, formatAsClientDate, formatAsClientTime, fromClientToDatetime;

  if (typeof module !== 'undefined' && module.exports) require('date-utils');

  /*
  Утилиты для конвертирования и форматирования дат, которыми обмениваются клиент и сервер.
  Сервер хранит либо время timestamp'ом, либо дату iso-строкой
  */

  dateRegexp = /(\d{4})-(\d{2})-(\d{2})/;

  convertDate = exports.convertDate = function(date) {
    var month, year, _ref;
    _ref = date.match(dateRegexp).slice(1, 4), year = _ref[0], month = _ref[1], date = _ref[2];
    return new Date(year, month - 1, date);
  };

  convertDatetime = exports.convertDatetime = function(datetime) {
    return new Date(datetime * 1000);
  };

  exports.convertCalendricalDate = function(date) {
    var day, month, year, _ref;
    _ref = date.split('/'), day = _ref[0], month = _ref[1], year = _ref[2];
    return new Date(year, month - 1, day);
  };

  formatAsClientDate = exports.formatAsClientDate = function(date) {
    return date.toFormat('DD.MM.YYYY');
  };

  formatAsClientTime = exports.formatAsClientTime = function(date) {
    return date.toFormat('HH24:MI');
  };

  exports.convertDateTimeToClient = function(date, datetime) {
    var serverTime;
    if (datetime) {
      serverTime = convertDatetime(datetime);
      return [formatAsClientDate(serverTime), formatAsClientTime(serverTime)];
    } else if (date) {
      return [formatAsClientDate(convertDate(date))];
    } else {
      return [];
    }
  };

  fromClientToDatetime = exports.fromClientToDatetime = function(date, time) {
    var day, hour, minute, month, year, _ref, _ref2;
    _ref = date.split('.'), day = _ref[0], month = _ref[1], year = _ref[2];
    month -= 1;
    if (date && time) {
      _ref2 = time.split(':'), hour = _ref2[0], minute = _ref2[1];
      return new Date(year, month, day, hour, minute);
    } else if (date) {
      return new Date(year, month, day);
    }
  };

  exports.convertDateTimeToServer = function(date, time) {
    var localtime;
    if (!date && !time) return [];
    localtime = fromClientToDatetime(date, time);
    if (date && time) {
      return [void 0, Math.floor(localtime.getTime() / 1000)];
    } else if (date) {
      return [localtime.toYMD()];
    }
  };

}).call(this);

});

require.define("/node_modules/date-utils/package.json",function(require,module,exports,__dirname,__filename,process,global){module.exports = {"main":"./lib/date-utils"}
});

require.define("/node_modules/date-utils/lib/date-utils.js",function(require,module,exports,__dirname,__filename,process,global){/*

© 2011 by Jerry Sievert

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

(function () {
    // constants
    var monthsAbbr = [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec'
    ];

    var monthsFull = [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December'
    ];

    var daysAbbr = [
        'Sun',
        'Mon',
        'Tue',
        'Wed',
        'Thu',
        'Fri',
        'Sat'
    ];

    var daysFull = [
        'Sunday',
        'Monday',
        'Tuesday',
        'Wednesday',
        'Thursday',
        'Friday',
        'Saturday'
    ];

    var dayNames = {
        'su':         0,
        'sun':        0,
        'sunday':     0,
        'mo':         1,
        'mon':        1,
        'monday':     1,
        'tu':         2,
        'tue':        2,
        'tuesday':    2,
        'we':         3,
        'wed':        3,
        'wednesday':  3,
        'th':         4,
        'thu':        4,
        'thursday':   4,
        'fr':         5,
        'fri':        5,
        'friday':     5,
        'sa':         6,
        'sat':        6,
        'saturday':   6
    };
    var monthsAll = monthsFull.concat(monthsAbbr);
    var daysAll = [
        'su',
        'sun',
        'sunday',
        'mo',
        'mon',
        'monday',
        'tu',
        'tue',
        'tuesday',
        'we',
        'wed',
        'wednesday',
        'th',
        'thu',
        'thursday',
        'fr',
        'fri',
        'friday',
        'sa',
        'sat',
        'saturday'
    ];

    var monthNames = {
        'jan':        0,
        'january':    0,
        'feb':        1,
        'february':   1,
        'mar':        2,
        'march':      2,
        'apr':        3,
        'april':      3,
        'may':        4,
        'jun':        5,
        'june':       5,
        'jul':        6,
        'july':       6,
        'aug':        7,
        'august':     7,
        'sep':        8,
        'september':  8,
        'oct':        9,
        'october':    9,
        'nov':        10,
        'november':   10,
        'dec':        11,
        'december':   11
    };

    var daysInMonth = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];


    // private helper functions
    /** @ignore */
    function pad(str, length) {
        str = String(str);
        while (str.length < length) {
            str = '0' + str;
        }
        return str;
    }

    var isInteger = function (str) {
        if (str.match(/^(\d+)$/)) {
            return true;
        }
        return false;
    };
    var getInt = function (str, i, minlength, maxlength) {
        for (var x = maxlength; x >= minlength; x--) {
            var token = str.substring(i, i + x);
            if (token.length < minlength) {
                return null;
            }
            if (isInteger(token)) {
                return token;
            }
        }
        return null;
    };

    // static class methods
    var origParse = Date.parse;
    // ------------------------------------------------------------------
    // getDateFromFormat( date_string , format_string )
    //
    // This function takes a date string and a format string. It matches
    // If the date string matches the format string, it returns the
    // getTime() of the date. If it does not match, it returns NaN.
    // Original Author: Matt Kruse <matt@mattkruse.com>
    // WWW: http://www.mattkruse.com/
    // Adapted from: http://www.mattkruse.com/javascript/date/source.html
    // ------------------------------------------------------------------


    var getDateFromFormat = function (val, format) {
        val = val + "";
        format = format + "";
        var iVal = 0;
        var iFormat = 0;
        var c = "";
        var token = "";
        var token2 = "";
        var x, y;
        var now = new Date();
        var year = now.getYear();
        var month = now.getMonth() + 1;
        var date = 1;
        var hh = 0;
        var mm = 0;
        var ss = 0;
        var ampm = "";



        while (iFormat < format.length) {
            // Get next token from format string
            c = format.charAt(iFormat);
            token = "";
            while ((format.charAt(iFormat) === c) && (iFormat < format.length)) {
                token += format.charAt(iFormat++);
            }
            // Extract contents of value based on format token
            if (token === "yyyy" || token === "yy" || token === "y") {
                if (token === "yyyy") {
                    x = 4;
                    y = 4;
                }
                if (token === "yy") {
                    x = 2;
                    y = 2;
                }
                if (token === "y") {
                    x = 2;
                    y = 4;
                }
                year = getInt(val, iVal, x, y);
                if (year === null) {
                    return NaN;
                }
                iVal += year.length;
                if (year.length === 2) {
                    if (year > 70) {
                        year = 1900 + (year - 0);
                    } else {
                        year = 2000 + (year - 0);
                    }
                }
            } else if (token === "MMM" || token === "NNN") {
                month = 0;
                for (var i = 0; i < monthsAll.length; i++) {
                    var monthName = monthsAll[i];
                    if (val.substring(iVal, iVal + monthName.length).toLowerCase() === monthName.toLowerCase()) {
                        if (token === "MMM" || (token === "NNN" && i > 11)) {
                            month = i + 1;
                            if (month > 12) {
                                month -= 12;
                            }
                            iVal += monthName.length;
                            break;
                        }
                    }
                }
                if ((month < 1) || (month > 12)) {
                    return NaN;
                }
            } else if (token === "EE" || token === "E") {
                for (var n = 0; n < daysAll.length; n++) {
                    var dayName = daysAll[n];
                    if (val.substring(iVal, iVal + dayName.length).toLowerCase() === dayName.toLowerCase()) {
                        iVal += dayName.length;
                        break;
                    }
                }
            } else if (token === "MM" || token === "M") {
                month = getInt(val, iVal, token.length, 2);
                if (month === null || (month < 1) || (month > 12)) {
                    return NaN;
                }
                iVal += month.length;
            } else if (token === "dd" || token === "d") {
                date = getInt(val, iVal, token.length, 2);
                if (date === null || (date < 1) || (date > 31)) {
                    return NaN;
                }
                iVal += date.length;
            } else if (token === "hh" || token === "h") {
                hh = getInt(val, iVal, token.length, 2);
                if (hh === null || (hh < 1) || (hh > 12)) {
                    return NaN;
                }
                iVal += hh.length;
            } else if (token === "HH" || token === "H") {
                hh = getInt(val, iVal, token.length, 2);
                if (hh === null || (hh < 0) || (hh > 23)) {
                    return NaN;
                }
                iVal += hh.length;
            } else if (token === "KK" || token === "K") {
                hh = getInt(val, iVal, token.length, 2);
                if (hh === null || (hh < 0) || (hh > 11)) {
                    return NaN;
                }
                iVal += hh.length;
            } else if (token === "kk" || token === "k") {
                hh = getInt(val, iVal, token.length, 2);
                if (hh === null || (hh < 1) || (hh > 24)) {
                    return NaN;
                }
                iVal += hh.length;
                hh--;
            } else if (token === "mm" || token === "m") {
                mm = getInt(val, iVal, token.length, 2);
                if (mm === null || (mm < 0) || (mm > 59)) {
                    return NaN;
                }
                iVal += mm.length;
            } else if (token === "ss" || token === "s") {
                ss = getInt(val, iVal, token.length, 2);
                if (ss === null || (ss < 0) || (ss > 59)) {
                    return NaN;
                }
                iVal += ss.length;
            } else if (token === "a") {
                if (val.substring(iVal, iVal + 2).toLowerCase() === "am") {
                    ampm = "AM";
                } else if (val.substring(iVal, iVal + 2).toLowerCase() === "pm") {
                    ampm = "PM";
                } else {
                    return NaN;
                }
                iVal += 2;
            } else {
                if (val.substring(iVal, iVal + token.length) !== token) {
                    return NaN;
                } else {
                    iVal += token.length;
                }
            }
        }
        // If there are any trailing characters left in the value, it doesn't match
        if (iVal !== val.length) {
            return NaN;
        }
        // Is date valid for month?
        if (month === 2) {
            // Check for leap year
            if (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0)) { // leap year
                if (date > 29) {
                    return NaN;
                }
            } else {
                if (date > 28) {
                    return NaN;
                }
            }
        }
        if ((month === 4) || (month === 6) || (month === 9) || (month === 11)) {
            if (date > 30) {
                return NaN;
            }
        }
        // Correct hours value
        if (hh < 12 && ampm === "PM") {
            hh = hh - 0 + 12;
        } else if (hh > 11 && ampm === "AM") {
            hh -= 12;
        }
        var newdate = new Date(year, month - 1, date, hh, mm, ss);
        return newdate.getTime();
    };


    /** @ignore */
    Date.parse = function (date, format) {
        if (format) {
            return getDateFromFormat(date, format);
        }
        var timestamp = origParse(date), minutesOffset = 0, match;
        if (isNaN(timestamp) && (match = /^(\d{4}|[+\-]\d{6})-(\d{2})-(\d{2})(?:[T ](\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?))?/.exec(date))) {
            if (match[8] !== 'Z') {
                minutesOffset = +match[10] * 60 + (+match[11]);

                if (match[9] === '+') {
                    minutesOffset = 0 - minutesOffset;
                }
            }

            match[7] = match[7] || '000';

            timestamp = Date.UTC(+match[1], +match[2] - 1, +match[3], +match[4], +match[5] + minutesOffset, +match[6], +match[7].substr(0, 3));
        }

        return timestamp;
    };

    function polyfill(name, func) {
        if (Date.prototype[name] === undefined) {
            Date.prototype[name] = func;
        }
    }

    /**
        Returns new instance of Date object with the date set to today and
        the time set to midnight
        @returns {Date} Today's Date
        @function
     */
    Date.today = function () {
        return new Date().clearTime();
    };

    /**
        Returns new instance of Date object with the date set to today and
        the time set to midnight in UTC
        @returns {Date} Today's Date in UTC
        @function
     */
    Date.UTCtoday = function () {
        return new Date().clearUTCTime();
    };

    /**
        Returns new instance of Date object with the date set to tomorrow and
        the time set to midnight
        @returns {Date} Tomorrow's Date
        @function
     */
    Date.tomorrow = function () {
        return Date.today().add({days: 1});
    };

    /**
        Returns new instance of Date object with the date set to tomorrow and
        the time set to midnight in UTC
        @returns {Date} Tomorrow's Date in UTC
        @function
     */
    Date.UTCtomorrow = function () {
        return Date.UTCtoday().add({days: 1});
    };

    /**
        Returns new instance of Date object with the date set to yesterday and
        the time set to midnight
        @returns {Date} Yesterday's Date
        @function
     */
    Date.yesterday = function () {
        return Date.today().add({days: -1});
    };

    /**
        Returns new instance of Date object with the date set to yesterday and
        the time set to midnight in UTC
        @returns {Date} Yesterday's Date in UTC
        @function
     */
    Date.UTCyesterday = function () {
        return Date.UTCtoday().add({days: -1});
    };

    Date.validateDay = function (day, year, month) {
        var date = new Date(year, month, day);
        return (date.getFullYear() === year &&
            date.getMonth() === month &&
            date.getDate() === day);
    };

    Date.validateYear = function (year) {
        return (year >= 0 && year <= 9999);
    };

    Date.validateSecond = function (second) {
        return (second >= 0 && second < 60);
    };

    Date.validateMonth = function (month) {
        return (month >= 0 && month < 12);
    };

    Date.validateMinute = function (minute) {
        return (minute >= 0 && minute < 60);
    };

    Date.validateMillisecond = function (milli) {
        return (milli >= 0 && milli < 1000);
    };

    Date.validateHour = function (hour) {
        return (hour >= 0 && hour < 24);
    };

    Date.compare = function (date1, date2) {
        if (date1.valueOf() < date2.valueOf()) {
            return -1;
        } else if (date1.valueOf() > date2.valueOf()) {
            return 1;
        }
        return 0;
    };

    Date.equals = function (date1, date2) {
        return date1.valueOf() === date2.valueOf();
    };


    Date.getDayNumberFromName = function (name) {
        return dayNames[name.toLowerCase()];
    };


    Date.getMonthNumberFromName = function (name) {
        return monthNames[name.toLowerCase()];
    };

    Date.isLeapYear = function (year) {
        return (new Date(year, 1, 29).getDate() === 29);
    };

    Date.getDaysInMonth = function (year, month) {
        if (month === 1) {
            return Date.isLeapYear(year) ? 29 : 28;
        }
        return daysInMonth[month];
    };

    polyfill('getMonthAbbr', function () {
        return monthsAbbr[this.getMonth()];
    });

    polyfill('getMonthName', function () {
        return monthsFull[this.getMonth()];
    });

    polyfill('getUTCOffset', function () {
        var tz = pad(Math.abs(this.getTimezoneOffset() / 0.6), 4);
        if (this.getTimezoneOffset() > 0) {
            tz = '-' + tz;
        }
        return tz;
    });

    polyfill('toCLFString',  function () {
        return pad(this.getDate(), 2) + '/' + this.getMonthAbbr() + '/' +
               this.getFullYear() + ':' + pad(this.getHours(), 2) + ':' +
               pad(this.getMinutes(), 2) + ':' + pad(this.getSeconds(), 2) +
               ' ' + this.getUTCOffset();
    });

    polyfill('toYMD', function (separator) {
        separator = typeof separator === 'undefined' ? '-' : separator;
        return this.getFullYear() + separator + pad(this.getMonth() + 1, 2) +
            separator + pad(this.getDate(), 2);
    });

    polyfill('toDBString', function () {
        return this.getUTCFullYear() + '-' +  pad(this.getUTCMonth() + 1, 2) +
               '-' + pad(this.getUTCDate(), 2) + ' ' + pad(this.getUTCHours(), 2) +
               ':' + pad(this.getUTCMinutes(), 2) + ':' + pad(this.getUTCSeconds(), 2);
    });

    polyfill('clearTime', function () {
        this.setHours(0);
        this.setMinutes(0);
        this.setSeconds(0);
        this.setMilliseconds(0);

        return this;
    });

    polyfill('clearUTCTime', function () {
        this.setUTCHours(0);
        this.setUTCMinutes(0);
        this.setUTCSeconds(0);
        this.setUTCMilliseconds(0);

        return this;
    });

    polyfill('add', function (obj) {
        if (obj.milliseconds !== undefined) {
            this.setMilliseconds(this.getMilliseconds() + obj.milliseconds);
        }
        if (obj.seconds !== undefined) {
            this.setSeconds(this.getSeconds() + obj.seconds);
        }
        if (obj.minutes !== undefined) {
            this.setMinutes(this.getMinutes() + obj.minutes);
        }
        if (obj.hours !== undefined) {
            this.setHours(this.getHours() + obj.hours);
        }
        if (obj.days !== undefined) {
            this.setDate(this.getDate() + obj.days);
        }
        if (obj.months !== undefined) {
            this.setMonth(this.getMonth() + obj.months);
        }
        if (obj.years !== undefined) {
            this.setFullYear(this.getFullYear() + obj.years);
        }
        return this;
    });

    polyfill('addMilliseconds', function (milliseconds) {
        return this.add({ milliseconds: milliseconds });
    });

    polyfill('addSeconds', function (seconds) {
        return this.add({ seconds: seconds });
    });

    polyfill('addMinutes', function (minutes) {
        return this.add({ minutes: minutes });
    });

    polyfill('addHours', function (hours) {
        return this.add({ hours: hours });
    });

    polyfill('addDays', function (days) {
        return this.add({ days: days });
    });

    polyfill('addWeeks', function (weeks) {
        return this.add({ days: (weeks * 7) });
    });

    polyfill('addMonths', function (months) {
        return this.add({ months: months });
    });

    polyfill('addYears', function (years) {
        return this.add({ years: years });
    });

    polyfill('setTimeToNow', function () {
        var n = new Date();
        this.setMilliseconds(n.getMilliseconds());
        this.setSeconds(n.getSeconds());
        this.setMinutes(n.getMinutes());
        this.setHours(n.getHours());
    });

    polyfill('clone', function () {
        return new Date(this.valueOf());
    });

    polyfill('between', function (start, end) {
        return (this.valueOf() >= start.valueOf() &&
                this.valueOf() <= end.valueOf());
    });

    polyfill('compareTo', function (date) {
        return Date.compare(this, date);
    });

    polyfill('equals', function (date) {
        return Date.equals(this, date);
    });

    polyfill('isAfter', function (date) {
        date = date ? date : new Date();
        return (this.compareTo(date) > 0);
    });

    polyfill('isBefore', function (date) {
        date = date ? date : new Date();
        return (this.compareTo(date) < 0);
    });

    polyfill('getDaysBetween', function (date) {
        return ((date.clone().valueOf() - this.valueOf()) / 86400000) | 0;
    });

    polyfill('getHoursBetween', function (date) {
        return ((date.clone().valueOf() - this.valueOf()) / 3600000) | 0;
    });

    polyfill('getMinutesBetween', function (date) {
        return ((date.clone().valueOf() - this.valueOf()) / 60000) | 0;
    });

    polyfill('getSecondsBetween', function (date) {
        return ((date.clone().valueOf() - this.valueOf()) / 1000) | 0;
    });

    polyfill('getOrdinalNumber', function () {
        return Math.ceil((this.clone().clearTime() - new Date(this.getFullYear(), 0, 1)) / 86400000) + 1;
    });

    polyfill('toFormat', function (format) {
        return toFormat(format, getReplaceMap(this));
    });

    polyfill('toUTCFormat', function (format) {
        return toFormat(format, getUTCReplaceMap(this));
    });

    var toFormat = function(format, replaceMap) {
        var f = [ format ], i, l, s;
        var replace = function (str, rep) {
            var i = 0, l = f.length, j, ll, t, n = [];
            for (; i < l; i++) {
                if (typeof f[i] == 'string') {
                    t = f[i].split(str);
                    for (j = 0, ll = t.length - 1; j < ll; j++) {
                        n.push(t[j]);
                        n.push([rep]); // replacement pushed as non-string
                    }
                    n.push(t[ll]);
                } else {
                    // must be a replacement, don't process, just push
                    n.push(f[i]);
                }
            }
            f = n;
        };

        for (i in replaceMap) {
            replace(i, replaceMap[i]);
        }

        s = '';
        for (i = 0, l = f.length; i < l; i++)
          s += typeof f[i] == 'string' ? f[i] : f[i][0];
        return f.join('');
    };

    var getReplaceMap = function(date) {
        var hours = (date.getHours() % 12) ? date.getHours() % 12 : 12;
        return {
            'YYYY': date.getFullYear(),
            'YY': String(date.getFullYear()).slice(-2),
            'MMMM': monthsFull[date.getMonth()],
            'MMM': monthsAbbr[date.getMonth()],
            'MM': pad(date.getMonth() + 1, 2),
            'MI': pad(date.getMinutes(), 2),
            'M': date.getMonth() + 1,
            'DDDD': daysFull[date.getDay()],
            'DDD': daysAbbr[date.getDay()],
            'DD': pad(date.getDate(), 2),
            'D': date.getDate(),
            'HH24': pad(date.getHours(), 2),
            'HH': pad(hours, 2),
            'H': hours,
            'SS': pad(date.getSeconds(), 2),
            'PP': (date.getHours() >= 12) ? 'PM' : 'AM',
            'P': (date.getHours() >= 12) ? 'pm' : 'am',
            'LL': pad(date.getMilliseconds(), 3)
        };
    };

    var getUTCReplaceMap = function(date) {
        var hours = (date.getUTCHours() % 12) ? date.getUTCHours() % 12 : 12;
        return {
            'YYYY': date.getUTCFullYear(),
            'YY': String(date.getUTCFullYear()).slice(-2),
            'MMMM': monthsFull[date.getUTCMonth()],
            'MMM': monthsAbbr[date.getUTCMonth()],
            'MM': pad(date.getUTCMonth() + 1, 2),
            'MI': pad(date.getUTCMinutes(), 2),
            'M': date.getUTCMonth() + 1,
            'DDDD': daysFull[date.getUTCDay()],
            'DDD': daysAbbr[date.getUTCDay()],
            'DD': pad(date.getUTCDate(), 2),
            'D': date.getUTCDate(),
            'HH24': pad(date.getUTCHours(), 2),
            'HH': pad(hours, 2),
            'H': hours,
            'SS': pad(date.getUTCSeconds(), 2),
            'PP': (date.getUTCHours() >= 12) ? 'PM' : 'AM',
            'P': (date.getUTCHours() >= 12) ? 'pm' : 'am',
            'LL': pad(date.getUTCMilliseconds(), 3)
        };
    };
}());

});

require.define("/lib/client/client/file/module.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BaseModule, FileModule, FileProcessor, ck,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  BaseModule = require('../../share/base_module').BaseModule;

  FileProcessor = require('./processor').FileProcessor;

  ck = window.CoffeeKup;

  FileModule = (function(_super) {

    __extends(FileModule, _super);

    function FileModule() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      FileModule.__super__.constructor.apply(this, args);
      this._fileProcessor = new FileProcessor(this._rootRouter);
    }

    return FileModule;

  })(BaseModule);

  exports.FileModule = FileModule;

}).call(this);

});

require.define("/lib/client/client/file/processor.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var FileProcessor, FileStatus, Request,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = Array.prototype.slice,
    __hasProp = Object.prototype.hasOwnProperty;

  Request = require('../../share/communication').Request;

  FileStatus = require('../../share/file').FileStatus;

  FileProcessor = (function() {

    function FileProcessor() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._getRemoteFilesInfo = __bind(this._getRemoteFilesInfo, this);
      this._init.apply(this, args);
    }

    FileProcessor.prototype._init = function(_rootRouter) {
      this._rootRouter = _rootRouter;
      exports.instance = this;
      this._counter = 0;
      this._files = {};
      return this._timeout = null;
    };

    FileProcessor.prototype._hasFiles = function(arr) {
      var item, _i, _len;
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        item = arr[_i];
        if (item) return true;
      }
      return false;
    };

    FileProcessor.prototype._getRemoteFilesInfo = function() {
      var fileId, fileIds, info, request, _ref,
        _this = this;
      fileIds = [];
      _ref = this._files;
      for (fileId in _ref) {
        if (!__hasProp.call(_ref, fileId)) continue;
        info = _ref[fileId];
        if (info.requested) continue;
        fileIds.push(fileId);
        info.requested = true;
      }
      if (!fileIds.length) return;
      request = new Request({
        fileIds: fileIds
      }, function(err, data) {
        var callback, callbacks, fileId, fileInfo, status, _i, _len, _ref2, _results;
        if (err) return console.error(err);
        _results = [];
        for (fileId in data) {
          if (!__hasProp.call(data, fileId)) continue;
          fileInfo = data[fileId];
          callbacks = (_ref2 = _this._files[fileId]) != null ? _ref2['callbacks'] : void 0;
          if (callbacks) {
            for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
              callback = callbacks[_i];
              callback(fileInfo);
            }
          }
          status = fileInfo.status;
          _results.push(delete _this._files[fileId]);
        }
        return _results;
      });
      request.setProperty('recallOnDisconnect', true);
      request.setProperty('wait', false);
      return this._rootRouter.handle('network.file.getFilesInfo', request);
    };

    FileProcessor.prototype.getRandomId = function(callback) {
      var request,
        _this = this;
      request = new Request({}, function(curWave) {
        return callback("" + (curWave.getModel().getServerId()) + "-" + window.fileUuid + "-" + (_this._counter++) + "-" + (Math.random()));
      });
      return this._rootRouter.handle('wave.getCurWave', request);
    };

    FileProcessor.prototype.getFilesInfo = function(fileIds, callback) {};

    FileProcessor.prototype.getFileInfo = function(fileId, callback) {
      var _base, _base2;
      (_base = this._files)[fileId] || (_base[fileId] = {});
      (_base2 = this._files[fileId])['callbacks'] || (_base2['callbacks'] = []);
      this._files[fileId]['callbacks'].push(callback);
      if (this._timeout != null) {
        clearTimeout(this._timeout);
        this._timeout = null;
      }
      return this._timeout = setTimeout(this._getRemoteFilesInfo, 1500);
    };

    return FileProcessor;

  })();

  exports.instance = null;

  exports.FileProcessor = FileProcessor;

}).call(this);

});

require.define("/lib/client/share/file.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BMP_TYPE, Error, FileStatus, GIF_TYPE, JPEG_TYPE, PNG_TYPE;

  FileStatus = (function() {

    function FileStatus() {}

    FileStatus.ERROR = 'ERROR';

    FileStatus.UPLOADING = 'UPLOADING';

    FileStatus.PROCESSING = 'PROCESSING';

    FileStatus.READY = 'READY';

    return FileStatus;

  })();

  Error = (function() {

    function Error() {}

    Error.FILE_UPLOAD_LIMIT_EXCEEDED_ERROR = 'FILE_UPLOAD_LIMIT_EXCEEDED_ERROR';

    return Error;

  })();

  exports.FileStatus = FileStatus;

  exports.JPEG_TYPE = JPEG_TYPE = 'image/jpeg';

  exports.BMP_TYPE = BMP_TYPE = 'image/bmp';

  exports.GIF_TYPE = GIF_TYPE = 'image/gif';

  exports.PNG_TYPE = PNG_TYPE = 'image/png';

  exports.BrowserSupportedImageTypes = [BMP_TYPE, JPEG_TYPE, GIF_TYPE, PNG_TYPE];

  exports.Error = Error;

}).call(this);

});

require.define("/lib/client/client/wave/processor.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var OtProcessor, Request, User, WaveProcessor, contactsUpdateWindowParams,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Request = require('../../share/communication').Request;

  OtProcessor = require('../ot/processor').OtProcessor;

  User = require('../user/models').User;

  exports.contactsUpdateWindowParams = contactsUpdateWindowParams = {
    google: {
      width: 640,
      height: 400
    },
    facebook: {
      width: 1025,
      height: 585
    }
  };

  WaveProcessor = (function() {

    function WaveProcessor(_rootRouter) {
      this._rootRouter = _rootRouter;
      this.showPageError = __bind(this.showPageError, this);
      this._processOp = __bind(this._processOp, this);
      this._init(this._rootRouter);
    }

    WaveProcessor.prototype._init = function(_rootRouter) {
      var send,
        _this = this;
      this._rootRouter = _rootRouter;
      this._updateContactsCallbacks = [];
      send = function(blipId, callId, operationData, callback) {
        var params, request;
        params = {
          blipId: blipId,
          callId: callId,
          version: operationData.v,
          op: operationData.op,
          random: Math.random()
        };
        request = new Request(params, callback);
        request.setProperty('recallOnDisconnect', true);
        request.setProperty('close-confirm', true);
        return _this._rootRouter.handle('network.wave.postOpToBlip', request);
      };
      return require('../ot/processor').instance = this._otProcessor = new OtProcessor(send, this.showPageError);
    };

    WaveProcessor.prototype.createWave = function(callback) {
      /*
              Отправляет на сервер запрос создания волны.
              @param callback: function
      */
      var request;
      request = this._createRequest({}, callback);
      return this._rootRouter.handle('network.wave.createWave', request);
    };

    WaveProcessor.prototype.initCreateWaveWithParticipants = function(userIds) {
      /*
              Просит модуль волны создать волну со списком userIds
              волны с waveId.
              @param userIds: Array
      */
      var request;
      request = new Request({
        userIds: userIds
      }, function() {});
      return this._rootRouter.handle('wave.createWaveWithParticipants', request);
    };

    WaveProcessor.prototype.createWaveWithParticipants = function(waveId, participants, callback) {
      /*
              Отправляет на сервер запрос создания волны с указанными участниками
              @param participants: Array
              @param callback: function
      */
      var request;
      request = this._createRequest({
        waveId: waveId,
        participants: participants
      }, callback);
      return this._rootRouter.handle('network.wave.createWaveWithParticipants', request);
    };

    WaveProcessor.prototype.createWaveByWizard = function(title, emails, callback) {
      /*
              Создает топик со списком участников и заголовком
              @param participants: Array of emails
              @param title: String
      */
      var request;
      request = this._createRequest({
        title: title,
        emails: emails
      }, callback);
      return this._rootRouter.handle('network.wave.createWaveByWizard', request);
    };

    WaveProcessor.prototype.updateReaderForAllBlips = function(waveId, callback) {
      /*
              Помечает на сервере прочитанными все блипы топика
      */
      var request;
      request = this._createRequest({
        waveId: waveId
      }, callback);
      return this._rootRouter.handle('network.wave.updateReaderForAllBlips', request);
    };

    WaveProcessor.prototype._createRequest = function(args, callback, shouldRecall) {
      var res;
      if (shouldRecall == null) shouldRecall = false;
      /*
              Создает Request
              @param args: object, аргументы вызова
              @param callback: function, будет вызван при получении ошибки или результата
              @param shouldRecall: boolean, повторять ли запрос при ошибках сети
              @return: Request
      */
      res = new Request(args, callback);
      res.setProperty('recallOnDisconnect', shouldRecall);
      return res;
    };

    WaveProcessor.prototype._processOp = function(err, op, callId) {
      if (err) {
        return this.showPageError(err);
      } else {
        try {
          return this._otProcessor.processOp(op, callId);
        } catch (e) {
          return this.showPageError(e);
        }
      }
    };

    WaveProcessor.prototype.subscribeForWaveData = function(wave) {
      /*
              Подписывается на изменения данных волны и ее блипов
              @param wave: WaveViewModel
              @return: string, callId для подписки на операции документа
      */
      var callId, getRequest, request,
        _this = this;
      callId = null;
      getRequest = function() {
        var processOp, res;
        processOp = function(err, op) {
          return _this._processOp(err, op, callId);
        };
        res = _this._createRequest({
          versions: wave.getWaveAndBlipsVersions()
        }, processOp, getRequest);
        res.setProperty('wait', true);
        return res;
      };
      request = getRequest();
      this._rootRouter.handle('network.wave.subscribeWaveWithBlips', request);
      callId = request.callId;
      this._otProcessor.setGroupSubscriptionCallId(wave.getId(), callId);
      return callId;
    };

    WaveProcessor.prototype._removeWaveDataSubscription = function(subscriptionCallId) {
      var request;
      request = new Request({
        callId: subscriptionCallId
      }, function(err) {
        if (err) {
          return console.warn("Could not remove wave with subscription " + subscriptionCallId + ":", err);
        }
      });
      return this._rootRouter.handle('network.wave.removeCall', request);
    };

    WaveProcessor.prototype.rootRouterIsConnected = function() {
      return this._rootRouter.isConnected();
    };

    WaveProcessor.prototype.getWaveWithBlips = function(serverWaveId, callback) {
      /*
              Отправляет на сервер запрос получения волны и всех ее блипов.
              @param waveServerId: string, идентификатор открываемой волны
              @param callback: function
                  callback(err, shareDoc, {blipId: blipShareDoc}, socialSharingUrl)
      */
      var args, data, err, processResponse, referalEmailHash, request, _ref, _ref2, _ref3,
        _this = this;
      processResponse = function(err, data) {
        var blips, shareBlips, shareDoc, wave, _ref;
        if (err) return callback(err);
        wave = data.wave, blips = data.blips;
        _ref = _this._makeDocs(wave, blips), err = _ref[0], shareDoc = _ref[1], shareBlips = _ref[2];
        return callback(err, shareDoc, shareBlips, wave.socialSharingUrl);
      };
      if (((_ref = window.getWaveWithBlipsResults) != null ? _ref[serverWaveId] : void 0) != null) {
        _ref2 = window.getWaveWithBlipsResults[serverWaveId], err = _ref2.err, data = _ref2.data;
        delete window.getWaveWithBlipsResults[serverWaveId];
        window.setTimeout(function() {
          return processResponse(err, data);
        }, 0);
        return {};
      }
      args = {
        waveId: serverWaveId
      };
      referalEmailHash = (_ref3 = window.userInfo) != null ? _ref3.referalEmailHash : void 0;
      if (referalEmailHash) args.referalEmailHash = referalEmailHash;
      request = this._createRequest(args, processResponse, true);
      this._rootRouter.handle('network.wave.getWaveWithBlips', request);
      return request;
    };

    WaveProcessor.prototype.getPlaybackData = function(waveId, blipId, callback) {
      var request,
        _this = this;
      request = new Request({
        waveId: waveId,
        blipId: blipId
      }, function(err, data) {
        var blips, shareBlips, shareDoc, wave, _ref;
        if (err) return callback(err);
        wave = data.wave, blips = data.blips;
        _ref = _this._makeDocs(wave, blips), err = _ref[0], shareDoc = _ref[1], shareBlips = _ref[2];
        return callback(err, shareDoc, shareBlips, wave.socialSharingUrl);
      });
      return this._rootRouter.handle('network.playback.getPlaybackData', request);
    };

    WaveProcessor.prototype._makeDocs = function(wave, blips) {
      var blip, unpackedBlips, unpackedWave, waveId, _i, _len;
      waveId = Math.random().toString();
      try {
        unpackedWave = this._otProcessor.makeDoc(waveId, wave, waveId);
      } catch (err) {
        return [err, null, null];
      }
      unpackedBlips = {};
      for (_i = 0, _len = blips.length; _i < _len; _i++) {
        blip = blips[_i];
        unpackedBlips[blip.docId] = blip;
      }
      return [null, unpackedWave, unpackedBlips];
    };

    WaveProcessor.prototype.markWaveAsSocialSharing = function(serverWaveId, callback) {
      /*
              Помечает волну как доступную для публикации в соц. сети
      */
      var request;
      request = new Request({
        waveId: serverWaveId
      }, function(err) {
        if (err) {
          console.error("Could not mark wave " + serverWaveId + " as social sharing:", err);
        }
        return callback();
      });
      return this._rootRouter.handle('network.wave.markWaveAsSocialSharing', request);
    };

    WaveProcessor.prototype.closeWave = function(serverWaveId, subscriptionCallId, waveId) {
      /*
              Отписывает клиента от волны.
              @param waveId: string
              @param subscriptionCallId: string
              @param uniqueWaveId: string
      */
      var _this = this;
      return this._otProcessor.closeGroup(waveId, function() {
        var request;
        request = _this._createRequest({
          waveId: serverWaveId,
          callId: subscriptionCallId
        }, function(err) {
          if (err) return console.warn("Got error when closing wave", err);
        }, true);
        _this._rootRouter.handle('network.wave.closeWave', request);
        return _this._removeWaveDataSubscription(subscriptionCallId);
      });
    };

    WaveProcessor.prototype.addParticipant = function(serverWaveId, userId, roleId, callback) {
      /*
              Отправляет запрос на добавления участника в волну
              @param waveId: string, идентификатор волны
              @param userId: string, идентификатор участника
              @param roleId: int, идентификатор роли участника
              @param callback: function
                  callback(err, resp)
      */
      var request;
      if (!userId.length) return;
      request = this._createRequest({
        waveId: serverWaveId,
        participantId: userId,
        role: roleId
      }, callback);
      return this._rootRouter.handle('network.wave.addParticipant', request);
    };

    WaveProcessor.prototype.addParticipants = function(serverWaveId, userIds, roleId, noNotification, callback) {
      /*
              Отправляет запрос добавления участников в волну
              @param waveId: string, идентификатор волны
              @param userIds: [string], идентификаторы участника
              @param roleId: int, идентификатор роли всех участников
              @param noNotification: boolean, true, если не надо рассылать письма добавленным участникам
              @param callback: function
                  callback(err, resp)
      */
      var request;
      request = this._createRequest({
        waveId: serverWaveId,
        participantIds: userIds,
        role: roleId,
        noNotification: noNotification
      }, callback);
      return this._rootRouter.handle('network.wave.addParticipants', request);
    };

    WaveProcessor.prototype.removeParticipant = function(serverWaveId, userId, callback) {
      /*
              Отправляет запрос на удаление участника из волны
              @param serverWaveId: string, идентификатор волны на сервере
              @param userId: string, идентификатор участника
              @param callback: function
                  callback(err, resp)
      */
      var request;
      request = this._createRequest({
        waveId: serverWaveId,
        participantId: userId
      }, callback);
      return this._rootRouter.handle('network.wave.deleteParticipant', request);
    };

    WaveProcessor.prototype.removeParticipants = function(serverWaveId, userIds, callback) {
      var request;
      request = this._createRequest({
        waveId: serverWaveId,
        participantIds: userIds
      }, callback);
      return this._rootRouter.handle('network.wave.deleteParticipants', request);
    };

    WaveProcessor.prototype.changeParticipantRole = function(serverWaveId, userId, roleId, callback) {
      var request;
      request = this._createRequest({
        waveId: serverWaveId,
        participantId: userId,
        role: roleId
      }, callback);
      return this._rootRouter.handle('network.wave.changeParticipantRole', request);
    };

    WaveProcessor.prototype.showPageError = function(err) {
      /*
              Показывает ошибку на странице. Использовать для тех ошибок, которые приводят
              к необходимости перезагрузить страницу
              @param err: object
      */
      var showErrRequest;
      console.error("Got severe topic error", new Date(), err);
      console.error(err.stack);
      showErrRequest = new Request({
        error: err
      }, function() {});
      return this._rootRouter.handle('pageError.showError', showErrRequest);
    };

    WaveProcessor.prototype.updateSearchUnreadCount = function(serverWaveId, unreadCount, totalCount) {
      /*
              Обновляет количество непрочитанных блипов в этой волне в результатах поиска
              @param serverWaveId: string
              @param unreadCount: Number
              @param totalCount: Number
      */
      var request;
      request = new Request({
        waveId: serverWaveId,
        unreadCount: unreadCount,
        totalCount: totalCount
      }, function() {});
      return this._rootRouter.handle('navigation.updateTopicsUnreadCount', request);
    };

    WaveProcessor.prototype.updateBlipIsRead = function(serverWaveId, blipId, isRead) {
      var request;
      request = new Request({
        waveId: serverWaveId,
        blipId: blipId,
        isRead: isRead
      }, function() {});
      return this._rootRouter.handle('navigation.updateBlipIsRead', request);
    };

    WaveProcessor.prototype.initContactsUpdate = function(source, x, y, callback) {
      /*
              Начинает обновление контактов из сервиса. Открывает окно, обновляющее контакты, в указанных координатах.
              @param source: string, источник для новых контактов
              @param x: float
              @param y: float
              @param callback: function
      */
      var params;
      this._updateContactsCallbacks.push(callback);
      params = contactsUpdateWindowParams[source];
      if (!this._updatingContacts) {
        this._updatingContacts = true;
        return window.open("/contacts/" + source + "/update/", 'Updating', "width=" + params.width + ",height=" + params.height + ",left=" + x + ",top=" + x);
      }
    };

    WaveProcessor.prototype.setWaveShareState = function(serverWaveId, state, defaultRoleId, callback) {
      /*
              Устанавливает "расшаренность" волны
              @param serverWaveId: string
              @param isPublic: boolean
              @param defaultRoleId: int
              @param callback: function
                  callback(err)
      */
      var request;
      request = new Request({
        waveId: serverWaveId,
        sharedState: state,
        defaultRole: defaultRoleId
      }, callback);
      return this._rootRouter.handle('network.wave.setShareState', request);
    };

    WaveProcessor.prototype.getUserContacts = function(callback, fromServer) {
      var request,
        _this = this;
      if (fromServer == null) fromServer = false;
      if ((this._userContacts != null) && !fromServer) {
        return callback(null, this._userContacts);
      }
      request = new Request({}, function(err, contacts) {
        if (!err) _this._userContacts = _this._convertUserContacts(contacts);
        return callback(err, _this._userContacts);
      });
      return this._rootRouter.handle('network.user.getUserContacts', request);
    };

    WaveProcessor.prototype._convertUserContacts = function(serverContacts) {
      var entry, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = serverContacts.length; _i < _len; _i++) {
        entry = serverContacts[_i];
        _results.push(new User(null, entry.email, entry.name, entry.avatar, null, entry.source));
      }
      return _results;
    };

    WaveProcessor.prototype.updateUserContacts = function(contacts) {
      /*
              Вызывается, когда из открытого окна будут получены контакты пользователя
      */
      var callback, _i, _len, _ref;
      this._userContacts = this._convertUserContacts(contacts);
      _ref = this._updateContactsCallbacks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        callback();
      }
      this._updateContactsCallbacks = [];
      return this._updatingContacts = false;
    };

    WaveProcessor.prototype.addOrUpdateContact = function(user) {
      var userContact, _i, _len, _ref;
      if ((window.userInfo != null) && window.userInfo.email === user.email) {
        return;
      }
      _ref = this._userContacts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        userContact = _ref[_i];
        if (userContact.getEmail() === user.email) return;
      }
      return this._userContacts.push(new User(null, user.email, user.name, user.avatar, null, 'manually'));
    };

    WaveProcessor.prototype.showTips = function() {
      var request;
      request = new Request({
        force: true
      }, function() {});
      return this._rootRouter.handle('wave.showNextTip', request);
    };

    WaveProcessor.prototype.showNextTip = function() {
      var request;
      request = new Request({}, function() {});
      return this._rootRouter.handle('wave.showNextTip', request);
    };

    WaveProcessor.prototype.openAccountWizard = function() {
      var request;
      request = new Request({}, function() {});
      return this._rootRouter.handle('wave.openAndInitAccountWizard', request);
    };

    WaveProcessor.prototype.setUserClientOption = function(name, value, callback) {
      var request;
      request = new Request({
        name: name,
        value: value
      }, callback);
      return this._rootRouter.handle('network.user.setUserClientOption', request);
    };

    WaveProcessor.prototype.sendAccessRequest = function(waveId, callback) {
      var request;
      request = new Request({
        waveId: waveId
      }, callback);
      return this._rootRouter.handle('network.wave.sendAccessRequest', request);
    };

    return WaveProcessor;

  })();

  module.exports.WaveProcessor = WaveProcessor;

  module.exports.instance = null;

}).call(this);

});

require.define("/lib/client/client/ot/processor.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var DOC_TYPE, Document, MicroEvent, OtProcessor, Request, ShareJSConnection, TYPES,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __slice = Array.prototype.slice;

  TYPES = sharejs.types;

  DOC_TYPE = TYPES['volna'];

  MicroEvent = require('../utils/microevent');

  Document = sharejs.Doc;

  Request = require('../../share/communication').Request;

  OtProcessor = (function() {
    /*
        Подключение к серверу с OT
        Объекту этого класса необходимо хранить в себе все созданные документы, чтобы
        вызывать у них обработчик пришедших операций
    */
    function OtProcessor(_transportSend, _errorCallback) {
      this._transportSend = _transportSend;
      this._errorCallback = _errorCallback;
      this._getClientDocId = __bind(this._getClientDocId, this);
      this._isSubscribed = __bind(this._isSubscribed, this);
      this._getServerDocId = __bind(this._getServerDocId, this);
      this._removeDoc = __bind(this._removeDoc, this);
      this.processOp = __bind(this.processOp, this);
      /*
              Инициализирует модуль
              @param _transportSend: function, функция для отправки сообщений на сервер
              @param _errorCallback: function, будет вызвана в случае возникновения ошибки
      */
      this._docs = {};
      this._removeCallbacks = {};
      this._connections = {};
      this._groupIdByCallId = {};
    }

    OtProcessor.prototype._getGroupIdByCallId = function(callId) {
      if (!(this._groupIdByCallId[callId] != null)) return null;
      return this._groupIdByCallId[callId];
    };

    OtProcessor.prototype.processOp = function(msg, subscriptionCallId) {
      /*
              Обрабатывает пришедшую операцию
              @param msg: ShareJS message
              @param subscriptionCallId: string
      */
      var doc, groupId, serverDocId, _ref;
      serverDocId = msg['docId'];
      groupId = this._getGroupIdByCallId(subscriptionCallId);
      if (!(groupId != null)) {
        console.warn("OT processor got operation for doc " + serverDocId + ", call id " + subscriptionCallId + " which is not present");
        return;
      }
      if (!msg['op']) return console.warn("Got operation of unexpected type", msg);
      if (((_ref = this._docs[groupId]) != null ? _ref.byServerId[serverDocId] : void 0) != null) {
        doc = this._docs[groupId].byServerId[serverDocId];
        msg['doc'] = doc.name;
      } else {
        console.warn("OT processor got operation for doc " + serverDocId + ", group id " + groupId + " which is not present");
        return;
      }
      return doc._onOpReceived(msg);
    };

    OtProcessor.prototype._removeDoc = function(groupId, docId) {
      /*
              Удаляет документ из памяти документ указанной группы, если у него не осталось
              неотправленных операций.
              Вызывает соответствующий callback.
              @param groupId: string
              @param docId: string
      */
      var doc, gId, group, _ref;
      if (!(groupId in this._removeCallbacks)) return;
      group = this._docs[groupId];
      doc = group.byId[docId];
      if (doc.hasUnsentOps()) return;
      delete group.byId[docId];
      if (doc.serverId != null) delete group.byServerId[doc.serverId];
      _ref = this._docs[groupId].byId;
      for (gId in _ref) {
        if (!__hasProp.call(_ref, gId)) continue;
        return;
      }
      return this._removeGroup(groupId);
    };

    OtProcessor.prototype._removeGroup = function(groupId) {
      /*
              Удаляет группу документов
              @param groupId: string
      */
      var callId, _base;
      delete this._docs[groupId];
      callId = this._connections[groupId].subscriptionCallId;
      this._connections[groupId].removeAllListeners();
      delete this._connections[groupId];
      if (callId != null) delete this._groupIdByCallId[callId];
      if (typeof (_base = this._removeCallbacks)[groupId] === "function") {
        _base[groupId]();
      }
      return delete this._removeCallbacks[groupId];
    };

    OtProcessor.prototype.closeGroup = function(groupId, callback) {
      /*
              Удаляет у себя информацию о группе документов
              @param groupId: string
      */
      var docId, _results;
      if (!(this._docs[groupId] != null)) {
        throw new Error("ShareJS group of docs " + groupId + " not found");
      }
      this._removeCallbacks[groupId] = callback;
      _results = [];
      for (docId in this._docs[groupId].byId) {
        _results.push(this._removeDoc(groupId, docId));
      }
      return _results;
    };

    OtProcessor.prototype.makeDoc = function(docId, docData, groupId) {
      /*
              Создает ShareJS document из пришедших с сервера данных
              @param docId: string, идентификатор документа, сгенерированный на клиенте
              @param docData: {docId: DOC_ID, v: VERSION, snapshot: SNAPSHOT}
              @param groupId: string, уникальный идентификатор для группы документов
              @return: ShareJS document
      */
      var connection, doc, _base;
      connection = this._getShareConnection(groupId);
      doc = new Document(connection, docId, docData['v'], DOC_TYPE, docData['snapshot']);
      doc.connection = connection;
      doc.serverId = docData['docId'];
      if ((_base = this._docs)[groupId] == null) {
        _base[groupId] = {
          byId: {},
          byServerId: {}
        };
      }
      this._docs[groupId].byId[docId] = doc;
      if (doc.serverId) this._docs[groupId].byServerId[doc.serverId] = doc;
      return doc;
    };

    OtProcessor.prototype.setGroupSubscriptionCallId = function(groupId, subscriptionCallId) {
      /*
              Устанавливает для документа id подписки, чтобы он мог слать операции
              @param groupId: string, уникальный идентификатор для группы документов
              @param subscriptionCallId: string
      */
      var connection, doc, id, _ref;
      connection = this._connections[groupId];
      connection.subscriptionCallId = subscriptionCallId;
      this._groupIdByCallId[subscriptionCallId] = groupId;
      _ref = this._docs[groupId].byId;
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        doc = _ref[id];
        doc.subscribed = true;
      }
      return connection.tryFlushAllOps();
    };

    OtProcessor.prototype.onSubscribe = function(subscriptionCallId, serverId) {
      var doc, groupId;
      groupId = this._groupIdByCallId[subscriptionCallId];
      if (!groupId) return;
      doc = this._docs[groupId].byServerId[serverId];
      if (!doc) return;
      doc.subscribed = true;
      return this._connections[groupId].tryFlushDocOps(doc.name);
    };

    OtProcessor.prototype.setDocServerId = function(groupId, docId, serverId) {
      var doc, group;
      group = this._docs[groupId];
      doc = group.byId[docId];
      doc.serverId = serverId;
      group.byServerId[serverId] = doc;
      return this._connections[groupId].tryFlushDocOps(docId);
    };

    OtProcessor.prototype._getServerDocId = function(groupId, docId) {
      var _ref, _ref2;
      return (_ref = this._docs[groupId]) != null ? (_ref2 = _ref.byId[docId]) != null ? _ref2.serverId : void 0 : void 0;
    };

    OtProcessor.prototype._isSubscribed = function(groupId, docId) {
      var _ref, _ref2;
      return (_ref = this._docs[groupId]) != null ? (_ref2 = _ref.byId[docId]) != null ? _ref2.subscribed : void 0 : void 0;
    };

    OtProcessor.prototype._getClientDocId = function(groupId, docServerId) {
      var _ref, _ref2;
      return (_ref = this._docs[groupId]) != null ? (_ref2 = _ref.byServerId[docServerId]) != null ? _ref2.name : void 0 : void 0;
    };

    OtProcessor.prototype._getShareConnection = function(groupId) {
      /*
              Возвращает объект connection, необходимый ShareJS
              @param groupId: string
              @return: Object
      */
      var connection,
        _this = this;
      if (!(groupId in this._connections)) {
        connection = new ShareJSConnection(groupId, this._getServerDocId, this._isSubscribed, this._getClientDocId, this._transportSend, this._removeDoc, this._errorCallback);
        connection.on('start-send', function() {
          return _this.emit('start-send', groupId);
        });
        connection.on('finish-send', function() {
          return _this.emit('finish-send', groupId);
        });
        this._connections[groupId] = connection;
      }
      return this._connections[groupId];
    };

    return OtProcessor;

  })();

  ShareJSConnection = (function() {

    function ShareJSConnection(_groupId, _getServerDocId, _isSubscribed, _getClientDocId, _transportSend, _docOpProcessed, _errorCallback) {
      this._groupId = _groupId;
      this._getServerDocId = _getServerDocId;
      this._isSubscribed = _isSubscribed;
      this._getClientDocId = _getClientDocId;
      this._transportSend = _transportSend;
      this._docOpProcessed = _docOpProcessed;
      this._errorCallback = _errorCallback;
      this._processOpResponse = __bind(this._processOpResponse, this);
      this.send = __bind(this.send, this);
      /*
              @param groupId: string, идентификатор группы документов, нужен для отправки операций на сервер
              @param getServerDocId: function
              @param getClientDocId: function
              @param transportSend: function
              @param docOpProcessed: function, нужна для удаления документов, помеченных на удаление, после отправки
                  всех операций
      */
      this._buffer = {};
      this._count = 0;
    }

    ShareJSConnection.prototype.send = function(op, callback) {
      var doSend, serverDocId, _base, _name,
        _this = this;
      doSend = function() {
        var serverDocId;
        if (!_this._count) _this.emit('start-send');
        _this._count += 1;
        serverDocId = _this._getServerDocId(_this._groupId, op.doc);
        return _this._send(_this.subscriptionCallId, serverDocId, op, function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          _this._count -= 1;
          if (!_this._count) _this.emit('finish-send');
          return callback.apply(null, args);
        });
      };
      serverDocId = this._getServerDocId(this._groupId, op.doc);
      if ((serverDocId != null) && (this.subscriptionCallId != null) && this._isSubscribed(this._groupId, op.doc)) {
        return doSend();
      } else {
        if ((_base = this._buffer)[_name = op.doc] == null) _base[_name] = [];
        return this._buffer[op.doc].push(doSend);
      }
    };

    ShareJSConnection.prototype.tryFlushDocOps = function(docId) {
      if (!(this.subscriptionCallId != null) || !this._getServerDocId(this._groupId, docId) || !this._isSubscribed(this._groupId, docId)) {
        return;
      }
      return this._flushBuffer(docId);
    };

    ShareJSConnection.prototype.tryFlushAllOps = function() {
      var docId, _results;
      if (!(this.subscriptionCallId != null)) return;
      _results = [];
      for (docId in this._buffer) {
        if (this._getServerDocId(this._groupId, docId) && this._isSubscribed(this._groupId, docId)) {
          _results.push(this._flushBuffer(docId));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    ShareJSConnection.prototype._flushBuffer = function(docId) {
      var doSend, _i, _len, _ref;
      if (!(this._buffer[docId] != null)) return;
      _ref = this._buffer[docId];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        doSend = _ref[_i];
        doSend();
      }
      return delete this._buffer[docId];
    };

    ShareJSConnection.prototype._send = function(subscriptionCallId, serverDocId, op, callback) {
      /*
              Отправляет операцию на сервер
              @param subscriptionCallId: string
              @param serverDocId: string
              @param op: object, отправляемая операция
              @param callback: function, будет вызвана при получении ответа сервера
                  callback(error, response)
      */
      var _this = this;
      if ((op.open != null) && !op.open) {
        console.warn("Open or close OT operation", op);
        return callback(null, op);
      }
      op.doc = op.docId = serverDocId;
      return this._transportSend(serverDocId, subscriptionCallId, op, function(err, res) {
        return _this._processOpResponse(err, res, serverDocId, callback);
      });
    };

    ShareJSConnection.prototype._processOpResponse = function(err, response, serverDocId, callback) {
      /*
              Обрабатывает пришедший ответ на операцию
              @param err: object|null
              @param response: ShareJS operation|null
              @param serverDocId: string
              @param callback: function
              @TODO: добавить обработку ошибок, пришедших с сервера
              @TODO: добавить обработку ошибок, возникших на клиенте
      */
      var docId;
      if (err) return this._errorCallback(err);
      try {
        docId = this._getClientDocId(this._groupId, serverDocId);
        if (!(docId != null)) {
          throw new Error("Got response for unknown doc with group id " + this._groupId + " and doc id " + serverDocId);
        }
        response.doc = docId;
        if (typeof callback === "function") callback(null, response);
        return this._docOpProcessed(this._groupId, docId);
      } catch (e) {
        console.error("Got severe error while processing operation response.", new Date(), e.stack, e);
        console.error("Response is", response);
        return this._errorCallback(e);
      }
    };

    return ShareJSConnection;

  })();

  MicroEvent.mixin(OtProcessor);

  MicroEvent.mixin(ShareJSConnection);

  module.exports.OtProcessor = OtProcessor;

  module.exports.instance = null;

}).call(this);

});

require.define("/lib/client/client/user/models.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ANONYMOUS_ICON_SRC, ANONYMOUS_USER_ID, EMPTY_ICON_SRC, LOADING_USER_NAME, PUBLIC_USER_NAME, UNKNOWN_ICON_SRC, UNKNOWN_USER_NAME, User, UserAuth, contactsConstants, getAbsoluteUrl, getUserInitials;

  getUserInitials = require('../../share/user/utils').getUserInitials;

  contactsConstants = require('../../share/contacts/constants');

  LOADING_USER_NAME = '(...)';

  UNKNOWN_USER_NAME = '(unknown)';

  PUBLIC_USER_NAME = 'public';

  ANONYMOUS_USER_ID = '0_user_0';

  getAbsoluteUrl = function(relative) {
    if (relative.indexOf('http') === 0) return relative;
    return "" + location.protocol + "//" + window.HOST + relative;
  };

  ANONYMOUS_ICON_SRC = getAbsoluteUrl('/s/img/user/anonim.png');

  UNKNOWN_ICON_SRC = getAbsoluteUrl('/s/img/user/unknown.png');

  EMPTY_ICON_SRC = getAbsoluteUrl('/s/img/user/empty.png');

  User = (function() {

    function User(_id, _email, _name, _avatar, _extra, _source, _skypeId, _loaded) {
      this._id = _id;
      this._email = _email != null ? _email : null;
      this._name = _name != null ? _name : null;
      this._avatar = _avatar != null ? _avatar : null;
      this._extra = _extra != null ? _extra : null;
      this._source = _source != null ? _source : null;
      this._skypeId = _skypeId != null ? _skypeId : null;
      this._loaded = _loaded != null ? _loaded : true;
      if (this.isAnonymous()) {
        this._name = PUBLIC_USER_NAME;
        this._avatar = ANONYMOUS_ICON_SRC;
        this._loaded = true;
      }
      this.lastRequestedTime = 0;
    }

    User.prototype.toObject = function() {
      /*
              Сериализует модель в Javascript-объект
      */      return {
        id: this._id,
        email: this.getEmail(),
        name: this.getName(),
        avatar: this.getAvatar(),
        initials: this.getInitials(),
        extra: this._extra,
        source: this._source,
        skypeId: this._skypeId
      };
    };

    User.prototype.isAnonymous = function() {
      /*
              Возвращает true, если текущий пользователй является анонимным, иначе false
      */      return this._id === ANONYMOUS_USER_ID;
    };

    User.prototype.isLoaded = function() {
      /*
              Возвращает true, если модель содержит обновленную информацию, полученную с сервера, иначе false
      */      return this._loaded;
    };

    User.prototype.updateInfo = function(_email, _name, _avatar, _extra, _source, _skypeId) {
      this._email = _email;
      this._name = _name;
      this._avatar = _avatar;
      this._extra = _extra;
      this._source = _source;
      this._skypeId = _skypeId;
      /*
              Обновление модели пользователя
      */
      return this._loaded = true;
    };

    User.prototype.getId = function() {
      /*
              Возвращает идентификатор модели
              @returns string
      */      return this._id;
    };

    User.prototype.getName = function() {
      /*
              Возвращает отображаемое имя пользователя
              @returns string
      */
      var email;
      if (this._name) return this._name;
      email = this.getEmail();
      if (email) return email;
      return UNKNOWN_USER_NAME;
    };

    User.prototype.getRealName = function() {
      return this._name;
    };

    User.prototype.getInitials = function() {
      return getUserInitials(this._avatar, this._name);
    };

    User.prototype.getAvatar = function() {
      /*
              Возвращает  URL к иконке пользователя
              @returns: string
      */      if (this._avatar) return this._avatar;
      return UNKNOWN_ICON_SRC;
    };

    User.prototype.getEmail = function() {
      /*
              Возвращает email пользователя
              @returns: string
      */      if (this._email != null) return this._email;
      if (window.userInfo != null) {
        if (this._id === window.userInfo.id) return window.userInfo.email;
      }
      return '';
    };

    User.prototype.getSkypeId = function() {
      return this._skypeId;
    };

    User.prototype.getSearchString = function() {
      /*
              Возвращает строку, по которой нужно искать autocomplete'у
              @returns: string
      */      return ("" + (this.getName()) + " " + (this.getEmail())).toLowerCase();
    };

    User.prototype.getDataForAutocomplete = function(isParticipant) {
      /*
              Возвращает данные для рендеринга контакта
              @param isParticipant: boolean
              @returns: object
      */      return {
        isParticipant: isParticipant,
        id: this.getId(),
        name: this.getName(),
        email: this.getEmail(),
        avatar: this.getAvatar(),
        initials: this.getInitials(),
        source: this._source
      };
    };

    User.prototype.fromGoogle = function() {
      return this._source === contactsConstants.SOURCE_NAME_GOOGLE;
    };

    User.prototype.fromManually = function() {
      return this._source === contactsConstants.SOURCE_NAME_MANUALLY;
    };

    User.prototype.isNewUser = function() {
      /*
              Определяем заходил ли пользователь в ризому
              @returns: bool
      */      return !this._avatar && !this._name;
    };

    User.getUserStub = function(id) {
      /*
               Создает заглушку для пользователя
               @returns: User
      */      return new User(id, null, LOADING_USER_NAME, EMPTY_ICON_SRC, null, null, null, false);
    };

    return User;

  })();

  UserAuth = (function() {

    function UserAuth(_id, auth_type, auth_id, user_id) {
      this._id = _id != null ? _id : null;
      this.auth_type = auth_type != null ? auth_type : null;
      this.auth_id = auth_id != null ? auth_id : null;
      this.user_id = user_id != null ? user_id : null;
    }

    return UserAuth;

  })();

  module.exports.User = User;

  module.exports.UserAuth = UserAuth;

  module.exports.UNKNOWN_ICON_SRC = UNKNOWN_ICON_SRC;

}).call(this);

});

require.define("/lib/client/share/user/utils.js",function(require,module,exports,__dirname,__filename,process,global){(function() {

  exports.getUserInitials = function(avatar, name) {
    var nameWords;
    if (avatar || !name) return '';
    nameWords = name.split(' ');
    if (nameWords.length < 2) return '';
    return ("" + nameWords[0][0] + nameWords[nameWords.length - 1][0]).toUpperCase();
  };

}).call(this);

});

require.define("/lib/client/share/contacts/constants.js",function(require,module,exports,__dirname,__filename,process,global){(function() {

  module.exports = {
    SOURCE_NAME_MANUALLY: 'manually',
    SOURCE_NAME_GOOGLE: 'google',
    SOURCE_NAME_FACEBOOK: 'facebook'
  };

}).call(this);

});

require.define("/lib/client/client/user/processor.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var MicroEvent, Request, User, UserProcessor, instance,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = Array.prototype.slice;

  MicroEvent = require('../utils/microevent');

  User = require('./models').User;

  Request = require('../../share/communication').Request;

  UserProcessor = (function() {

    function UserProcessor() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._processResponse = __bind(this._processResponse, this);
      this._init.apply(this, args);
    }

    UserProcessor.prototype._init = function(_rootRouter) {
      this._rootRouter = _rootRouter;
      return this._cache = {};
    };

    UserProcessor.prototype._processResponse = function(err, users) {
      /*
              Обработчик ответа от сервера
              @param err: Error
              @param users: [Object]
      */      if (err) {
        console.warn("Error in user info response", err);
        return;
      }
      if (!users.length) return;
      return this.addOrUpdateUsersInfo(users);
    };

    UserProcessor.prototype.addOrUpdateUsersInfo = function(users) {
      /*
              Обновляет информацию в кэше и вызывает событие 'update'
              @param users: [Object]
      */
      var info, userIds, _i, _len;
      userIds = [];
      for (_i = 0, _len = users.length; _i < _len; _i++) {
        info = users[_i];
        if (!this._cache[info.id]) {
          this._cache[info.id] = new User(info.id, info.email, info.name, info.avatar, info.extra, info.source, info.skypeId);
        } else {
          this._cache[info.id].updateInfo(info.email, info.name, info.avatar, info.extra, info.source, info.skypeId);
        }
        userIds.push(info.id);
      }
      return this.emit('update', userIds);
    };

    UserProcessor.prototype._getUsersInfo = function(userIds, waveId) {
      /*
              Отправляет запрос на получение информации о пользователях волны
              @param userIds: [string], идентификаторы пользователей
              @param waveId: string, идентификатор волны
      */
      var request;
      request = new Request({
        participantIds: userIds,
        waveId: waveId
      }, this._processResponse);
      request.setProperty('recallOnDisconnect', true);
      return this._rootRouter.handle('network.user.getUsersInfo', request);
    };

    UserProcessor.prototype.getUsers = function(userIds, waveId, force) {
      /*
              Метод позволяет получить модели пользователей по идентификаторам
              @param userIds: [string], идентификаторы пользователей
              @param waveId: string, идентификатор волны
              @returns [Users], массив моделей пользователей
      */
      var emptyUsers, now, resultUsers, user, userId, _base, _i, _len;
      emptyUsers = [];
      resultUsers = [];
      for (_i = 0, _len = userIds.length; _i < _len; _i++) {
        userId = userIds[_i];
        now = Date.now();
        user = (_base = this._cache)[userId] || (_base[userId] = User.getUserStub(userId));
        if (force || (!user.isLoaded() && (now - user.lastRequestedTime > 10000))) {
          user.lastRequestedTime = now;
          emptyUsers.push(userId);
        }
        resultUsers.push(user);
      }
      if (emptyUsers.length) this._getUsersInfo(emptyUsers, waveId);
      return resultUsers;
    };

    UserProcessor.prototype.getMyPrefs = function() {
      var _ref, _ref2;
      return (_ref = this._myPrefs) != null ? _ref : this._myPrefs = (_ref2 = window.userInfo) != null ? _ref2.clientPreferences : void 0;
    };

    UserProcessor.prototype.prepareMerge = function(emailToMerge, callback) {
      var request;
      request = new Request({
        emailToMerge: emailToMerge
      }, callback);
      return this._rootRouter.handle('network.user.prepareMerge', request);
    };

    UserProcessor.prototype.mergeByOauth = function(code, callback) {
      var request;
      request = new Request({
        code: code
      }, callback);
      return this._rootRouter.handle('network.user.mergeByOauth', request);
    };

    return UserProcessor;

  })();

  MicroEvent.mixin(UserProcessor);

  instance = null;

  exports.UserProcessor = UserProcessor;

  exports.instance = instance;

}).call(this);

});

require.define("/lib/client/client/search_panel/topic/processor.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BaseTopicsProcessor, Request, TopicsProcessor,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BaseTopicsProcessor = require('../base_topic_processor').BaseTopicsProcessor;

  Request = require('../../../share/communication').Request;

  TopicsProcessor = (function(_super) {

    __extends(TopicsProcessor, _super);

    function TopicsProcessor(_rootRouter) {
      this._rootRouter = _rootRouter;
    }

    TopicsProcessor.prototype.followTopic = function(waveId, callback) {
      TopicsProcessor.__super__.followTopic.call(this, waveId, callback);
      return _gaq.push(['_trackEvent', 'Topic content', 'Follow topic', 'Make followed']);
    };

    TopicsProcessor.prototype.unfollowTopic = function(waveId, callback) {
      TopicsProcessor.__super__.unfollowTopic.call(this, waveId, callback);
      return _gaq.push(['_trackEvent', 'Topic content', 'Follow topic', 'Make unfollowed']);
    };

    return TopicsProcessor;

  })(BaseTopicsProcessor);

  module.exports = {
    TopicsProcessor: TopicsProcessor,
    instance: null
  };

}).call(this);

});

require.define("/lib/client/client/search_panel/base_topic_processor.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BaseSearchProcessor, BaseTopicsProcessor, Request,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BaseSearchProcessor = require('./base_processor').BaseSearchProcessor;

  Request = require('../../share/communication').Request;

  BaseTopicsProcessor = (function(_super) {

    __extends(BaseTopicsProcessor, _super);

    function BaseTopicsProcessor(_rootRouter) {
      this._rootRouter = _rootRouter;
    }

    BaseTopicsProcessor.prototype.followTopic = function(waveId, callback) {
      var request;
      request = new Request({
        waveId: waveId
      }, callback);
      return this._rootRouter.handle('network.wave.followWave', request);
    };

    BaseTopicsProcessor.prototype.unfollowTopic = function(waveId, callback) {
      var request;
      request = new Request({
        waveId: waveId
      }, callback);
      return this._rootRouter.handle('network.wave.unfollowWave', request);
    };

    return BaseTopicsProcessor;

  })(BaseSearchProcessor);

  module.exports = {
    BaseTopicsProcessor: BaseTopicsProcessor,
    instance: null
  };

}).call(this);

});

require.define("/lib/client/client/search_panel/base_processor.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BaseRouter, BaseSearchProcessor, Request,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BaseRouter = require('../../share/base_router').BaseRouter;

  Request = require('../../share/communication').Request;

  BaseSearchProcessor = (function(_super) {

    __extends(BaseSearchProcessor, _super);

    function BaseSearchProcessor(_rootRouter) {
      this._rootRouter = _rootRouter;
      BaseSearchProcessor.__super__.constructor.call(this, this._rootRouter);
    }

    BaseSearchProcessor.prototype.search = function(searchFunction, queryString, lastSearchDate, additionalParams, callback) {
      var key, request, searchParams, val;
      if (additionalParams == null) additionalParams = {};
      searchParams = {
        queryString: queryString || '',
        lastSearchDate: lastSearchDate
      };
      if (typeof additionalParams === 'function') {
        callback = additionalParams;
      } else {
        for (key in additionalParams) {
          val = additionalParams[key];
          searchParams[key] = val;
        }
      }
      request = new Request(searchParams, callback);
      return this._rootRouter.handle(searchFunction, request);
    };

    return BaseSearchProcessor;

  })(BaseRouter);

  exports.BaseSearchProcessor = BaseSearchProcessor;

}).call(this);

});

require.define("/lib/client/client/search_panel/mention/processor.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BaseSearchProcessor, MentionsProcessor, Request,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  Request = require('../../../share/communication').Request;

  BaseSearchProcessor = require('../base_processor').BaseSearchProcessor;

  MentionsProcessor = (function(_super) {

    __extends(MentionsProcessor, _super);

    function MentionsProcessor(_rootRouter) {
      this._rootRouter = _rootRouter;
      MentionsProcessor.__super__.constructor.call(this, this._rootRouter);
    }

    MentionsProcessor.prototype.addRecipientByEmail = function(blipId, version, position, email, callback) {
      var params, request;
      params = {
        blipId: blipId,
        version: version,
        position: position,
        email: email
      };
      request = new Request(params, callback);
      return this._rootRouter.handle('network.message.addRecipientByEmail', request);
    };

    MentionsProcessor.prototype.send = function(blipId, callback) {
      var request;
      request = new Request({
        blipId: blipId
      }, callback);
      return this._rootRouter.handle('network.message.send', request);
    };

    return MentionsProcessor;

  })(BaseSearchProcessor);

  module.exports = {
    MentionsProcessor: MentionsProcessor,
    instance: null
  };

}).call(this);

});

require.define("/lib/client/client/search_panel/task/processor.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BaseSearchProcessor, ParamsField, Request, TasksProcessor,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  ParamsField = require('../../editor/model').ParamsField;

  Request = require('../../../share/communication').Request;

  BaseSearchProcessor = require('../base_processor').BaseSearchProcessor;

  TasksProcessor = (function(_super) {

    __extends(TasksProcessor, _super);

    function TasksProcessor(_rootRouter) {
      this._rootRouter = _rootRouter;
    }

    TasksProcessor.prototype.assign = function(params, callback) {
      var request;
      delete params.recipientId;
      delete params.senderId;
      delete params[ParamsField.TYPE];
      if (params.deadlineDate != null) {
        params.deadline = {
          date: params.deadlineDate
        };
      }
      delete params.deadlineDate;
      if (params.deadlineDatetime != null) {
        params.deadline = {
          datetime: params.deadlineDatetime
        };
      }
      delete params.deadlineDatetime;
      request = new Request(params, callback);
      request.setProperty('recallOnDisconnect', true);
      return this._rootRouter.handle('network.task.assign', request);
    };

    TasksProcessor.prototype.send = function(blipId, callback) {
      var request;
      request = new Request({
        blipId: blipId
      }, callback);
      request.setProperty('recallOnDisconnect', true);
      return this._rootRouter.handle('network.task.send', request);
    };

    TasksProcessor.prototype.updateTaskSearchInfo = function(taskInfo) {
      var request;
      request = new Request({
        taskInfo: taskInfo
      }, function() {});
      return this._rootRouter.handle('navigation.updateTaskInfo', request);
    };

    return TasksProcessor;

  })(BaseSearchProcessor);

  module.exports = {
    TasksProcessor: TasksProcessor,
    instance: null
  };

}).call(this);

});

require.define("/lib/client/client/editor/model/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {

  module.exports = require('../../../share/model');

}).call(this);

});

require.define("/lib/client/share/model/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var LineLevelParams, ModelField, ModelType, ObjectParams, ParamsField, TextLevelParams,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  ObjectParams = (function() {

    function ObjectParams() {}

    ObjectParams.isValid = function(param) {
      /*
              Проверяет, что указанный параметр присутствует в данном наборе параметров
              @param param: any
              @return: boolean
      */      if (typeof param !== 'string') return false;
      if (param === 'RANDOM' || param === '__RANDOM') return true;
      if (param.substring(0, 2) !== this._prefix) return false;
      if (this.hasOwnProperty(param.substring(2))) return true;
      return false;
    };

    return ObjectParams;

  })();

  TextLevelParams = (function(_super) {

    __extends(TextLevelParams, _super);

    function TextLevelParams() {
      TextLevelParams.__super__.constructor.apply(this, arguments);
    }

    /*
        Список поддерживаемых текстовых параметров
        Соглашение имен: для проверки важно ставить значения параметров равному имени параметра с префиксом 'T_'
    */

    TextLevelParams._prefix = 'T_';

    TextLevelParams.URL = 'T_URL';

    TextLevelParams.BOLD = 'T_BOLD';

    TextLevelParams.ITALIC = 'T_ITALIC';

    TextLevelParams.STRUCKTHROUGH = 'T_STRUCKTHROUGH';

    TextLevelParams.UNDERLINED = 'T_UNDERLINED';

    TextLevelParams.BG_COLOR = 'T_BG_COLOR';

    return TextLevelParams;

  })(ObjectParams);

  LineLevelParams = (function(_super) {

    __extends(LineLevelParams, _super);

    function LineLevelParams() {
      LineLevelParams.__super__.constructor.apply(this, arguments);
    }

    /*
        Список поддерживаемых текстовых параметров
        Соглашение имен: для проверки важно ставить значения параметров равному имени параметра с префиксом 'L_'
    */

    LineLevelParams._prefix = 'L_';

    LineLevelParams.BULLETED = 'L_BULLETED';

    LineLevelParams.NUMBERED = 'L_NUMBERED';

    return LineLevelParams;

  })(ObjectParams);

  ModelField = (function() {

    function ModelField() {}

    ModelField.PARAMS = 'params';

    ModelField.TEXT = 't';

    return ModelField;

  })();

  ParamsField = (function() {

    function ParamsField() {}

    ParamsField.TEXT = '__TEXT';

    ParamsField.TYPE = '__TYPE';

    ParamsField.ID = '__ID';

    ParamsField.URL = '__URL';

    ParamsField.MIME = '__MIME';

    ParamsField.SIZE = '__SIZE';

    ParamsField.THUMBNAIL = '__THUMBNAIL';

    ParamsField.USER_ID = '__USER_ID';

    ParamsField.NAME = '__NAME';

    ParamsField.RANDOM = 'RANDOM';

    ParamsField.TAG = '__TAG';

    ParamsField.THREAD_ID = '__THREAD_ID';

    return ParamsField;

  })();

  ModelType = (function() {

    function ModelType() {}

    ModelType.TEXT = 'TEXT';

    ModelType.BLIP = 'BLIP';

    ModelType.LINE = 'LINE';

    ModelType.ATTACHMENT = 'ATTACHMENT';

    ModelType.RECIPIENT = 'RECIPIENT';

    ModelType.TASK_RECIPIENT = 'TASK';

    ModelType.GADGET = 'GADGET';

    ModelType.FILE = 'FILE';

    ModelType.TAG = 'TAG';

    return ModelType;

  })();

  exports.TextLevelParams = TextLevelParams;

  exports.LineLevelParams = LineLevelParams;

  exports.ModelField = ModelField;

  exports.ParamsField = ParamsField;

  exports.ModelType = ModelType;

}).call(this);

});

require.define("/lib/client/client/search_panel/public_topic/processor.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BaseTopicsProcessor, PublicTopicsProcessor, Request,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BaseTopicsProcessor = require('../base_topic_processor').BaseTopicsProcessor;

  Request = require('../../../share/communication').Request;

  PublicTopicsProcessor = (function(_super) {

    __extends(PublicTopicsProcessor, _super);

    function PublicTopicsProcessor(_rootRouter) {
      this._rootRouter = _rootRouter;
    }

    PublicTopicsProcessor.prototype.followTopic = function(waveId, callback) {
      PublicTopicsProcessor.__super__.followTopic.call(this, waveId, callback);
      return _gaq.push(['_trackEvent', 'Topic content', 'Follow topic', 'Make followed public']);
    };

    PublicTopicsProcessor.prototype.unfollowTopic = function(waveId, callback) {
      PublicTopicsProcessor.__super__.unfollowTopic.call(this, waveId, callback);
      return _gaq.push(['_trackEvent', 'Topic content', 'Follow topic', 'Make unfollowed public']);
    };

    return PublicTopicsProcessor;

  })(BaseTopicsProcessor);

  module.exports = {
    PublicTopicsProcessor: PublicTopicsProcessor,
    instance: null
  };

}).call(this);

});

require.define("/lib/client/client/market_panel/processor.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BaseRouter, MarketProcessor, Request,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BaseRouter = require('../../share/base_router').BaseRouter;

  Request = require('../../share/communication').Request;

  MarketProcessor = (function(_super) {

    __extends(MarketProcessor, _super);

    function MarketProcessor(_rootRouter) {
      this._rootRouter = _rootRouter;
      MarketProcessor.__super__.constructor.call(this, this._rootRouter);
    }

    MarketProcessor.prototype.getVisibleItemList = function(callback) {
      var request;
      request = new Request({}, callback);
      return this._rootRouter.handle('network.store.getVisibleItemList', request);
    };

    MarketProcessor.prototype.installStoreItem = function(id, callback) {
      var params, request;
      params = {
        itemId: id
      };
      request = new Request(params, callback);
      return this._rootRouter.handle('network.user.installStoreItem', request);
    };

    MarketProcessor.prototype.uninstallStoreItem = function(id, callback) {
      var params, request;
      params = {
        itemId: id
      };
      request = new Request(params, callback);
      return this._rootRouter.handle('network.user.uninstallStoreItem', request);
    };

    MarketProcessor.prototype.getCurrentWave = function(callback) {
      var request;
      request = new Request([], callback);
      return this._rootRouter.handle('wave.getCurWave', request);
    };

    return MarketProcessor;

  })(BaseRouter);

  module.exports = {
    MarketProcessor: MarketProcessor,
    instance: null
  };

}).call(this);

});

require.define("/lib/client/client/export/processor.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BaseRouter, ExportProcessor, Request,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BaseRouter = require('../../share/base_router').BaseRouter;

  Request = require('../../share/communication').Request;

  ExportProcessor = (function(_super) {

    __extends(ExportProcessor, _super);

    function ExportProcessor() {
      ExportProcessor.__super__.constructor.apply(this, arguments);
    }

    ExportProcessor.prototype.findArchives = function(callback) {
      var request;
      request = new Request({}, callback);
      return this._rootRouter.handle('network.export.findArchives', request);
    };

    ExportProcessor.prototype.exportTopics = function(ids, callback) {
      var request;
      request = new Request({
        ids: ids
      }, callback);
      return this._rootRouter.handle('network.export.exportTopics', request);
    };

    return ExportProcessor;

  })(BaseRouter);

  exports.ExportProcessor = ExportProcessor;

}).call(this);

});

require.define("/lib/client/client/account_setup_wizard/processor.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var AccountSetupProcessor, BaseRouter, LIST_UPDATE_INTERVAL, LocalStorage, MicroEvent, REQUEST_KEY, Request,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  BaseRouter = require('../../share/base_router').BaseRouter;

  Request = require('../../share/communication').Request;

  MicroEvent = require('../utils/microevent');

  REQUEST_KEY = 'network.team.getTeamTopics';

  LocalStorage = require('../utils/localStorage').LocalStorage;

  LIST_UPDATE_INTERVAL = 60 * 60 * 1000;

  AccountSetupProcessor = (function(_super) {

    __extends(AccountSetupProcessor, _super);

    function AccountSetupProcessor() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      AccountSetupProcessor.__super__.constructor.apply(this, args);
      this._isBusinessUser = false;
    }

    AccountSetupProcessor.prototype._createRequest = function(args, callback, shouldRecall) {
      var res;
      if (shouldRecall == null) shouldRecall = false;
      /*
              Создает Request
              @param args: object, аргументы вызова
              @param callback: function, будет вызван при получении ошибки или результата
              @param shouldRecall: boolean, повторять ли запрос при ошибках сети
              @return: Request
      */
      res = new Request(args, callback);
      res.setProperty('recallOnDisconnect', shouldRecall);
      return res;
    };

    AccountSetupProcessor.prototype.createTeamByWizard = function(emails, teamName, callback) {
      /*
              Отправляет на сервер запрос группового топика
              @param callback: function
      */
      var request;
      request = this._createRequest({
        emails: emails,
        teamName: teamName
      }, callback);
      return this._rootRouter.handle('network.team.createTeamByWizard', request);
    };

    AccountSetupProcessor.prototype.sendEnterpriseRequest = function(companyName, contactEmail, comment, callback) {
      /*
              Отправляет на сервер поля для письма-запроса на ентерпрайз аккаунт
              @param callback: function
      */
      var request;
      request = this._createRequest({
        companyName: companyName,
        contactEmail: contactEmail,
        comment: comment
      }, callback);
      return this._rootRouter.handle('network.team.sendEnterpriseRequest', request);
    };

    AccountSetupProcessor.prototype.getTeamTopics = function(callback) {
      /*
              Получает с сервера список командных топиков
              @param callback: function
      */
      var request,
        _this = this;
      request = this._createRequest({}, function(err, res) {
        if (err) return callback(err);
        _this._emitDebtEvent(res.hasDebt);
        return callback(null, res);
      });
      return this._rootRouter.handle('network.team.getTeamTopics', request);
    };

    AccountSetupProcessor.prototype._emitDebtEvent = function(hasDebt) {
      return this.emit('team-debt-change', hasDebt);
    };

    AccountSetupProcessor.prototype.setAccountTypeSelected = function(callback) {
      /*
              Помечает что тип аккаунта выбран
              @param callback: function
      */
      var request;
      request = this._createRequest({}, callback);
      return this._rootRouter.handle('network.team.onAccountTypeSelected', request);
    };

    AccountSetupProcessor.prototype.getCachedTeamTopics = function() {
      var hasDebt, res, _ref, _ref2;
      res = LocalStorage.getSearchResults(REQUEST_KEY, (_ref = window.userInfo) != null ? _ref.teamsCacheKey : void 0);
      if (!res) {
        this.clearCachedTeamTopics();
      } else {
        hasDebt = (_ref2 = res.value) != null ? _ref2.hasDebt : void 0;
        if (hasDebt != null) this._emitDebtEvent(hasDebt);
      }
      return res;
    };

    AccountSetupProcessor.prototype.setCachedTeamTopics = function(topics, hasDebt) {
      var dateToCache, _ref;
      dateToCache = {
        topics: topics
      };
      if (hasDebt != null) dateToCache.hasDebt = hasDebt;
      return LocalStorage.setSearchResults(REQUEST_KEY, dateToCache, (_ref = window.userInfo) != null ? _ref.teamsCacheKey : void 0);
    };

    AccountSetupProcessor.prototype.clearCachedTeamTopics = function() {
      return LocalStorage.clearSearchResult(REQUEST_KEY);
    };

    AccountSetupProcessor.prototype.checkIsBusinessUser = function() {
      var interval, responseCache, _ref,
        _this = this;
      responseCache = this.getCachedTeamTopics();
      if (responseCache && responseCache.value) {
        interval = Date.now() - responseCache.savedTime;
        if (interval < LIST_UPDATE_INTERVAL) {
          return this.changeBusinessType(!!((_ref = responseCache.value.topics) != null ? _ref.length : void 0));
        }
      }
      return this.getTeamTopics(function(err, res) {
        if (err) return;
        return _this.changeBusinessType(!!res.topics.length);
      });
    };

    AccountSetupProcessor.prototype.isBusinessUser = function() {
      return this._isBusinessUser;
    };

    AccountSetupProcessor.prototype.changeBusinessType = function(isBusinessUser) {
      if (isBusinessUser === this._isBusinessUser) return;
      this._isBusinessUser = isBusinessUser;
      return this.emit('is-business-change', this._isBusinessUser);
    };

    AccountSetupProcessor.prototype.forceIsBusinessUpdate = function() {
      LocalStorage.clearSearchResult(REQUEST_KEY);
      return this.emit('force-is-business-update');
    };

    return AccountSetupProcessor;

  })(BaseRouter);

  MicroEvent.mixin(AccountSetupProcessor);

  module.exports = {
    AccountSetupProcessor: AccountSetupProcessor,
    instance: null,
    LIST_UPDATE_INTERVAL: LIST_UPDATE_INTERVAL
  };

}).call(this);

});

require.define("/lib/client/client/utils/localStorage.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BLIP_READ_EVENT_TIMEOUT, BLIP_READ_STATE, BUFFER, CHANGE_TOPIC_LIST, CLEAR_EXCLUDE, ENTER_COUNT, LASTAUTH, LAST_HIDDEN_TIP_DATE, LAST_OPENED_COLLECTION_TOPIC_ID, LINKEDIN_POPUP_SHOWED, LOGIN_COUNT_COOKIE, LocalStorage, MicroEvent, REPLIES_COUNT, TOPICS_COUNT, TOPICS_CREATED, USERS_ADDED,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = Array.prototype.indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  MicroEvent = require('./microevent');

  BUFFER = 'buffer';

  LASTAUTH = 'lauth';

  LOGIN_COUNT_COOKIE = "cap_lc";

  ENTER_COUNT = 'ec';

  BLIP_READ_STATE = 'blipReadState';

  CHANGE_TOPIC_LIST = "network.wave.searchBlipContent";

  LINKEDIN_POPUP_SHOWED = 'lps';

  REPLIES_COUNT = 'replies_count';

  TOPICS_COUNT = 'topics_count';

  TOPICS_CREATED = 'topics_created';

  USERS_ADDED = 'users_added';

  CLEAR_EXCLUDE = [LASTAUTH, LINKEDIN_POPUP_SHOWED, ENTER_COUNT, REPLIES_COUNT, TOPICS_COUNT, USERS_ADDED, TOPICS_CREATED];

  BLIP_READ_EVENT_TIMEOUT = 5 * 1000;

  LAST_HIDDEN_TIP_DATE = 'interface.lastHiddenTipDate';

  LAST_OPENED_COLLECTION_TOPIC_ID = 'interface.collection.lastOpenedTopicId';

  LocalStorage = (function() {

    function LocalStorage() {
      this._writeCapturedBlipReadEvents = __bind(this._writeCapturedBlipReadEvents, this);
      this._handleEvent = __bind(this._handleEvent, this);      this._blipReadEvents = [];
      window.addEventListener('storage', this._handleEvent, false);
    }

    LocalStorage.prototype._handleEvent = function(event) {
      return this._dispatchUpdateEvent(event.key, event.oldValue, event.newValue);
    };

    LocalStorage.prototype._dispatchEvent = function(eventType, eventParams) {
      return this.emit(eventType, eventParams);
    };

    LocalStorage.prototype._dispatchUpdateEvent = function(key, oldValue, newValue) {
      var params;
      if (key == null) return this._dispatchEvent('clear');
      if (key === BLIP_READ_STATE) {
        return this._dispatchBlipReadEvent(oldValue, newValue);
      } else if (key === CHANGE_TOPIC_LIST) {
        if (newValue === null) return;
        params = JSON.parse(newValue).value;
      } else {
        params = {
          oldValue: oldValue,
          newValue: newValue
        };
      }
      return this._dispatchEvent(key, params);
    };

    LocalStorage.prototype._dispatchBlipReadEvent = function(oldValue, newValue) {
      var event, events, _i, _len, _results;
      if (!newValue) return;
      events = JSON.parse(newValue);
      _results = [];
      for (_i = 0, _len = events.length; _i < _len; _i++) {
        event = events[_i];
        _results.push(this._dispatchEvent(BLIP_READ_STATE, event));
      }
      return _results;
    };

    LocalStorage.prototype._dispatchErrorEvent = function() {
      return this._dispatchEvent('error');
    };

    LocalStorage.prototype._setUserItem = function(key, value) {
      var _ref;
      value = {
        userId: (_ref = window.userInfo) != null ? _ref.id : void 0,
        value: value
      };
      if (key === CHANGE_TOPIC_LIST) value.time = Date.now();
      try {
        return window.localStorage.setItem(key, JSON.stringify(value));
      } catch (_error) {}
    };

    LocalStorage.prototype._getUserItem = function(key) {
      var value, _ref;
      try {
        value = JSON.parse(window.localStorage.getItem(key));
      } catch (e) {
        console.warn("JSON.parse error for localStorage item, key " + key + ", err: " + e);
        return null;
      }
      if (!value) return;
      if (value.userId === ((_ref = window.userInfo) != null ? _ref.id : void 0)) {
        return value.value;
      }
      try {
        window.localStorage.removeItem(key);
      } catch (_error) {}
      return null;
    };

    LocalStorage.prototype.hasBuffer = function() {
      return !!this.getBuffer();
    };

    LocalStorage.prototype.getBuffer = function() {
      try {
        return window.localStorage.getItem(BUFFER);
      } catch (_error) {}
    };

    LocalStorage.prototype.setBuffer = function(value) {
      var oldValue;
      oldValue = this.getBuffer();
      try {
        window.localStorage.setItem(BUFFER, value);
      } catch (_error) {}
      return this._dispatchUpdateEvent(BUFFER, oldValue, value);
    };

    LocalStorage.prototype.removeBuffer = function() {
      var oldValue;
      oldValue = this.getBuffer();
      try {
        window.localStorage.removeItem(BUFFER);
      } catch (_error) {}
      return this._dispatchUpdateEvent(BUFFER, oldValue, null);
    };

    LocalStorage.prototype.getLastAuth = function() {
      try {
        return window.localStorage.getItem(LASTAUTH);
      } catch (_error) {}
    };

    LocalStorage.prototype.setLastAuth = function(value) {
      try {
        return window.localStorage.setItem(LASTAUTH, value);
      } catch (_error) {}
    };

    LocalStorage.prototype.getTopicsCount = function() {
      var cnt;
      cnt = (function() {
        try {
          return window.localStorage.getItem(TOPICS_COUNT);
        } catch (_error) {}
      })();
      if (!cnt) cnt = 0;
      return parseInt(cnt);
    };

    LocalStorage.prototype.setTopicsCount = function(value) {
      try {
        return window.localStorage.setItem(TOPICS_COUNT, value);
      } catch (_error) {}
    };

    LocalStorage.prototype.getUsersAdded = function() {
      var cnt;
      cnt = (function() {
        try {
          return window.localStorage.getItem(USERS_ADDED);
        } catch (_error) {}
      })();
      if (!cnt) cnt = 0;
      return parseInt(cnt);
    };

    LocalStorage.prototype.incUsersAdded = function(delta) {
      if (delta == null) delta = 1;
      try {
        return window.localStorage.setItem(USERS_ADDED, this.getUsersAdded() + delta);
      } catch (_error) {}
    };

    LocalStorage.prototype.getTopicsCreated = function() {
      var cnt;
      cnt = (function() {
        try {
          return window.localStorage.getItem(TOPICS_CREATED);
        } catch (_error) {}
      })();
      if (!cnt) cnt = 0;
      return parseInt(cnt);
    };

    LocalStorage.prototype.incTopicsCreated = function() {
      try {
        return window.localStorage.setItem(TOPICS_CREATED, this.getTopicsCreated() + 1);
      } catch (_error) {}
    };

    LocalStorage.prototype.getRepliesCount = function() {
      var cnt;
      cnt = (function() {
        try {
          return window.localStorage.getItem(REPLIES_COUNT);
        } catch (_error) {}
      })();
      if (!cnt) cnt = 0;
      return parseInt(cnt);
    };

    LocalStorage.prototype.incRepliesCount = function() {
      try {
        return window.localStorage.setItem(REPLIES_COUNT, this.getRepliesCount() + 1);
      } catch (_error) {}
    };

    LocalStorage.prototype.getEnterCount = function() {
      try {
        return window.localStorage.getItem(ENTER_COUNT);
      } catch (_error) {}
    };

    LocalStorage.prototype.setEnterCount = function(value) {
      try {
        return window.localStorage.setItem(ENTER_COUNT, value);
      } catch (_error) {}
    };

    LocalStorage.prototype.increaseLoginCount = function() {
      var loginCount;
      if (!(window.userInfo != null)) return;
      if (window.userInfo.daysAfterFirstVisit < 22) {
        if (!window.firstSessionLoggedIn) return;
        loginCount = parseInt($.cookie(LOGIN_COUNT_COOKIE) || 0);
        return $.cookie(LOGIN_COUNT_COOKIE, loginCount + 1, {
          path: '/topic/',
          expires: 100
        });
      } else {
        if ($.cookie(LOGIN_COUNT_COOKIE) != null) {
          return $.cookie(LOGIN_COUNT_COOKIE, '', {
            path: '/topic/',
            expires: -1
          });
        }
      }
    };

    LocalStorage.prototype.loginCountIsMoreThanTwo = function() {
      var cookieVal;
      if (!(window.userInfo != null)) return false;
      cookieVal = $.cookie(LOGIN_COUNT_COOKIE);
      if (!(cookieVal != null)) return true;
      return parseInt(cookieVal) > 2;
    };

    LocalStorage.prototype.getLoginCount = function() {
      var cookieVal;
      cookieVal = $.cookie(LOGIN_COUNT_COOKIE);
      if (!(cookieVal != null)) return null;
      return parseInt(cookieVal);
    };

    LocalStorage.prototype.setSearchResults = function(key, value, mode) {
      value = {
        savedTime: Date.now(),
        value: value,
        mode: mode
      };
      return this._setUserItem(key, value);
    };

    LocalStorage.prototype.getSearchResults = function(key, mode) {
      var val;
      val = this._getUserItem(key);
      if (val && mode === val.mode) return val;
    };

    LocalStorage.prototype.clearSearchResult = function(key) {
      try {
        return window.localStorage.removeItem(key);
      } catch (_error) {}
    };

    LocalStorage.prototype.clear = function() {
      var k, v, _ref, _results;
      try {
        _ref = window.localStorage;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          if (__indexOf.call(CLEAR_EXCLUDE, k) >= 0) continue;
          _results.push(window.localStorage.removeItem(k));
        }
        return _results;
      } catch (_error) {}
    };

    LocalStorage.prototype.updateBlipReadState = function(params) {
      this.emit(BLIP_READ_STATE, params);
      this._blipReadEvents.push(params);
      return this._freeCapturedBlipReadEvents();
    };

    LocalStorage.prototype._freeCapturedBlipReadEvents = function() {
      var delta, nextTime, prevTime;
      if (this._nextWriteHandler != null) return;
      if (!this._blipReadEvents.length) return;
      prevTime = this._prevWriteTime || 0;
      nextTime = prevTime + BLIP_READ_EVENT_TIMEOUT;
      delta = Math.max(0, nextTime - Date.now());
      return this._nextWriteHandler = setTimeout(this._writeCapturedBlipReadEvents, delta);
    };

    LocalStorage.prototype._writeCapturedBlipReadEvents = function() {
      try {
        window.localStorage.setItem(BLIP_READ_STATE, JSON.stringify(this._blipReadEvents));
      } catch (_error) {}
      try {
        window.localStorage.removeItem(BLIP_READ_STATE);
      } catch (_error) {}
      this._blipReadEvents = [];
      this._prevWriteTime = Date.now();
      this._nextWriteHandler = null;
      return this._freeCapturedBlipReadEvents();
    };

    LocalStorage.prototype.setLastHiddenTipDate = function(date) {
      return this._setUserItem(LAST_HIDDEN_TIP_DATE, date);
    };

    LocalStorage.prototype.getLastHiddenTipDate = function() {
      var date;
      date = this._getUserItem(LAST_HIDDEN_TIP_DATE);
      if (!(date != null) && window.loggedIn) {
        date = (function() {
          try {
            return window.localStorage.getItem('last-hidden-tip-date');
          } catch (_error) {}
        })();
        if (date != null) {
          this._setUserItem(LAST_HIDDEN_TIP_DATE, date);
          try {
            window.localStorage.removeItem('last-hidden-tip-date');
          } catch (_error) {}
        }
      }
      return date;
    };

    LocalStorage.prototype.removeLastHiddenTipDate = function() {
      try {
        return window.localStorage.removeItem(LAST_HIDDEN_TIP_DATE);
      } catch (_error) {}
    };

    LocalStorage.prototype._fixLastHiddenTipDate = function() {
      /*
              Переводит last hidden tip date из старого формата в новый
      */      if (!window.loggedIn) {}
    };

    LocalStorage.prototype.setLinkedinPopupShowed = function() {
      return this._setUserItem(LINKEDIN_POPUP_SHOWED, true);
    };

    LocalStorage.prototype.getLinkedinPopupShowed = function() {
      return this._getUserItem(LINKEDIN_POPUP_SHOWED);
    };

    LocalStorage.prototype.setLastCollectionTopicId = function(topicId) {
      return this._setUserItem(LAST_OPENED_COLLECTION_TOPIC_ID, topicId);
    };

    LocalStorage.prototype.getLastCollectionTopicId = function() {
      return this._getUserItem(LAST_OPENED_COLLECTION_TOPIC_ID);
    };

    return LocalStorage;

  })();

  MicroEvent.mixin(LocalStorage);

  module.exports.BLIP_READ_STATE = BLIP_READ_STATE;

  module.exports.CHANGE_TOPIC_LIST = CHANGE_TOPIC_LIST;

  module.exports.LocalStorage = new LocalStorage();

}).call(this);

});

require.define("/lib/client/client/utils/browser_events.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BEFORE_COPY_EVENT, BEFORE_CUT_EVENT, BEFORE_PASTE_EVENT, BLUR_EVENT, CLICK_EVENT, COMPOSITION_END_EVENT, COMPOSITION_START_EVENT, COMPOSITION_UPDATE_EVENT, COPY_EVENT, CUT_EVENT, DRAG_END_EVENT, DRAG_ENTER_EVENT, DRAG_EVENT, DRAG_LEAVE_EVENT, DRAG_OVER_EVENT, DRAG_START_EVENT, DROP_EVENT, FOCUS_EVENT, KEY_DOWN_EVENT, KEY_PRESS_EVENT, KEY_UP_EVENT, MOUSE_DOWN_EVENT, MOUSE_UP_EVENT, PASTE_EVENT, TEXT_EVENT, TEXT_INPUT_EVENT, blockEvent, createEvent, createTouchEvent, stopEventPropagation;

  exports.CLICK_EVENT = CLICK_EVENT = 'click';

  exports.MOUSE_DOWN_EVENT = MOUSE_DOWN_EVENT = 'mousedown';

  exports.MOUSE_UP_EVENT = MOUSE_UP_EVENT = 'mouseup';

  exports.MOUSE_EVENTS = [CLICK_EVENT, 'dblclick', MOUSE_DOWN_EVENT, MOUSE_UP_EVENT, 'mouseover', 'mousemove', 'mouseout', 'mousewheel', 'contextmenu', 'selectstart'];

  exports.TOUCH_START_EVENT = 'touchstart';

  exports.TOUCH_MOVE_EVENT = 'touchmove';

  exports.TOUCH_END_EVENT = 'touchend';

  exports.TOUCH_CANCEL_EVENT = 'touchcancel';

  exports.KEY_DOWN_EVENT = KEY_DOWN_EVENT = 'keydown';

  exports.KEY_PRESS_EVENT = KEY_PRESS_EVENT = 'keypress';

  exports.KEY_UP_EVENT = KEY_UP_EVENT = 'keyup';

  exports.KEY_EVENTS = [KEY_DOWN_EVENT, KEY_PRESS_EVENT, KEY_UP_EVENT];

  exports.DRAG_EVENT = DRAG_EVENT = 'drag';

  exports.DRAG_START_EVENT = DRAG_START_EVENT = 'dragstart';

  exports.DRAG_ENTER_EVENT = DRAG_ENTER_EVENT = 'dragenter';

  exports.DRAG_OVER_EVENT = DRAG_OVER_EVENT = 'dragover';

  exports.DRAG_LEAVE_EVENT = DRAG_LEAVE_EVENT = 'dragleave';

  exports.DRAG_END_EVENT = DRAG_END_EVENT = 'dragend';

  exports.DROP_EVENT = DROP_EVENT = 'drop';

  exports.DRAGDROP_EVENTS = [DRAG_EVENT, DRAG_START_EVENT, DRAG_ENTER_EVENT, DRAG_OVER_EVENT, DRAG_LEAVE_EVENT, DRAG_END_EVENT, DROP_EVENT];

  exports.COPY_EVENT = COPY_EVENT = 'copy';

  exports.CUT_EVENT = CUT_EVENT = 'cut';

  exports.PASTE_EVENT = PASTE_EVENT = 'paste';

  exports.BEFORE_CUT_EVENT = BEFORE_CUT_EVENT = 'beforecut';

  exports.BEFORE_COPY_EVENT = BEFORE_COPY_EVENT = 'beforecopy';

  exports.BEFORE_PASTE_EVENT = BEFORE_PASTE_EVENT = 'beforepaste';

  exports.CLIPBOARD_EVENTS = [CUT_EVENT, COPY_EVENT, PASTE_EVENT];

  exports.BLUR_EVENT = BLUR_EVENT = 'blur';

  exports.FOCUS_EVENT = FOCUS_EVENT = 'focus';

  exports.FOCUS_EVENTS = [FOCUS_EVENT, BLUR_EVENT, 'beforeeditfocus'];

  exports.DOM_FOCUS_IN = 'DOMFocusIn';

  exports.DOM_FOCUS_OUT = 'DOMFocusOut';

  exports.DOM_NODE_INSERTED = 'DOMNodeInserted';

  exports.DOM_NODE_REMOVED = 'DOMNodeRemoved';

  exports.MUTATION_EVENTS = ['DOMActivate', 'DOMAttributeNameChanged', 'DOMAttrModified', 'DOMCharacterDataModified', 'DOMElementNameChanged', exports.DOM_FOCUS_IN, exports.DOM_FOCUS_OUT, 'DOMMouseScroll', exports.DOM_NODE_INSERTED, 'DOMNodeInsertedIntoDocument', exports.DOM_NODE_REMOVED, 'DOMNodeRemovedFromDocument', 'DOMSubtreeModified'];

  exports.COMPOSITION_START_EVENT = COMPOSITION_START_EVENT = "compositionstart";

  exports.COMPOSITION_END_EVENT = COMPOSITION_END_EVENT = "compositionend";

  exports.COMPOSITION_UPDATE_EVENT = COMPOSITION_UPDATE_EVENT = "compositionupdate";

  exports.TEXT_EVENT = TEXT_EVENT = "text";

  exports.INPUT_EVENT = 'input';

  exports.TEXT_INPUT_EVENT = TEXT_INPUT_EVENT = 'textInput';

  exports.INPUT_EVENTS = [COMPOSITION_START_EVENT, COMPOSITION_END_EVENT, COMPOSITION_UPDATE_EVENT, TEXT_EVENT, TEXT_INPUT_EVENT];

  exports.OTHER_EVENTS = ["load", "unload", "abort", "error", "resize", "scroll", "beforeunload", "stop", "select", "change", "submit", "reset", "domfocusin", "domfocusout", "domactivate", "afterupdate", "beforeupdate", "cellchange", "dataavailable", "datasetchanged", "datasetcomplete", "errorupdate", "rowenter", "rowexit", "rowsdelete", "rowinserted", "help", "start", "finish", "bounce", "beforeprint", "afterprint", "propertychange", "filterchange", "readystatechange", "losecapture"];

  exports.C_FOCUS_EVENT = 'c_focus';

  exports.C_BLIP_CREATE_EVENT = 'c_blip_create_event';

  exports.C_BLIP_INSERT_EVENT = 'c_blip_insert_event';

  exports.C_EDITOR_MOUSE_DOWN_EVENT = 'c_editor_mouse_down';

  exports.C_READ_ALL_EVENT = 'c_read_all';

  blockEvent = exports.blockEvent = function(event) {
    event.stopPropagation();
    return event.preventDefault();
  };

  createEvent = function(type, name, bubbles, cancelable) {
    var e;
    e = document.createEvent(type);
    e.initEvent(name, bubbles, cancelable);
    return e;
  };

  createTouchEvent = function(name, bubbles, cancelable) {
    var e;
    e = document.createEvent('TouchEvent');
    e.initTouchEvent(name, bubbles, cancelable);
    if (e.type !== name) e.initUIEvent(name, bubbles, cancelable);
    return e;
  };

  stopEventPropagation = function(event) {
    return event.stopPropagation();
  };

  exports.addBlocker = function(element, type, capture) {
    if (capture == null) capture = false;
    return element.addEventListener(type, blockEvent, capture);
  };

  exports.removeBlocker = function(element, type, capture) {
    if (capture == null) capture = false;
    return element.removeEventListener(type, blockEvent, capture);
  };

  exports.addPropagationBlocker = function(element, type, capture) {
    if (capture == null) capture = false;
    return element.addEventListener(type, stopEventPropagation, capture);
  };

  exports.removePropagationBlocker = function(element, type, capture) {
    if (capture == null) capture = false;
    return element.removeEventListener(type, stopEventPropagation, capture);
  };

  exports.createCustomEvent = function(name, bubbles, cancelable) {
    return createEvent('Event', name, bubbles, cancelable);
  };

  exports.createTouchEvent = function(name, bubbles, cancelable) {
    return createTouchEvent(name, bubbles, cancelable);
  };

}).call(this);

});

require.define("/lib/client/client/tag/processor.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var MicroEvent, Request, TagProcessor,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Request = require('../../share/communication').Request;

  MicroEvent = require('../../utils/microevent');

  TagProcessor = (function() {

    function TagProcessor(_rootRouter) {
      this._rootRouter = _rootRouter;
      this.getTags = __bind(this.getTags, this);
      this._tags = [];
    }

    TagProcessor.prototype._updateNavigationTagList = function() {
      var request;
      request = new Request({
        tags: this._tags
      });
      try {
        return this._rootRouter.handle('navigation.updateTagList', request);
      } catch (_error) {}
    };

    TagProcessor.prototype._addTag = function(tag) {
      var lowerTag, t, _i, _len, _ref;
      lowerTag = tag.toLowerCase();
      _ref = this._tags;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        if (lowerTag === t.toLowerCase()) return false;
      }
      this._tags.push(tag);
      return true;
    };

    TagProcessor.prototype._addTags = function(tags) {
      var tag, tagWasAdded, _i, _len;
      tagWasAdded = false;
      for (_i = 0, _len = tags.length; _i < _len; _i++) {
        tag = tags[_i];
        tagWasAdded = this._addTag(tag) || tagWasAdded;
      }
      if (tagWasAdded) return this._updateNavigationTagList();
    };

    TagProcessor.prototype.requestTags = function() {
      var request,
        _this = this;
      request = new Request({}, function(err, tags) {
        if (err) return console.warn("Could not get tag list", err);
        return _this._addTags(tags);
      });
      return this._rootRouter.handle('network.gtag.getGTagList', request);
    };

    TagProcessor.prototype.getTags = function() {
      return this._tags;
    };

    TagProcessor.prototype.addTag = function(tag) {
      if (this._addTag(tag)) return this._updateNavigationTagList();
    };

    TagProcessor.prototype.getCurWave = function(callback) {
      var request;
      request = new Request({}, callback);
      return this._rootRouter.handle('wave.getCurWave', request);
    };

    TagProcessor.prototype.findTopicListByTagText = function(text, sharedState) {
      var request;
      request = new Request({
        text: text,
        sharedState: sharedState
      }, function() {});
      return this._rootRouter.handle('navigation.findTopicListByTagText', request);
    };

    return TagProcessor;

  })();

  module.exports = {
    TagProcessor: TagProcessor
  };

  MicroEvent.mixin(TagProcessor);

}).call(this);

});

require.define("/lib/client/client/analytics/ping.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var HeaderTextForAutoPopup, History, PingAnalytics, StyleForChangedPopup, localStorage, splitTmpl,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  History = require('../utils/history_navigation');

  localStorage = require('../utils/localStorage').LocalStorage;

  StyleForChangedPopup = require('./style_for_auto_popup').renderStyleForAutoPopup;

  HeaderTextForAutoPopup = require('./style_for_auto_popup').renderHeaderTextForAutoPopup;

  splitTmpl = function() {
    return div({
      style: "margin:10px auto;        margin: 30px 0 -70px 0;        font-size: 22px;        font-family: PFAgoraSansProLightRegular, Helvetica, Arial;        color: white;        position: relative;        z-index: 4;"
    }, function() {
      if (this.v1) {
        return div("Sign in to view and comment");
      } else {
        div("Anonymous access is disabled");
        return div("Sign in to view the discussion");
      }
    });
  };

  PingAnalytics = (function() {

    function PingAnalytics() {
      this._trackNewVisit = __bind(this._trackNewVisit, this);
      this._updateLoginCount = __bind(this._updateLoginCount, this);
      var _this = this;
      $(document).ready(function() {
        _this._trackNewVisit();
        if (window.loggedIn) _this._updateLoginCount();
        if (!window.loggedIn) {
          _this._createAutoPopupSplitTest();
          return _this._createAuthSplitTest();
        }
      });
    }

    PingAnalytics.prototype._createAutoPopupSplitTest = function() {
      var setDefaultStyleForPopup, setStyleForAutoPopup, willShowPopup;
      if (History.isEmbedded()) return;
      willShowPopup = Math.round(Math.random()) === 0;
      if (willShowPopup) {
        _gaq.push(['_setCustomVar', 4, 'auto popup split test', 'popup was showed', 2]);
      } else {
        _gaq.push(['_setCustomVar', 4, 'auto popup split test', 'popup was not showed', 2]);
      }
      setTimeout(function() {
        if (willShowPopup && !window.AuthDialog.visible()) {
          window.AuthDialog.initAndShow(true, History.getLoginRedirectUrl());
          setStyleForAutoPopup();
          return $('.close-auth-dialog-btn').one('click', setDefaultStyleForPopup);
        }
      }, 20000);
      setStyleForAutoPopup = function() {
        $('head').append(StyleForChangedPopup());
        $('.auth-container div:first-child').hide();
        return $('.auth-dialog').addClass('auto-popup').append(HeaderTextForAutoPopup).siblings('.notification-overlay').css({
          background: '#728AA0',
          opacity: '0.8'
        });
      };
      return setDefaultStyleForPopup = function() {
        $('.auth-container div:first-child').show();
        $('.auth-dialog').removeClass('auto-popup');
        $('.call-to-action').remove();
        return $('.auth-dialog').siblings('.notification-overlay').css({
          background: '#000000',
          opacity: '0.5'
        });
      };
    };

    PingAnalytics.prototype._createAuthSplitTest = function() {
      var authDlg, renderSplit, v1;
      if (History.isEmbedded()) return;
      authDlg = $('.js-auth-dialog');
      v1 = Math.round(Math.random()) === 1;
      if (v1) {
        _gaq.push(['_setCustomVar', 5, 'topic landing', '"sign in" slogan', 2]);
      } else {
        _gaq.push(['_setCustomVar', 5, 'topic landing', '"Anonymous access" slogan', 2]);
      }
      renderSplit = window.CoffeeKup.compile(splitTmpl);
      return authDlg.prepend(renderSplit({
        v1: v1
      }));
    };

    PingAnalytics.prototype._updateLoginCount = function() {
      var cnt, curDate, ec, ldate;
      ec = localStorage.getEnterCount();
      if (!ec) ec = '0.0';
      ec = ec.split('.');
      if (ec.length !== 2) ec = '0.0';
      ldate = ec[0];
      cnt = ec[1];
      curDate = Math.round(Date.now() / 3600000 / 24) + '';
      if (ldate !== curDate) {
        cnt++;
        ldate = curDate;
        localStorage.setEnterCount(ldate + '.' + cnt);
      }
      if (cnt === 5) {
        return mixpanel.track("Visit 5 times", {
          "count": cnt
        });
      }
    };

    PingAnalytics.prototype._trackNewVisit = function() {
      var gcookie, l, rcookie;
      l = window.loggedIn;
      if (!l) return;
      gcookie = $.cookie('__utma');
      if (!gcookie) return;
      gcookie = gcookie.split('.');
      if (gcookie.length < 6) return;
      rcookie = localStorage.getLastAuth();
      if (rcookie) {
        rcookie = rcookie.split('.');
        if (rcookie.length < 2) rcookie = ['', ''];
      } else {
        rcookie = ['', ''];
      }
      if (gcookie[0] !== rcookie[0] || gcookie[4] !== rcookie[1]) {
        if (window.justRegisteredForGA) {
          _gaq.push(['_trackEvent', 'Authorization', 'Visit started', 'visit started new']);
          mixpanel.track("Visit app", {
            "type": "new"
          });
          delete window.justRegisteredForGA;
        } else {
          _gaq.push(['_trackEvent', 'Authorization', 'Visit started', 'visit started returning']);
          mixpanel.track("Visit app", {
            "type": "returning"
          });
        }
        return localStorage.setLastAuth(gcookie[0] + '.' + gcookie[4]);
      }
    };

    return PingAnalytics;

  })();

  module.exports.trackTopicCreatedAndUserAdded = function(usersAdded, topicCreated) {
    var topics, users;
    users = localStorage.getUsersAdded();
    topics = localStorage.getTopicsCreated();
    if (users * topics === 0 && (users + usersAdded) * (topics + topicCreated) > 0) {
      return mixpanel.track("Create topic and add user", {});
    }
  };

  module.exports.PingAnalytics = PingAnalytics;

  module.exports.instance = null;

}).call(this);

});

require.define("/lib/client/client/analytics/style_for_auto_popup.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var HeaderTextForAutoPopup, StyleForAutoPopup, ck;

  ck = window.CoffeeKup;

  StyleForAutoPopup = function() {
    return style('', function() {
      return text(".auto-popup{\n  width: 600px !important;\n  height: 300px !important;\n  background-color: #c2c9cf !important;\n  border: 4px solid white !important;\n  border-radius: 5px !important;\n  }\n  .auto-popup .call-to-action{\n      position:absolute;\n      top:30px;\n      font-size: 20px;\n      text-align: left;\n      margin: 0 20px;\n      font-weight: normal;\n  }\n  .auto-popup .or-glue{\n      display: none;\n  }\n  .auto-popup .google-sign-in-btn, .auto-popup .facebook-sign-in-btn{\n      position:absolute;\n      top:70px;\n      left:30px;\n      margin: 0 20px;\n  }\n  .auto-popup .facebook-sign-in-btn{\n      top: 130px;\n  }\n  .auto-popup .email-field, .auto-popup .password-field, .auto-popup .sign-in-btn, .auto-popup .msg, .auto-popup .show-forgot-password-form-link, .auto-popup .name-field, .auto-popup .sign-up-btn{\n      position:absolute;\n      margin: 0 20px;\n      left:350px;\n  }\n  .auto-popup #sign-in-form .email-field{\n      top:68px;\n  }\n  .auto-popup #sign-in-form .password-field{\n      top:130px;\n  }\n  .auto-popup #sign-in-form .sign-in-btn{\n      top:205px;\n  }\n  .auto-popup #sign-in-form .msg{\n      top:240px;\n  }\n  .auto-popup #sign-in-form .show-forgot-password-form-link{\n      top:290px;\n  }\n  .auto-popup #sign-up-form .name-field{\n      top:68px;\n  }\n  .auto-popup #sign-up-form .email-field{\n      top:120px;\n  }\n  .auto-popup #sign-up-form .password-field{\n      top:170px;\n  }\n  .auto-popup #sign-up-form .sign-up-btn{\n      top:230px;\n  }\n  .auto-popup #sign-up-form .msg{\n      top:275px;\n  }\n  .auto-popup #sign-in-form{\n      height: 280px;\n      width: 580px;\n      padding: 10px;\n  }");
    });
  };

  HeaderTextForAutoPopup = function() {
    return div('call-to-action', function() {
      return text("Sign in to leave comments or subscribe for updates");
    });
  };

  exports.renderStyleForAutoPopup = ck.compile(StyleForAutoPopup);

  exports.renderHeaderTextForAutoPopup = ck.compile(HeaderTextForAutoPopup);

}).call(this);

});

require.define("/lib/client/client/blip/processor.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipProcessor, BlipProcessorBase, BlipViewModel, PlaybackBlipViewModel, PlaybackWaveViewModel, Request,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BlipProcessorBase = require('./processor_base').BlipProcessorBase;

  BlipViewModel = require('./').BlipViewModel;

  PlaybackBlipViewModel = require('../playback/blip_view_model').PlaybackBlipViewModel;

  PlaybackWaveViewModel = require('../playback/wave_view_model').PlaybackWaveViewModel;

  Request = require('../../share/communication').Request;

  BlipProcessor = (function(_super) {

    __extends(BlipProcessor, _super);

    function BlipProcessor() {
      BlipProcessor.__super__.constructor.apply(this, arguments);
    }

    BlipProcessor.prototype.__constructBlip = function(blipData, waveViewModel, container, parentBlip) {
      /*
              @override
      */
      var BlipViewModelClass, isPlaybackMode, viewModel, _ref;
      isPlaybackMode = waveViewModel instanceof PlaybackWaveViewModel;
      BlipViewModelClass = isPlaybackMode ? PlaybackBlipViewModel : BlipViewModel;
      viewModel = BlipProcessor.__super__.__constructBlip.call(this, blipData, waveViewModel, container, parentBlip, BlipViewModelClass);
      if (isPlaybackMode) {
        viewModel.getModel().appendOps((_ref = blipData.meta) != null ? _ref.ops : void 0);
      }
      return viewModel;
    };

    BlipProcessor.prototype._sendGetBlipRequest = function(waveViewModel, request) {
      var isPlaybackMode;
      isPlaybackMode = waveViewModel instanceof PlaybackWaveViewModel;
      if (isPlaybackMode) {
        return this._rootRouter.handle('network.playback.getBlipForPlayback', request);
      } else {
        return BlipProcessor.__super__._sendGetBlipRequest.call(this, waveViewModel, request);
      }
    };

    BlipProcessor.prototype.getPlaybackOps = function(blipId, offset, callback) {
      var request,
        _this = this;
      request = new Request({
        blipId: blipId,
        offset: offset
      }, function(err, ops) {
        if (err) _this.showPageError(err);
        return callback(err, ops);
      });
      return this._rootRouter.handle('network.playback.getPlaybackOps', request);
    };

    return BlipProcessor;

  })(BlipProcessorBase);

  module.exports.BlipProcessor = BlipProcessor;

  module.exports.instance = null;

}).call(this);

});

require.define("/lib/client/client/blip/processor_base.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipProcessorBase, Request,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Request = require('../../share/communication').Request;

  BlipProcessorBase = (function() {

    function BlipProcessorBase(_rootRouter) {
      this._rootRouter = _rootRouter;
      this.showPageError = __bind(this.showPageError, this);
      this._processOp = __bind(this._processOp, this);
      this._init();
    }

    BlipProcessorBase.prototype._init = function() {
      return this._otProcessor = require('../ot/processor').instance;
    };

    BlipProcessorBase.prototype.__constructBlip = function(blipData, waveViewModel, container, parentBlip, BlipViewModel) {
      /*
              @param blipData: Object, данные блипа
              @param waveViewModel: WaveViewModel
              @param container: HTMLElement, контейнер, в котором будет отрисовываться блип
              @param parentBlip: BlipViewModel|null
              @param BlipViewModel: BlipViewModelClass
              @returns: BlipViewModel
      */
      var blipId, isRead, shareDoc, timestamp, title, waveId;
      blipId = Math.random().toString();
      shareDoc = this._otProcessor.makeDoc(blipId, blipData, waveViewModel.getId());
      isRead = blipData.meta.isRead;
      waveId = blipData.meta.waveId;
      timestamp = blipData.meta.ts;
      title = blipData.meta.title;
      return new BlipViewModel(waveViewModel, this, shareDoc, container, parentBlip, isRead, waveId, timestamp, title);
    };

    BlipProcessorBase.prototype._processOp = function(err, op, callId) {
      if (err) {
        return this.showPageError(err);
      } else {
        try {
          return this._otProcessor.processOp(op, callId);
        } catch (e) {
          return this.showPageError(e);
        }
      }
    };

    BlipProcessorBase.prototype.openBlip = function(waveViewModel, blipId, container, parentBlip, callback) {
      /*
              Отправляет на сервер запрос на открытие блипа.
              Подписывается на изменение данных блипа, если он открылся без ошибок
              Если произошла ошибка, покажет сообщение об ошибке на странице,
              callback не будет вызван
              @param waveViewModel: WaveViewModel
              @param blipId: string
              @param container: HTMLElement, контейнер, в котором будет отрисовываться блип
              @param parentBlip: BlipViewModel|null
              @param callback: function
                  callback(err, BlipViewModel)
      */
      var request, setBlipAsLoaded,
        _this = this;
      try {
        if (waveViewModel.isBlipRequested(blipId)) {
          return console.error("Blip " + blipId + " is already loaded");
        }
      } catch (e) {
        return console.warn('Wave for request blip is already closed', blipId);
      }
      waveViewModel.setBlipAsRequested(blipId);
      setBlipAsLoaded = function(blipViewModel) {
        callback(null, blipViewModel);
        waveViewModel.addChildBlip(blipViewModel);
        return waveViewModel.setBlipAsLoaded(blipViewModel);
      };
      if (blipId in waveViewModel.blipCache) {
        window.setTimeout(function() {
          var blipData, blipViewModel;
          if (!waveViewModel.getModel()) return;
          blipData = waveViewModel.blipCache[blipId];
          blipViewModel = _this.__constructBlip(blipData, waveViewModel, container, parentBlip);
          return setBlipAsLoaded(blipViewModel);
        }, 0);
        return;
      }
      request = new Request({
        blipId: blipId
      }, function(err, blipData) {
        var blipViewModel;
        if (err) return _this.showPageError(err);
        if (!waveViewModel.getModel()) {
          return console.warn('Wave was closed before blip construct call', blipId);
        }
        blipViewModel = _this.__constructBlip(blipData, waveViewModel, container, parentBlip);
        return setBlipAsLoaded(blipViewModel);
      });
      request.setProperty('recallOnDisconnect', true);
      return this._sendGetBlipRequest(waveViewModel, request);
    };

    BlipProcessorBase.prototype._sendGetBlipRequest = function(waveViewModel, request) {
      return this._rootRouter.handle('network.wave.getBlip', request);
    };

    BlipProcessorBase.prototype.subscribeBlip = function(blip, callId) {
      /*
              Подписывается на изменения блипа
              @param blip: BlipModel
              @param callId: string, идентификатор подписки, в рамках которой будут присылаться операции блипа
      */
      var args, request,
        _this = this;
      args = {
        blipId: blip.serverId,
        version: blip.getVersion(),
        callId: callId
      };
      request = new Request(args, function(err) {
        if (err) return _this.showPageError(err);
        return _this._otProcessor.onSubscribe(callId, blip.serverId);
      });
      request.setProperty('recallOnDisconnect', true);
      return this._rootRouter.handle('network.wave.subscribeBlip', request);
    };

    BlipProcessorBase.prototype.createBlip = function(waveViewModel, container, blipParams, parentBlip) {
      /*
              Отправляет на сервер запрос на создание блипа.
              @param waveViewModel: WaveViewModel
              @param blipId: string
              @param container: HTMLElement, контейнер, в котором будет отрисовываться блип
              @param blipParams: Object,  параметры для создаваемого блипа
              @param parentBlip: BlipViewModel|null
      */
      var blipData, blipViewModel, request,
        _this = this;
      blipData = this._getNewBlipData(waveViewModel.getServerId(), blipParams);
      blipViewModel = this.__constructBlip(blipData, waveViewModel, container, parentBlip);
      request = new Request({
        waveId: waveViewModel.getServerId(),
        blipParams: blipParams
      }, function(err, res) {
        if (blipViewModel.isClosed()) return;
        if (err) return _this.showPageError(err);
        blipViewModel.setServerId(res);
        waveViewModel.setBlipAsRequested(res);
        return waveViewModel.setBlipAsLoaded(blipViewModel);
      });
      request.setProperty('recallOnDisconnect', true);
      request.setProperty('close-confirm', true);
      if (blipParams.sourceBlipId) {
        this._rootRouter.handle('network.wave.createCopiedBlip', request);
      } else {
        if (blipParams.contributors != null) delete blipParams.contributors;
        if (blipParams.isFoldedByDefault != null) {
          delete blipParams.isFoldedByDefault;
        }
        this._rootRouter.handle('network.wave.createBlip', request);
      }
      waveViewModel.addChildBlip(blipViewModel);
      return blipViewModel;
    };

    BlipProcessorBase.prototype._getNewBlipData = function(serverWaveId, params) {
      var contributor, contributors, hasSelfUser, selfId, _i, _len;
      params.isFoldedByDefault || (params.isFoldedByDefault = false);
      contributors = params.contributors || [];
      selfId = window.userInfo.id;
      hasSelfUser = false;
      for (_i = 0, _len = contributors.length; _i < _len; _i++) {
        contributor = contributors[_i];
        if (contributor.id === selfId) hasSelfUser = true;
      }
      if (!hasSelfUser) {
        contributors.push({
          id: selfId
        });
      }
      params.contributors = contributors;
      params.content || (params.content = [
        {
          t: ' ',
          params: {
            __TYPE: "LINE",
            RANDOM: Math.random().toString()
          }
        }
      ]);
      return {
        meta: {
          isRead: true,
          title: '',
          ts: Math.floor(Date.now() / 1000),
          waveId: serverWaveId
        },
        snapshot: {
          content: params.content,
          contributors: contributors,
          isFoldedByDefault: params.isFoldedByDefault,
          isRootBlip: false,
          pluginData: {}
        },
        v: 0
      };
    };

    BlipProcessorBase.prototype.updateBlipReader = function(blipViewModel) {
      var blipModel, request;
      blipModel = blipViewModel.getModel();
      if (!(blipModel.serverId != null)) return;
      request = new Request({
        blipId: blipModel.serverId
      }, function() {});
      request.setProperty('recallOnDisconnect', true);
      return this._rootRouter.handle('network.wave.updateBlipReader', request);
    };

    BlipProcessorBase.prototype.showPageError = function(err) {
      /*
              Показывает ошибку, которая требует перезагрузки страницы
              @param err: object
      */
      var showErrRequest;
      console.error("Got severe blip error", new Date(), err);
      console.error(err.stack);
      showErrRequest = new Request({
        error: err
      }, function() {});
      return this._rootRouter.handle('pageError.showError', showErrRequest);
    };

    BlipProcessorBase.prototype.showPlaybackView = function(waveId, blipId, waveViewModel) {
      var request;
      request = new Request({
        waveId: waveId,
        blipId: blipId,
        waveViewModel: waveViewModel
      });
      return this._rootRouter.handle('playback.showPlaybackView', request);
    };

    return BlipProcessorBase;

  })();

  module.exports.BlipProcessorBase = BlipProcessorBase;

}).call(this);

});

require.define("/lib/client/client/blip/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipView, BlipViewModel, BlipViewModelBase,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BlipViewModelBase = require('./index_base');

  BlipView = require('./view').BlipView;

  BlipViewModel = (function(_super) {

    __extends(BlipViewModel, _super);

    function BlipViewModel() {
      BlipViewModel.__super__.constructor.apply(this, arguments);
    }

    BlipViewModel.prototype.__initView = function(waveViewModel, blipProcessor, model, timestamp, container, parentBlip, isRead) {
      return this.__view = new BlipView(waveViewModel, blipProcessor, this, model, timestamp, container, parentBlip, isRead);
    };

    return BlipViewModel;

  })(BlipViewModelBase);

  exports.BlipViewModel = BlipViewModel;

}).call(this);

});

require.define("/lib/client/client/blip/index_base.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipModel, BlipViewModelBase, FText, MicroEvent, ModelField, ModelType, ParamsField, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = Array.prototype.slice;

  BlipModel = require('./model').BlipModel;

  FText = sharejs.types.ftext;

  MicroEvent = require('../utils/microevent');

  _ref = require('../editor/model'), ModelType = _ref.ModelType, ModelField = _ref.ModelField, ParamsField = _ref.ParamsField;

  BlipViewModelBase = (function() {

    BlipViewModelBase.Events = {
      DESTROYED: 'destroyed'
    };

    function BlipViewModelBase() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._processRemoteChanges = __bind(this._processRemoteChanges, this);
      this._init.apply(this, args);
    }

    BlipViewModelBase.prototype._init = function(_waveViewModel, blipProcessor, blipData, container, parentBlip, isRead, waveId, timestamp, title) {
      var _ref2;
      this._waveViewModel = _waveViewModel;
      this.__parentBlip = parentBlip;
      this._initModel(blipData, waveId, isRead, title);
      this.__initView(this._waveViewModel, blipProcessor, this._model, timestamp, container, (_ref2 = this.__parentBlip) != null ? _ref2.getView() : void 0, isRead);
      blipData.on('remoteop', this._processRemoteChanges);
      return this._blipData = blipData;
    };

    BlipViewModelBase.prototype._initModel = function(blipData, waveId, isRead, title) {
      return this.__model = this._model = new BlipModel(blipData, waveId, isRead, title);
    };

    BlipViewModelBase.prototype.__initView = function(waveViewModel, blipProcessor, model, timestamp, container, parentBlip, isRead) {
      throw new Error('not implemented');
    };

    BlipViewModelBase.prototype._processRemoteChanges = function(ops, oldSnapshot, meta) {
      var contentOps, needLastSentUpdate, op, paramName, params, root, _base, _i, _len, _ref2, _ref3, _ref4, _ref5;
      contentOps = [];
      for (_i = 0, _len = ops.length; _i < _len; _i++) {
        op = ops[_i];
        if (FText.isFormattedTextOperation(op)) {
          if ((op.paramsi != null) || (op.paramsd != null)) {
            params = op.paramsi || op.paramsd;
            for (paramName in params) {
              if (paramName === 'lastSent' || paramName === 'lastSenderId') {
                needLastSentUpdate = true;
              }
            }
          }
          contentOps.push(op);
          continue;
        }
        if (op.p.length === 0 && ((_ref2 = op.oi) != null ? (_ref3 = _ref2.pluginData) != null ? (_ref4 = _ref3.message) != null ? _ref4.lastSent : void 0 : void 0 : void 0)) {
          needLastSentUpdate = true;
          continue;
        }
        if (op.p.length === 1 && op.p[0] === 'pluginData' && ((_ref5 = op.oi) != null ? _ref5.message : void 0)) {
          needLastSentUpdate = true;
          continue;
        }
        if (op.p.length === 2 && op.p[0] === 'pluginData' && op.p[1] === 'message') {
          needLastSentUpdate = true;
          continue;
        }
        root = op.p.shift();
        switch (root) {
          case 'contributors':
            this.__view.applyParticipantOp(op);
            break;
          case 'isFoldedByDefault':
            this.__view.applyisFoldedByDefaultOp(op);
            break;
          default:
            console.warn("Got unknown operation", op);
        }
      }
      if (contentOps.length) {
        this.__view.applyOps(contentOps, false, meta);
        this.emit('remote-ops', contentOps);
      }
      if (needLastSentUpdate) {
        return typeof (_base = this.__view).updateLastSent === "function" ? _base.updateLastSent() : void 0;
      }
    };

    BlipViewModelBase.prototype.applyUndoRedoOps = function(ops) {
      this.__view.applyOps(ops, true);
      return this.emit('undo-redo-ops', ops);
    };

    BlipViewModelBase.prototype.getView = function() {
      return this.__view;
    };

    BlipViewModelBase.prototype.getModel = function() {
      return this._model;
    };

    BlipViewModelBase.prototype.getWaveViewModel = function() {
      return this._waveViewModel;
    };

    BlipViewModelBase.prototype.getServerId = function() {
      return this.__model.getServerId();
    };

    BlipViewModelBase.prototype.setServerId = function(serverId) {
      this._model.serverId = serverId;
      require('../ot/processor').instance.setDocServerId(this._waveViewModel.getId(), this._model.id, serverId);
      this.emit('set-server-id', serverId);
      return this.removeListeners('set-server-id');
    };

    BlipViewModelBase.prototype.insertGadget = function(url) {
      var _ref2;
      return (_ref2 = this.__view.getEditor()) != null ? _ref2.insertGadget(url) : void 0;
    };

    BlipViewModelBase.prototype.setEditable = function(editable) {
      return this.__view.setEditable(editable);
    };

    BlipViewModelBase.prototype.focus = function() {
      return this.__view.focus();
    };

    BlipViewModelBase.prototype.unfoldToRoot = function() {
      return this.__view.unfoldToRootBlip();
    };

    BlipViewModelBase.prototype.getContainer = function() {
      return this.__view.getContainer();
    };

    BlipViewModelBase.prototype.getNearestServerId = function() {
      /*
              Возвращает serverId блипа. Если такого нет, возвращает serverId ближайшего
              родителя.
              @return: string|null
      */
      var serverId;
      if (!this.__parentBlip) return null;
      serverId = this.__model.getServerId();
      if (serverId) return serverId;
      return this.__parentBlip.getNearestServerId();
    };

    BlipViewModelBase.prototype.destroy = function() {
      var childBlip, childBlipId, _ref2;
      this._blipData.removeListener('remoteop', this._processRemoteChanges);
      this.emit(this.constructor.Events.DESTROYED, this);
      this.removeAllListeners();
      _ref2 = this.__model.getChildBlips();
      for (childBlipId in _ref2) {
        childBlip = _ref2[childBlipId];
        childBlip.destroy();
      }
      this.__model.destroy();
      this.__view.destroy();
      delete this.__parentBlip;
      delete this._waveViewModel;
      return this._isClosed = true;
    };

    BlipViewModelBase.prototype.isClosed = function() {
      return this._isClosed;
    };

    BlipViewModelBase.prototype.getParent = function() {
      return this.__parentBlip;
    };

    BlipViewModelBase.prototype.getChildIndex = function(child) {
      var block, childId, id, index, _len, _ref2;
      childId = child.getModel().getServerId();
      _ref2 = this._model.getSnapshotContent();
      for (index = 0, _len = _ref2.length; index < _len; index++) {
        block = _ref2[index];
        id = block[ModelField.PARAMS][ParamsField.ID];
        if (childId === id) return index;
      }
      return null;
    };

    BlipViewModelBase.prototype.getNextUnread = function(startIndex) {
      var block, blockType, child, content, i, id, params, unread, _ref2;
      if (!this.__view.isRead()) return this;
      content = this._model.getSnapshotContent();
      if (startIndex > content.length) return null;
      for (i = startIndex, _ref2 = content.length; startIndex <= _ref2 ? i < _ref2 : i > _ref2; startIndex <= _ref2 ? i++ : i--) {
        block = content[i];
        params = block[ModelField.PARAMS];
        blockType = params[ParamsField.TYPE];
        if (blockType !== ModelType.BLIP) continue;
        id = params[ParamsField.ID];
        child = this.__view.getChildBlipByServerId(id);
        if (!child) continue;
        if (!child.getView().isRead()) return child;
        unread = child.getNextUnread(0);
        if (unread) return unread;
      }
      return null;
    };

    BlipViewModelBase.prototype.getCursorIndex = function() {
      var block, contentIndex, editor, index, length, _len, _ref2;
      editor = this.__view.getEditor();
      if (!editor) return null;
      contentIndex = editor.getCurrentIndex();
      if (contentIndex == null) return null;
      length = 0;
      _ref2 = this._model.getSnapshotContent();
      for (index = 0, _len = _ref2.length; index < _len; index++) {
        block = _ref2[index];
        length += block.t.length;
        if (length >= contentIndex) return index;
      }
      return null;
    };

    BlipViewModelBase.prototype.markAsReadRecursively = function() {
      var child, childBlips, id;
      childBlips = this.__view.getChildBlips();
      for (id in childBlips) {
        child = childBlips[id];
        child.markAsReadRecursively();
      }
      if (!this.__view.isRead()) return this.__view.setReadState(true, false);
    };

    return BlipViewModelBase;

  })();

  MicroEvent.mixin(BlipViewModelBase);

  module.exports = BlipViewModelBase;

}).call(this);

});

require.define("/lib/client/client/blip/model.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipModel, COMMENT_PERMISSION, EDIT_PERMISSION, ModelField, ModelType, ParamsField, READ_PERMISSION,
    __slice = Array.prototype.slice;

  ModelField = require('../editor/model').ModelField;

  ParamsField = require('../editor/model').ParamsField;

  ModelType = require('../editor/model').ModelType;

  EDIT_PERMISSION = 'edit';

  COMMENT_PERMISSION = 'comment';

  READ_PERMISSION = 'read';

  BlipModel = (function() {

    function BlipModel() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._init.apply(this, args);
    }

    BlipModel.prototype._init = function(_doc, waveId, isRead, title) {
      this._doc = _doc;
      this.isRead = isRead;
      this.title = title;
      /*
              @param title: заголовок блипа сервер передает только для корневого блипа
      */
      this.id = this._doc.name;
      this.serverId = this._doc.serverId;
      this.waveId = waveId;
      return this._childBlips = {};
    };

    BlipModel.prototype.submitOps = function(ops) {
      /*
              Отправляет операции пользователя на сервер
              @param ops: [ShareJS operation]
      */      return this._doc.submitOp(ops);
    };

    BlipModel.prototype.isFoldedByDefault = function() {
      /*
              Возвращает true, если блип нужно по умолчанию показывать свернутым
              @return: boolean
      */      return this._doc.snapshot.isFoldedByDefault;
    };

    BlipModel.prototype.setIsFoldedByDefault = function(value) {
      /*
              Устанавливает значение флага isFoldedByDefault
              @param value: boolean
      */
      var op;
      if (value === this.isFoldedByDefault()) return;
      op = {
        p: ['isFoldedByDefault'],
        od: this.isFoldedByDefault(),
        oi: value
      };
      return this._doc.submitOp([op]);
    };

    BlipModel.prototype.getVersion = function() {
      return this._doc.version;
    };

    BlipModel.prototype.getSnapshotContent = function() {
      return this._doc.snapshot.content;
    };

    BlipModel.prototype.getContributors = function() {
      return this._doc.snapshot.contributors;
    };

    BlipModel.prototype.getChildBlipsPositions = function() {
      /*
              Возвращает позиции дочерних блипов
              @return: object {blipId: pos}
      */
      var block, id, pos, res, _i, _len, _ref;
      pos = 0;
      res = {};
      _ref = this.getSnapshotContent();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        block = _ref[_i];
        if (block[ModelField.PARAMS][ParamsField.TYPE] === ModelType.BLIP) {
          id = block[ModelField.PARAMS][ParamsField.ID];
          res[id] = pos;
        }
        pos += block[ModelField.TEXT].length;
      }
      return res;
    };

    BlipModel.prototype.onChange = function(callback) {
      /*
      */      return this._doc.on('change', callback);
    };

    BlipModel.prototype.getMessageInfo = function() {
      var _ref;
      return (_ref = this._doc.snapshot.pluginData) != null ? _ref.message : void 0;
    };

    BlipModel.prototype.getServerId = function() {
      return this._doc.serverId;
    };

    BlipModel.prototype.getId = function() {
      return this._doc.name;
    };

    BlipModel.prototype._getBlockText = function(block) {
      switch (block[ModelField.PARAMS][ParamsField.TYPE]) {
        case ModelType.TEXT:
          return block[ModelField.TEXT];
        case ModelType.TAG:
          return '#' + block[ModelField.PARAMS][ParamsField.TAG];
        case ModelType.LINE:
          return ' ';
        default:
          return '';
      }
    };

    BlipModel.prototype._getLinesText = function(from, to) {
      var block, lineNumber, res, _i, _len, _ref;
      lineNumber = -1;
      res = '';
      _ref = this._doc.snapshot.content;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        block = _ref[_i];
        if (block[ModelField.PARAMS][ParamsField.TYPE] === ModelType.LINE) {
          lineNumber++;
        }
        if (lineNumber > to) break;
        if (lineNumber >= from) res += this._getBlockText(block);
      }
      return res;
    };

    BlipModel.prototype.getTitle = function() {
      return this._getLinesText(0, 0);
    };

    BlipModel.prototype.getSnippet = function() {
      return this._getLinesText(1).slice(0, 101);
    };

    BlipModel.prototype.getAuthorId = function() {
      return this._doc.snapshot.contributors[0].id;
    };

    BlipModel.prototype.getChildBlips = function() {
      return this._childBlips;
    };

    BlipModel.prototype.destroy = function() {
      return delete this._childBlips;
    };

    return BlipModel;

  })();

  module.exports = {
    BlipModel: BlipModel,
    EDIT_PERMISSION: EDIT_PERMISSION,
    COMMENT_PERMISSION: COMMENT_PERMISSION,
    READ_PERMISSION: READ_PERMISSION
  };

}).call(this);

});

require.define("/lib/client/client/blip/view.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var Author, BlipEventInteractor, BlipThread, BlipView, BlipViewBase, BrowserEvents, BrowserSupport, COMMENT_PERMISSION, Contributors, DOM, EDIT_PERMISSION, EDIT_TOPIC_MODE, Editor, LocalStorage, MicroEvent, ModelField, ModelType, ParamsField, READ_PERMISSION, READ_TOPIC_MODE, ROLE_COMMENTATOR, ROLE_EDITOR, ROLE_OWNER, RangeMenu, Recipient, RecipientInput, TaskRecipient, TaskRecipientInput, async, escapeHTML, formatDate, getGadgetLinkEditor, renderBlip, trackParticipantAddition, _ref, _ref2, _ref3, _ref4,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __indexOf = Array.prototype.indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = Array.prototype.slice;

  BlipViewBase = require('./view_base');

  _ref = require('./model'), EDIT_PERMISSION = _ref.EDIT_PERMISSION, COMMENT_PERMISSION = _ref.COMMENT_PERMISSION, READ_PERMISSION = _ref.READ_PERMISSION;

  _ref2 = require('../editor/model'), ModelType = _ref2.ModelType, ModelField = _ref2.ModelField, ParamsField = _ref2.ParamsField;

  Editor = require('../editor/editor_v2').Editor;

  getGadgetLinkEditor = require('../editor/gadget/gadget_link_editor').get;

  _ref3 = require('../wave/participants/constants'), ROLE_OWNER = _ref3.ROLE_OWNER, ROLE_EDITOR = _ref3.ROLE_EDITOR, ROLE_COMMENTATOR = _ref3.ROLE_COMMENTATOR;

  Contributors = require('./contributors').Contributors;

  Author = require('./contributors/author').Author;

  TaskRecipient = require('./task_recipient').TaskRecipient;

  TaskRecipientInput = require('./task_recipient/input').TaskRecipientInput;

  _ref4 = require('./recipient'), Recipient = _ref4.Recipient, RecipientInput = _ref4.RecipientInput;

  renderBlip = require('./template').renderBlip;

  RangeMenu = require('./menu/range_menu');

  BlipThread = require('./blip_thread').BlipThread;

  DOM = require('../utils/dom');

  MicroEvent = require('../utils/microevent');

  escapeHTML = require('../utils/string').escapeHTML;

  formatDate = require('../../share/utils/datetime').formatDate;

  BrowserEvents = require('../utils/browser_events');

  LocalStorage = require('../utils/localStorage').LocalStorage;

  BrowserSupport = require('../utils/browser_support');

  async = require('async');

  trackParticipantAddition = require('../wave/participants/utils').trackParticipantAddition;

  BlipEventInteractor = require('./interactor').BlipEventInteractor;

  READ_TOPIC_MODE = 'read_topic_mode';

  EDIT_TOPIC_MODE = 'edit_topic_mode';

  BlipView = (function(_super) {
    var FROM_BOTTOM_BLIP_BORDER, MENU_TOP_OFFSET;

    __extends(BlipView, _super);

    /*
        Класс для отображения одного сообщения в документе
    */

    function BlipView(_waveViewModel, _blipProcessor, _blipViewModel, _model, _ts, _blipContainer, _parent, isRead) {
      this._waveViewModel = _waveViewModel;
      this._blipProcessor = _blipProcessor;
      this._blipViewModel = _blipViewModel;
      this._model = _model;
      this._ts = _ts;
      this._blipContainer = _blipContainer;
      this._parent = _parent;
      this.unmarkActive = __bind(this.unmarkActive, this);
      this.markActive = __bind(this.markActive, this);
      this._getTaskRecipient = __bind(this._getTaskRecipient, this);
      this._updateTaskSearchInfo = __bind(this._updateTaskSearchInfo, this);
      this._getTaskRecipientInput = __bind(this._getTaskRecipientInput, this);
      this._getRecipientInput = __bind(this._getRecipientInput, this);
      this._getRecipient = __bind(this._getRecipient, this);
      this._removeInlineBlip = __bind(this._removeInlineBlip, this);
      this._addInlineBlip = __bind(this._addInlineBlip, this);
      this._processEditorChanges = __bind(this._processEditorChanges, this);
      this._usersInfoUpdateHandler = __bind(this._usersInfoUpdateHandler, this);
      this._processFocusOutEvent = __bind(this._processFocusOutEvent, this);
      this._processFocusInEvent = __bind(this._processFocusInEvent, this);
      this._getPermission = __bind(this._getPermission, this);
      this._getContent = __bind(this._getContent, this);
      this._sendTasks = __bind(this._sendTasks, this);
      this._sendMessages = __bind(this._sendMessages, this);
      this._addTaskRecipient = __bind(this._addTaskRecipient, this);
      this._insertRecipientByEmail = __bind(this._insertRecipientByEmail, this);
      /*
              Создает объект для отображения блипа
              @param _waveViewModel: WaveViewModel
              @param _blipProcessor: BlipProcessor
              @param _model: BlipModel
              @param snapshot: текущий снимок блипа
              @param ts: время последнего редактирования
              @param _blipContainer: HTMLNode, нода, в которой отображаться блипу
              @param _parent: BlipView, родитель, нужен для кнопки "удалить"
              @param isRead: boolean
      */
      BlipView.__super__.constructor.call(this);
      this.__blipContainer = this._blipContainer;
      this.__model = this._model;
      this._blipContainer['__rizzoma_id'] = this._model.id;
      this._requestedBlips = {};
      this._childBlips = this._model._childBlips;
      this._init(isRead);
      this._messagesProcessor = require('../search_panel/mention/processor').instance;
      this._tasksProcessor = require('../search_panel/task/processor').instance;
      if (this.isRoot()) this._addRootBlipClasses();
      this._canEdit = BrowserSupport.isSupported() && !this._isAnonymous;
    }

    BlipView.prototype._addRootBlipClasses = function() {
      DOM.addClass(this._blipContainer, 'root-blip');
      DOM.addClass(this._blipContainer, 'increase-first-line');
      return DOM.addClass(this._blipContainer, 'with-reserved-menu-space');
    };

    BlipView.prototype._init = function(isRead) {
      /*
              Инициализирует объект
      */
      var blipThread, _ref5;
      this._rendered = false;
      this.__isNotInRootThread = ((_ref5 = this._parent) != null ? _ref5.getParent() : void 0) != null;
      if (!this._parent) {
        this._render();
      } else {
        this.__unreadIndicatorHidden = true;
        blipThread = BlipThread.getBlipThread(this._blipContainer);
        if (blipThread) {
          if (this.isRoot()) blipThread.setAsRoot();
          this.__initFold();
        } else {
          this._blipContainer.addEventListener(BrowserEvents.C_BLIP_INSERT_EVENT, this.__initFold, false);
        }
        $(this._blipContainer).on('focusin', this._processFocusInEvent).on('focusout', this._processFocusOutEvent);
        if (isRead != null) {
          this._focused = false;
          if (isRead) {
            this._markAsRead();
          } else {
            this._markAsUnread();
          }
        } else {
          this._focused = true;
        }
        this._initChildBlips(this._model.getSnapshotContent());
      }
      return this._waveViewModel.on('usersInfoUpdate', this._usersInfoUpdateHandler);
    };

    BlipView.prototype._render = function() {
      var _this = this;
      if (this._rendered) return;
      this._rendered = true;
      this._createDOM(this._ts);
      if (this._parent) {
        this._initBlipInfo(this._model.getContributors());
        this.__initUnreadIndicator();
      }
      this._blipContainer.addEventListener(BrowserEvents.DRAG_OVER_EVENT, this._preventDragDropEvent, false);
      $(this._blipContainer).find('.js-finish-edit').click(function() {
        return _this._setEditable(false, true);
      });
      this._initEditor(this._model.getSnapshotContent());
      this._initBlipEventsInteractor();
      this._setPermission();
      this._setEditable(this._waveViewModel.getView().isEditMode(), false);
      return this.updateReadState();
    };

    BlipView.prototype._initBlipEventsInteractor = function() {
      return this._interactor = new BlipEventInteractor(this._blipViewModel, this);
    };

    BlipView.prototype.renderRecursively = function() {
      var blip, blipId, _ref5, _results;
      this._render();
      _ref5 = this._childBlips;
      _results = [];
      for (blipId in _ref5) {
        blip = _ref5[blipId];
        _results.push(blip.getView().renderRecursively());
      }
      return _results;
    };

    BlipView.prototype.renderRecursivelyToRoot = function() {
      if (this._rendered) return;
      this._parent.renderRecursivelyToRoot();
      return this._render();
    };

    BlipView.prototype._initChildBlips = function(content) {
      var block, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = content.length; _i < _len; _i++) {
        block = content[_i];
        if (block[ModelField.PARAMS][ParamsField.TYPE] !== ModelType.BLIP) {
          continue;
        }
        _results.push(this._addInlineBlip(block[ModelField.PARAMS][ParamsField.ID]));
      }
      return _results;
    };

    BlipView.prototype._initBlipInfo = function(contributors) {
      /*
              Инициализирует элемент, отвечающий за информацию о блипе
      */
      var $shownContributorContainer, author, authors, c;
      c = $(this._blipContainer);
      $shownContributorContainer = c.find('.js-shown-contributor');
      authors = [contributors[0].id];
      if (contributors.length > 1) authors.push(contributors[1].id);
      author = new Author(this._waveViewModel, authors);
      this._contributors = new Contributors(this._waveViewModel, contributors, author);
      $shownContributorContainer.append(author.getContainer());
      return c.find('.js-blip-info-container').append(this._contributors.getContainer());
    };

    BlipView.prototype._attachMenu = function() {
      var lastSender, lastSent, params, _ref5,
        _this = this;
      _ref5 = this._getLastSentParams(), lastSent = _ref5[0], lastSender = _ref5[1];
      params = {
        canEdit: this._hasEditPermission(),
        foldable: this._hasChildBlips(),
        foldedByDefault: this._model.isFoldedByDefault(),
        sendable: this._hasRecipients(),
        lastSent: lastSent,
        lastSender: lastSender,
        isRoot: this.isRoot(),
        handlers: {
          hasServerId: this._model.serverId != null
        }
      };
      this._interactor.attachMenu(this._waveViewModel.getBlipMenu(), this._menuContainer, params);
      return this._onServerId(function() {
        var _ref6;
        return (_ref6 = _this._interactor) != null ? _ref6.enableIdDependantButtons() : void 0;
      });
    };

    BlipView.prototype._detachMenu = function() {
      return this._interactor.detachMenu();
    };

    BlipView.prototype._getLastSentParams = function() {
      var curLastSent, data, lastSender, lastSenderId, lastSent, message, recipient, _i, _len, _ref5;
      lastSent = 0;
      message = this._blipViewModel.getModel().getMessageInfo();
      if (message) {
        lastSent = message.lastSent;
        lastSenderId = message.lastSenderId;
      }
      if (!this._editor) return [null, null];
      _ref5 = this._editor.getTaskRecipients();
      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
        recipient = _ref5[_i];
        data = recipient.getData();
        curLastSent = data.lastSent;
        if (!curLastSent) continue;
        if (curLastSent < lastSent) continue;
        lastSent = curLastSent;
        lastSenderId = data.lastSenderId;
      }
      lastSender = null;
      if (lastSent && lastSenderId) {
        lastSender = this._blipViewModel.getWaveViewModel().getUser(lastSenderId).getName();
      }
      return [lastSent, lastSender];
    };

    BlipView.prototype._setReplyButtonHandler = function() {
      var _this = this;
      this._replyButton = $(this._blipContainer).find('.js-blip-reply-button')[0];
      return $(this._replyButton).on('click', function() {
        _gaq.push(['_trackEvent', 'Blip usage', 'Insert reply', 'Re in bottom blip menu']);
        return _this.insertReplyBlip();
      });
    };

    BlipView.prototype.insertReplyBlip = function() {
      var blipViewModel;
      return blipViewModel = this._parent.initInsertInlineBlip(true, {}, BlipThread.getBlipThread(this._blipContainer));
    };

    BlipView.prototype._onServerId = function(callback) {
      /*
              Вызывает callback, когда у текущего блипа появится serverId. Вызывает сразу, если serverId уже есть.
      */      if (this._model.serverId) return callback();
      return this._blipViewModel.on('set-server-id', callback);
    };

    BlipView.prototype._insertRecipientByEmail = function(position, email, callback) {
      var _this = this;
      return this._onServerId(function() {
        return _this._messagesProcessor.addRecipientByEmail(_this._model.serverId, _this._model.getVersion(), position, email, function(err, user) {
          var message;
          callback();
          if (err) {
            message = "Could not add recipient " + email;
            if (err.logId) message += ": " + err.logId;
            _this._waveViewModel.showWarning(message);
            return console.error(err);
          }
          trackParticipantAddition('By mention', user);
          return _this._waveViewModel.updateUserInfo(user);
        });
      });
    };

    BlipView.prototype._addTaskRecipient = function(params, callback) {
      var _this = this;
      return this._onServerId(function() {
        params.blipId = _this._model.serverId;
        params.version = _this._model.getVersion();
        return _this._tasksProcessor.assign(params, function(err, user) {
          var message;
          callback();
          if (err) {
            message = "Could not add task recipient " + params.recipientEmail;
            if (err.logId) message += ": " + err.logId;
            _this._waveViewModel.showWarning(message);
            return console.error(err);
          }
          trackParticipantAddition('By task', user);
          return _this._waveViewModel.updateUserInfo(user);
        });
      });
    };

    BlipView.prototype._initEditor = function(content) {
      /*
              Инициализирует редактор содержимого блипа
      */
      var c, editorContainer, functions, lightBoxId,
        _this = this;
      c = $(this._blipContainer);
      this._editorNode = c.find('.js-editor-container')[0];
      lightBoxId = escapeHTML(this._model.id);
      functions = {
        getChildBlip: function(id) {
          return _this._childBlips[id];
        },
        getSnapshot: this._getContent,
        addInlineBlip: this._addInlineBlip,
        removeInlineBlip: this._removeInlineBlip,
        getRecipientInput: this._getRecipientInput,
        getRecipient: this._getRecipient,
        addRecipientByEmail: this._insertRecipientByEmail,
        getTaskRecipientInput: this._getTaskRecipientInput,
        getTaskRecipient: this._getTaskRecipient,
        addTaskRecipient: this._addTaskRecipient,
        getNewChildBlip: function(insertInBlip, params, thread) {
          return _this.initInsertInlineBlip(insertInBlip, params, thread);
        },
        getScrollableElement: function() {
          var _ref5, _ref6;
          return (_ref5 = _this._waveViewModel) != null ? (_ref6 = _ref5.getView()) != null ? _ref6.getScrollableElement() : void 0 : void 0;
        }
      };
      this._editor = new Editor(lightBoxId, {}, functions, false);
      this._editor.on('ops', this._processEditorChanges);
      this._editor.on('error', function(e) {
        _this._editor.setEditable(false);
        _this._editor.removeListener('ops', _this._processEditorChanges);
        return _this._blipProcessor.showPageError(e);
      });
      this._editor.on('copy', function() {
        return _this.renderRecursively();
      });
      this._editor.initContent();
      editorContainer = this._editor.getContainer();
      this._editorNode.appendChild(editorContainer);
      if (!this._parent) {
        return DOM.addClass(editorContainer, 'container-blip-editor');
      }
    };

    BlipView.prototype.updateLastSent = function() {
      var lastSender, lastSent, _ref5, _ref6;
      _ref5 = this._getLastSentParams(), lastSent = _ref5[0], lastSender = _ref5[1];
      return (_ref6 = this._interactor) != null ? _ref6.setLastSent(lastSent, lastSender) : void 0;
    };

    FROM_BOTTOM_BLIP_BORDER = 65;

    MENU_TOP_OFFSET = 19;

    BlipView.prototype._resetMenuPosition = function() {
      var _ref5;
      DOM.removeClass(this._menuContainer, 'fixed');
      return (_ref5 = this._menuContainer) != null ? _ref5.removeAttribute('style', 0) : void 0;
    };

    BlipView.prototype.updateMenuLeftPosition = function() {
      var $menuContainer;
      if (this.isRoot()) return;
      $menuContainer = $(this._menuContainer);
      if (!$menuContainer.hasClass('fixed')) return;
      return $menuContainer.css('left', "" + (this.getContainer().getBoundingClientRect().left) + "px");
    };

    BlipView.prototype.updateMenuPosition = function() {
      var $menuContainer, blipOffsetTop, cancelMenuScrollChanges, containerRect, css, leftOffsetCorrection, scrollTop, scrollable, scrollableOffsetTop, _ref5, _ref6;
      if (this.isRoot()) return;
      containerRect = this.getContainer().getBoundingClientRect();
      scrollable = (_ref5 = this._waveViewModel) != null ? (_ref6 = _ref5.getView()) != null ? _ref6.getScrollableElement() : void 0 : void 0;
      if (!scrollable) return;
      scrollableOffsetTop = scrollable.offsetTop;
      blipOffsetTop = containerRect.top - scrollableOffsetTop;
      scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      $menuContainer = $(this._menuContainer);
      if (blipOffsetTop > MENU_TOP_OFFSET) return this._resetMenuPosition();
      cancelMenuScrollChanges = containerRect.bottom - scrollableOffsetTop < 0 || containerRect.bottom - scrollableOffsetTop < FROM_BOTTOM_BLIP_BORDER;
      if (cancelMenuScrollChanges) return this._resetMenuPosition();
      css = {};
      $menuContainer.addClass('fixed');
      if (!this.__isNotInRootThread) {
        leftOffsetCorrection = 32;
      } else {
        leftOffsetCorrection = 0;
      }
      css.left = containerRect.left + leftOffsetCorrection;
      css.top = scrollTop ? Math.max(scrollableOffsetTop - scrollTop, 0) : '';
      return $menuContainer.css(css);
    };

    BlipView.prototype._handleSend = function(callback) {
      if (!this._model.serverId) return callback();
      return async.parallel([this._sendMessages, this._sendTasks], function(err) {
        return callback(err);
      });
    };

    BlipView.prototype._sendMessages = function(callback) {
      var isFirstSend, _ref5,
        _this = this;
      if (!this._editor.getRecipients().length) return callback(null);
      isFirstSend = !(((_ref5 = this._model.getMessageInfo()) != null ? _ref5.lastSent : void 0) != null);
      return this._messagesProcessor.send(this._model.serverId, function(error, message) {
        var eventLabel, id, recipient, recipients, sendError, _i, _len;
        if (error) return callback(error);
        recipients = _this._editor.getRecipients();
        for (_i = 0, _len = recipients.length; _i < _len; _i++) {
          recipient = recipients[_i];
          id = recipient.getId();
          if (message != null ? message.hasOwnProperty(id) : void 0) {
            recipient.markAsInvalid(message[id].message);
            sendError = true;
          } else {
            if (!id) continue;
            recipient.render();
          }
        }
        if (sendError) {
          error = new Error('Not all recipients were sent');
          error.explanation = "Error while sending " + (formatDate(Date.now() / 1000));
          return callback(error);
        }
        eventLabel = isFirstSend ? 'First time' : 'Again';
        _gaq.push(['_trackEvent', 'Mention', 'Mention sending', eventLabel, recipients.length]);
        return callback(null);
      });
    };

    BlipView.prototype._sendTasks = function(callback) {
      var isFirstSend, _ref5,
        _this = this;
      if (!this._editor.getTaskRecipients().length) return callback(null);
      isFirstSend = !(((_ref5 = this._model.getMessageInfo()) != null ? _ref5.lastSent : void 0) != null);
      return this._tasksProcessor.send(this._model.serverId, function(error, message) {
        var eventLabel, id, recipient, recipients, sendError, _i, _len;
        if (error) return callback(error);
        recipients = _this._editor.getTaskRecipients();
        for (_i = 0, _len = recipients.length; _i < _len; _i++) {
          recipient = recipients[_i];
          id = recipient.getRecipientId();
          if (message != null ? message.hasOwnProperty(id) : void 0) {
            recipient.markAsInvalid(message[id].message);
            sendError = true;
          } else {
            if (!id) continue;
            recipient.markAsValid();
          }
        }
        if (sendError) {
          error = new Error('Not all tasks were sent');
          error.explanation = "Error while sending " + (formatDate(Date.now() / 1000));
          return callback(error);
        }
        eventLabel = isFirstSend ? 'First time' : 'Again';
        _gaq.push(['_trackEvent', 'Task', 'Task sending', eventLabel, recipients.length]);
        return callback(null);
      });
    };

    BlipView.prototype._getContent = function() {
      return this._model.getSnapshotContent();
    };

    BlipView.prototype._createDOM = function(ts) {
      /*
              Создает все необходимые для отображения сообщения DOM-ноды
      */
      var c, params;
      c = $(this._blipContainer);
      params = {
        isNotInRootThread: this.__isNotInRootThread,
        isRoot: !this._parent,
        datetime: formatDate(ts),
        fullDatetime: formatDate(ts, true),
        isAnonymous: !window.loggedIn
      };
      c.addClass('blip-container');
      if (!this._parent) {
        c.prepend(renderBlip(params));
      } else {
        c.append(renderBlip(params));
      }
      this._editorNode = c.find('.js-editor-container')[0];
      if (this.isRoot()) {
        this._menuContainer = $(this._waveViewModel.getView().container).find('.js-wave-panel')[0];
      } else {
        this._menuContainer = c.find('.js-blip-menu-container')[0] || null;
      }
      return this._setReplyButtonHandler();
    };

    BlipView.prototype.recursivelyUpdatePermission = function() {
      var blip, _, _ref5, _results;
      this._updatePermission();
      _ref5 = this._childBlips;
      _results = [];
      for (_ in _ref5) {
        blip = _ref5[_];
        _results.push(blip.getView().recursivelyUpdatePermission());
      }
      return _results;
    };

    BlipView.prototype._getPermission = function() {
      var permission, role, _ref5, _ref6;
      role = (_ref5 = this._waveViewModel) != null ? _ref5.getRole() : void 0;
      switch (role) {
        case ROLE_OWNER:
          permission = EDIT_PERMISSION;
          break;
        case ROLE_EDITOR:
          permission = EDIT_PERMISSION;
          break;
        case ROLE_COMMENTATOR:
          if (_ref6 = this._model.getAuthorId(), __indexOf.call(window.userInfo.mergedIds, _ref6) >= 0) {
            permission = EDIT_PERMISSION;
          } else {
            permission = COMMENT_PERMISSION;
          }
          break;
        default:
          permission = READ_PERMISSION;
      }
      return permission;
    };

    BlipView.prototype._hasEditPermission = function() {
      return this._getPermission() === EDIT_PERMISSION;
    };

    BlipView.prototype._setPermission = function() {
      var hasEditPermission, _ref5;
      this._permission = this._getPermission();
      if (!this._rendered) return;
      this._editor.setPermission(this._permission);
      if (hasEditPermission = this._hasEditPermission()) {
        $(this._blipContainer).removeClass('non-editable');
      } else {
        $(this._blipContainer).addClass('non-editable');
      }
      return (_ref5 = this._interactor) != null ? _ref5.setCanEdit(hasEditPermission) : void 0;
    };

    BlipView.prototype._updatePermission = function() {
      this._setPermission();
      return this._setEditable(this._editable, false);
    };

    BlipView.prototype._setModeStyle = function(editable) {
      var funcName;
      funcName = editable ? 'addClass' : 'removeClass';
      if (this.isRoot()) {
        return $(this._waveViewModel.getView().getContainer()).find('.js-wave-panel')[funcName]('edit-mode');
      } else {
        return $(this._blipContainer)[funcName]('edit-mode');
      }
    };

    BlipView.prototype._setEditable = function(editable, updateGlobally) {
      if (!this._parent || !this._editor) return this._editable = false;
      if (editable && this._hasEditPermission() && this._canEdit) {
        this._interactor.setEditableMode(true);
        this._updateUndoRedoState();
        RangeMenu.get().hide();
        this._setModeStyle(true);
        this._editable = true;
      } else {
        this._interactor.setEditableMode(false);
        this._setModeStyle(false);
        this._editable = false;
      }
      this._editor.setEditable(this._editable);
      if (!updateGlobally) return;
      if (this._editable) {
        return this._waveViewModel.getView().setEditModeEnabled(true);
      } else {
        return this._waveViewModel.getView().setEditModeEnabled(false);
      }
    };

    BlipView.prototype.getPermission = function() {
      return this._permission;
    };

    BlipView.prototype._processFocusInEvent = function(event) {
      this._focused = true;
      this.setReadState(true);
      return event.stopPropagation();
    };

    BlipView.prototype._processFocusOutEvent = function(event) {
      this._focused = false;
      this.setReadState(true);
      return event.stopPropagation();
    };

    BlipView.prototype.addChildToUnreads = function(id) {
      var blipThread, _ref5;
      blipThread = BlipThread.getBlipThread(this._blipContainer);
      if (blipThread != null ? blipThread.blipIsUnread(id) : void 0) return;
      if (blipThread != null) blipThread.setUnreadBlip(id);
      return (_ref5 = this._parent) != null ? _ref5.addChildToUnreads(id) : void 0;
    };

    BlipView.prototype.removeChildFromUnreads = function(id) {
      var blipThread, _ref5;
      blipThread = BlipThread.getBlipThread(this._blipContainer);
      if (blipThread && (!blipThread.blipIsUnread(id))) return;
      if (blipThread != null) blipThread.removeUnreadBlip(id);
      return (_ref5 = this._parent) != null ? _ref5.removeChildFromUnreads(id) : void 0;
    };

    BlipView.prototype._markAsRead = function() {
      this.__hideUnreadIndicator();
      this._model.isRead = true;
      if (this._model.serverId) {
        return this._waveViewModel.setBlipAsRead(this._model.serverId);
      }
    };

    BlipView.prototype.markAsRead = function() {
      return this._markAsRead();
    };

    BlipView.prototype._markAsUnread = function() {
      this.__showUnreadIndicator();
      this._model.isRead = false;
      if (this._model.serverId) {
        return this._waveViewModel.setBlipAsUnread(this._model.serverId);
      }
    };

    BlipView.prototype.markAsUnread = function() {
      return this._markAsUnread();
    };

    BlipView.prototype.setReadState = function(isRead, sendToServer) {
      var params;
      if (sendToServer == null) sendToServer = true;
      if (isRead === this._model.isRead) return;
      if (!this._model.serverId) {
        if (isRead) {
          this._markAsRead();
        } else {
          this._markAsUnread();
        }
        return;
      }
      if (isRead) {
        this._waveViewModel.setBlipAsRead(this._model.serverId);
      } else {
        this._waveViewModel.setBlipAsUnread(this._model.serverId);
      }
      params = {
        waveId: this._waveViewModel.getServerId(),
        blipId: this._model.serverId,
        unreadBlipsCount: this._waveViewModel.getUnreadBlipsCount(),
        totalBlipsCount: this._waveViewModel.getTotalUsableBlipsCount(),
        isRead: isRead
      };
      LocalStorage.updateBlipReadState(params);
      if (isRead && sendToServer) {
        this._blipProcessor.updateBlipReader(this._blipViewModel);
        return this._waveViewModel.checkBlipSetAsRead(this._model.serverId);
      }
    };

    BlipView.prototype._usersInfoUpdateHandler = function(userIds) {
      /*
              Обработчик события обновления информации о пользователях
      */
      var lastSenderId, _ref5;
      lastSenderId = (_ref5 = this._model.getMessageInfo()) != null ? _ref5.lastSenderId : void 0;
      if (lastSenderId && $.inArray(lastSenderId, userIds)) {
        return this.updateLastSent();
      }
    };

    BlipView.prototype.initInsertInlineBlip = function(insertIntoEditor, params, thread) {
      var blipThread, blipViewModel, container,
        _this = this;
      if (insertIntoEditor == null) insertIntoEditor = true;
      if (params == null) params = {};
      if (thread == null) thread = null;
      /*
              Начинает вставку вложенного сообщения
              @param insertToEnd: boolean, нужно ли вставить дочерний блип в конец
              @return: blipViewModel
      */
      container = this._getChildBlipContainer();
      if (!this._waveViewModel.getView().isEditMode()) {
        this._waveViewModel.getView().setEditModeEnabled(true);
      }
      blipViewModel = require('./processor').instance.createBlip(this._waveViewModel, container, params, this._blipViewModel);
      if (insertIntoEditor) {
        if (thread) {
          thread.appendBlipElement(container);
        } else {
          blipThread = new BlipThread("" + (Math.random()), container);
          blipThread.unfold();
          this._editor.insertNodeAtCurrentPosition(blipThread.getContainer());
        }
      }
      this._childBlips[blipViewModel.getModel().id] = blipViewModel;
      blipViewModel.on('set-server-id', function(serverId) {
        if (!_this._editor.insertBlip(serverId, container, (thread || blipThread).getId(), !!thread)) {
          return blipViewModel.destroy();
        }
      });
      blipViewModel.getView().renderRecursively();
      blipViewModel.getView().focus();
      window.setTimeout(function() {
        return _this._waveViewModel.getView().runCheckRange();
      }, 0);
      this._updateChildBlipsCounter();
      return blipViewModel;
    };

    BlipView.prototype.initInsertImage = function() {
      return getUploadForm().open(this._editor, true);
    };

    BlipView.prototype.initInsertFile = function() {
      return getUploadForm().open(this._editor, false);
    };

    BlipView.prototype.initLinkManagement = function() {
      /*
              Вызывает редактор ссылок для указанного диапазона
      */
      var _ref5;
      return (_ref5 = this._editor) != null ? _ref5.openLinkEditor() : void 0;
    };

    BlipView.prototype.initInsertGadget = function() {
      /*
              Вызывает редактор ссылки для гаджета
      */      return getGadgetLinkEditor().open(this._editor);
    };

    BlipView.prototype._processEditorChanges = function(ops) {
      this.submitOps(ops);
      this._updateUndoRedoState();
      try {
        return this._onEditorUpdate();
      } catch (err) {
        return console.warn(err);
      }
    };

    BlipView.prototype._getChildBlipContainer = function() {
      var res;
      res = document.createElement('span');
      res.contentEditable = 'false';
      return res;
    };

    BlipView.prototype._addInlineBlip = function(serverBlipId) {
      /*
              Добавляет вложенный в текущий блип
              @param serverBlipId: string
              @return: HTMLElement, контейнер вставки
      */
      var childBlip, childBlipId, container,
        _this = this;
      container = this._getChildBlipContainer();
      childBlipId = this._getChildBlipId(serverBlipId);
      if (childBlipId) {
        childBlip = this._childBlips[childBlipId];
        return childBlip.getView().getContainer();
      }
      if (this._requestedBlips[serverBlipId]) {
        return this._requestedBlips[serverBlipId];
      }
      this._requestedBlips[serverBlipId] = container;
      this._newChildBlip(serverBlipId, container, function(err, blipViewModel) {
        if (!(_this._requestedBlips[serverBlipId] != null)) return;
        if (err) return _this._blipProcessor.showPageError(err);
        delete _this._requestedBlips[serverBlipId];
        if (_this._childBlips != null) {
          _this._childBlips[blipViewModel.getModel().id] = blipViewModel;
          return _this._updateChildBlipsCounter();
        } else {
          return blipViewModel.close();
        }
      });
      return container;
    };

    BlipView.prototype._getChildBlipId = function(serverBlipId) {
      /*
              Возвращает идентификатор вложенного блипа по серверному id
              @param serverBlipId: string
              @return: string|null
      */
      var blip, blipId, _ref5;
      _ref5 = this._childBlips;
      for (blipId in _ref5) {
        blip = _ref5[blipId];
        if (blip.getModel().serverId === serverBlipId) return blipId;
      }
      return null;
    };

    BlipView.prototype._removeInlineBlip = function(serverBlipId) {
      /*
              Удаляет вложенный в текущий блип
              @param blipId: string
      */
      var blipId, childBlip, childContainer, childThread, secondBlipId, _ref5;
      if (this._requestedBlips[serverBlipId] != null) {
        delete this._requestedBlips[serverBlipId];
      }
      blipId = this._getChildBlipId(serverBlipId);
      if (blipId === null) return;
      childBlip = this._childBlips[blipId];
      childContainer = childBlip.getView().getContainer();
      childThread = BlipThread.getBlipThread(childContainer);
      if (childThread != null ? childThread.isFirstInThread(childContainer) : void 0) {
        secondBlipId = (_ref5 = childThread.getSecondBlipElement()) != null ? _ref5['__rizzoma_id'] : void 0;
        if (secondBlipId) {
          this._childBlips[secondBlipId].getView().setFoldedByDefault(childBlip.getModel().isFoldedByDefault());
        }
      }
      childBlip.destroy();
      delete this._childBlips[blipId];
      return this._updateChildBlipsCounter();
    };

    BlipView.prototype._getRecipient = function() {
      var args, canConvert, canDelete,
        _this = this;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      canDelete = function(id) {
        var _ref5;
        return _this._hasEditPermission() || id === ((_ref5 = window.userInfo) != null ? _ref5.id : void 0);
      };
      canConvert = function(id) {
        return _this._hasEditPermission();
      };
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return typeof result === "object" ? result : child;
      })(Recipient, [this._waveViewModel, canDelete, canConvert].concat(__slice.call(args)), function() {});
    };

    BlipView.prototype._getRecipientInput = function() {
      return new RecipientInput(this._waveViewModel);
    };

    BlipView.prototype._getTaskRecipientInput = function() {
      return new TaskRecipientInput(this._waveViewModel, this._updateTaskSearchInfo);
    };

    BlipView.prototype._updateTaskSearchInfo = function(data) {
      var info, recipient, sender;
      info = {
        waveId: this._waveViewModel.getServerId(),
        blipId: this._model.serverId,
        changed: true,
        title: this._model.getTitle(),
        snippet: this._model.getSnippet(),
        isRead: true,
        status: data.status
      };
      if ((data.deadlineDate != null) || data.deadlineDatetime) {
        info.deadline = {
          date: data.deadlineDate,
          datetime: data.deadlineDatetime
        };
      }
      if (data.recipientId != null) {
        recipient = this._waveViewModel.getUser(data.recipientId);
        info.recipientName = recipient.getName();
        info.recipientEmail = recipient.getEmail();
        info.recipientAvatar = recipient.getAvatar();
      } else {
        info.recipientEmail = data.recipientEmail;
      }
      sender = this._waveViewModel.getUser(data.senderId);
      info.senderName = sender.getName();
      info.senderEmail = sender.getEmail();
      info.senderAvatar = sender.getAvatar();
      return this._tasksProcessor.updateTaskSearchInfo(info);
    };

    BlipView.prototype._getTaskRecipient = function() {
      var args, canEditBlip,
        _this = this;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      canEditBlip = function() {
        return _this._permission === EDIT_PERMISSION;
      };
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return typeof result === "object" ? result : child;
      })(TaskRecipient, [this._waveViewModel].concat(__slice.call(args), [this._updateTaskSearchInfo], [canEditBlip]), function() {});
    };

    BlipView.prototype._hasChildBlips = function() {
      var _;
      for (_ in this._childBlips) {
        return true;
      }
      return false;
    };

    BlipView.prototype._hasRecipients = function() {
      return this._editor.hasRecipientsOrTasks();
    };

    BlipView.prototype._updateChildBlipsCounter = function() {
      var _ref5;
      return (_ref5 = this._interactor) != null ? _ref5.setFoldable(this._hasChildBlips()) : void 0;
    };

    BlipView.prototype._updateRecipientsCounter = function() {
      var _ref5;
      return (_ref5 = this._interactor) != null ? _ref5.setSendable(this._hasRecipients()) : void 0;
    };

    BlipView.prototype._onEditorUpdate = function() {
      return this._updateRecipientsCounter();
    };

    BlipView.prototype.setEditable = function(editable) {
      if (!this._canEdit) {
        return alert("You need to use the lastest version of Chrome, Firefox, Safari or Internet Explorer in order to edit");
      }
      return this._setEditable(editable, true);
    };

    BlipView.prototype.focus = function() {
      /*
              Устанавливает курсор в текущий редактор
      */
      var _ref5;
      this.setReadState(true);
      return (_ref5 = this._editor) != null ? _ref5.focus() : void 0;
    };

    BlipView.prototype.markActive = function() {
      var editMode;
      if (!this._parent) return;
      this._isActive = true;
      this._attachMenu();
      editMode = this._waveViewModel.getView().isEditMode();
      if (this.isRoot()) DOM.addClass(this._menuContainer, 'active');
      DOM.addClass(this._blipContainer, 'active');
      return this._setEditable(editMode, false);
    };

    BlipView.prototype.unmarkActive = function() {
      $(this._menuContainer).removeClass('fixed');
      if (this._waveViewModel) {
        this._isActive = false;
        if (this.isRoot()) DOM.removeClass(this._menuContainer, 'active');
        DOM.removeClass(this._blipContainer, 'active');
        this._detachMenu();
        return this._setEditable(false, false);
      }
    };

    BlipView.prototype.isActive = function() {
      return this._isActive;
    };

    BlipView.prototype.removeChild = function(id) {
      /*
              Удаляет дочерний блип
              @param id: string
      */
      var blip, _ref5;
      blip = this._childBlips[id];
      if (!blip) return;
      if (blip.getModel().serverId != null) {
        return this._editor.removeBlip(blip.getModel().serverId);
      }
      blip.destroy();
      if ((_ref5 = window.getSelection()) != null) _ref5.removeAllRanges();
      delete this._childBlips[id];
      return this._updateChildBlipsCounter();
    };

    BlipView.prototype.remove = function() {
      return this._parent.removeChild(this._model.id);
    };

    BlipView.prototype.getContainer = function() {
      return this._blipContainer;
    };

    BlipView.prototype._newChildBlip = function(serverBlipId, container, callback) {
      /*
              Создает объект вложенного блипа
              @param serverBlipId: string, идентификатор блипа
              @param container: HTMLNode, нода, в которой будет сообщение
              @param callback: function
                  callback(BlipViewModel)
      */      return require('./processor').instance.openBlip(this._waveViewModel, serverBlipId, container, this._blipViewModel, callback);
    };

    BlipView.prototype.applyisFoldedByDefaultOp = function(op) {
      var _ref5;
      return (_ref5 = this._interactor) != null ? _ref5.updateFoldedByDefault(op.oi) : void 0;
    };

    BlipView.prototype.applyParticipantOp = function(op) {
      var _ref5;
      if (!this._parent) return;
      return (_ref5 = this._contributors) != null ? _ref5.applyOp(op) : void 0;
    };

    BlipView.prototype._opSetsUnreadIndicator = function(op) {
      var blockType, param, paramName;
      if (op.paramsi || op.paramsd) {
        param = op.paramsi || op.paramsd;
        for (paramName in param) {
          if (paramName === 'lastSent' || paramName === 'lastSenderId') {
            return false;
          }
        }
      }
      if (!((op.ti != null) || (op.td != null))) return true;
      blockType = op[ModelField.PARAMS][ParamsField.TYPE];
      if (blockType === ModelType.BLIP) return false;
      if ((op.td != null) && (blockType === ModelType.RECIPIENT || blockType === ModelType.TASK_RECIPIENT)) {
        return false;
      }
      return true;
    };

    BlipView.prototype._opsSetUnreadIndicator = function(ops) {
      var op, _i, _len;
      for (_i = 0, _len = ops.length; _i < _len; _i++) {
        op = ops[_i];
        if (this._opSetsUnreadIndicator(op)) return true;
      }
    };

    BlipView.prototype._isMyMeta = function(meta) {
      var _ref5;
      if ((meta != null ? meta.user : void 0) != null) {
        if (meta.user === ((_ref5 = window.userInfo) != null ? _ref5.id : void 0)) {
          return true;
        }
      }
    };

    BlipView.prototype.applyOps = function(ops, shiftCursor, meta) {
      /*
              Применяет операции, сделанные другими пользователями
              @param ops: [ShareJS operation]
              @param shiftCursor: boolean, смещать ли курсор к выполненной операции
              @param meta: object, метаинформация к операциям, если они пришли с сервера
      */
      var name, u, user;
      if (this._editor) {
        user = null;
        if ((meta != null) && (meta.user != null) && !this._isMyMeta(meta)) {
          u = this._waveViewModel.getUser(meta.user);
          if (u.isLoaded() && (name = u.getRealName() || u.getEmail())) {
            user = {
              name: name,
              id: u.getId()
            };
          }
        }
        this._editor.applyOps(ops, shiftCursor, user);
        try {
          this._onEditorUpdate();
        } catch (err) {
          console.warn(err);
        }
      } else {
        this._processBlipOps(ops);
      }
      if (this._focused) return;
      if ((meta != null) && this._isMyMeta(meta)) {
        return this.setReadState(true);
      } else if (this._opsSetUnreadIndicator(ops)) {
        return this.setReadState(false);
      }
    };

    BlipView.prototype._processBlipOps = function(ops) {
      var blipId, block, changedBlipIds, haveChanges, id, op, opType, _i, _j, _len, _len2, _ref5, _results;
      changedBlipIds = {};
      for (_i = 0, _len = ops.length; _i < _len; _i++) {
        op = ops[_i];
        if ((!(op.ti != null)) && (!(op.td != null))) continue;
        opType = op[ModelField.PARAMS][ParamsField.TYPE];
        if (opType !== ModelType.BLIP) continue;
        blipId = op[ModelField.PARAMS][ParamsField.ID];
        changedBlipIds[blipId] = true;
        haveChanges = true;
      }
      if (!haveChanges) return;
      _ref5 = this._model.getSnapshotContent();
      for (_j = 0, _len2 = _ref5.length; _j < _len2; _j++) {
        block = _ref5[_j];
        id = block[ModelField.PARAMS][ParamsField.ID];
        if (!(id in changedBlipIds)) continue;
        delete changedBlipIds[id];
        this._addInlineBlip(id);
      }
      _results = [];
      for (id in changedBlipIds) {
        _results.push(this._removeInlineBlip(id));
      }
      return _results;
    };

    BlipView.prototype.submitOps = function(ops) {
      /*
              Отправляет операции пользователя на сервер
              @param ops: [ShareJS operation]
      */      if (!ops.length) return;
      try {
        this._model.submitOps(ops);
        return this.emit('ops', ops);
      } catch (e) {
        this._editor.removeListener('ops', this._processEditorChanges);
        this._editor.setEditable(false);
        return this._blipProcessor.showPageError(e);
      }
    };

    BlipView.prototype.isRead = function() {
      return this._model.isRead;
    };

    BlipView.prototype.getParent = function() {
      return this._parent;
    };

    BlipView.prototype.setFoldedByDefault = function(folded) {
      var _ref5;
      this._model.setIsFoldedByDefault(folded);
      return (_ref5 = this._interactor) != null ? _ref5.updateFoldedByDefault(folded) : void 0;
    };

    BlipView.prototype.getChildBlipByServerId = function(serverBlipId) {
      /*
              Возвращает объект со вложенными блипами
              @return: BlipViewModel|null
      */
      var childBlipId;
      childBlipId = this._getChildBlipId(serverBlipId);
      if (!(childBlipId != null)) return null;
      return this._childBlips[childBlipId];
    };

    BlipView.prototype.getBlipCopyOpByServerId = function(serverBlipId) {
      var childBlipContainer, _ref5;
      this.renderRecursively();
      childBlipContainer = (_ref5 = this.getChildBlipByServerId(serverBlipId)) != null ? _ref5.getView().getContainer() : void 0;
      if (!childBlipContainer) return null;
      return this._editor.getCopyElementOp(childBlipContainer);
    };

    BlipView.prototype._preventDragDropEvent = function(e) {
      var _ref5;
      e.stopPropagation();
      e.preventDefault();
      return (_ref5 = e.dataTransfer) != null ? _ref5.dropEffect = 'none' : void 0;
    };

    BlipView.prototype.removeWithConfirm = function() {
      /*
              Удаляет это сообщение
      */      if (window.confirm("Delete reply?")) {
        _gaq.push(['_trackEvent', 'Blip usage', 'Delete blip']);
        return this.remove();
      }
    };

    BlipView.prototype.sendMessages = function(callback) {
      return this._handleSend(callback);
    };

    BlipView.prototype.destroy = function() {
      var _ref5, _ref6, _ref7;
      BlipView.__super__.destroy.call(this);
      this._blipContainer.removeEventListener(BrowserEvents.DRAG_OVER_EVENT, this._preventDragDropEvent, false);
      this.removeAllListeners();
      if ((_ref5 = this._interactor) != null) _ref5.destroy();
      delete this._interactor;
      delete this._blipViewModel;
      if (this._model.serverId) {
        this._waveViewModel.setBlipAsRemoved(this._model.serverId);
      }
      this._waveViewModel.removeListener('usersInfoUpdate', this._usersInfoUpdateHandler);
      delete this._waveViewModel;
      if (this._parent) {
        if ((_ref6 = this._contributors) != null) _ref6.destroy();
        delete this._contributors;
        delete this._parent;
      }
      if ((_ref7 = this._editor) != null) _ref7.destroy();
      delete this._model;
      return $(this._blipContainer).remove();
    };

    BlipView.prototype.getBlipContainingCursor = function(cursor) {
      /*
              Возвращает самый вложенный блип, который содержит в себе указанный курсор
              @param cursor: [HTMLElement, int]
              @return: BlipView|null
      */
      var blip, res, _, _ref5;
      if (!this._editor) return null;
      if (this._editor.getContainer() === cursor[0]) return this;
      if (!this._editor.containsNode(cursor[0])) return null;
      _ref5 = this._childBlips;
      for (_ in _ref5) {
        blip = _ref5[_];
        res = blip.getView().getBlipContainingCursor(cursor);
        if (res) return res;
        if (blip.getView().getBlipContainingElement(cursor[0])) return null;
      }
      return this;
    };

    BlipView.prototype.getBlipContainingElement = function(e) {
      /*
              Возвращает самый вложенный блип, который содержит в себе указанный элемент
              @param e: HTMLElement
              @return: BlipView|null
      */
      var blip, res, _, _ref5;
      if (!DOM.contains(this._blipContainer, e)) return null;
      _ref5 = this._childBlips;
      for (_ in _ref5) {
        blip = _ref5[_];
        res = blip.getView().getBlipContainingElement(e);
        if (res) return res;
      }
      return this;
    };

    BlipView.prototype.getEditor = function() {
      /*
              Возвращает редактор внутри этого блипа
              @return: Editor
      */      return this._editor;
    };

    BlipView.prototype.getUrl = function() {
      /*
              Возвращает ссылку на блип
              @return: string
      */      return "" + (this._waveViewModel.getView().getUrl()) + this._model.serverId + "/";
    };

    BlipView.prototype.isRoot = function() {
      var _ref5, _ref6;
      return ((_ref5 = this._model) != null ? _ref5.getServerId() : void 0) === ((_ref6 = this._waveViewModel) != null ? _ref6.getRootBlipId() : void 0);
    };

    BlipView.prototype.setCursor = function() {
      this._interactor.updateEditingModifiers();
      return this._editor.setCursor();
    };

    BlipView.prototype.updateCursor = function() {
      this._interactor.updateEditingModifiers();
      return this._editor.updateCursor();
    };

    BlipView.prototype.clearCursor = function() {
      return this._editor.clearCursor();
    };

    BlipView.prototype.getViewModel = function() {
      return this._blipViewModel;
    };

    BlipView.prototype.markLastEdit = function() {
      /*
              Ставится класс для пометки последного редактируемого блипа синей рамкой
      */      return $(this._blipContainer).addClass('last-active');
    };

    BlipView.prototype.unmarkLastEdit = function() {
      /*
              Снимается класс для пометки последного редактируемого блипа синей рамкой
      */      return $(this._blipContainer).removeClass('last-active');
    };

    BlipView.prototype.setRangeMenuPosByRange = function(r, parent) {
      var editCallback, rangeMenu, rect,
        _this = this;
      rangeMenu = RangeMenu.get();
      if (!(rect = this._getRectFromRange(r, parent))) return rangeMenu.hide();
      editCallback = null;
      if (this._hasEditPermission) {
        editCallback = function() {
          return _this._setEditable(true, true);
        };
      }
      return rangeMenu.show(this._model.getId(), rect, parent, function() {
        return _this.initInsertInlineBlip();
      }, editCallback);
    };

    BlipView.prototype.updateRangeMenuPosByRange = function(r, parent) {
      var rangeMenu, rect;
      rangeMenu = RangeMenu.get();
      if (!(rect = this._getRectFromRange(r, parent))) return rangeMenu.hide();
      return rangeMenu.update(rect);
    };

    BlipView.prototype._getRectFromRange = function(r, parent) {
      var rect;
      if (!this._isActive) return;
      if (this._editable) return;
      if (!r) return;
      try {
        if (this._getPermission() === READ_PERMISSION) return;
        rect = this._editor.getCursorRectFromRange(r, parent);
      } catch (e) {
        return console.warn('Failed to get permissions for RangeMenu');
      }
      if (!rect) return;
      if (!rect.top && !rect.bottom && !rect.left && !rect.right) return;
      DOM.convertWindowCoordsToRelative(rect, parent);
      if (rect.bottom > parent.clientHeight) return;
      return rect;
    };

    BlipView.prototype._updateUndoRedoState = function() {
      return this._interactor.updateUndoRedoState();
    };

    BlipView.prototype.showPlaybackView = function() {
      return this._blipProcessor.showPlaybackView(this._waveViewModel.getServerId(), this._model.serverId, this._waveViewModel);
    };

    return BlipView;

  })(BlipViewBase);

  MicroEvent.mixin(BlipView);

  module.exports = {
    BlipView: BlipView
  };

}).call(this);

});

require.define("/lib/client/client/blip/view_base.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipThread, BlipViewBase, BrowserEvents,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  BrowserEvents = require('../utils/browser_events');

  BlipThread = require('./blip_thread').BlipThread;

  BlipViewBase = (function() {

    function BlipViewBase() {
      this.unfoldAllChildBlips = __bind(this.unfoldAllChildBlips, this);
      this.foldAllChildBlips = __bind(this.foldAllChildBlips, this);
      this.unfold = __bind(this.unfold, this);
      this._isFolded = __bind(this._isFolded, this);
      this.__initFold = __bind(this.__initFold, this);
      this._processUnfold = __bind(this._processUnfold, this);
    }

    BlipViewBase.prototype._processUnfold = function() {
      var blipThread;
      blipThread = BlipThread.getBlipThread(this.__blipContainer);
      blipThread.removeListener('unfold', this._processUnfold);
      return this._render();
    };

    BlipViewBase.prototype._decThreadUnreadBlipsCount = function() {
      if (!this._parent) return;
      return this.removeChildFromUnreads(this.__model.getId());
    };

    BlipViewBase.prototype._incThreadUnreadBlipsCount = function() {
      if (!this._parent) return;
      return this.addChildToUnreads(this.__model.getId());
    };

    BlipViewBase.prototype.__initUnreadIndicator = function() {
      var c;
      c = $(this.__blipContainer);
      this._unreadIndicator = c.find('.js-blip-unread-indicator')[0];
      if (this.__unreadIndicatorHidden) {
        return this.__hideUnreadIndicator(true);
      } else {
        return this.__showUnreadIndicator(true);
      }
    };

    BlipViewBase.prototype.__initFold = function() {
      /*
              Инициализирует элементы, отвечающие за свернутость и развернутость блипа
      */
      var blipThread;
      this.__blipContainer.removeEventListener(BrowserEvents.C_BLIP_INSERT_EVENT, this.__initFold, false);
      blipThread = BlipThread.getBlipThread(this.__blipContainer);
      if (!this._isFolded(blipThread)) {
        return this._render();
      } else {
        return blipThread.on('unfold', this._processUnfold);
      }
    };

    BlipViewBase.prototype._isFolded = function(blipThread) {
      var isFolded;
      isFolded = false;
      if (blipThread.isFirstInThread(this.__blipContainer)) {
        isFolded = this.__isFoldedWithoutRendering || this.__model.isFoldedByDefault();
        blipThread.initFold(isFolded);
      } else {
        isFolded = blipThread.isFolded();
      }
      return isFolded;
    };

    BlipViewBase.prototype.__hideUnreadIndicator = function(force) {
      var _ref;
      if (force == null) force = false;
      if (!force && this.__unreadIndicatorHidden) return;
      this._decThreadUnreadBlipsCount();
      this.__unreadIndicatorHidden = true;
      return (_ref = this._unreadIndicator) != null ? _ref.style.display = 'none' : void 0;
    };

    BlipViewBase.prototype.__showUnreadIndicator = function(force) {
      var _ref;
      if (force == null) force = false;
      if (!force && !this.__unreadIndicatorHidden) return;
      this._incThreadUnreadBlipsCount();
      this.__unreadIndicatorHidden = false;
      return (_ref = this._unreadIndicator) != null ? _ref.style.display = 'block' : void 0;
    };

    BlipViewBase.prototype.updateReadState = function() {
      var blip, blipId, _ref, _results;
      if (this.__unreadIndicatorHidden) {
        this._decThreadUnreadBlipsCount();
      } else {
        this._incThreadUnreadBlipsCount();
      }
      _ref = this._childBlips;
      _results = [];
      for (blipId in _ref) {
        blip = _ref[blipId];
        _results.push(blip.getView().updateReadState());
      }
      return _results;
    };

    BlipViewBase.prototype.unfold = function() {
      var blipThread;
      if (!this.__isNotInRootThread) return;
      blipThread = BlipThread.getBlipThread(this.__blipContainer);
      return blipThread.unfold();
    };

    BlipViewBase.prototype.fold = function() {
      var blipThread;
      if (!this.__isNotInRootThread) return;
      blipThread = BlipThread.getBlipThread(this.__blipContainer);
      if (blipThread) {
        if (blipThread.isFirstInThread(this.__blipContainer)) {
          return blipThread.fold();
        }
      } else {
        return this.__isFoldedWithoutRendering = true;
      }
    };

    BlipViewBase.prototype.unfoldToRootBlip = function() {
      var _ref;
      if ((_ref = this._parent) != null) _ref.unfoldToRootBlip();
      return this.unfold();
    };

    BlipViewBase.prototype.selectAll = function() {
      return this._editor.selectAll();
    };

    BlipViewBase.prototype.setCursorToStart = function() {
      return this._editor.setCursorToStart();
    };

    BlipViewBase.prototype.getChildBlips = function() {
      return this._childBlips;
    };

    BlipViewBase.prototype.foldAllChildBlips = function() {
      var childBlip, childBlipId, _ref, _results;
      _ref = this._childBlips;
      _results = [];
      for (childBlipId in _ref) {
        childBlip = _ref[childBlipId];
        childBlip.getView().fold();
        _results.push(childBlip.getView().foldAllChildBlips());
      }
      return _results;
    };

    BlipViewBase.prototype.unfoldAllChildBlips = function() {
      var childBlip, childBlipId, _ref, _results;
      _ref = this._childBlips;
      _results = [];
      for (childBlipId in _ref) {
        childBlip = _ref[childBlipId];
        childBlip.getView().unfold();
        _results.push(childBlip.getView().unfoldAllChildBlips());
      }
      return _results;
    };

    BlipViewBase.prototype.destroy = function() {
      var thread;
      this._decThreadUnreadBlipsCount();
      this.__blipContainer.removeEventListener(BrowserEvents.C_BLIP_INSERT_EVENT, this.__initFold, false);
      $(this.__blipContainer).off('focusin focusout');
      thread = BlipThread.getBlipThread(this.__blipContainer);
      if (thread) {
        thread.deleteBlipNode(this.__blipContainer);
        return thread.removeListener('unfold', this._processUnfold);
      }
    };

    return BlipViewBase;

  })();

  module.exports = BlipViewBase;

}).call(this);

});

require.define("/lib/client/client/blip/blip_thread.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ANIMATED_CLASS, ANIMATION_DURATION, BlipThread, BrowserEvents, DomUtils, FOLDED_CLASS, MicroEvent, blipThreadTmpl, renderBlipThread,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  DomUtils = require('../utils/dom');

  MicroEvent = require('../utils/microevent');

  BrowserEvents = require('../utils/browser_events');

  blipThreadTmpl = function() {
    div('fold-button-container', {
      contentEditable: 'false'
    }, function() {
      return span('js-fold-button fold-button', function() {
        return div(function() {
          img({
            src: "/s/img/empty_pixel.png",
            height: '20px',
            width: '18px'
          });
          div('', '');
          return img('.plus-minus', {
            src: "/s/img/plus_minus.png"
          });
        });
      });
    });
    return div('js-blips-container blips-container', '');
  };

  renderBlipThread = window.CoffeeKup.compile(blipThreadTmpl);

  ANIMATED_CLASS = 'animated';

  ANIMATION_DURATION = 3000;

  FOLDED_CLASS = 'folded';

  BlipThread = (function() {

    function BlipThread(_threadId, blipNode) {
      this._threadId = _threadId;
      this._toggleFold = __bind(this._toggleFold, this);
      this._unreadBlips = {};
      this._blipNodes = [];
      this._container = document.createElement('span');
      this._container.contentEditable = 'false';
      this._container.className = 'blip-thread';
      this._container.rzContainer = true;
      this._container.rzBlipThread = this;
      this._container.innerHTML = renderBlipThread();
      this._blipsContainer = this._container.getElementsByClassName('js-blips-container')[0];
      this.initFold(true);
      if (blipNode) this.appendBlipElement(blipNode);
    }

    BlipThread.prototype._toggleFold = function() {
      /*
              Изменяет свернутость треда
      */      if (this._folded) {
        return this._unfold();
      } else {
        return this._fold(false);
      }
    };

    BlipThread.prototype._setAnimated = function(animated) {
      if (animated) {
        return DomUtils.addClass(this._container, ANIMATED_CLASS);
      } else {
        return DomUtils.removeClass(this._container, ANIMATED_CLASS);
      }
    };

    BlipThread.prototype._unfold = function() {
      this._folded = false;
      DomUtils.removeClass(this._container, FOLDED_CLASS);
      if (this._animationTimer) {
        this._animationTimer = window.clearTimeout(this._animationTimer);
      }
      this._setAnimated(false);
      return this.emit('unfold');
    };

    BlipThread.prototype._fold = function(animated) {
      var _this = this;
      if (this._folded) return;
      this._folded = true;
      DomUtils.addClass(this._container, FOLDED_CLASS);
      if (!animated) return;
      this._setAnimated(true);
      return this._animationTimer = window.setTimeout(function() {
        _this._setAnimated(false);
        return _this._animationTimer = null;
      }, ANIMATION_DURATION);
    };

    BlipThread.prototype._dispatchBlipInsertEvent = function(blipElement) {
      return blipElement.dispatchEvent(BrowserEvents.createCustomEvent(BrowserEvents.C_BLIP_INSERT_EVENT, false, false));
    };

    BlipThread.prototype.isFirstInThread = function(blipNode) {
      return this._blipNodes[0] === blipNode;
    };

    BlipThread.prototype.getSecondBlipElement = function() {
      return this._blipNodes[1];
    };

    BlipThread.prototype.initFold = function(isFolded) {
      /*
              Инициализирует элементы, отвечающие за свернутость и развернутость блипа
      */      this._foldButton = this._container.getElementsByClassName('js-fold-button')[0];
      if (!this._foldButton) return;
      if (isFolded) {
        this._fold(false);
      } else {
        this._unfold();
      }
      this._foldButton.addEventListener('click', this._toggleFold, false);
      BrowserEvents.addPropagationBlocker(this._foldButton, BrowserEvents.MOUSE_DOWN_EVENT);
      return BrowserEvents.addPropagationBlocker(this._foldButton, BrowserEvents.CLICK_EVENT);
    };

    BlipThread.prototype.setAsRoot = function() {
      return DomUtils.addClass(this._container, 'root-thread');
    };

    BlipThread.prototype.destroy = function() {
      var parentNode;
      delete this._container.rzBlipThread;
      delete this._blipNodes;
      if (this._foldButton) {
        this._foldButton.removeEventListener('click', this._toggleFold, false);
      }
      BrowserEvents.removePropagationBlocker(this._foldButton, BrowserEvents.MOUSE_DOWN_EVENT);
      if ((parentNode = this._container.parentNode)) {
        parentNode.removeChild(this._container);
      }
      return delete this._blipsContainer;
    };

    BlipThread.getBlipThread = function(element) {
      /*
              @param element: HTMLElement - корневой элемент блипа, принадлежащего треда
      */      while (element && !element.rzBlipThread) {
        element = element.parentNode;
      }
      return element != null ? element.rzBlipThread : void 0;
    };

    BlipThread.prototype.splitAfterBlipNode = function(blipNodeAfter) {
      var blip, index, newThread, splicedBlips;
      index = this._blipNodes.indexOf(blipNodeAfter);
      if (index === -1) throw new Error('Blip node does not belong to thread');
      index += 1;
      if (index === this._blipNodes.length) return [this._container, null];
      splicedBlips = this._blipNodes.splice(index);
      newThread = new BlipThread(splicedBlips.shift());
      DomUtils.insertNextTo(newThread.getContainer(), this._container);
      while (blip = splicedBlips.shift()) {
        newThread.appendBlipElement(blip);
      }
      return [this._container, newThread.getContainer()];
    };

    BlipThread.prototype.mergeWithNext = function() {
      var blipNode, blipNodes, nextNode, nextThread, _i, _len;
      nextNode = this._container.nextSibling;
      if (!nextNode || !(nextThread = nextNode.rzBlipThread)) return;
      if (this._threadId !== nextThread.getId()) return;
      blipNodes = nextThread.getBlipNodes();
      for (_i = 0, _len = blipNodes.length; _i < _len; _i++) {
        blipNode = blipNodes[_i];
        this.appendBlipElement(blipNode);
      }
      return nextThread.destroy();
    };

    BlipThread.prototype.getBlipNodes = function() {
      return this._blipNodes;
    };

    BlipThread.prototype.getId = function() {
      return this._threadId;
    };

    BlipThread.prototype.deleteBlipNode = function(blipNode) {
      var index;
      index = this._blipNodes.indexOf(blipNode);
      if (index === -1) throw new Error('Blip node does not belong to thread');
      this._blipNodes.splice(index, 1);
      this._blipsContainer.removeChild(blipNode);
      if (!this._blipNodes.length) return this.destroy();
    };

    BlipThread.prototype.insertBlipNodeAfter = function(blipNode, blipNodeAfter) {
      var index;
      index = this._blipNodes.indexOf(blipNodeAfter);
      if (index === -1) throw new Error('Blip node does not belong to thread');
      this._blipNodes.splice(index + 1, 0, blipNode);
      DomUtils.insertNextTo(blipNode, blipNodeAfter);
      return this._dispatchBlipInsertEvent(blipNode);
    };

    BlipThread.prototype.insertBlipNodeBefore = function(blipNode, blipNodeBefore) {
      var index;
      index = this._blipNodes.indexOf(blipNodeBefore);
      if (index === -1) throw new Error('Blip node does not belong to thread');
      this._blipNodes.splice(index, 0, blipNode);
      this._blipsContainer.insertBefore(blipNode, blipNodeBefore);
      return this._dispatchBlipInsertEvent(blipNode);
    };

    BlipThread.prototype.appendBlipElement = function(blipElement) {
      this._blipNodes.push(blipElement);
      this._blipsContainer.appendChild(blipElement);
      return this._dispatchBlipInsertEvent(blipElement);
    };

    BlipThread.prototype.getContainer = function() {
      return this._container;
    };

    BlipThread.prototype.unfold = function() {
      return this._unfold();
    };

    BlipThread.prototype.fold = function() {
      return this._fold(true);
    };

    BlipThread.prototype.isFolded = function() {
      return this._folded;
    };

    BlipThread.prototype.setUnreadBlip = function(blipId) {
      this._unreadBlips[blipId] = true;
      return $(this._foldButton).addClass('unread');
    };

    BlipThread.prototype.blipIsUnread = function(blipId) {
      return this._unreadBlips[blipId];
    };

    BlipThread.prototype.removeUnreadBlip = function(blipId) {
      delete this._unreadBlips[blipId];
      if (!this.isRead()) return;
      return $(this._foldButton).removeClass('unread');
    };

    BlipThread.prototype.isRead = function() {
      var blipId;
      for (blipId in this._unreadBlips) {
        return false;
      }
      return true;
    };

    return BlipThread;

  })();

  MicroEvent.mixin(BlipThread);

  exports.BlipThread = BlipThread;

}).call(this);

});

require.define("/lib/client/client/editor/editor_v2.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipThread, BrowserEvents, BrowserSupport, Buffer, COMMENT_PERMISSION, CachedRange, DATA_ATTRS, DATA_VARS, DEBUG_KEY_EVENTS, DRAG_CALL_ME_LATER, DRAG_COUNT, DRAG_START_LINE, DRAG_TYPE_MARKER, DomUtils, EDIT_PERMISSION, Editor, EventType, Gadget, HtmlOpParser, HtmlParser, INITIAL_CONTENT, INITIAL_LINE, KeyCodes, LAST_DRAG_OP, LAST_DRAG_OVER, LAST_DRAG_OVER_CLASS, LINK_POPUP_TIMEOUT, LineLevelParams, LinkEditor, LinkPopup, LocalStorage, MicroEvent, ModelField, ModelType, NOT_PERFORMED_TASK, OpParsedElementProcessor, ParamsField, Renderer, SCROLL_INTO_VIEW_OFFSET, SCROLL_INTO_VIEW_TIMER, SET_RANGE_TIMEOUT, SPECIAL_INPUT, SelectionAction, SelectionHelper, TagInput, TaskRecipientStub, TextLevelParams, TextParser, Utf16Util, clearDragProps, clearDragView, editorTmpl, getUploadForm, isDragToTop, matchUrls, removeArrayElement, renderEditor, updateDragView, _ref, _ref2, _ref3, _ref4, _ref5,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = Array.prototype.slice,
    __hasProp = Object.prototype.hasOwnProperty;

  BrowserEvents = require('../utils/browser_events');

  BrowserSupport = require('../utils/browser_support');

  Buffer = require('./buffer').Buffer;

  CachedRange = require('./cached_range').CachedRange;

  KeyCodes = require('../utils/key_codes').KeyCodes;

  _ref = require('./model'), TextLevelParams = _ref.TextLevelParams, LineLevelParams = _ref.LineLevelParams, ModelField = _ref.ModelField, ParamsField = _ref.ParamsField, ModelType = _ref.ModelType;

  _ref2 = require('./parser'), HtmlParser = _ref2.HtmlParser, TextParser = _ref2.TextParser, DATA_VARS = _ref2.DATA_VARS, DATA_ATTRS = _ref2.DATA_ATTRS, HtmlOpParser = _ref2.HtmlOpParser, OpParsedElementProcessor = _ref2.OpParsedElementProcessor;

  Renderer = require('./renderer').Renderer;

  SelectionHelper = require('./selection/html_selection_helper');

  DomUtils = require('../utils/dom');

  MicroEvent = require('../utils/microevent');

  _ref3 = require('../utils/string'), Utf16Util = _ref3.Utf16Util, matchUrls = _ref3.matchUrls;

  LinkPopup = require('./link_editor/link_popup').LinkPopup;

  LinkEditor = require('./link_editor').LinkEditor;

  TagInput = require('./tag').TagInput;

  NOT_PERFORMED_TASK = require('../search_panel/task/constants').NOT_PERFORMED_TASK;

  TaskRecipientStub = require('../blip/task_recipient').TaskRecipientStub;

  BlipThread = require('../blip/blip_thread').BlipThread;

  _ref4 = require('../blip/model'), EDIT_PERMISSION = _ref4.EDIT_PERMISSION, COMMENT_PERMISSION = _ref4.COMMENT_PERMISSION;

  getUploadForm = require('./file/upload_form').getInstance;

  LocalStorage = require('../utils/localStorage').LocalStorage;

  Gadget = require('./gadget').Gadget;

  _ref5 = require('./common'), EventType = _ref5.EventType, SPECIAL_INPUT = _ref5.SPECIAL_INPUT;

  editorTmpl = function() {
    return ul('.js-editor.editor', {
      contentEditable: this.isEditable.toString(),
      spellcheck: 'false',
      tabIndex: 1
    }, '');
  };

  renderEditor = window.CoffeeKup.compile(editorTmpl);

  SCROLL_INTO_VIEW_TIMER = 100;

  SCROLL_INTO_VIEW_OFFSET = -50;

  SelectionAction = (function() {

    function SelectionAction() {}

    SelectionAction.DELETE = 'DELETE';

    SelectionAction.TEXT = 'TEXT';

    SelectionAction.LINE = 'LINE';

    SelectionAction.UPDATE_SELECTION_INDENT = 1;

    SelectionAction.GETTEXTPARAMS = 'GETTEXTPARAMS';

    SelectionAction.GETLINEPARAMS = 'GETLINEPARAMS';

    SelectionAction.CLEARTEXTPARAMS = 'CLEARTEXTPARAMS';

    SelectionAction.COPY_CONTENT = 'COPY_CONTENT';

    return SelectionAction;

  })();

  INITIAL_LINE = {};

  INITIAL_LINE[ModelField.TEXT] = ' ';

  INITIAL_LINE[ModelField.PARAMS] = {};

  INITIAL_LINE[ModelField.PARAMS][ParamsField.TYPE] = ModelType.LINE;

  INITIAL_CONTENT = [INITIAL_LINE];

  LINK_POPUP_TIMEOUT = 50;

  SET_RANGE_TIMEOUT = 500;

  removeArrayElement = function(array, elem) {
    var index, _ref6;
    index = array.indexOf(elem);
    if (index === -1) return;
    return ([].splice.apply(array, [index, index - index + 1].concat(_ref6 = [])), _ref6);
  };

  LAST_DRAG_OP = void 0;

  LAST_DRAG_OVER = void 0;

  LAST_DRAG_OVER_CLASS = void 0;

  DRAG_CALL_ME_LATER = void 0;

  DRAG_START_LINE = void 0;

  DRAG_TYPE_MARKER = 0;

  DRAG_COUNT = 0;

  DEBUG_KEY_EVENTS = false;

  clearDragView = function() {
    if (LAST_DRAG_OVER && LAST_DRAG_OVER_CLASS) {
      DomUtils.removeClass(LAST_DRAG_OVER, LAST_DRAG_OVER_CLASS);
    }
    LAST_DRAG_OVER = void 0;
    return LAST_DRAG_OVER_CLASS = void 0;
  };

  updateDragView = function(view) {
    if (view === LAST_DRAG_OVER) return;
    clearDragView();
    return LAST_DRAG_OVER = view;
  };

  clearDragProps = function() {
    clearDragView();
    LAST_DRAG_OP = void 0;
    DRAG_CALL_ME_LATER = void 0;
    DRAG_START_LINE = void 0;
    return DRAG_COUNT = 0;
  };

  isDragToTop = function(clientY) {
    var h, r;
    if (!LAST_DRAG_OVER) return;
    r = LAST_DRAG_OVER.getBoundingClientRect();
    h = (r.bottom - r.top) / 2 + r.top;
    return h > clientY;
  };

  Editor = (function() {

    function Editor() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._insertLink = __bind(this._insertLink, this);
      this._updateLink = __bind(this._updateLink, this);
      this._handleLinkEditorClose = __bind(this._handleLinkEditorClose, this);
      this._openLinkEditor = __bind(this._openLinkEditor, this);
      this._processLinkPopup = __bind(this._processLinkPopup, this);
      this._removeInline = __bind(this._removeInline, this);
      this._convertRecipientToTask = __bind(this._convertRecipientToTask, this);
      this.__scrollIntoCursor = __bind(this.__scrollIntoCursor, this);
      this._finishHtmlPaste = __bind(this._finishHtmlPaste, this);
      this._finishHtmlDataCopy = __bind(this._finishHtmlDataCopy, this);
      this._processCopyEvent = __bind(this._processCopyEvent, this);
      this._processCutEvent = __bind(this._processCutEvent, this);
      this._processPasteEvent = __bind(this._processPasteEvent, this);
      this.processDropEvent = __bind(this.processDropEvent, this);
      this._processDragOverEvent = __bind(this._processDragOverEvent, this);
      this._processDragLeaveEvent = __bind(this._processDragLeaveEvent, this);
      this._processDragEnterEvent = __bind(this._processDragEnterEvent, this);
      this._processDragStartEvent = __bind(this._processDragStartEvent, this);
      this._removeDragStartLine = __bind(this._removeDragStartLine, this);
      this._realSetCachedRange = __bind(this._realSetCachedRange, this);
      this._processMouseDownEvent = __bind(this._processMouseDownEvent, this);
      this._processKeyEvent = __bind(this._processKeyEvent, this);
      this._processTextInputEvent = __bind(this._processTextInputEvent, this);
      this._processCompositionEndEvent = __bind(this._processCompositionEndEvent, this);
      this._processCompositionUpdateEvent = __bind(this._processCompositionUpdateEvent, this);
      this._processCompositionStartEvent = __bind(this._processCompositionStartEvent, this);
      this._handleGadgetDelete = __bind(this._handleGadgetDelete, this);
      this._handleGadgetParamChange = __bind(this._handleGadgetParamChange, this);
      this._createInlineElement = __bind(this._createInlineElement, this);
      this._init.apply(this, args);
    }

    Editor.prototype._init = function(id, config, functions, _alwaysShowPopupAtBottom) {
      var getRecipient, getTaskRecipient,
        _this = this;
      this._alwaysShowPopupAtBottom = _alwaysShowPopupAtBottom;
      this._getSnapshot = functions.getSnapshot;
      this._getRecipientInput = functions.getRecipientInput;
      this._getRecipient = functions.getRecipient;
      this._addRecipientByEmail = functions.addRecipientByEmail;
      this._getTaskRecipientInput = functions.getTaskRecipientInput;
      this._getTaskRecipient = functions.getTaskRecipient;
      this._addTaskRecipient = functions.addTaskRecipient;
      this._getChildBlip = functions.getChildBlip;
      this._getNewChildBlip = functions.getNewChildBlip;
      this._getScrollableElement = functions.getScrollableElement;
      this._editable = false;
      this._createDom();
      this.__registerDomEventHandling();
      getRecipient = function(id) {
        return _this._getRecipient(id, _this._removeInline, _this._convertRecipientToTask);
      };
      getTaskRecipient = function() {
        var args, convertToRecipient, recipient, removeTaskRecipient, updateTaskRecipient;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        recipient = null;
        updateTaskRecipient = function(data) {
          recipient = _this._updateTaskRecipient(recipient, data);
          return recipient;
        };
        removeTaskRecipient = function() {
          return _this._removeInline(recipient);
        };
        convertToRecipient = function() {
          return _this._convertTaskToRecipient(recipient);
        };
        return recipient = _this._getTaskRecipient.apply(_this, __slice.call(args).concat([updateTaskRecipient], [removeTaskRecipient], [convertToRecipient]));
      };
      this._renderer = new Renderer(id, config, functions.addInlineBlip, functions.removeInlineBlip, getRecipient, getTaskRecipient, this._createInlineElement);
      this._renderer.on('gadgetParamChange', this._handleGadgetParamChange);
      this._renderer.on('gadgetDelete', this._handleGadgetDelete);
      this.__renderer = this._renderer;
      this._gadgets = [];
      this._modifiers = {};
      return this._setRangePaused = false;
    };

    Editor.prototype._createDom = function() {
      var tmpContainer;
      tmpContainer = document.createElement('span');
      $(tmpContainer).append(renderEditor({
        isEditable: this._editable
      }));
      return this._container = tmpContainer.firstChild;
    };

    Editor.prototype.initContent = function() {
      var content, i, ops, _ref6;
      try {
        content = this._getSnapshot();
        if (!content.length) {
          content = INITIAL_CONTENT;
          ops = [];
          for (i = _ref6 = content.length - 1; _ref6 <= 0 ? i <= 0 : i >= 0; _ref6 <= 0 ? i++ : i--) {
            ops.push({
              p: 0,
              ti: content[i].t,
              params: content[i].params
            });
          }
        }
        this._renderer.renderContent(this._container, content);
        if (ops != null) return this.emit('ops', ops);
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype.getCursorRectFromRange = function(r) {
      var container, el, offset, rect, rects, type, _, _ref6;
      if (!r) return null;
      _ref6 = this._getElementsAndOffsets(r), _ = _ref6[0], _ = _ref6[1], _ = _ref6[2], el = _ref6[3], _ = _ref6[4], offset = _ref6[5];
      if (!(type = this._renderer.getElementType(el))) return null;
      if (type !== ModelType.BLIP) {
        return this._renderer.getCursorFromElement(el, offset);
      }
      try {
        container = BlipThread.getBlipThread(el).getContainer();
      } catch (e) {
        return null;
      }
      rects = container.getClientRects();
      if (rects.length) {
        r = rects[rects.length - 1];
        rect = {
          top: r.top,
          left: r.right,
          bottom: r.top,
          right: r.right
        };
        return rect;
      }
      return null;
    };

    Editor.prototype._createInlineElement = function(params) {
      var element, elementType, key, p, value,
        _this = this;
      elementType = params[ParamsField.TYPE];
      switch (elementType) {
        case ModelType.GADGET:
          p = {};
          for (key in params) {
            value = params[key];
            if (!(key[0] === '$' && key.length > 1)) continue;
            p[this._removePrefix(key)] = value;
          }
          element = new Gadget(params[ParamsField.URL], p, this._editable);
          this._gadgets.push(element);
          element.on('update', function(params) {
            return _this._handleElementUpdate(element, params);
          });
          return element;
        default:
          return null;
      }
    };

    Editor.prototype._addPrefix = function(str) {
      return '$' + str;
    };

    Editor.prototype._removePrefix = function(str) {
      if (str[0] !== '$') throw new Error('string does not have prefix');
      return str.substr(1);
    };

    Editor.prototype._handleElementUpdate = function(element, params) {
      var container, elementParams, offset, op, ops, paramName, paramValue, prefixedName, prop;
      container = element.getContainer();
      offset = this._getOffsetBefore(container);
      if (!(offset != null)) return null;
      elementParams = this._renderer.getElementParams(container);
      ops = [];
      for (paramName in params) {
        paramValue = params[paramName];
        prefixedName = this._addPrefix(paramName);
        if (elementParams[prefixedName] === paramValue) continue;
        if (elementParams[prefixedName] != null) {
          prop = {};
          prop[prefixedName] = elementParams[prefixedName];
          op = {
            p: offset,
            paramsd: prop,
            len: 1
          };
          ops.push(op);
        }
        if (paramValue != null) {
          prop = {};
          prop[prefixedName] = paramValue;
          op = {
            p: offset,
            paramsi: prop,
            len: 1
          };
          ops.push(op);
        }
      }
      try {
        if (ops.length) return this._submitOps(ops, false);
      } catch (e) {
        return this.emit('error');
      }
    };

    Editor.prototype._handleGadgetParamChange = function(elementContainer, params, param, value) {
      var gadget, index, _i, _len, _ref6, _results;
      this._gadgetQueue || (this._gadgetQueue = []);
      this._opsQueue || (this._opsQueue = []);
      if (params[ParamsField.TYPE] !== ModelType.GADGET) {
        throw new Error('not implemented');
      }
      _ref6 = this._gadgets;
      _results = [];
      for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
        gadget = _ref6[_i];
        if (gadget.getContainer() !== elementContainer) continue;
        index = this._gadgetQueue.indexOf(gadget);
        if (index === -1) {
          index = this._gadgetQueue.length;
          this._gadgetQueue.push(gadget);
          this._opsQueue.push([]);
        }
        _results.push(this._opsQueue[index].push([param, value]));
      }
      return _results;
    };

    Editor.prototype._flushOpsQueue = function() {
      var delta, gadget, index, op, ops, param, paramName, value, _i, _len, _len2, _ref6;
      if (!this._gadgetQueue || !this._opsQueue) return;
      _ref6 = this._gadgetQueue;
      for (index = 0, _len = _ref6.length; index < _len; index++) {
        gadget = _ref6[index];
        if (this._gadgets.indexOf(gadget) === -1) continue;
        delta = {};
        ops = this._opsQueue[index];
        for (_i = 0, _len2 = ops.length; _i < _len2; _i++) {
          op = ops[_i];
          param = op[0], value = op[1];
          paramName = this._removePrefix(param);
          delta[paramName] = value;
        }
        gadget.setStateDelta(delta);
      }
      delete this._gadgetQueue;
      return delete this._opsQueue;
    };

    Editor.prototype._handleGadgetDelete = function(element) {
      var gadget, _i, _len, _ref6, _results;
      _ref6 = this._gadgets;
      _results = [];
      for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
        gadget = _ref6[_i];
        if (gadget.getContainer() !== element) continue;
        gadget.destroy();
        gadget.removeAllListeners();
        removeArrayElement(this._gadgets, gadget);
        break;
      }
      return _results;
    };

    Editor.prototype.__registerDomEventHandling = function() {
      this._container.addEventListener(BrowserEvents.KEY_DOWN_EVENT, this._processKeyEvent, false);
      this._container.addEventListener(BrowserEvents.KEY_PRESS_EVENT, this._processKeyEvent, false);
      this._container.addEventListener(BrowserEvents.COMPOSITION_START_EVENT, this._processCompositionStartEvent, false);
      if (BrowserSupport.isWebKit()) {
        this._container.addEventListener(BrowserEvents.TEXT_INPUT_EVENT, this._processTextInputEvent, false);
      }
      this._container.addEventListener(BrowserEvents.COMPOSITION_UPDATE_EVENT, this._processCompositionUpdateEvent, false);
      this._container.addEventListener(BrowserEvents.COMPOSITION_END_EVENT, this._processCompositionEndEvent, false);
      this._container.addEventListener(BrowserEvents.COPY_EVENT, this._processCopyEvent, false);
      this._container.addEventListener(BrowserEvents.CUT_EVENT, this._processCutEvent, false);
      this._container.addEventListener(BrowserEvents.PASTE_EVENT, this._processPasteEvent, false);
      this._container.addEventListener(BrowserEvents.MOUSE_DOWN_EVENT, this._processMouseDownEvent, false);
      this._container.addEventListener(BrowserEvents.DRAG_START_EVENT, this._processDragStartEvent, false);
      this._container.addEventListener(BrowserEvents.DRAG_ENTER_EVENT, this._processDragEnterEvent, false);
      this._container.addEventListener(BrowserEvents.DRAG_LEAVE_EVENT, this._processDragLeaveEvent, false);
      this._container.addEventListener(BrowserEvents.DRAG_OVER_EVENT, this._processDragOverEvent, false);
      this._container.addEventListener(BrowserEvents.DROP_EVENT, this.processDropEvent, false);
      this._container.addEventListener(BrowserEvents.DRAG_END_EVENT, this._processDragEndEvent, false);
      if (BrowserSupport.isIe()) {
        return this._container.addEventListener(BrowserEvents.BEFORE_PASTE_EVENT, this._processPasteEvent, false);
      }
    };

    Editor.prototype.__unregisterDomEventHandling = function() {
      this._container.removeEventListener(BrowserEvents.KEY_DOWN_EVENT, this._processKeyEvent, false);
      this._container.removeEventListener(BrowserEvents.KEY_PRESS_EVENT, this._processKeyEvent, false);
      this._container.removeEventListener(BrowserEvents.COMPOSITION_START_EVENT, this._processCompositionStartEvent, false);
      if (BrowserSupport.isWebKit()) {
        this._container.removeEventListener(BrowserEvents.TEXT_INPUT_EVENT, this._processTextInputEvent, false);
      }
      this._container.removeEventListener(BrowserEvents.COMPOSITION_UPDATE_EVENT, this._processCompositionUpdateEvent, false);
      this._container.removeEventListener(BrowserEvents.COMPOSITION_END_EVENT, this._processCompositionEndEvent, false);
      this._container.removeEventListener(BrowserEvents.COPY_EVENT, this._processCopyEvent, false);
      this._container.removeEventListener(BrowserEvents.CUT_EVENT, this._processCutEvent, false);
      this._container.removeEventListener(BrowserEvents.PASTE_EVENT, this._processPasteEvent, false);
      this._container.removeEventListener(BrowserEvents.MOUSE_DOWN_EVENT, this._processMouseDownEvent, false);
      this._container.removeEventListener(BrowserEvents.DRAG_START_EVENT, this._processDragStartEvent, false);
      this._container.removeEventListener(BrowserEvents.DRAG_ENTER_EVENT, this._processDragEnterEvent, false);
      this._container.removeEventListener(BrowserEvents.DRAG_LEAVE_EVENT, this._processDragLeaveEvent, false);
      this._container.removeEventListener(BrowserEvents.DRAG_OVER_EVENT, this._processDragOverEvent, false);
      this._container.removeEventListener(BrowserEvents.DROP_EVENT, this.processDropEvent, false);
      this._container.removeEventListener(BrowserEvents.DRAG_END_EVENT, this._processDragEndEvent, false);
      if (BrowserSupport.isIe()) {
        return this._container.removeEventListener(BrowserEvents.BEFORE_PASTE_EVENT, this._processPasteEvent, false);
      }
    };

    Editor.prototype._processCompositionStartEvent = function(event) {
      var ops, range, span, _ref6;
      event.stopPropagation();
      if (!this._editable || BrowserSupport.isIe()) return event.preventDefault();
      range = this._getCachedRange();
      if (!range) return;
      if (!range.isCollapsed()) {
        try {
          ops = this._deleteSelection(range);
          this._submitOps(ops);
        } catch (e) {
          this.emit('error', e);
          return;
        }
      }
      this.pauseSetRange();
      span = document.createElement('span');
      this._renderer.insertNodeAt(span, range.getStartIndex());
      Buffer.attachNextTo(span);
      return (_ref6 = span.parentNode) != null ? _ref6.removeChild(span) : void 0;
    };

    Editor.prototype._processCompositionUpdateEvent = function(event) {
      var range, span, _ref6;
      event.stopPropagation();
      if (Buffer.getText() !== '') return;
      range = this._getCachedRange(false);
      if (!range) return;
      span = document.createElement('span');
      this._renderer.insertNodeAt(span, range.getStartIndex());
      Buffer.attachNextTo(span);
      return (_ref6 = span.parentNode) != null ? _ref6.removeChild(span) : void 0;
    };

    Editor.prototype._processCompositionEndEvent = function(event) {
      event.stopPropagation();
      if (BrowserSupport.isMozilla()) this.insertTextData(Buffer.getText(), false);
      if (BrowserSupport.isMozilla()) {
        Buffer.detach();
        return this.resumeSetRange(true, true);
      }
    };

    Editor.prototype._processTextInputEvent = function(event) {
      event.preventDefault();
      event.stopPropagation();
      if (!this._editable) return;
      try {
        if (event.data === '\n') {
          this._handleNewLine();
        } else {
          this.insertTextData(event.data);
        }
      } catch (e) {
        this.emit('error', e);
      }
      return Buffer.clear();
    };

    Editor.prototype._processKeyEvent = function(event) {
      var cancel;
      if (DEBUG_KEY_EVENTS) {
        console.log(event != null ? event.type : void 0, event != null ? event.keyCode : void 0, event != null ? event.charCode : void 0, event);
      }
      cancel = this._handleKeyEvent(event);
      if (cancel) {
        event.stopPropagation();
        return event.preventDefault();
      }
    };

    Editor.prototype._detachBuffer = function() {
      this._resumeSetRange(false, true);
      return Buffer.detach();
    };

    Editor.prototype._processMouseDownEvent = function() {
      this._detachBuffer();
      return this._clearCachedRange();
    };

    Editor.prototype._handleKeyEvent = function(event) {
      var eventType;
      eventType = this._getKeyEventType(event);
      if (!this._editable) {
        switch (eventType) {
          case EventType.NAVIGATION:
          case EventType.NOEFFECT:
            return false;
          default:
            return true;
        }
      }
      switch (eventType) {
        case EventType.INPUT:
          this._detachBuffer();
          try {
            this.insertTextData(String.fromCharCode(event.charCode));
          } catch (e) {
            this.emit('error', e);
          }
          return true;
        case EventType.LINE:
          this._detachBuffer();
          try {
            this._handleNewLine();
          } catch (e) {
            this.emit('error', e);
          }
          return true;
        case EventType.TAB:
          this._detachBuffer();
          try {
            this._handleTab(event.shiftKey);
          } catch (e) {
            this.emit('error', e);
          }
          return true;
        case EventType.DELETE:
          this._detachBuffer();
          try {
            this._handleDelete(event);
          } catch (e) {
            this.emit('error', e);
          }
          return true;
        case EventType.NAVIGATION:
          this._detachBuffer();
          if (this._cachedRange) this._setCachedRange(true);
          return false;
        case EventType.NOEFFECT:
          event.stopPropagation();
          return false;
        case EventType.DANGEROUS:
          return true;
        default:
          return true;
      }
    };

    Editor.prototype._getKeyEventType = function(event) {
      var computedKeyCode, type;
      computedKeyCode = event.which !== 0 ? event.which : event.keyCode;
      if (!BrowserSupport.isMac() && event.keyCode === KeyCodes.KEY_DELETE && event.shiftKey && !event.ctrlKey && !event.altKey) {
        return EventType.NOEFFECT;
      }
      type = null;
      if (BrowserSupport.isWebKit()) {
        if (!computedKeyCode) {
          type = EventType.DANGEROUS;
        } else if (event.type === BrowserEvents.KEY_PRESS_EVENT) {
          if (computedKeyCode === KeyCodes.KEY_ESCAPE || ((event.ctrlKey || event.metaKey) && !event.altKey)) {
            type = EventType.NOEFFECT;
          } else if (computedKeyCode === KeyCodes.KEY_TAB) {
            type = EventType.TAB;
          } else {
            type = EventType.INPUT;
          }
        } else if (KeyCodes.NAVIGATION_KEYS.indexOf(computedKeyCode) !== -1) {
          type = EventType.NAVIGATION;
        } else if (computedKeyCode === KeyCodes.KEY_DELETE || computedKeyCode === KeyCodes.KEY_BACKSPACE) {
          type = EventType.DELETE;
        } else if (computedKeyCode === KeyCodes.KEY_ESCAPE || event.keyIdentifier === 'U+0010') {
          type = EventType.NOEFFECT;
        } else if (computedKeyCode === KeyCodes.KEY_ENTER) {
          type = EventType.LINE;
        } else if (computedKeyCode === KeyCodes.KEY_TAB) {
          type = EventType.TAB;
        } else {
          type = EventType.NOEFFECT;
        }
      } else if (BrowserSupport.isMozilla()) {
        if (event.type === BrowserEvents.KEY_DOWN_EVENT) {
          if ((event.keyCode === KeyCodes.KEY_BACKSPACE || event.keyCode === KeyCodes.KEY_DELETE) && event.ctrlKey && !event.altKey) {
            return EventType.DELETE;
          } else if (KeyCodes.NAVIGATION_KEYS.indexOf(computedKeyCode) !== -1) {
            return EventType.NAVIGATION;
          } else {
            return EventType.NOEFFECT;
          }
        }
        if (!computedKeyCode) {
          type = EventType.DANGEROUS;
        } else if (event.ctrlKey || event.metaKey || event.altKey) {
          type = EventType.NOEFFECT;
        } else if (event.charCode) {
          type = EventType.INPUT;
        } else if (computedKeyCode === KeyCodes.KEY_DELETE || computedKeyCode === KeyCodes.KEY_BACKSPACE) {
          type = EventType.DELETE;
        } else if (KeyCodes.NAVIGATION_KEYS.indexOf(computedKeyCode) !== -1) {
          type = EventType.NAVIGATION;
        } else if (computedKeyCode === KeyCodes.KEY_ENTER) {
          type = EventType.LINE;
        } else if (computedKeyCode === KeyCodes.KEY_TAB) {
          type = EventType.TAB;
        } else {
          type = EventType.NOEFFECT;
        }
      } else if (BrowserSupport.isIe()) {
        if (event.type === BrowserEvents.KEY_DOWN_EVENT) {
          if (computedKeyCode === KeyCodes.KEY_BACKSPACE || computedKeyCode === KeyCodes.KEY_DELETE) {
            return EventType.DELETE;
          }
          if (computedKeyCode === KeyCodes.KEY_TAB) return EventType.TAB;
          if (computedKeyCode === KeyCodes.KEY_ENTER) return EventType.LINE;
          return EventType.NOEFFECT;
        } else if (event.type === BrowserEvents.KEY_PRESS_EVENT) {
          if (computedKeyCode === KeyCodes.KEY_ESCAPE || ((event.ctrlKey || event.metaKey) && !event.altKey)) {
            return EventType.NOEFFECT;
          }
          return EventType.INPUT;
        }
      } else {
        type = EventType.DANGEROUS;
      }
      return type;
    };

    Editor.prototype._getCurrentElement = function(node, offset) {
      var element, leftNode, prevElement, rightNode;
      if (DomUtils.isTextNode(node)) {
        prevElement = this._renderer.getPreviousElement(node);
        if (prevElement !== node.parentNode) {
          offset = this._renderer.getElementLength(prevElement);
        }
        return [prevElement, offset];
      }
      rightNode = node.childNodes[offset];
      if (rightNode) {
        element = this._renderer.getPreviousElement(rightNode);
        if (!element) return [this._container.firstChild, 1];
        if (DomUtils.isTextNode(rightNode) && element === rightNode.parentNode) {
          return [element, 0];
        }
        return [element, this._renderer.getElementLength(element)];
      }
      leftNode = node.childNodes[offset - 1] || node;
      if (leftNode) {
        leftNode = this._renderer.getDeepestLastNode(leftNode);
        element = (this._renderer.getElementType(leftNode)) != null ? leftNode : this._renderer.getPreviousElement(leftNode);
        if (!element) return [this._container.firstChild, 1];
        return [element, this._renderer.getElementLength(element)];
      }
      console.error(node, offset);
      throw 'could not determine real node';
    };

    Editor.prototype._getOffsetBefore = function(node) {
      var offset;
      offset = 0;
      while (node = this._renderer.getPreviousElement(node)) {
        offset += this._renderer.getElementLength(node);
      }
      return offset;
    };

    Editor.prototype._getOffsetsBefore = function(startElement, endElement) {
      var countStart, elementLength, endOffset, isCollapsed, startOffset;
      startOffset = 0;
      endOffset = 0;
      isCollapsed = startElement === endElement;
      countStart = false;
      while (endElement = this._renderer.getPreviousElement(endElement)) {
        elementLength = this._renderer.getElementLength(endElement);
        endOffset += elementLength;
        if (!isCollapsed && !countStart && endElement === startElement) {
          countStart = true;
          continue;
        }
        if (countStart) startOffset += elementLength;
      }
      if (isCollapsed) startOffset = endOffset;
      return [startOffset, endOffset];
    };

    Editor.prototype._getElementsAndOffsets = function(range) {
      var endElement, endOffset, endOffsetBefore, startElement, startOffset, startOffsetBefore, _ref6, _ref7, _ref8;
      _ref6 = this._getCurrentElement(range.startContainer, range.startOffset), startElement = _ref6[0], startOffset = _ref6[1];
      if (range.collapsed) {
        endElement = startElement;
        endOffset = startOffset;
      } else {
        _ref7 = this._getCurrentElement(range.endContainer, range.endOffset), endElement = _ref7[0], endOffset = _ref7[1];
      }
      _ref8 = this._getOffsetsBefore(startElement, endElement), startOffsetBefore = _ref8[0], endOffsetBefore = _ref8[1];
      return [startElement, startOffsetBefore + startOffset, startOffset, endElement, endOffsetBefore + endOffset, endOffset];
    };

    Editor.prototype._getCachedRange = function(clearSelection) {
      var endElement, endIndex, endOffset, range, startElement, startIndex, startOffset, _ref6;
      if (clearSelection == null) clearSelection = true;
      if (this._setRangePaused) return this._cachedRange;
      if (!this._cachedRange) {
        range = SelectionHelper.getRangeInside(this._container);
        if (range) {
          _ref6 = this._getElementsAndOffsets(range), startElement = _ref6[0], startIndex = _ref6[1], startOffset = _ref6[2], endElement = _ref6[3], endIndex = _ref6[4], endOffset = _ref6[5];
          this._cachedRange = new CachedRange(this, startElement, startOffset, startIndex, endElement, endOffset, endIndex);
        } else {
          this._cachedRange = null;
        }
      }
      if (clearSelection && this._cachedRange) SelectionHelper.clearSelection();
      return this._cachedRange;
    };

    Editor.prototype._realSetCachedRange = function() {
      var endElement, startElement;
      if (this._setRangeTimeoutId != null) {
        this._setRangeTimeoutId = clearTimeout(this._setRangeTimeoutId);
      }
      if (!this._cachedRange) return;
      startElement = this._cachedRange.getStartElement();
      endElement = this._cachedRange.getEndElement();
      try {
        SelectionHelper.setRangeObject(startElement, this._renderer.getElementType(startElement), this._cachedRange.getStartOffset(), endElement, this._renderer.getElementType(endElement), this._cachedRange.getEndOffset());
      } catch (e) {
        console.warn('failed to set range', e, startElement, this._renderer.getElementType(startElement), this._cachedRange.getStartOffset(), endElement, this._renderer.getElementType(endElement), this._cachedRange.getEndOffset());
      }
      this.focus();
      return delete this._cachedRange;
    };

    Editor.prototype._setCachedRange = function(force) {
      if (force == null) force = false;
      if (this._setRangePaused) return;
      if (force) return this._realSetCachedRange();
      if (this._setRangeTimeoutId != null) clearTimeout(this._setRangeTimeoutId);
      return this._setRangeTimeoutId = setTimeout(this._realSetCachedRange, SET_RANGE_TIMEOUT);
    };

    Editor.prototype._clearCachedRange = function() {
      if (this._setRangeTimeoutId != null) {
        this._setRangeTimeoutId = clearTimeout(this._setRangeTimeoutId);
      }
      this._setRangePaused = false;
      if (this._cachedRange) return delete this._cachedRange;
    };

    Editor.prototype._getElementTextParams = function(element) {
      /*
              Возвращает текстовые параметры указанного элемента (для нетекстовых
              элементов возвращает пустые параметры текстового объекта)
              @param element: DomUtils node
              @return: object
      */
      var params;
      if (this._renderer.getElementType(element) === ModelType.TEXT) {
        return this._renderer.getElementParams(element);
      }
      params = {};
      params[ParamsField.TYPE] = ModelType.TEXT;
      return params;
    };

    Editor.prototype._processInChildBlip = function(action) {
      /*
              Когда блип можно только комментировать, для большей части ввода создается дочерний
              блип и ввод производится в него.
      */
      var childBlip, childBlipView, childEditor;
      childBlip = this._getNewChildBlip(true);
      childBlipView = childBlip.getView();
      childEditor = childBlipView.getEditor();
      childEditor.focus();
      return action(childEditor);
    };

    Editor.prototype.insertTextData = function(data, sync) {
      var endElementParams, endElementUrl, key, nextElement, nextElementParams, op, ops, params, prevElement, r, startElement, startElementType, startOffset, value, _ref6,
        _this = this;
      if (sync == null) sync = true;
      data = Utf16Util.traverseString(data);
      if (!data.length) return;
      r = this._getCachedRange();
      if (!r) return;
      if (this._permission === COMMENT_PERMISSION) {
        return this._processInChildBlip(function(editor) {
          if (editor.getPermission() !== EDIT_PERMISSION) return;
          return editor.insertTextData(data);
        });
      }
      if (this._permission !== EDIT_PERMISSION) return;
      ops = [];
      if (!r.isCollapsed() && !Buffer.isAttached()) ops = this._deleteSelection(r);
      startElement = r.getStartElement();
      startElementType = this._renderer.getElementType(startElement);
      startOffset = r.getStartOffset();
      if (data in SPECIAL_INPUT && (data !== '@' || startElementType !== ModelType.TEXT || startOffset === 0 || startElement.textContent.charAt(startOffset - 1).match(/^\W/)) && (data !== '~' || require('../account_setup_wizard/processor').instance.isBusinessUser())) {
        if (ops.length) this._submitOps(ops);
        if (sync) {
          this[SPECIAL_INPUT[data]]();
        } else {
          setTimeout(function() {
            return _this[SPECIAL_INPUT[data]]();
          }, 0);
        }
        return;
      }
      params = this._getElementTextParams(startElement);
      _ref6 = this._modifiers;
      for (key in _ref6) {
        value = _ref6[key];
        if (value === null) {
          delete params[key];
        } else {
          params[key] = value;
        }
      }
      if (params[TextLevelParams.URL] != null) {
        if (!startOffset) {
          if ((prevElement = this._renderer.getPreviousElement(startElement))) {
            if (this._renderer.getElementParams(prevElement)[TextLevelParams.URL] !== params[TextLevelParams.URL]) {
              delete params[TextLevelParams.URL];
            }
          } else {
            delete params[TextLevelParams.URL];
          }
        }
      }
      if (params[TextLevelParams.URL] != null) {
        endElementParams = this._renderer.getElementParams(r.getEndElement());
        endElementUrl = endElementParams[TextLevelParams.URL];
        if (endElementUrl !== params[TextLevelParams.URL]) {
          delete params[TextLevelParams.URL];
        } else {
          if (r.getEndOffset() === this._renderer.getElementLength(r.getEndElement())) {
            if ((nextElement = this._renderer.getNextElement(r.getEndElement()))) {
              nextElementParams = this._renderer.getElementParams(nextElement);
              if (nextElementParams[TextLevelParams.URL] !== params[TextLevelParams.URL]) {
                delete params[TextLevelParams.URL];
              }
            } else {
              delete params[TextLevelParams.URL];
            }
          }
        }
      }
      op = {
        p: r.getStartIndex(),
        ti: data,
        params: params
      };
      ops.push(op);
      return this._submitOps(ops);
    };

    Editor.prototype._lineIsEmpty = function(line) {
      /*
              Возвращает true, если переданный параграф является пустым
              @param line: HTMLElement
              @return: boolean
      */
      var next;
      next = this._renderer.getNextElement(line);
      if (next == null) return true;
      return this._renderer.getElementType(next) === ModelType.LINE;
    };

    Editor.prototype._handleNewLine = function() {
      var op, params, prevLine, prevParams, range;
      range = this._getCachedRange();
      if (!range) return;
      if (this._permission === COMMENT_PERMISSION) {
        return this._processInChildBlip(function() {});
      }
      if (this._permission !== EDIT_PERMISSION) return;
      prevLine = this._renderer.getParagraphNode(range.getStartElement());
      prevParams = this._renderer.getElementParams(prevLine);
      params = {};
      if (prevParams[LineLevelParams.BULLETED] != null) {
        params[LineLevelParams.BULLETED] = prevParams[LineLevelParams.BULLETED];
      } else if (prevParams[LineLevelParams.NUMBERED] != null) {
        params[LineLevelParams.NUMBERED] = prevParams[LineLevelParams.NUMBERED];
      }
      if (this._lineIsEmpty(prevLine) && ((prevParams[LineLevelParams.BULLETED] != null) || (prevParams[LineLevelParams.NUMBERED] != null))) {
        op = {
          p: range.getStartIndex() - 1,
          len: 1,
          paramsd: params
        };
      } else {
        params[ParamsField.TYPE] = ModelType.LINE;
        params[ParamsField.RANDOM] = Math.random();
        op = {
          p: range.getStartIndex(),
          ti: ' ',
          params: params
        };
      }
      return this._submitOp(op);
    };

    Editor.prototype._handleTab = function(shiftKey) {
      /*
              Обрабатывает нажатие на tab
      */
      var diff, line, ops, range;
      if (this._permission !== EDIT_PERMISSION) return;
      range = this._getCachedRange();
      if (!range) return;
      diff = shiftKey ? -1 : 1;
      line = this._renderer.getParagraphNode(range.getStartElement());
      ops = this._getSelectionOps(this._getOffsetBefore(line), line, 0, range.getEndElement(), range.getEndOffset(), SelectionAction.UPDATE_SELECTION_INDENT, diff);
      if (!ops) return;
      return this._submitOps(ops);
    };

    Editor.prototype._getDeleteOp = function(element, index, textOffset, length) {
      /*
              Генерирует операцию удаления
              @param element: HTMLNode - элемент, в котором будет происходить удаление
              @param index: int - индекс, по которому будет происходить удаление
              @param length: int - обязательный параметр для удаления текста, при удалении элементов остальных
                      типов не будет использован
      */
      var op, type;
      type = this._renderer.getElementType(element);
      op = {
        p: index,
        params: this._renderer.getElementParams(element)
      };
      switch (type) {
        case ModelType.TEXT:
          op.td = element.firstChild.data.substr(textOffset, length);
          break;
        default:
          op.td = ' ';
      }
      return op;
    };

    Editor.prototype._deleteNext = function(element, offset, index) {
      var nextElement, type;
      if (!index || !element) return [];
      if (offset === this._renderer.getElementLength(element)) {
        nextElement = this._renderer.getNextElement(element);
        if (!nextElement) return [];
        return this._deleteNext(nextElement, 0, index);
      }
      type = this._renderer.getElementType(element);
      switch (type) {
        case ModelType.TEXT:
          return [this._getDeleteOp(element, index, offset, 1)];
        case ModelType.LINE:
          return this._deleteLine(element, index);
        default:
          if (this._renderer.getElementType(element) === ModelType.BLIP) return [];
          return [this._getDeleteOp(element, index)];
      }
    };

    Editor.prototype._deletePrev = function(element, offset, index) {
      var lineParams, params, prevElement, type;
      type = this._renderer.getElementType(element);
      if (type === ModelType.LINE) {
        lineParams = this._renderer.getElementParams(element);
        if ((lineParams[LineLevelParams.BULLETED] != null) || (lineParams[LineLevelParams.NUMBERED] != null)) {
          params = {};
          if (lineParams[LineLevelParams.BULLETED] != null) {
            params[LineLevelParams.BULLETED] = lineParams[LineLevelParams.BULLETED];
          } else {
            params[LineLevelParams.NUMBERED] = lineParams[LineLevelParams.NUMBERED];
          }
          return [
            {
              p: index,
              len: 1,
              paramsd: params
            }
          ];
        }
        return this._deleteLine(element, index);
      }
      if (!offset) {
        prevElement = this._renderer.getPreviousElement(element);
        if (!prevElement) return [];
        return this._deletePrev(prevElement, this._renderer.getElementLength(prevElement), index);
      }
      if (!index) return [];
      switch (type) {
        case ModelType.TEXT:
          return [this._getDeleteOp(element, index, offset - 1, 1)];
        case ModelType.BLIP:
          return [];
        default:
          return [this._getDeleteOp(element, index)];
      }
    };

    Editor.prototype._isLineWithoutParams = function(line) {
      var params, type;
      if (!(line != null)) return false;
      type = this._renderer.getElementType(line);
      if (type !== ModelType.LINE) return false;
      params = this._renderer.getElementParams(line);
      return !((params[LineLevelParams.BULLETED] != null) || (params[LineLevelParams.NUMBERED] != null));
    };

    Editor.prototype._deleteLine = function(line, index) {
      var curParams, params, prevElement, res;
      if (!index) return [];
      res = [this._getDeleteOp(line, index)];
      prevElement = this._renderer.getPreviousElement(line);
      if (this._isLineWithoutParams(prevElement)) {
        curParams = this._renderer.getElementParams(line);
        if ((curParams[LineLevelParams.BULLETED] != null) || (curParams[LineLevelParams.NUMBERED] != null)) {
          params = {};
          if (curParams[LineLevelParams.BULLETED] != null) {
            params[LineLevelParams.BULLETED] = curParams[LineLevelParams.BULLETED];
          } else {
            params[LineLevelParams.NUMBERED] = curParams[LineLevelParams.NUMBERED];
          }
          res.push({
            p: index - 1,
            len: 1,
            paramsi: params
          });
        }
      }
      return res;
    };

    Editor.prototype._getTextMarkupOps = function(element, index, length, param, value) {
      var op, ops, params, type;
      ops = [];
      if (!TextLevelParams.isValid(param)) {
        throw new Error("Bad text param is set: " + param + ", " + value);
      }
      type = this._renderer.getElementType(element);
      if (type !== ModelType.TEXT) return ops;
      params = this._renderer.getElementParams(element);
      if (params[param] === value) return ops;
      if (params[param] != null) {
        op = {
          p: index,
          len: length,
          paramsd: {}
        };
        op.paramsd[param] = params[param];
        ops.push(op);
      }
      if (value != null) {
        op = {
          p: index,
          len: length,
          paramsi: {}
        };
        op.paramsi[param] = value;
        ops.push(op);
      }
      return ops;
    };

    Editor.prototype._getClearTextMarkupOps = function(element, index, length) {
      var op, ops, param, params, type;
      ops = [];
      type = this._renderer.getElementType(element);
      if (type !== ModelType.TEXT) return ops;
      params = this._renderer.getElementParams(element);
      for (param in params) {
        if (param === ParamsField.TYPE) continue;
        if (param === TextLevelParams.URL) continue;
        op = {
          p: index,
          len: length,
          paramsd: {}
        };
        op.paramsd[param] = params[param];
        ops.push(op);
      }
      return ops;
    };

    Editor.prototype._getLineMarkupOps = function(element, index, param, value) {
      var op, ops, p, params, prevVal, type, _i, _len, _ref6;
      ops = [];
      if (!LineLevelParams.isValid(param)) {
        throw new Error("Bad line param is set: " + param + ", " + value);
      }
      type = this._renderer.getElementType(element);
      if (type !== ModelType.LINE) return ops;
      params = this._renderer.getElementParams(element);
      _ref6 = [LineLevelParams.BULLETED, LineLevelParams.NUMBERED];
      for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
        p = _ref6[_i];
        if (params[p] == null) continue;
        prevVal = params[p];
        op = {
          p: index,
          len: 1,
          paramsd: {}
        };
        op.paramsd[p] = prevVal;
        ops.push(op);
      }
      if (value != null) {
        op = {
          p: index,
          len: 1,
          paramsi: {}
        };
        op.paramsi[param] = prevVal && !value ? prevVal : value;
        ops.push(op);
      }
      return ops;
    };

    Editor.prototype._getLineIndentUpdateOps = function(element, index, indent) {
      var lvl, newValue, op, ops, param, params, type;
      ops = [];
      type = this._renderer.getElementType(element);
      if (type !== ModelType.LINE) return ops;
      params = this._renderer.getElementParams(element);
      if ((lvl = params[LineLevelParams.BULLETED]) != null) {
        param = LineLevelParams.BULLETED;
      } else if ((lvl = params[LineLevelParams.NUMBERED]) != null) {
        param = LineLevelParams.NUMBERED;
      } else {
        return ops;
      }
      newValue = Math.max(0, lvl + indent);
      if (newValue === lvl) return ops;
      op = {
        p: index,
        len: 1,
        paramsd: {}
      };
      op.paramsd[param] = params[param];
      ops.push(op);
      op = {
        p: index,
        len: 1,
        paramsi: {}
      };
      op.paramsi[param] = newValue;
      ops.push(op);
      return ops;
    };

    Editor.prototype._getCopyElementOp = function(element, offset, length) {
      var blipParams, childBlip, childModel, ops, params, type, _name;
      type = this._renderer.getElementType(element);
      if (!type) return null;
      switch (type) {
        case ModelType.TEXT:
          return {
            ti: element.firstChild.data.substr(offset, length),
            params: this._renderer.getElementParams(element)
          };
        case ModelType.BLIP:
          childBlip = this._getChildBlip(element['__rizzoma_id']);
          if (!childBlip) return null;
          ops = childBlip.getView().getEditor().getCopyContentOps();
          childModel = childBlip.getModel();
          blipParams = {
            isFoldedByDefault: childModel.isFoldedByDefault(),
            contributors: childModel.getContributors(),
            sourceBlipId: childModel.getServerId()
          };
          params = this._renderer.getElementParams(element);
          params[_name = ParamsField.THREAD_ID] || (params[_name] = params[ParamsField.ID]);
          return {
            ti: ' ',
            params: params,
            ops: ops,
            blipParams: blipParams
          };
        case ModelType.LINE:
        case ModelType.ATTACHMENT:
        case ModelType.FILE:
        case ModelType.RECIPIENT:
          params = this._renderer.getElementParams(element);
          if (type === ModelType.FILE) {
            params[ParamsField.URL] = element.getAttribute('rzUrl') || '';
          }
          return {
            ti: ' ',
            params: params
          };
        default:
          params = this._renderer.getElementParams(element);
          if (type === ModelType.FILE) {
            params[ParamsField.URL] = element.getAttribute('rzUrl') || '';
          }
          return {
            ti: ' ',
            params: params
          };
      }
    };

    Editor.prototype._processSelection = function(startIndex, endIndex, endElement, endOffset, action, param, value) {
      /*
              Для указанного выделения возвращает результаты, полученные одним из действий:
              SelectionAction.DELETE: удаление, возвращает ShareJS-операции удаления
              SelectionAction.TEXT: изменение параметров текста, возввращает ShareJS-операции
                  маркировки текста
              SelectionAction.LINE: изменение парметров абзацев, возвращает ShareJS-операции
                  маркировки абзацев
              SelectionAction.GETTEXTPARAMS: текстовые параметры, возвращает массив объектов параметров
                  для всех текстовых блоков внутри выделения
              SelectionAction.GETLINEPARAMS: абзацевые параметры. возвращает массив объектов параметров
                  для всех абзацев, содержащих выделение
              SelectionAction.GETLINEPARAMS: обновление абзацевых параметров
              SelectionAction.CLEARTEXTPARAMS: удаление параметров текста, возвращает ShareJS-операции
                  удаления маркировки текста (кроме ссылок)
              @param startIndex: int - начальное смещение
              @param endIndex: int - конечное смещение (не включая элемент по смещению)
              @param endElement: HTMLElement - элемент, на который попадает конец выделения (включен в выделение)
              @param action: SelectionAction - действие, которое будет совершаться над выделением
              @param param: имя параметра для маркировки (только для действий по маркировке выделения)
              @param value: значение параметра для маркировки (только для действий по маркировке веделения)
              @returns: [object]
      */
      var endElementLength, index, op, ops, params, res, selectionLength, type, workingLength;
      if (!endOffset) {
        endElement = this._renderer.getPreviousElement(endElement);
        endOffset = this._renderer.getElementLength(endElement);
      }
      res = [];
      selectionLength = endIndex - startIndex;
      while (selectionLength) {
        params = this._renderer.getElementParams(endElement);
        type = this._renderer.getElementType(endElement);
        endElementLength = this._renderer.getElementLength(endElement);
        endOffset || (endOffset = endElementLength);
        workingLength = Math.min(Math.min(selectionLength, endElementLength), endOffset);
        index = endIndex - workingLength;
        switch (action) {
          case SelectionAction.DELETE:
            ops = [this._getDeleteOp(endElement, index, endOffset - workingLength, workingLength)];
            break;
          case SelectionAction.TEXT:
            ops = this._getTextMarkupOps(endElement, index, workingLength, param, value);
            break;
          case SelectionAction.LINE:
            ops = this._getLineMarkupOps(endElement, index, param, value);
            break;
          case SelectionAction.CLEARTEXTPARAMS:
            ops = this._getClearTextMarkupOps(endElement, index, workingLength);
            break;
          case SelectionAction.GETTEXTPARAMS:
            type = this._renderer.getElementType(endElement);
            if (type === ModelType.TEXT) {
              ops = [this._renderer.getElementParams(endElement)];
            } else {
              ops = null;
            }
            break;
          case SelectionAction.GETLINEPARAMS:
            type = this._renderer.getElementType(endElement);
            if (type === ModelType.LINE) {
              ops = [this._renderer.getElementParams(endElement)];
            } else {
              ops = null;
            }
            break;
          case SelectionAction.COPY_CONTENT:
            op = this._getCopyElementOp(endElement, endOffset - workingLength, workingLength);
            if (op) ops = [op];
        }
        while (ops && ops.length) {
          if (action === SelectionAction.TEXT || action === SelectionAction.COPY_CONTENT) {
            res.unshift(ops.pop());
          } else {
            res.push(ops.shift());
          }
        }
        endIndex -= workingLength;
        selectionLength -= workingLength;
        endOffset = null;
        endElement = this._renderer.getPreviousElement(endElement);
      }
      return res;
    };

    Editor.prototype._getSelectionOps = function(startIndex, startElement, startOffset, endElement, endOffset, action, param, value) {
      var needBreak, op, ops, res, workingLength;
      if (startOffset === this._renderer.getElementLength(startElement)) {
        startElement = this._renderer.getNextElement(startElement);
        startOffset = 0;
      }
      if (!endOffset) {
        endElement = this._renderer.getPreviousElement(endElement);
        endOffset = this._renderer.getElementLength(endElement);
      }
      res = [];
      while (startElement) {
        if (startElement === endElement) {
          needBreak = true;
          workingLength = endOffset - startOffset;
        } else {
          workingLength = this._renderer.getElementLength(startElement) - startOffset;
        }
        switch (action) {
          case SelectionAction.TEXT:
            ops = this._getTextMarkupOps(startElement, startIndex, workingLength, param, value);
            break;
          case SelectionAction.COPY_CONTENT:
            op = this._getCopyElementOp(startElement, startOffset, workingLength);
            if (op) ops = [op];
            break;
          case SelectionAction.UPDATE_SELECTION_INDENT:
            ops = this._getLineIndentUpdateOps(startElement, startIndex, param);
            break;
          default:
            return res;
        }
        startIndex += workingLength;
        while (ops && ops.length) {
          res.push(ops.shift());
        }
        startOffset = 0;
        startElement = this._renderer.getNextElement(startElement);
        if (needBreak) break;
      }
      return res;
    };

    Editor.prototype._deleteSelection = function(range) {
      /*
              @param range: CachedRange
      */      return this._processSelection(range.getStartIndex(), range.getEndIndex(), range.getEndElement(), range.getEndOffset(), SelectionAction.DELETE);
    };

    Editor.prototype._handleDelete = function(event) {
      var direction, isDelete, ops, range, sel;
      if (this._permission !== EDIT_PERMISSION) return;
      range = this._getCachedRange(false);
      if (!range) return;
      if (!range.isCollapsed()) return this._handleRangeDelete();
      isDelete = event.keyCode === KeyCodes.KEY_DELETE;
      if (event.ctrlKey) {
        direction = isDelete ? 'right' : 'left';
        sel = window.getSelection();
        sel.modify('extend', direction, 'word');
        this._cachedRange = null;
        return this._handleRangeDelete();
      }
      if (isDelete) {
        ops = this._deleteNext(range.getStartElement(), range.getStartOffset(), range.getStartIndex());
      } else {
        ops = this._deletePrev(range.getStartElement(), range.getStartOffset(), range.getStartIndex() - 1);
      }
      if (ops.length) return this._submitOps(ops);
    };

    Editor.prototype._handleRangeDelete = function() {
      var ops, range;
      range = this._getCachedRange(false);
      if (!range || range.isCollapsed()) return;
      ops = this._deleteSelection(range);
      if (ops.length) return this._submitOps(ops);
    };

    Editor.prototype._isValidLineForDrop = function(par, top, checkStartLine) {
      var prev;
      if (this._permission !== EDIT_PERMISSION) return false;
      if (DRAG_START_LINE === par && checkStartLine) return false;
      if (DomUtils.contains(DRAG_START_LINE, par)) return false;
      if (top && (prev = this._renderer.getPreviousElement(par)) && this._renderer.getParagraphNode(prev) === DRAG_START_LINE) {
        return false;
      } else if (!top) {
        while ((par = this._renderer.getNextElement(par))) {
          if (this._renderer.getElementType(par) === ModelType.LINE) break;
        }
        if (par && par === DRAG_START_LINE) return false;
      }
      return true;
    };

    Editor.prototype._removeDragStartLine = function() {
      var additionalOps, endElement, endIndex, endOffset, lineParams, next, nextLine, ops, processParams, startIndex;
      if (!DRAG_START_LINE.parentNode) return;
      startIndex = this._getOffsetBefore(DRAG_START_LINE);
      endElement = DRAG_START_LINE;
      endIndex = startIndex + 1;
      endOffset = 1;
      next = DRAG_START_LINE;
      nextLine = null;
      while ((next = this._renderer.getNextElement(next))) {
        if (this._renderer.getElementType(next) === ModelType.LINE) {
          nextLine = next;
          break;
        }
        endOffset = this._renderer.getElementLength(next);
        endIndex += endOffset;
        endElement = next;
      }
      additionalOps = [];
      processParams = function(arr, lineParams, action) {
        var op, param, params, _i, _len, _ref6, _results;
        _ref6 = [LineLevelParams.BULLETED, LineLevelParams.NUMBERED];
        _results = [];
        for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
          param = _ref6[_i];
          if (lineParams[param] == null) continue;
          op = {
            p: 0,
            len: 1
          };
          params = {};
          params[param] = lineParams[param];
          op[action] = params;
          _results.push(arr.push(op));
        }
        return _results;
      };
      if (startIndex === 0) {
        startIndex = 1;
        lineParams = this._renderer.getElementParams(DRAG_START_LINE);
        processParams(additionalOps, lineParams, 'paramsd');
        if (nextLine) {
          endElement = nextLine;
          endIndex += 1;
          lineParams = this._renderer.getElementParams(nextLine);
          processParams(additionalOps, lineParams, 'paramsi');
        }
      }
      ops = this._processSelection(startIndex, endIndex, endElement, endOffset, SelectionAction.DELETE).concat(additionalOps);
      this._clearCachedRange();
      SelectionHelper.clearSelection();
      if (ops != null ? ops.length : void 0) return this._submitOps(ops);
    };

    Editor.prototype._processDragStartEvent = function(e) {
      var dragEnd, dragOffset, dragStartIndex, dt, next, ops, par;
      e.stopPropagation();
      if (this._permission !== EDIT_PERMISSION) return e.preventDefault();
      par = this._renderer.getParagraphNode(e.target);
      if (!DomUtils.hasClass(e.target, 'js-draggable-marker') || par.parentNode !== this._container) {
        clearDragProps();
        return e.preventDefault();
      }
      DRAG_START_LINE = par;
      LAST_DRAG_OP = DRAG_TYPE_MARKER;
      LAST_DRAG_OVER_CLASS = void 0;
      DRAG_CALL_ME_LATER = this._removeDragStartLine;
      this.emit('copy');
      dragEnd = par;
      dragOffset = 1;
      dragStartIndex = this._getOffsetBefore(dragEnd);
      while ((next = this._renderer.getNextElement(dragEnd))) {
        if (this._renderer.getElementType(next) === ModelType.LINE) break;
        dragOffset = this._renderer.getElementLength(next);
        dragEnd = next;
      }
      dt = e.dataTransfer;
      try {
        ops = this._getSelectionOps(dragStartIndex, par, 0, dragEnd, dragOffset, SelectionAction.COPY_CONTENT);
        dt.setData('text/rizzoma', JSON.stringify(ops));
      } catch (err) {
        console.warn(err);
        clearDragProps();
        return e.preventDefault();
      }
      dt.effectsAllowed = 'move';
      if (dt.addElement) {
        return dt.addElement(this._renderer.getParagraphNode(e.target));
      }
    };

    Editor.prototype._processDragEndEvent = function(e) {
      e.stopPropagation();
      return clearDragProps();
    };

    Editor.prototype._findDropTarget = function(target, y) {
      var child, els, i, par, r, _len;
      if (target === this._container) {
        els = this._container.children;
        for (i = 0, _len = els.length; i < _len; i++) {
          child = els[i];
          r = child.getBoundingClientRect();
          if (!i && y < r.top) return updateDragView(child);
          if (y < r.bottom) return updateDragView(child);
        }
        if (els.length) return updateDragView(els[els.length - 1]);
      }
      par = this._renderer.getParagraphNode(target);
      if (par.parentNode === this._container) {
        return updateDragView(par);
      } else {
        return clearDragView();
      }
    };

    Editor.prototype._processDragEnterEvent = function(e) {
      if (LAST_DRAG_OP !== DRAG_TYPE_MARKER) return;
      if (e.defaultPrevented) return;
      e.preventDefault();
      DRAG_COUNT++;
      return this._findDropTarget(e.target, e.clientY);
    };

    Editor.prototype._processDragLeaveEvent = function(e) {
      if (LAST_DRAG_OP !== DRAG_TYPE_MARKER) return;
      if (e.defaultPrevented1) return;
      e.defaultPrevented1 = true;
      DRAG_COUNT--;
      if (!DRAG_COUNT) return clearDragView();
    };

    Editor.prototype._processDragOverEvent = function(e) {
      var cl, dt, r, top;
      e.stopPropagation();
      e.preventDefault();
      if (LAST_DRAG_OP === DRAG_TYPE_MARKER) {
        this._findDropTarget(e.target, e.clientY);
        dt = e.dataTransfer;
        if (!LAST_DRAG_OVER) return dt.dropEffect = 'none';
        top = isDragToTop(e.clientY);
        cl = "drag-over-" + (top ? 'top' : 'bottom');
        if (this._isValidLineForDrop(LAST_DRAG_OVER, top, false)) {
          dt.dropEffect = 'move';
        } else {
          dt.dropEffect = 'none';
          return clearDragView();
        }
        if (cl !== LAST_DRAG_OVER_CLASS) {
          DomUtils.removeClass(LAST_DRAG_OVER, LAST_DRAG_OVER_CLASS);
          DomUtils.addClass(LAST_DRAG_OVER, LAST_DRAG_OVER_CLASS = cl);
        }
        return;
      }
      try {
        r = SelectionHelper.getRangeFromPoint(e.clientX, e.clientY, this._container);
      } catch (_error) {}
      if (!r) return e.dataTransfer.dropEffect = 'none';
      this._clearCachedRange();
      SelectionHelper.setRange(r);
      r = this._getCachedRange();
      return e.dataTransfer.dropEffect = r ? 'copy' : 'none';
    };

    Editor.prototype.processDropEvent = function(event, r) {
      var data, index, next, top, _ref6,
        _this = this;
      if (event.defaultPrevented) return;
      event.preventDefault();
      if (!event.defaultPrevented) event.defaultPrevented = true;
      if (LAST_DRAG_OP === DRAG_TYPE_MARKER && (data = JSON.parse(event.dataTransfer.getData('text/rizzoma')))) {
        if (!LAST_DRAG_OVER) return;
        top = isDragToTop(event.clientY);
        if (!this._isValidLineForDrop(LAST_DRAG_OVER, top, true)) return;
        index = this._getOffsetBefore(LAST_DRAG_OVER);
        if (!top) {
          index += 1;
          next = LAST_DRAG_OVER;
          while ((next = this._renderer.getNextElement(next))) {
            if (this._renderer.getElementType(next) === ModelType.LINE) break;
            index += this._renderer.getElementLength(next);
          }
        }
        try {
          this._insertOps(index, data);
          DRAG_CALL_ME_LATER();
          clearDragProps();
        } catch (e) {
          this.emit('error', e);
        }
        return;
      }
      if (!r) {
        try {
          r = SelectionHelper.getRangeFromPoint(event.clientX, event.clientY, this._container);
        } catch (_error) {}
        this._clearCachedRange();
        SelectionHelper.setRange(r);
      }
      r = this._getCachedRange();
      if (!r) return;
      if (this._permission === COMMENT_PERMISSION) {
        return this._processInChildBlip(function(editor) {
          if (editor.getPermission() !== EDIT_PERMISSION) return;
          editor.setCursorToStart();
          return editor.processDropEvent(event, r);
        });
      }
      if (this._permission !== EDIT_PERMISSION) return;
      this._pauseSetRange();
      return (_ref6 = getUploadForm()) != null ? _ref6.openImmediateUpload(this, event.dataTransfer.files, function() {
        return _this._resumeSetRange(true, true);
      }) : void 0;
    };

    Editor.prototype._processPasteEvent = function(event) {
      var cancel;
      event.stopPropagation();
      if (!this._editable) return event.preventDefault();
      try {
        cancel = this.handlePasteEvent(event);
      } catch (e) {
        cancel = true;
        console.warn(e);
      }
      if (cancel) return event.preventDefault();
    };

    Editor.prototype._processCutEvent = function(event) {
      var cancel;
      event.stopPropagation();
      try {
        cancel = this._handleCut(event);
      } catch (e) {
        cancel = true;
        console.warn(e);
      }
      if (cancel) return event.preventDefault();
    };

    Editor.prototype._processCopyEvent = function(event) {
      var cancel;
      event.stopPropagation();
      try {
        cancel = this._handleCopy(event);
      } catch (e) {
        cancel = true;
        console.warn('copy processing failed', e);
      }
      if (cancel) return event.preventDefault();
    };

    Editor.prototype._renderOpsForCopy = function(copyOps, textData) {
      var container;
      container = document.createElement('span');
      if (container.dataset) {
        container.dataset[DATA_VARS.CLIPBOARD] = 'true';
      } else {
        container.setAttribute(DATA_ATTRS.CLIPBOARD, 'true');
      }
      this._renderer.renderOps(copyOps, container, textData);
      return container;
    };

    Editor.prototype._handleClipboardCopy = function(range, clipboardData) {
      var container, ops, textData;
      ops = this._getSelectionOps(range.getStartIndex(), range.getStartElement(), range.getStartOffset(), range.getEndElement(), range.getEndOffset(), SelectionAction.COPY_CONTENT);
      textData = [];
      container = this._renderOpsForCopy(ops, textData);
      clipboardData.setData('text/rizzoma', JSON.stringify(ops));
      clipboardData.setData('text/html', container.outerHTML);
      return clipboardData.setData('text/plain', textData.join(''));
    };

    Editor.prototype._handleHtmlCopy = function(range, removeSelection) {
      var container, copyOps, ops;
      copyOps = this._getSelectionOps(range.getStartIndex(), range.getStartElement(), range.getStartOffset(), range.getEndElement(), range.getEndOffset(), SelectionAction.COPY_CONTENT);
      if (removeSelection) {
        ops = this._deleteSelection(range);
        if (ops.length) this._submitOps(ops);
      }
      this.pauseSetRange();
      container = this._renderOpsForCopy(copyOps, null);
      Buffer.setFragmentContent(container);
      Buffer.selectAll();
      return Buffer.onTextChange(this._finishHtmlDataCopy);
    };

    Editor.prototype._finishHtmlDataCopy = function() {
      return this.resumeSetRange(true, true);
    };

    Editor.prototype._handleCopy = function(event) {
      var range;
      range = this._getCachedRange(false);
      if (!range || range.isCollapsed()) return false;
      this.emit('copy');
      if (event.clipboardData) {
        this._handleClipboardCopy(range, event.clipboardData);
        return true;
      }
      this._handleHtmlCopy(range, false);
      return false;
    };

    Editor.prototype._handleCut = function(event) {
      var ops, range;
      range = this._getCachedRange();
      if (!range || range.isCollapsed()) return true;
      this.emit('copy');
      if (event.clipboardData) {
        this._handleClipboardCopy(range, event.clipboardData);
        if (this._permission === EDIT_PERMISSION && this._editable && !range.isCollapsed()) {
          ops = this._deleteSelection(range);
          if (ops.length) this._submitOps(ops);
        }
        return true;
      }
      this._handleHtmlCopy(range, this._permission === EDIT_PERMISSION && this._editable);
      return false;
    };

    Editor.prototype._getBlockParamsChangeOps = function(p, len, fromParams, toParams) {
      /*
              Возвращает операции, необходимые для замены одних параметров другими
              @param pos: int
              @param len: int
              @param fromParams: {key: value}, исходные параметры
              @param toParams: {key: value}, конечные параметры
      */
      var name, paramsd, paramsi, res, value;
      res = [];
      for (name in toParams) {
        value = toParams[name];
        if (!LineLevelParams.isValid(name)) continue;
        if (name === 'RANDOM') continue;
        if (value === fromParams[name]) continue;
        if (fromParams[name] != null) {
          paramsd = {};
          paramsd[name] = fromParams[name];
          res.push({
            p: p,
            len: len,
            paramsd: paramsd
          });
        }
        if (toParams[name] != null) {
          paramsi = {};
          paramsi[name] = value;
          res.push({
            p: p,
            len: len,
            paramsi: paramsi
          });
        }
      }
      for (name in fromParams) {
        value = fromParams[name];
        if (!LineLevelParams.isValid(name)) continue;
        if (name in toParams) continue;
        paramsd = {};
        paramsd[name] = value;
        res.push({
          p: p,
          len: len,
          paramsd: paramsd
        });
      }
      return res;
    };

    Editor.prototype._getModifiedInsertionOps = function(index, insOps) {
      /*
              Изменяет индекс у всех операций вставки так, чтобы вставка началась с указанного индекса.
              Не генерирует операций для вложенных блипов, помещая их во временные контейнеры.
              @param index: int
              @param insOps: [{p, ti, params}]
              @return: [ops, {index: container}]
      */
      var blipsToInsert, childBlip, childBlipView, curFirstParagraphParams, firstPara, lastBlipThreadId, lastThread, op, ops, params, type, _i, _len;
      ops = [];
      blipsToInsert = {};
      lastThread = null;
      lastBlipThreadId = null;
      if (index === 0) {
        curFirstParagraphParams = this._getSnapshot()[0][ModelField.PARAMS];
        firstPara = insOps.shift();
        if (firstPara[ModelField.PARAMS][ParamsField.TYPE] !== ModelType.LINE) {
          throw new Error("Cannot insert non-paragraph in pos 0");
        }
        index = 1;
        ops = this._getBlockParamsChangeOps(0, 1, curFirstParagraphParams, firstPara[ModelField.PARAMS]);
        insOps.push(firstPara);
      }
      for (_i = 0, _len = insOps.length; _i < _len; _i++) {
        op = insOps[_i];
        params = op[ModelField.PARAMS];
        type = params[ParamsField.TYPE];
        if (type !== ModelType.BLIP) {
          lastThread = null;
          op.p = index;
          ops.push(op);
          if (type !== ModelType.TEXT) {
            op[ModelField.PARAMS][ParamsField.RANDOM] = Math.random();
          }
          index += op.ti.length;
          continue;
        }
        if (!lastThread || lastBlipThreadId !== params[ParamsField.THREAD_ID]) {
          lastBlipThreadId = params[ParamsField.THREAD_ID];
          lastThread = new BlipThread(Math.random());
          if (blipsToInsert[index] == null) blipsToInsert[index] = [];
          blipsToInsert[index].push(lastThread.getContainer());
        }
        childBlip = this._getNewChildBlip(false, op.blipParams, lastThread);
        childBlipView = childBlip.getView();
        lastThread.appendBlipElement(childBlipView.getContainer());
        childBlipView.getEditor().setInitialOps(op.ops);
      }
      if (firstPara != null) {
        ops = ops.concat(this._getBlockParamsChangeOps(index - 1, 1, firstPara[ModelField.PARAMS], curFirstParagraphParams));
      }
      return [ops, blipsToInsert];
    };

    Editor.prototype._insertOps = function(index, insOps) {
      var blipNodes, blipWasInserted, blipsToInsert, ops, range, _ref6;
      _ref6 = this._getModifiedInsertionOps(index, insOps), ops = _ref6[0], blipsToInsert = _ref6[1];
      if (ops.length) this._submitOps(ops);
      range = this._getCachedRange(false);
      blipWasInserted = false;
      for (index in blipsToInsert) {
        blipNodes = blipsToInsert[index];
        blipWasInserted = true;
        this._renderer.insertTemporaryBlipNodes(blipNodes, index, range);
      }
      if (blipWasInserted && range) {
        this._cachedRange = range;
        return this._setCachedRange(true);
      }
    };

    Editor.prototype._handleOpsPaste = function(ops, range) {
      var selOps;
      if (!range.isCollapsed()) {
        selOps = this._deleteSelection(range);
        if (selOps.length) this._submitOps(selOps);
      }
      range = this._getCachedRange();
      return this._insertOps(range.getStartIndex(), ops);
    };

    Editor.prototype._handleClipboardPaste = function(range, clipboardData) {
      var data, fragment, item, ops, parser, skipped, tmpEl, _ref6, _ref7,
        _this = this;
      skipped = false;
      if ((data = clipboardData.getData('text/rizzoma'))) {
        ops = JSON.parse(data);
        this._handleOpsPaste(ops, range);
      } else if ((data = clipboardData.getData('text/html'))) {
        tmpEl = document.createElement('span');
        tmpEl.innerHTML = data;
        fragment = document.createDocumentFragment();
        while (tmpEl.firstChild) {
          fragment.appendChild(tmpEl.firstChild);
        }
        this._handleHtmlPaste(fragment, range);
      } else if (BrowserSupport.isMozilla()) {
        skipped = true;
      } else if ((data = clipboardData.getData('text/plain'))) {
        ops = [];
        if (!range.isCollapsed()) ops = this._deleteSelection(range);
        parser = new TextParser(OpParsedElementProcessor, range.getStartIndex());
        parser.parseText(ops, data);
        if (ops.length) this._submitOps(ops);
      } else if ((/Files/.test(clipboardData.types)) && (item = (_ref6 = clipboardData.items) != null ? _ref6[0] : void 0)) {
        this._pauseSetRange();
        if ((_ref7 = getUploadForm()) != null) {
          _ref7.openImmediateUpload(this, [item.getAsFile()], function() {
            return _this._resumeSetRange(true, true);
          });
        }
      } else {
        skipped = true;
      }
      return skipped;
    };

    Editor.prototype._handleHtmlPaste = function(fragment, range) {
      var frags, htmlParser, offset, ops, parsedOps;
      if (!range) return;
      offset = range.getStartIndex();
      frags = fragment.querySelectorAll("[" + DATA_ATTRS.CLIPBOARD + "=\"true\"]");
      if (frags.length === 1) {
        htmlParser = new HtmlOpParser(offset);
        ops = htmlParser.parse(frags[0], offset);
        if (ops.length) {
          this._handleOpsPaste(ops, range);
          return;
        }
      }
      ops = [];
      if (!range.isCollapsed()) ops = this._deleteSelection(range);
      htmlParser = new HtmlParser(OpParsedElementProcessor, offset);
      parsedOps = htmlParser.parse(fragment);
      while (parsedOps.length) {
        ops.push(parsedOps.shift());
      }
      return this._submitOps(ops);
    };

    Editor.prototype._finishHtmlPaste = function(err, fragment) {
      this.resumeSetRange(true, true);
      if (fragment) return this._handleHtmlPaste(fragment, this._getCachedRange());
    };

    Editor.prototype.handlePasteEvent = function(event) {
      var range, skipped;
      if (BrowserSupport.isIe() && event.type === BrowserEvents.PASTE_EVENT) {
        return true;
      }
      if (this._permission === COMMENT_PERMISSION) {
        return this._processInChildBlip(function(editor) {
          if (editor.getPermission() !== EDIT_PERMISSION) return;
          return editor.handlePasteEvent(event);
        });
      }
      if (this._permission !== EDIT_PERMISSION) return;
      range = this._getCachedRange();
      if (!range) return true;
      if (event.clipboardData && event.clipboardData.getData) {
        skipped = this._handleClipboardPaste(range, event.clipboardData);
        if (!skipped) return true;
      }
      this.pauseSetRange();
      Buffer.setFragmentContent(null);
      Buffer.selectAll();
      Buffer.onTextChange(this._finishHtmlPaste);
      return false;
    };

    Editor.prototype.__scrollIntoCursor = function() {
      var container, elementBottom, elementTop, range, scrollable, waveViewBottom, waveViewTop;
      this._scrollTimer = null;
      range = DomUtils.getRange();
      if (!range || !range.collapsed) return;
      container = range.startContainer;
      if (!(scrollable = this._getScrollableElement()) || !DomUtils.contains(scrollable, container)) {
        return;
      }
      if (DomUtils.isTextNode(container)) container = container.parentNode;
      waveViewTop = scrollable.getBoundingClientRect().top;
      elementTop = container.getBoundingClientRect().top;
      if (waveViewTop > elementTop) {
        return DomUtils.scrollTargetIntoViewWithAnimation(container, scrollable, true, SCROLL_INTO_VIEW_OFFSET);
      }
      waveViewBottom = waveViewTop + scrollable.offsetHeight;
      elementBottom = elementTop + container.offsetHeight;
      if (waveViewBottom < elementBottom) return container.scrollIntoView(false);
    };

    Editor.prototype.__scrollCursorIntoView = function() {
      if (DomUtils.isFrameElement(document.activeElement)) return;
      if (this._scrollTimer != null) clearTimeout(this._scrollTimer);
      return this._scrollTimer = setTimeout(this.__scrollIntoCursor, SCROLL_INTO_VIEW_TIMER);
    };

    Editor.prototype._performPostSubmitActions = function(ops, shiftCursor) {
      var _this = this;
      this._flushOpsQueue();
      if (shiftCursor) {
        this.__scrollCursorIntoView();
        this._setCachedRange(true);
      }
      if (this._cursor) {
        setTimeout(function() {
          return _this._processCursor();
        }, 0);
      }
      return this.emit('ops', ops);
    };

    Editor.prototype._submitOp = function(op, shiftCursor) {
      if (shiftCursor == null) shiftCursor = true;
      this._renderer.applyOp(op, this._cachedRange, shiftCursor);
      return this._performPostSubmitActions([op], shiftCursor);
    };

    Editor.prototype._submitOps = function(ops, shiftCursor) {
      if (shiftCursor == null) shiftCursor = true;
      this._renderer.applyOps(ops, this._cachedRange, shiftCursor);
      return this._performPostSubmitActions(ops, shiftCursor);
    };

    Editor.prototype.getRange = function() {
      var endElement, startElement;
      if (this._cachedRange) {
        startElement = this._cachedRange.getStartElement();
        endElement = this._cachedRange.getEndElement();
        return SelectionHelper.getRangeObject(startElement, this._renderer.getElementType(startElement), this._cachedRange.getStartOffset(), endElement, this._renderer.getElementType(endElement), this._cachedRange.getEndOffset());
      } else {
        return SelectionHelper.getRangeInside(this._container);
      }
    };

    Editor.prototype.insertBlip = function(serverBlipId, container, threadId, shiftLeft) {
      /*
              Отправляет операцию вставки указанного блипа в этот
              Возвращает true, если операция была сделана
              @param id: string
              @param container: HTMLNode
              @param threadId: string
              @param shiftLeft: boolean
              @return: boolean
      */
      var cnt, offset, op, params;
      if (!this.containsNode(container)) return false;
      LocalStorage.incRepliesCount();
      cnt = LocalStorage.getRepliesCount();
      if (cnt === 10 || cnt === 20) {
        mixpanel.track(cnt + " replies done", {
          "count": cnt
        });
      }
      offset = this._getOffsetBefore(container);
      params = {};
      params[ParamsField.TYPE] = ModelType.BLIP;
      params[ParamsField.ID] = serverBlipId;
      params[ParamsField.RANDOM] = Math.random();
      params[ParamsField.THREAD_ID] = threadId;
      op = {
        p: offset,
        ti: ' ',
        params: params
      };
      if (shiftLeft) op.shiftLeft = true;
      try {
        this._renderer.setParamsToInlineElement(container, params);
        this.emit('ops', [op]);
      } catch (e) {
        this.emit('error', e);
        return false;
      }
      return true;
    };

    Editor.prototype.removeBlip = function(id) {
      var element, offset, op, params, _results;
      try {
        element = null;
        _results = [];
        while (element = this._renderer.getNextElement(element)) {
          if (this._renderer.getElementType(element) !== ModelType.BLIP) continue;
          params = this._renderer.getElementParams(element);
          if (params[ParamsField.ID] !== id) continue;
          offset = this._getOffsetBefore(element);
          op = {
            p: offset,
            td: ' ',
            params: params
          };
          this._clearCachedRange();
          SelectionHelper.clearSelection();
          this._submitOp(op, false);
          break;
        }
        return _results;
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype.insertAttachment = function(url) {
      var op, params, range;
      range = this._getCachedRange();
      if (!range) return;
      params = {};
      params[ParamsField.TYPE] = ModelType.ATTACHMENT;
      params[ParamsField.URL] = url;
      params[ParamsField.RANDOM] = Math.random();
      op = {
        p: range.getEndIndex(),
        ti: ' ',
        params: params
      };
      try {
        return this._submitOp(op);
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype.insertFile = function(id) {
      var op, params, range;
      range = this._getCachedRange();
      if (!range) return;
      params = {};
      params[ParamsField.ID] = id;
      params[ParamsField.TYPE] = ModelType.FILE;
      params[ParamsField.RANDOM] = Math.random();
      op = {
        p: range.getEndIndex(),
        ti: ' ',
        params: params
      };
      try {
        return this._submitOp(op);
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype._insertAndFocusInlineInput = function(inline) {
      var container, range;
      range = this._getCachedRange();
      container = inline.getContainer();
      this._renderer.preventEventsPropagation(container);
      this._renderer.insertNodeAt(container, range.getEndIndex());
      this._clearCachedRange();
      inline.focus();
      return inline;
    };

    Editor.prototype._destroyInlineInput = function(inlineInput) {
      var offset;
      offset = this._getOffsetBefore(inlineInput.getContainer());
      inlineInput.destroy();
      this.setCursorToStart();
      this._getCachedRange();
      return offset;
    };

    Editor.prototype._bindForEscape = function(container, callback) {
      var _this = this;
      return $(container).bind("blur " + (BrowserEvents.KEY_EVENTS.join(' ')), function(event) {
        if ((event.keyCode != null) && event.keyCode !== KeyCodes.KEY_ESCAPE) {
          return;
        }
        return callback();
      });
    };

    Editor.prototype._cancelInlineInput = function(input, text) {
      var container, offset, op, params, prevElement;
      if (!this._renderer) return input.destroy();
      container = input.getContainer();
      prevElement = this._renderer.getPreviousElement(container);
      params = this._getElementTextParams(prevElement);
      offset = this._getOffsetBefore(container);
      input.destroy();
      if (!text) return this.focus();
      op = {
        p: offset,
        ti: text,
        params: params
      };
      this.setCursorToStart();
      this._getCachedRange();
      return this._submitOp(op);
    };

    Editor.prototype.insertTag = function() {
      /*
              Вставляет поле ввода для тега
      */
      var inputContainer, tagInput,
        _this = this;
      if (!this._getCachedRange()) return;
      if (this._permission === COMMENT_PERMISSION) {
        return this._processInChildBlip(function(editor) {
          if (editor.getPermission() !== EDIT_PERMISSION) return;
          return editor.insertTag();
        });
      }
      if (this._permission !== EDIT_PERMISSION) return;
      try {
        tagInput = this._insertAndFocusInlineInput(new TagInput());
        inputContainer = tagInput.getContainer();
        $(inputContainer).bind('tagInserted', function(event, tagText) {
          return _this._insertTag(tagInput, tagText);
        });
        this._bindForEscape(inputContainer, function() {
          return _this._cancelInlineInput(tagInput, '#' + tagInput.getValue());
        });
        return tagInput;
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype._insertTag = function(tagInput, tagText) {
      var offset, op, params;
      offset = this._destroyInlineInput(tagInput);
      params = {};
      params[ParamsField.TYPE] = ModelType.TAG;
      params[ParamsField.TAG] = tagText;
      params[ParamsField.RANDOM] = Math.random();
      op = {
        p: offset,
        ti: ' ',
        params: params
      };
      return this._submitOp(op);
    };

    Editor.prototype.insertRecipient = function() {
      /*
              Вставляет поле ввода для получателя сообщения
              Создает обработчики потери фокуса и нажатия клавиш.
              При выборе участника удаляет поле ввода и генерирует операцию для вставки получателя
      */
      var recipientContainer, recipientInput,
        _this = this;
      if (!this._getCachedRange()) return;
      if (this._permission === COMMENT_PERMISSION) {
        return this._processInChildBlip(function(editor) {
          if (editor.getPermission() !== EDIT_PERMISSION) return;
          return editor.insertRecipient();
        });
      }
      if (this._permission !== EDIT_PERMISSION) return;
      try {
        recipientInput = this._insertAndFocusInlineInput(this._getRecipientInput());
        recipientContainer = recipientInput.getContainer();
        $(recipientContainer).bind('itemSelected', function(event, userId) {
          var offset;
          if (userId == null) return;
          offset = _this._destroyInlineInput(recipientInput);
          return _this._insertRecipientByUserId(offset, userId);
        });
        $(recipientContainer).bind('emailSelected', function(event, email) {
          return _this._insertRecipientByEmail(recipientInput, email);
        });
        $(recipientContainer).bind('cancel', function(event, text) {
          if (text != null) text = '@' + text;
          return _this._cancelInlineInput(recipientInput, text);
        });
        return recipientInput;
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype.insertTaskRecipient = function() {
      /*
              Вставляет поле ввода для получателя задачи.
              Создает обработчики потери фокуса и нажатия клавиш.
              При заполнении полей удаляет поле ввода и генерирует операцию для вставки получателя.
      */
      var taskRecipientInput,
        _this = this;
      if (!this._getCachedRange()) return;
      if (this._permission === COMMENT_PERMISSION) {
        return this._processInChildBlip(function(editor) {
          if (editor.getPermission() !== EDIT_PERMISSION) return;
          return editor.insertTaskRecipient();
        });
      }
      if (this._permission !== EDIT_PERMISSION) return;
      try {
        taskRecipientInput = this._insertAndFocusInlineInput(this._getTaskRecipientInput());
        taskRecipientInput.on('finish', function(taskParams) {
          var offset, taskRecipientStub;
          offset = _this._getOffsetBefore(taskRecipientInput.getContainer());
          if (taskParams.recipientId != null) {
            _this._destroyInlineInput(taskRecipientInput);
            return _this._insertTaskRecipient(offset, taskParams);
          }
          taskParams.position = offset;
          taskRecipientStub = taskRecipientInput.stub();
          taskRecipientInput.destroy();
          _this.focus();
          return _this._addTaskRecipient(taskParams, function() {
            return taskRecipientStub.destroy();
          });
        });
        taskRecipientInput.on('cancel', function(text) {
          if (text != null) text = '~' + text;
          return _this._cancelInlineInput(taskRecipientInput, text);
        });
        return taskRecipientInput;
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype._insertTaskRecipient = function(offset, params) {
      var op;
      params[ParamsField.TYPE] = ModelType.TASK_RECIPIENT;
      params[ParamsField.RANDOM] = Math.random();
      op = {
        p: offset,
        ti: ' ',
        params: params
      };
      return this._submitOp(op);
    };

    Editor.prototype._insertTaskRecipientByUserId = function(offset, recipientId) {
      var params;
      params = {
        recipientId: recipientId,
        status: NOT_PERFORMED_TASK,
        senderId: window.userInfo.id
      };
      return this._insertTaskRecipient(offset, params);
    };

    Editor.prototype._updateTaskRecipient = function(taskRecipient, data) {
      var container, offset, params;
      container = taskRecipient.getContainer();
      offset = this._getOffsetBefore(container);
      if (!(offset != null)) return null;
      params = this._renderer.getElementParams(container);
      if (data.recipientId) {
        return this._updateTaskRecipientParams(params, offset, data);
      } else {
        return this._replaceTaskRecipient(taskRecipient, params, offset, data);
      }
    };

    Editor.prototype._updateTaskRecipientParams = function(params, offset, data) {
      var delProp, insProp, op, ops, paramName, paramValue;
      ops = [];
      for (paramName in data) {
        paramValue = data[paramName];
        if (params[paramName] === paramValue) continue;
        if (params[paramName] != null) {
          delProp = {};
          delProp[paramName] = params[paramName];
          op = {
            p: offset,
            paramsd: delProp,
            len: 1
          };
          ops.push(op);
        }
        if (paramValue != null) {
          insProp = {};
          insProp[paramName] = paramValue;
          op = {
            p: offset,
            paramsi: insProp,
            len: 1
          };
          ops.push(op);
        }
      }
      try {
        if (ops.length) this._submitOps(ops);
        return $(this._renderer.getElement(offset)).data('object');
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype._replaceTaskRecipient = function(taskRecipient, params, offset, data) {
      var paramName, paramValue, stub;
      this._removeInline(taskRecipient);
      for (paramName in data) {
        paramValue = data[paramName];
        params[paramName] = paramValue;
      }
      stub = new TaskRecipientStub(params.recipientEmail, params.deadlineDate, params.deadlineDatetime);
      params.position = offset;
      this._renderer.insertNodeAt(stub.getContainer(), offset);
      this._addTaskRecipient(params, function() {
        return stub.destroy();
      });
      return null;
    };

    Editor.prototype._insertRecipientByUserId = function(offset, userId) {
      var op, params;
      params = {};
      params[ParamsField.TYPE] = ModelType.RECIPIENT;
      params[ParamsField.ID] = userId;
      params[ParamsField.RANDOM] = Math.random();
      op = {
        p: offset,
        ti: ' ',
        params: params
      };
      return this._submitOp(op);
    };

    Editor.prototype._insertRecipientByEmail = function(recipientInput, email) {
      var offset, recipientStub;
      if (email == null) return;
      offset = this._getOffsetBefore(recipientInput.getContainer());
      recipientStub = recipientInput.stub(email);
      recipientInput.destroy();
      this.focus();
      return this._addRecipientByEmail(offset, email, function() {
        return recipientStub.destroy();
      });
    };

    Editor.prototype._convertTaskToRecipient = function(task) {
      var offset, recipientId;
      offset = this._getOffsetBefore(task.getContainer());
      recipientId = task.getData().recipientId;
      this._removeInline(task);
      return this._insertRecipientByUserId(offset, recipientId);
    };

    Editor.prototype._convertRecipientToTask = function(recipient) {
      var offset, recipientData, recipientId;
      offset = this._getOffsetBefore(recipient.getContainer());
      recipientData = this._renderer.getElementParams(recipient.getContainer());
      recipientId = recipientData[ParamsField.ID];
      this._removeInline(recipient);
      this._insertTaskRecipientByUserId(offset, recipientId);
      return $(this._renderer.getElement(offset)).data('object');
    };

    Editor.prototype._removeInline = function(inline) {
      /*
              Удаляет inline из редактора
              @param inline: object
      */
      var node, offset, op, params;
      node = inline.getContainer();
      params = this._renderer.getElementParams(node);
      offset = this._getOffsetBefore(node);
      op = {
        p: offset,
        td: ' ',
        params: params
      };
      try {
        return this._submitOp(op);
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype.hasRecipientsOrTasks = function() {
      /*
              Проверяет наличия хотя бы одного получателя сообщения или задачи в редакторе
              @returns: boolean - true, если в редакторе присутствует хотя бы один получатель, иначе false
      */      return this._renderer.getRecipientNodes().length > 0 || this._renderer.getTaskRecipientNodes().length > 0;
    };

    Editor.prototype.getRecipients = function() {
      /*
              Возвращает массив, содержащий объекты получателей данного сообщения
              @returns: [Recipient]
      */
      var recipientNode, recipientNodes, recipients, _i, _len;
      recipientNodes = this._renderer.getRecipientNodes();
      recipients = [];
      for (_i = 0, _len = recipientNodes.length; _i < _len; _i++) {
        recipientNode = recipientNodes[_i];
        recipients.push($(recipientNode).data('recipient'));
      }
      return recipients;
    };

    Editor.prototype.getTaskRecipients = function() {
      var t, _i, _len, _ref6, _results;
      _ref6 = this._renderer.getTaskRecipientNodes();
      _results = [];
      for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
        t = _ref6[_i];
        _results.push($(t).data('object'));
      }
      return _results;
    };

    Editor.prototype.openUploadForm = function(insertImage) {
      var form, handleFormClose, range,
        _this = this;
      if (this._permission !== EDIT_PERMISSION) return;
      range = this._getCachedRange();
      if (!range) return;
      form = getUploadForm();
      handleFormClose = function() {
        return _this._resumeSetRange(true, true);
      };
      this._pauseSetRange();
      return form.open(this, insertImage, handleFormClose);
    };

    Editor.prototype.openLinkEditor = function() {
      var element, elementLength, elementParams, elementText, endElement, endOffset, index, leftOffset, leftSpace, ops, range, rightOffset, rightSpace, startElement, startIndex, startOffset, text, textBlocks, url, urls, _ref6, _ref7;
      if (this._permission !== EDIT_PERMISSION) return;
      range = this._getCachedRange();
      if (!range) return;
      if (!range.isCollapsed()) return this._openLinkEditor();
      element = startElement = endElement = range.getStartElement();
      startIndex = range.getStartIndex();
      leftOffset = rightOffset = range.getStartOffset();
      textBlocks = [];
      while (element) {
        elementParams = this._renderer.getElementParams(element);
        if (elementParams[ParamsField.TYPE] !== ModelType.TEXT || elementParams[TextLevelParams.URL]) {
          break;
        }
        elementText = element.textContent;
        if (leftOffset && (leftSpace = elementText.lastIndexOf(' ', leftOffset - 1)) !== -1) {
          text = elementText.substring(leftSpace + 1, leftOffset);
          if (text) textBlocks.unshift(text);
          startIndex -= leftOffset - 1 - leftSpace;
          startOffset = leftSpace + 1;
          startElement = element;
          break;
        }
        text = elementText.substring(0, leftOffset);
        if (text) textBlocks.unshift(text);
        startIndex -= leftOffset;
        startElement = element;
        startOffset = 0;
        element = this._renderer.getPreviousElement(element);
        leftOffset = this._renderer.getElementLength(element);
      }
      element = endElement;
      endOffset = rightOffset;
      while (element) {
        elementParams = this._renderer.getElementParams(element);
        if (elementParams[ParamsField.TYPE] !== ModelType.TEXT || elementParams[TextLevelParams.URL]) {
          break;
        }
        elementText = element.textContent;
        elementLength = this._renderer.getElementLength(element);
        if (rightOffset < elementLength && (rightSpace = elementText.indexOf(' ', rightOffset)) !== -1) {
          text = elementText.substring(rightOffset, rightSpace);
          if (text) textBlocks.push(text);
          endElement = element;
          endOffset = rightSpace;
          break;
        }
        text = elementText.substring(rightOffset);
        if (text) textBlocks.push(text);
        endOffset = elementLength;
        endElement = element;
        rightOffset = 0;
        element = this._renderer.getNextElement(element);
      }
      text = textBlocks.join('');
      urls = matchUrls(textBlocks.join(''));
      if (!(url = urls[0])) return this._openLinkEditor();
      if (url.endIndex !== text.length) {
        index = startIndex + url.endIndex;
        _ref6 = this._renderer.getElementAndOffset(index), endElement = _ref6[0], endOffset = _ref6[1];
        endOffset = index - endOffset + this._renderer.getElementLength(endElement);
      }
      if (url.startIndex) {
        startIndex += url.startIndex;
        _ref7 = this._renderer.getElementAndOffset(startIndex), startElement = _ref7[0], startOffset = _ref7[1];
        startOffset = startIndex - startOffset + this._renderer.getElementLength(startElement);
      }
      url = text.substring(urls[0].startIndex, urls[0].endIndex);
      ops = this._getSelectionOps(startIndex, startElement, startOffset, endElement, endOffset, SelectionAction.TEXT, TextLevelParams.URL, url);
      try {
        if (ops.length) return this._submitOps(ops);
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype.getElementAndOffset = function(index) {
      return this._renderer.getElementAndOffset(index);
    };

    Editor.prototype.getContainer = function() {
      return this._container;
    };

    Editor.prototype.applyOps = function(ops, shiftCursor, user) {
      var focused, raw, scrollable, sel, st, startContainer, startOffset,
        _this = this;
      try {
        if (!this._cachedRange) this._cachedRange = this._getCachedRange();
        if (this._cachedRange) this._cachedRange.setAsNotChanged();
        if (!this._cachedRange && DomUtils.contains(this._container, document.activeElement)) {
          focused = document.activeElement;
          sel = window.getSelection();
          if (sel && sel.rangeCount) {
            raw = sel.getRangeAt(0);
            startContainer = raw.startContainer;
            startOffset = raw.startOffset;
          }
        }
        this._renderer.applyOps(ops, this._cachedRange, shiftCursor, user);
        if (focused && startContainer && DomUtils.contains(document.body, startContainer)) {
          scrollable = typeof this._getScrollableElement === "function" ? this._getScrollableElement() : void 0;
          if (scrollable && focused !== document.activeElement) {
            st = scrollable.scrollTop;
            focused.focus();
            scrollable.scrollTop = st;
            SelectionHelper.setCaret(startContainer, startOffset);
          }
        }
        if (this._cachedRange) this._setCachedRange(true);
        if (this._cursor) {
          setTimeout(function() {
            return _this._processCursor();
          }, 0);
        }
        return this._flushOpsQueue();
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype.setEditable = function(editable) {
      var endEl, endOffset, endType, gadget, needFocusMagic, r, scrollable, st, startEl, startOffset, startType, _i, _len, _ref6;
      if (!BrowserSupport.isSupported()) return;
      if (editable === this._editable) return;
      needFocusMagic = BrowserSupport.isMozilla() && this._container === document.activeElement;
      if (needFocusMagic) {
        r = this._getCachedRange();
        scrollable = typeof this._getScrollableElement === "function" ? this._getScrollableElement() : void 0;
        if (scrollable) st = scrollable.scrollTop;
        Buffer.focus();
      }
      this._editable = editable;
      this._container.contentEditable = this._editable.toString();
      _ref6 = this._gadgets;
      for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
        gadget = _ref6[_i];
        gadget.setMode(editable);
      }
      if (!needFocusMagic) return;
      this.focus();
      if (scrollable) scrollable.scrollTop = st;
      if (r) {
        startEl = r.getStartElement();
        startType = this._renderer.getElementType(startEl);
        startOffset = r.getStartOffset();
        if (r.isCollapsed()) {
          endEl = startEl;
          endType = startType;
          endOffset = startOffset;
        } else {
          endEl = r.getEndElement();
          endType = this._renderer.getElementType(endEl);
          endOffset = r.getEndOffset();
        }
        return SelectionHelper.setRangeObject(startEl, startType, startOffset, endEl, endType, endOffset);
      }
    };

    Editor.prototype.containsNode = function(node) {
      /*
              Возвращает true, если указанный элемент находиться в этом редакторе
              @param node: HTMLElement
              @return: boolean
      */      return DomUtils.contains(this._container, node);
    };

    Editor.prototype.setEditingModifiers = function(_modifiers) {
      return this._modifiers = _modifiers;
      /*
              Устанавливает модификаторы стиля текста, которые будут применены к
              вводимому тексту
              @param _modifiers: object
      */
    };

    Editor.prototype.setRangeTextParam = function(name, value) {
      /*
              Устанавливает указанный текстовый параметр на текущем выбранном
              диапазоне в указанное значение.
              Если value=null, удаляет указанный параметр.
              @param name: string
              @param value: any
      */
      var ops, range;
      range = this._getCachedRange();
      if (!range || range.isCollapsed()) return;
      try {
        ops = this._processSelection(range.getStartIndex(), range.getEndIndex(), range.getEndElement(), range.getEndOffset(), SelectionAction.TEXT, name, value);
        if (ops != null ? ops.length : void 0) this._submitOps(ops);
        return this._setCachedRange(true);
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype._filterSameParams = function(blocks) {
      /*
              Возвращает объект, содержащий все пары ключ-значение, совпадающие
              у всех объектов переданного массива.
              @param blocks: [object]
              @return: object
      */
      var blockParams, key, params, value, _i, _len;
      if (!blocks.length) return {};
      params = blocks.pop();
      for (_i = 0, _len = blocks.length; _i < _len; _i++) {
        blockParams = blocks[_i];
        for (key in params) {
          if (!__hasProp.call(params, key)) continue;
          value = params[key];
          if (value !== blockParams[key]) delete params[key];
        }
      }
      return params;
    };

    Editor.prototype._hasTextParams = function(block, neededParams) {
      /*
              Возвращает true, если для указанного блока есть текстовый параметр
              @param block: object
              @param neededParams: {paramName: anything}
              @return: boolean
      */
      var param;
      for (param in block) {
        if (param === ParamsField.TYPE) continue;
        if (!(param in neededParams)) continue;
        return true;
      }
      return false;
    };

    Editor.prototype.hasTextParams = function(neededParams) {
      /*
              Возврващает true, если в выделенном тексте установлен хотя бы один из
              переданных параметров.
              @param neededParams: {paramName: anything}
              @return: boolean
      */
      var blocks, params, range, _i, _len;
      range = this._getCachedRange(false);
      if (!range) return false;
      try {
        if (range.isCollapsed()) {
          params = this._getElementTextParams(range.getEndElement());
          return this._hasTextParams(params, neededParams);
        } else {
          blocks = this._processSelection(range.getStartIndex(), range.getEndIndex(), range.getEndElement(), range.getEndOffset(), SelectionAction.GETTEXTPARAMS);
          for (_i = 0, _len = blocks.length; _i < _len; _i++) {
            params = blocks[_i];
            if (this._hasTextParams(params, neededParams)) return true;
          }
        }
        return false;
      } catch (e) {
        return this.emit('error', e);
      } finally {
        delete this._cachedRange;
      }
    };

    Editor.prototype.getTextParams = function() {
      /*
              Возвращает общие для выделенного текста параметры.
              @return: object
      */
      var blocks, params, range;
      range = this._getCachedRange(false);
      if (!range) return {};
      try {
        if (range.isCollapsed()) {
          params = this._getElementTextParams(range.getEndElement());
        } else {
          blocks = this._processSelection(range.getStartIndex(), range.getEndIndex(), range.getEndElement(), range.getEndOffset(), SelectionAction.GETTEXTPARAMS);
          params = this._filterSameParams(blocks);
        }
        delete params[ParamsField.TYPE];
        return params;
      } catch (e) {
        return this.emit('error', e);
      } finally {
        delete this._cachedRange;
      }
    };

    Editor.prototype.setRangeLineParam = function(name, value) {
      /*
              Устанавливает указанный параметр параграфа для всех параграфов, которые
              содержат текущий выбранный диапазон.
              Если value=null, удаляет указанный параметр.
              @param name: string
              @param value: any
      */
      var ops, range, startElement;
      range = this._getCachedRange();
      if (!range) return;
      try {
        startElement = this._renderer.getParagraphNode(range.getStartElement());
        ops = this._processSelection(this._getOffsetBefore(startElement), range.getEndIndex(), range.getEndElement(), range.getEndOffset(), SelectionAction.LINE, name, value);
        if (ops != null ? ops.length : void 0) this._submitOps(ops);
        return this._setCachedRange(true);
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype.getLineParams = function() {
      /*
              Возвращает параметры
      */
      var blocks, params, range, startElement;
      range = this._getCachedRange(false);
      if (!range) return {};
      try {
        startElement = this._renderer.getParagraphNode(range.getStartElement());
        blocks = this._processSelection(this._getOffsetBefore(startElement), range.getEndIndex(), range.getEndElement(), range.getEndOffset(), SelectionAction.GETLINEPARAMS);
        params = this._filterSameParams(blocks);
        delete params[ParamsField.TYPE];
        return params;
      } catch (e) {
        return this.emit('error', e);
      } finally {
        delete this._cachedRange;
      }
    };

    Editor.prototype.clearSelectedTextFormatting = function() {
      /*
              Очищает текстовое форматирование выбранного участка
      */
      var ops, range;
      range = this._getCachedRange();
      if (!range || range.isCollapsed()) return;
      try {
        ops = this._processSelection(range.getStartIndex(), range.getEndIndex(), range.getEndElement(), range.getEndOffset(), SelectionAction.CLEARTEXTPARAMS);
        if (ops != null ? ops.length : void 0) this._submitOps(ops);
        return this._setCachedRange(true);
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype.selectAll = function() {
      /*
              Выделяет все содержимое редактора
              range.selectNodeContents(@_container)
      */
      var range;
      this._clearCachedRange();
      range = document.createRange();
      range.selectNodeContents(this._container);
      DomUtils.setRange(range);
      return range;
    };

    Editor.prototype.setCursorToStart = function() {
      /*
              Устанавливает курсор в начало редактора
      */
      var range;
      this._clearCachedRange();
      range = document.createRange();
      range.setStart(this._container, 0);
      range.setEnd(this._container, 0);
      return DomUtils.setRange(range);
    };

    Editor.prototype._processLinkPopup = function() {
      var hasRange, linkPopup, nextElement, offset, prevElement, r, range, rect, startElement, type, url, _ref6;
      this._linkPopupTimer = null;
      hasRange = this._cachedRange != null;
      range = this._getCachedRange(false);
      linkPopup = LinkPopup.get();
      if (!range) return linkPopup.hide();
      startElement = range.getStartElement();
      offset = range.getStartIndex();
      if (!hasRange) this._clearCachedRange();
      url = (_ref6 = this._renderer.getElementParams(startElement)) != null ? _ref6[TextLevelParams.URL] : void 0;
      if (url == null) return linkPopup.hide();
      offset -= this._getOffsetBefore(startElement);
      if (offset === 0) {
        prevElement = this._renderer.getPreviousElement(startElement);
        if (!prevElement || url !== this._renderer.getElementParams(prevElement)[TextLevelParams.URL]) {
          return linkPopup.hide();
        }
      }
      if (offset === this._renderer.getElementLength(startElement)) {
        nextElement = this._renderer.getNextElement(startElement);
        if (!nextElement || url !== this._renderer.getElementParams(nextElement)[TextLevelParams.URL]) {
          return linkPopup.hide();
        }
      }
      if (linkPopup.getContainer().parentNode !== this._container.parentNode) {
        DomUtils.insertNextTo(linkPopup.getContainer(), this._container);
      }
      type = this._renderer.getElementType(startElement);
      offset = range.getStartOffset();
      if (offset === this._renderer.getElementLength(startElement)) offset -= 1;
      r = SelectionHelper.getRangeObject(startElement, type, offset, startElement, type, offset + 1);
      rect = r.getBoundingClientRect();
      rect = {
        top: rect.top,
        left: rect.left,
        right: rect.right,
        bottom: rect.bottom
      };
      DomUtils.convertWindowCoordsToRelative(rect, this._container.parentNode);
      return linkPopup.show(url, rect, this._openLinkEditor, this._alwaysShowPopupAtBottom);
    };

    Editor.prototype._processCursor = function() {
      if (this._linkPopupTimer != null) clearTimeout(this._linkPopupTimer);
      return this._linkPopupTimer = setTimeout(this._processLinkPopup, LINK_POPUP_TIMEOUT);
    };

    Editor.prototype.setCursor = function() {
      this._cursor = true;
      return this._processCursor();
    };

    Editor.prototype.updateCursor = function() {
      return this._processCursor();
    };

    Editor.prototype.clearCursor = function() {
      this._cursor = false;
      this._clearCachedRange();
      return LinkPopup.get().hide();
    };

    Editor.prototype._paragraphIsShifted = function(paragraph) {
      var params;
      params = this._renderer.getElementParams(paragraph);
      return (params[LineLevelParams.BULLETED] != null) || (params[LineLevelParams.NUMBERED] != null);
    };

    Editor.prototype.elementIsInShiftedParagraph = function(element) {
      var parNode;
      parNode = this._renderer.getParagraphNode(element);
      return this._paragraphIsShifted(parNode);
    };

    Editor.prototype.destroy = function() {
      var gadget, _i, _len, _ref6;
      this.__unregisterDomEventHandling();
      _ref6 = this._gadgets;
      for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
        gadget = _ref6[_i];
        gadget.destroy();
        gadget.removeAllListeners();
      }
      delete this._gadgets;
      this._renderer.destroy();
      delete this._renderer;
      delete this.__renderer;
      this._clearCachedRange();
      delete this._getSnapshot;
      delete this._getRecipientInput;
      delete this._getRecipient;
      delete this._addRecipientByEmail;
      delete this._getTaskRecipientInput;
      delete this._getTaskRecipient;
      delete this._addTaskRecipient;
      delete this._getChildBlip;
      delete this._getNewChildBlip;
      delete this._getScrollableElement;
      delete this._container;
      return this.removeAllListeners();
    };

    Editor.prototype.insertNodeAtCurrentPosition = function(node) {
      var el, offset, range, _ref6;
      range = this._getCachedRange(false);
      if (range) return this._renderer.insertNodeAt(node, range.getEndIndex());
      range = DomUtils.getRange();
      _ref6 = this._getCurrentElement(range.endContainer, range.endOffset), el = _ref6[0], offset = _ref6[1];
      return this._renderer.insertNodeAt(node, this._getOffsetBefore(el) + offset);
    };

    Editor.prototype.pauseSetRange = function(updateExisting) {
      if (updateExisting == null) updateExisting = false;
      return this._pauseSetRange(updateExisting);
    };

    Editor.prototype._pauseSetRange = function(updateExisting) {
      if (updateExisting == null) updateExisting = false;
      /*
              This method is only used by the classes that are close to editor (eg. Upload form, Link editor)
      */
      if (updateExisting && this._cachedRange) delete this._cachedRange;
      this._getCachedRange();
      return this._setRangePaused = true;
    };

    Editor.prototype.resumeSetRange = function(needToSetRange, force) {
      if (force == null) force = false;
      return this._resumeSetRange(needToSetRange, force);
    };

    Editor.prototype._resumeSetRange = function(needToSetRange, force) {
      if (force == null) force = false;
      /*
              This method is only used by the classes that are close to editor (eg. Upload form, Link editor)
      */
      this._setRangePaused = false;
      if (needToSetRange) {
        return this._setCachedRange(force);
      } else {
        return this._clearCachedRange();
      }
    };

    Editor.prototype.focus = function() {
      return this._container.focus();
    };

    Editor.prototype.getCopyContentOps = function() {
      var endElement, startElement;
      startElement = this._renderer.getNextElement();
      endElement = this._renderer.getPreviousElement();
      return this._getSelectionOps(0, startElement, 0, endElement, this._renderer.getElementLength(endElement), SelectionAction.COPY_CONTENT);
    };

    Editor.prototype.setInitialOps = function(ops) {
      var firstOp, level, op, p, params, paramsi;
      firstOp = ops.shift();
      params = firstOp[ModelField.PARAMS];
      if ((level = params[LineLevelParams.BULLETED]) != null) {
        p = LineLevelParams.BULLETED;
      } else if ((level = params[LineLevelParams.NUMBERED]) != null) {
        p = LineLevelParams.NUMBERED;
      }
      if (level != null) {
        paramsi = {};
        paramsi[p] = level;
        op = {
          p: 0,
          len: 1,
          paramsi: paramsi
        };
        this._submitOp(op);
      }
      return this._insertOps(1, ops);
    };

    Editor.prototype.copyElementToBuffer = function(element) {
      var op;
      op = this._getCopyElementOp(element);
      if (op) return LocalStorage.setBuffer(JSON.stringify(op));
    };

    Editor.prototype.getCopyElementOp = function(element) {
      return this._getCopyElementOp(element);
    };

    Editor.prototype.pasteBlipFromBufferToCursor = function() {
      var buffer, op, range;
      range = this._getCachedRange();
      if (!range) return;
      buffer = LocalStorage.getBuffer();
      if (!buffer) return;
      op = JSON.parse(buffer);
      this._insertOps(range.getStartIndex(), [op]);
      return LocalStorage.removeBuffer();
    };

    Editor.prototype.pasteBlipFromBufferAfter = function(blipContainer) {
      var buffer, op;
      buffer = LocalStorage.getBuffer();
      if (!buffer) return;
      op = JSON.parse(buffer);
      this.pasteBlipOpAfter(blipContainer, op);
      return LocalStorage.removeBuffer();
    };

    Editor.prototype.pasteBlipOpAfter = function(blipContainer, op) {
      var childBlip, childBlipView, thread;
      thread = BlipThread.getBlipThread(blipContainer);
      if (!(thread != null)) return;
      childBlip = this._getNewChildBlip(false, op.blipParams, thread);
      childBlipView = childBlip.getView();
      thread.insertBlipNodeAfter(childBlipView.getContainer(), blipContainer);
      return childBlipView.getEditor().setInitialOps(op.ops);
    };

    Editor.prototype.pasteBlipOpBefore = function(blipContainer, op) {
      var childBlip, childBlipView, thread;
      thread = BlipThread.getBlipThread(blipContainer);
      if (!(thread != null)) return;
      childBlip = this._getNewChildBlip(false, op.blipParams, thread);
      childBlipView = childBlip.getView();
      thread.insertBlipNodeBefore(childBlipView.getContainer(), blipContainer);
      return childBlipView.getEditor().setInitialOps(op.ops);
    };

    Editor.prototype.pasteOpsAtPosition = function(position, insOps) {
      return this._insertOps(position, insOps);
    };

    Editor.prototype.setPermission = function(permission) {
      return this._permission = permission;
    };

    Editor.prototype.getPermission = function() {
      return this._permission;
    };

    Editor.prototype.getCurrentIndex = function() {
      var range;
      range = this._getCachedRange();
      if (!range) return null;
      return range.getStartIndex();
    };

    Editor.prototype.insertGadget = function(url) {
      var op, params, range;
      if (this._permission === COMMENT_PERMISSION) {
        return this._processInChildBlip(function(editor) {
          return editor.insertGadget(url);
        });
      }
      range = this._getCachedRange();
      if (!range) return;
      params = {};
      params[ParamsField.TYPE] = ModelType.GADGET;
      params[ParamsField.URL] = url;
      params[ParamsField.RANDOM] = Math.random();
      op = {
        p: range.getEndIndex(),
        ti: ' ',
        params: params
      };
      try {
        return this._submitOp(op);
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype._getTextAndUrl = function(startElement, startOffset, endElement, endOffset) {
      var hasNonTextElement, params, text, url;
      text = '';
      url = void 0;
      hasNonTextElement = false;
      while (startElement) {
        params = this._renderer.getElementParams(startElement);
        if (params[ParamsField.TYPE] === ModelType.TEXT) {
          if (url == null) url = params[TextLevelParams.URL];
          if (startElement === endElement) {
            text += startElement.textContent.substring(startOffset, endOffset);
            break;
          }
          text += startElement.textContent.substring(startOffset);
        } else {
          if (startElement === endElement && startOffset === endOffset) break;
          hasNonTextElement = true;
        }
        startOffset = 0;
        if (startElement === endElement) break;
        startElement = this._renderer.getNextElement(startElement);
      }
      return [text, url, !hasNonTextElement];
    };

    Editor.prototype._expandLink = function(range) {
      var element, endElement, endOffset, params, rangeChanged, rawRange, startElement, startOffset, url;
      element = range.getStartElement();
      url = this._renderer.getElementParams(element)[TextLevelParams.URL];
      if (url) {
        startElement = element;
        while (element = this._renderer.getPreviousElement(element)) {
          params = this._renderer.getElementParams(element);
          if (params[TextLevelParams.URL] !== url) break;
          startElement = element;
        }
      }
      element = range.getEndElement();
      url = this._renderer.getElementParams(element)[TextLevelParams.URL];
      if (url) {
        endElement = element;
        while (element = this._renderer.getNextElement(element)) {
          params = this._renderer.getElementParams(element);
          if (params[TextLevelParams.URL] !== url) break;
          endElement = element;
        }
      }
      rawRange = this.getRange();
      rangeChanged = false;
      if (startElement) {
        startOffset = 0;
        rawRange.setStartBefore(startElement);
        rangeChanged = true;
      } else {
        startElement = range.getStartElement();
        startOffset = range.getStartOffset();
      }
      if (endElement) {
        endOffset = this._renderer.getElementLength(endElement);
        rawRange.setEndAfter(endElement);
        rangeChanged = true;
      } else {
        endElement = range.getEndElement();
        endOffset = range.getEndOffset();
      }
      if (rangeChanged) this._updateRange(rawRange);
      return [startElement, startOffset, endElement, endOffset];
    };

    Editor.prototype._openLinkEditor = function() {
      var editable, endElement, endOffset, linkEditor, range, startElement, startOffset, text, url, _ref6, _ref7;
      range = this._getCachedRange();
      if (!range) return;
      _ref6 = this._expandLink(range), startElement = _ref6[0], startOffset = _ref6[1], endElement = _ref6[2], endOffset = _ref6[3];
      _ref7 = this._getTextAndUrl(startElement, startOffset, endElement, endOffset), text = _ref7[0], url = _ref7[1], editable = _ref7[2];
      this.pauseSetRange();
      this._linkEditorAttached = true;
      linkEditor = LinkEditor.get();
      linkEditor.on('close', this._handleLinkEditorClose);
      return linkEditor.open(text, url, editable, this._updateLink, this._insertLink);
    };

    Editor.prototype._handleLinkEditorClose = function() {
      this._linkEditorAttached = false;
      LinkEditor.get().removeListener('close', this._handleLinkEditorClose);
      return this.resumeSetRange(true, true);
    };

    Editor.prototype._updateLink = function(url) {
      var ops, range;
      if (this._permission !== EDIT_PERMISSION) return;
      range = this._getCachedRange();
      if (!range || range.isCollapsed()) return;
      try {
        ops = this._processSelection(range.getStartIndex(), range.getEndIndex(), range.getEndElement(), range.getEndOffset(), SelectionAction.TEXT, TextLevelParams.URL, url);
        if (ops != null ? ops.length : void 0) return this._submitOps(ops);
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype._insertLink = function(text, url) {
      var ops, params, range;
      if (this._permission !== EDIT_PERMISSION) return;
      range = this._getCachedRange();
      if (!range) return;
      text = Utf16Util.traverseString(text);
      if (!text) return;
      ops = [];
      params = {};
      params[ParamsField.TYPE] = ModelType.TEXT;
      params[TextLevelParams.URL] = url;
      if (range.isCollapsed()) {
        ops = [];
      } else {
        try {
          ops = this._deleteSelection(range);
        } catch (e) {
          return this.emit('error', e);
        }
      }
      ops.push({
        p: range.getStartIndex(),
        ti: text,
        params: params
      });
      try {
        return this._submitOps(ops);
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype._updateRange = function(range, directionForward) {
      if (this._cachedRange) delete this._cachedRange;
      return SelectionHelper.setRange(range, directionForward);
    };

    Editor.prototype.setCursorAtParagraph = function(index) {
      var element, range, sel;
      element = this._renderer.getElementAndOffset(index)[0];
      sel = getSelection();
      sel.removeAllRanges();
      range = document.createRange();
      range.setStartBefore(element);
      range.setEndBefore(element);
      sel.addRange(range);
      return this._cachedRange = null;
    };

    return Editor;

  })();

  MicroEvent.mixin(Editor);

  exports.Editor = Editor;

}).call(this);

});

require.define("/lib/client/client/utils/browser_support.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BrowserSupport;

  BrowserSupport = (function() {

    function BrowserSupport() {}

    BrowserSupport.isWebKit = function() {
      return !!$.browser.webkit;
    };

    BrowserSupport.isMozilla = function() {
      return !!$.browser.mozilla;
    };

    BrowserSupport.isIe = function() {
      return !!$.browser.msie;
    };

    BrowserSupport.isDesktopChrome = function() {
      return window.navigator.userAgent.search("Chrome") !== -1 && window.navigator.userAgent.search("Mobile") === -1;
    };

    BrowserSupport.isSupported = function() {
      /*
              Возвращает true если в браузере поддерживается редактирование текста.
              Изменяющий! При изменении условий скопируй их в wave.html (этот метод там использовать не получается,
              т.к. там код должен выполниться еще до подключения этого класса)!
      */
      var test;
      test = document.createElement('div');
      if (!(test.contentEditable != null)) return false;
      if ($.browser.webkit || (($.browser.mozilla || $.browser.msie) && parseInt($.browser.version) >= 9)) {
        return true;
      }
      return false;
    };

    BrowserSupport.isWindows = function() {
      return navigator.appVersion.indexOf('Win') > -1;
    };

    BrowserSupport.isLinux = function() {
      return navigator.appVersion.indexOf('Linux') !== -1;
    };

    BrowserSupport.isUnix = function() {
      return navigator.appVersion.indexOf('X11') > -1;
    };

    BrowserSupport.isMac = function() {
      return navigator.appVersion.indexOf('Mac') > -1;
    };

    BrowserSupport.getOs = function() {
      var na;
      na = navigator.appVersion;
      if (na.indexOf("Linux") > -1) return 'Linux';
      if (na.indexOf('X11') > -1) return 'Unux';
      if (na.indexOf('Mac') > -1) return 'Mac';
      if (na.indexOf('Win') > -1) return 'Windows';
    };

    return BrowserSupport;

  })();

  module.exports = BrowserSupport;

}).call(this);

});

require.define("/lib/client/client/editor/buffer.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BUFFER_CHECK_INTERVAL, Buffer, DEADLINE_TIMEOUT, DomUtils, SelectionHelper,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  DomUtils = require('../utils/dom');

  SelectionHelper = require('./selection/html_selection_helper');

  BUFFER_CHECK_INTERVAL = 50;

  DEADLINE_TIMEOUT = 250;

  Buffer = (function() {

    function Buffer() {
      this._notifyChanged = __bind(this._notifyChanged, this);
      this._checkBuffer = __bind(this._checkBuffer, this);
      var _this = this;
      this._container = document.createElement('div');
      this._container.contentEditable = 'false';
      this._container.style.display = 'inline-block';
      this._dataContainer = this._container.appendChild(document.createElement('div'));
      this._dataContainer.style.display = 'inline-block';
      this._dataContainer.style.border = '1px solid transparent';
      this._dataContainer.style.margin = '-1px';
      this._dataContainer.style.whiteSpace = 'pre-wrap';
      this._dataContainer.style.zIndex = 200;
      this._dataContainer.style.backgroundColor = 'white';
      this._dataContainer.style.outline = 'none';
      this._dataContainer.contentEditable = 'true';
      this._changeIntervalId = null;
      this._deadLineTimeoutId = null;
      $(document).ready(function() {
        return _this.detach();
      });
    }

    Buffer.prototype._clear = function() {
      var _results;
      _results = [];
      while (this._dataContainer.firstChild) {
        _results.push(this._dataContainer.removeChild(this._dataContainer.firstChild));
      }
      return _results;
    };

    Buffer.prototype._checkBuffer = function() {
      var fragment;
      if (this._dataContainer.firstChild === this._currentFirstChild && this._dataContainer.textContent === this._currentText) {
        return;
      }
      fragment = document.createDocumentFragment();
      while (this._dataContainer.firstChild) {
        fragment.appendChild(this._dataContainer.firstChild);
      }
      return this._notifyChanged(null, fragment);
    };

    Buffer.prototype._notifyChanged = function(error, data) {
      if (data == null) data = null;
      if (this._changeIntervalId != null) {
        this._changeIntervalId = clearInterval(this._changeIntervalId);
      }
      if (this._deadLineTimeoutId != null) {
        this._deadLineTimeoutId = clearTimeout(this._deadLineTimeoutId);
      }
      if (this._textChangeCallback) this._textChangeCallback(error, data);
      this._removeTextChangeListener();
      return this._clear();
    };

    Buffer.prototype._removeTextChangeListener = function() {
      if (this._changeIntervalId != null) {
        this._changeIntervalId = clearInterval(this._changeIntervalId);
      }
      if (this._deadLineTimeoutId != null) {
        this._deadLineTimeoutId = clearTimeout(this._deadLineTimeoutId);
      }
      if (this._textChangeCallback) delete this._textChangeCallback;
      if (this._currentText != null) return delete this._currentText;
    };

    Buffer.prototype._focus = function() {
      return this._dataContainer.focus();
    };

    Buffer.prototype.focus = function() {
      return this._focus();
    };

    Buffer.prototype.clear = function() {
      return this._clear();
    };

    Buffer.prototype.selectAll = function() {
      SelectionHelper.selectNodeContents(this._dataContainer);
      return this._focus();
    };

    Buffer.prototype.getText = function() {
      return this._dataContainer.textContent;
    };

    Buffer.prototype.setFragmentContent = function(fragment) {
      this._clear();
      if (fragment) return this._dataContainer.appendChild(fragment);
    };

    Buffer.prototype.attachNextTo = function(nextTo) {
      this._container.style.position = 'static';
      if (!DomUtils.insertNextTo(this._container, nextTo)) return;
      this._attached = true;
      this._clear();
      return SelectionHelper.setCaret(this._dataContainer, 0);
    };

    Buffer.prototype.onTextChange = function(_textChangeCallback) {
      var _this = this;
      this._textChangeCallback = _textChangeCallback;
      if (this._changeIntervalId != null) clearInterval(this._changeIntervalId);
      if (this._deadLineTimeoutId != null) clearTimeout(this._deadLineTimeoutId);
      this._currentText = this._dataContainer.textContent;
      this._currentFirstChild = this._dataContainer.firstChild;
      this._changeIntervalId = setInterval(this._checkBuffer, BUFFER_CHECK_INTERVAL);
      return this._deadLineTimeoutId = setTimeout(function() {
        return _this._notifyChanged(true);
      }, DEADLINE_TIMEOUT);
    };

    Buffer.prototype.detach = function() {
      if (this._attached === false) return;
      this._attached = false;
      this._container.style.position = 'absolute';
      this._container.style.top = '-9999px';
      this._container.style.left = '-9999px';
      document.body.appendChild(this._container);
      return this._clear();
    };

    Buffer.prototype.isAttached = function() {
      return this._attached;
    };

    return Buffer;

  })();

  exports.Buffer = new Buffer();

}).call(this);

});

require.define("/lib/client/client/editor/selection/html_selection_helper.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var DomUtils, ModelType, SelectionHelper, collapseRangeByXRelationToRect, getClosestToContainerContentEditableFalsedElement, getDeepestRangeInside, getEditableSelectionInside, getRangeFromNodeSelectionByX, getRangeFromTextNode, getRangeObject, isNodeInEditingAllowedContainer, isSelectionFullyInside, isSelectionInEditingAllowedContainer, setRange, wrapRangeOnSingleItem,
    __slice = Array.prototype.slice;

  DomUtils = require('../../utils/dom');

  ModelType = require('../model').ModelType;

  isSelectionFullyInside = function(selection, container) {
    var anchorNode, focusNode;
    anchorNode = selection.anchorNode;
    focusNode = selection.focusNode;
    return (anchorNode === container || DomUtils.contains(container, anchorNode)) && (focusNode === container || DomUtils.contains(container, focusNode));
  };

  getClosestToContainerContentEditableFalsedElement = function(startNode, container) {
    var res;
    res = null;
    while (startNode && startNode !== container) {
      if (startNode.contentEditable === 'false' || (typeof startNode.getAttribute === "function" ? startNode.getAttribute('contentEditable') : void 0) === 'false') {
        res = startNode;
      }
      startNode = startNode.parentNode;
    }
    return res || startNode;
  };

  isNodeInEditingAllowedContainer = function(node, container) {
    var closest;
    closest = getClosestToContainerContentEditableFalsedElement(node, container);
    return closest === container;
  };

  isSelectionInEditingAllowedContainer = function(selection, container) {
    if (selection.isCollapsed) {
      return isNodeInEditingAllowedContainer(selection.anchorNode, container);
    } else {
      return isNodeInEditingAllowedContainer(selection.anchorNode, container) || isNodeInEditingAllowedContainer(selection.focusNode, container);
    }
  };

  getEditableSelectionInside = function(container) {
    var sel;
    sel = window.getSelection();
    if (!(sel != null) || !isSelectionFullyInside(sel, container) || !isSelectionInEditingAllowedContainer(sel, container)) {
      return null;
    }
    return sel;
  };

  setRange = function(r, directionForward) {
    var sel, startContainer, startOffset;
    if (directionForward == null) directionForward = true;
    sel = window.getSelection();
    if (!sel) return;
    sel.removeAllRanges();
    if (directionForward || !(sel.extend != null)) {
      return sel.addRange(r);
    } else {
      startContainer = r.startContainer;
      startOffset = r.startOffset;
      r.collapse(false);
      sel.addRange(r);
      return sel.extend(startContainer, startOffset);
    }
  };

  getRangeObject = function(startElement, startElementType, startOffset, endElement, endElementType, endOffset) {
    var getThread, range;
    getThread = function(element) {
      while (!element.rzBlipThread) {
        element = element.parentNode;
      }
      return element.rzBlipThread;
    };
    range = document.createRange();
    if (startElementType === ModelType.BLIP) {
      startElement = getThread(startElement).getContainer();
    }
    if (endElementType === ModelType.BLIP) {
      endElement = getThread(endElement).getContainer();
    }
    if (startElementType === ModelType.TEXT) {
      range.setStart(startElement.firstChild, startOffset);
    } else if (!startOffset) {
      range.setStartBefore(startElement);
    } else if (startElementType === ModelType.LINE) {
      range.setStart(startElement, 0);
    } else {
      range.setStartAfter(startElement);
    }
    if (endElementType === ModelType.TEXT) {
      range.setEnd(endElement.firstChild, endOffset);
    } else if (!endOffset) {
      range.setEndBefore(endElement);
    } else if (endElementType === ModelType.LINE) {
      range.setEnd(endElement, 0);
    } else {
      range.setEndAfter(endElement);
    }
    return range;
  };

  wrapRangeOnSingleItem = function(range, node, index) {
    range.setStart(node, index);
    return range.setEnd(node, index + 1);
  };

  collapseRangeByXRelationToRect = function(node, range, x, rect) {
    var collapseOutside, collapseToStart, offset, _ref;
    collapseToStart = (rect.right - rect.left) / 2 + rect.left > x;
    collapseOutside = !(node.contentEditable != null) || node.contentEditable === 'false';
    if (collapseToStart) {
      if (collapseOutside) return range.collapse(true);
      offset = 0;
    } else {
      if (collapseOutside) return range.collapse(false);
      offset = node.length != null ? node.length : ((_ref = node.childNodes) != null ? _ref.length : void 0) || 0;
    }
    range.setStart(node, offset);
    return range.setEnd(node, offset);
  };

  getRangeFromNodeSelectionByX = function(node, x) {
    var r;
    r = document.createRange();
    r.selectNode(node);
    collapseRangeByXRelationToRect(node, r, x, r.getBoundingClientRect());
    return r;
  };

  getRangeFromTextNode = function(x, y, textNode) {
    var bottom, index, length, r, rect;
    index = 0;
    length = textNode.length;
    r = document.createRange();
    wrapRangeOnSingleItem(r, textNode, index);
    while ((rect = r.getBoundingClientRect()) && rect.bottom < y && index < length - 1) {
      index += 1;
      wrapRangeOnSingleItem(r, textNode, index);
    }
    bottom = rect.bottom;
    while ((rect = r.getBoundingClientRect()) && bottom === rect.bottom && rect.right < x && index < length - 1) {
      index += 1;
      wrapRangeOnSingleItem(r, textNode, index);
    }
    if (bottom !== rect.bottom && index) {
      index -= 1;
      wrapRangeOnSingleItem(r, textNode, index);
      rect = r.getBoundingClientRect();
    }
    collapseRangeByXRelationToRect(textNode, r, x, rect);
    return r;
  };

  getDeepestRangeInside = function(x, y, node, container) {
    var child, range, rect;
    if (DomUtils.isTextNode(node)) return getRangeFromTextNode(x, y, node);
    if (node !== container && node.contentEditable === 'false') {
      return getRangeFromNodeSelectionByX(node, x);
    }
    child = node.firstChild;
    range = document.createRange();
    while (child) {
      range.selectNode(child);
      rect = range.getBoundingClientRect();
      if (y <= rect.bottom && x <= rect.right) {
        return getDeepestRangeInside(x, y, child, container) || collapseRangeByXRelationToRect(child, range);
      }
      child = child.nextSibling;
    }
    return null;
  };

  SelectionHelper = (function() {

    function SelectionHelper() {}

    SelectionHelper.clearSelection = function() {
      var _ref;
      return (_ref = window.getSelection()) != null ? _ref.removeAllRanges() : void 0;
    };

    SelectionHelper.getRange = function() {
      var s;
      s = window.getSelection();
      if (!s || !s.rangeCount) return null;
      return s.getRangeAt(0);
    };

    SelectionHelper.setRange = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return setRange.apply(null, args);
    };

    SelectionHelper.setCaret = function(container, offset) {
      var r;
      r = document.createRange();
      r.setStart(container, offset);
      r.setEnd(container, offset);
      return setRange(r);
    };

    SelectionHelper.getRangeInside = function(container) {
      var selection;
      selection = getEditableSelectionInside(container);
      if (!selection || !selection.rangeCount) return null;
      return selection.getRangeAt(0);
    };

    SelectionHelper.getRangeFromPoint = function(x, y, container) {
      var closest, pointElement;
      pointElement = document.elementFromPoint(x, y);
      closest = getClosestToContainerContentEditableFalsedElement(pointElement, container);
      if (closest && closest !== container) {
        return getRangeFromNodeSelectionByX(closest, x);
      }
      return getDeepestRangeInside(x, y, pointElement, container) || getRangeFromNodeSelectionByX(pointElement, x);
    };

    SelectionHelper.getRangeObject = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return getRangeObject.apply(null, args);
    };

    SelectionHelper.setRangeObject = function(startElement, startElementType, startOffset, endElement, endElementType, endOffset) {
      var range;
      range = getRangeObject(startElement, startElementType, startOffset, endElement, endElementType, endOffset);
      return setRange(range);
    };

    SelectionHelper.selectNodeContents = function(node) {
      var r;
      r = document.createRange();
      r.selectNodeContents(node);
      return setRange(r);
    };

    return SelectionHelper;

  })();

  module.exports = SelectionHelper;

}).call(this);

});

require.define("/lib/client/client/editor/cached_range.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var CachedRange, DomUtils,
    __slice = Array.prototype.slice;

  DomUtils = require('../utils/dom');

  CachedRange = (function() {

    function CachedRange(_editor, _startElement, _startOffset, _startIndex, _endElement, _endOffset, _endIndex) {
      this._editor = _editor;
      this._startElement = _startElement;
      this._startOffset = _startOffset;
      this._startIndex = _startIndex;
      this._endElement = _endElement;
      this._endOffset = _endOffset;
      this._endIndex = _endIndex;
      this.setAsNotChanged();
    }

    CachedRange.prototype.isCollapsed = function() {
      return this._startIndex === this._endIndex;
    };

    CachedRange.prototype.getStartElement = function() {
      return this._startElement;
    };

    CachedRange.prototype.getStartOffset = function() {
      return this._startOffset;
    };

    CachedRange.prototype.getStartIndex = function() {
      return this._startIndex;
    };

    CachedRange.prototype.getEndElement = function() {
      return this._endElement;
    };

    CachedRange.prototype.getEndOffset = function() {
      return this._endOffset;
    };

    CachedRange.prototype.getEndIndex = function() {
      return this._endIndex;
    };

    CachedRange.prototype.collapse = function(toStart) {
      if (toStart == null) toStart = false;
      if (toStart) {
        this._endElement = this._startElement;
        this._endOffset = this._startOffset;
        return this._endIndex = this._startIndex;
      } else {
        this._startElement = this._endElement;
        this._startOffset = this._endOffset;
        return this._startIndex = this._endIndex;
      }
    };

    CachedRange.prototype.setStart = function(element, offset, index) {
      this._startElement = element;
      this._startOffset = offset;
      return this._startIndex = index;
    };

    CachedRange.prototype.setEnd = function(element, offset, index) {
      this._endElement = element;
      this._endOffset = offset;
      return this._endIndex = index;
    };

    CachedRange.prototype.setCursor = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.setStart.apply(this, args);
      return this.setEnd.apply(this, args);
    };

    CachedRange.prototype.shiftStart = function(offset) {
      this.setAsChanged();
      this._startOffset += offset;
      return this._startIndex += offset;
    };

    CachedRange.prototype.shiftEnd = function(offset) {
      this.setAsChanged();
      this._endOffset += offset;
      return this._endIndex += offset;
    };

    CachedRange.prototype.shiftStartIndex = function(offset) {
      return this._startIndex += offset;
    };

    CachedRange.prototype.shiftEndIndex = function(offset) {
      return this._startIndex += offset;
    };

    CachedRange.prototype.setAsChanged = function() {
      return this._changed = true;
    };

    CachedRange.prototype.setAsNotChanged = function() {
      return this._changed = false;
    };

    CachedRange.prototype.processSplitText = function(element, newElement, index) {
      this.setAsChanged();
      if (this._endElement === element && index < this._endOffset) {
        this.setEnd(newElement, this._endOffset - index, this._endIndex);
        if (this.isCollapsed()) return this.collapse();
      }
      if (this._startElement === element && index < this._startOffset) {
        return this.setStart(newElement, this._startOffset - index, this._startIndex);
      }
    };

    CachedRange.prototype.processInsertText = function(element, offset, length, index) {
      var wasCollapsed;
      this.setAsChanged();
      wasCollapsed = this.isCollapsed();
      if (this._endElement === element && this._endOffset > offset) {
        this.shiftEnd(length);
        if (wasCollapsed) return this.collapse();
      } else if (index < this._endIndex) {
        this._endIndex += length;
        if (wasCollapsed) return this.collapse();
      }
      if (this._startElement === element) {
        if (this._startOffset === offset && !wasCollapsed) {
          return this.shiftStart(length);
        } else if (this._startOffset > offset) {
          return this.shiftStart(length);
        }
      } else if (index < this._startIndex) {
        return this._startIndex += length;
      }
    };

    CachedRange.prototype.processInsertElement = function(index, length) {
      var shiftEnd, shiftStart, wasCollapsed;
      this.setAsChanged();
      wasCollapsed = this.isCollapsed();
      shiftEnd = this._endOffset ? 0 : 1;
      if (index < this._endIndex + shiftEnd) {
        this._endIndex += length;
        if (wasCollapsed) return this._startIndex = this._endIndex;
      }
      shiftStart = this._startOffset ? 0 : 1;
      if (index < this._startIndex + shiftStart) return this._startIndex += length;
    };

    CachedRange.prototype.processDeleteElement = function(index, element, length, prevElement, prevElementLength) {
      var wasCollapsed;
      this.setAsChanged();
      wasCollapsed = this.isCollapsed();
      if (element === this._startElement) {
        this.setStart(prevElement, prevElementLength, index);
      } else if (index < this._startIndex) {
        this._startIndex -= length;
      }
      if (wasCollapsed) return this.collapse(true);
      if (element === this._endElement) {
        return this.setEnd(prevElement, prevElementLength, index);
      } else if (index < this._endIndex) {
        return this._endIndex -= length;
      }
    };

    CachedRange.prototype.processReplaceElement = function(oldElement, newElement) {
      this.setAsChanged();
      if (this._startElement === oldElement) this._startElement = newElement;
      if (this._endElement === oldElement) return this._endElement = newElement;
    };

    CachedRange.prototype.processInsertedStart = function(index, length) {
      this.setAsChanged();
      if (index < this._startIndex) return this._startIndex += length;
    };

    CachedRange.prototype.processInsertedEnd = function(index, length) {
      this.setAsChanged();
      if (index < this._endIndex) return this._endIndex += length;
    };

    CachedRange.prototype.isChanged = function() {
      return this._changed;
    };

    return CachedRange;

  })();

  exports.CachedRange = CachedRange;

}).call(this);

});

require.define("/lib/client/client/utils/key_codes.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var KeyCodes;

  KeyCodes = (function() {

    function KeyCodes() {}

    KeyCodes.KEY_ALT = 18;

    KeyCodes.KEY_BACKSPACE = 8;

    KeyCodes.KEY_CTRL = 17;

    KeyCodes.KEY_DELETE = 46;

    KeyCodes.KEY_DOWN = 40;

    KeyCodes.KEY_END = 35;

    KeyCodes.KEY_ENTER = 13;

    KeyCodes.KEY_ESCAPE = 27;

    KeyCodes.KEY_HOME = 36;

    KeyCodes.KEY_LEFT = 37;

    KeyCodes.KEY_PAGEDOWN = 34;

    KeyCodes.KEY_PAGEUP = 33;

    KeyCodes.KEY_RIGHT = 39;

    KeyCodes.KEY_SHIFT = 16;

    KeyCodes.KEY_TAB = 9;

    KeyCodes.KEY_UP = 38;

    KeyCodes.KEY_5 = 53;

    KeyCodes.KEY_6 = 54;

    KeyCodes.NAVIGATION_KEYS = [KeyCodes.KEY_LEFT, KeyCodes.KEY_RIGHT, KeyCodes.KEY_UP, KeyCodes.KEY_DOWN, KeyCodes.KEY_PAGEUP, KeyCodes.KEY_PAGEDOWN, KeyCodes.KEY_HOME, KeyCodes.KEY_END];

    KeyCodes.SPECIAL_KEYS = [KeyCodes.KEY_ALT, KeyCodes.KEY_CTRL, KeyCodes.KEY_SHIFT];

    return KeyCodes;

  })();

  exports.KeyCodes = KeyCodes;

}).call(this);

});

require.define("/lib/client/client/editor/parser.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var DATA_ATTRS, DATA_VARS, HtmlOpParser, HtmlParser, MAX_URL_LENGTH, ModelType, OpParsedElementProcessor, ParamsField, ParsedElementProcessor, Utf16Util,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  ModelType = require('./model').ModelType;

  ParamsField = require('./model').ParamsField;

  Utf16Util = require('../utils/string').Utf16Util;

  MAX_URL_LENGTH = require('./common').MAX_URL_LENGTH;

  ParsedElementProcessor = require('../../share/parser').ParsedElementProcessor;

  DATA_VARS = {
    BLIP_PARAMS: 'rzBlipParams',
    CLIPBOARD: 'rzClipboard',
    PARAMS: 'rzParams'
  };

  DATA_ATTRS = {
    BLIP_PARAMS: 'data-rz-blip-params',
    CLIPBOARD: 'data-rz-clipboard',
    PARAMS: 'data-rz-params'
  };

  module.exports = require('../../share/parser');

  HtmlParser = (function(_super) {

    __extends(HtmlParser, _super);

    function HtmlParser() {
      HtmlParser.__super__.constructor.apply(this, arguments);
    }

    HtmlParser.prototype.__insertImgOp = function(ops, url) {
      if (url.length > MAX_URL_LENGTH) return this._skipped = true;
      return HtmlParser.__super__.__insertImgOp.call(this, ops, url);
    };

    HtmlParser.prototype.parse = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._skipped = false;
      return HtmlParser.__super__.parse.apply(this, args);
    };

    return HtmlParser;

  })(module.exports.HtmlParser);

  module.exports.HtmlParser = HtmlParser;

  HtmlOpParser = (function() {

    function HtmlOpParser() {}

    HtmlOpParser.prototype._createIterator = function(rootNode) {
      var filter;
      filter = function(node) {
        if (node.dataset) {
          return !!(node.dataset[DATA_VARS.PARAMS] != null);
        } else {
          return !!node.getAttribute(DATA_ATTRS.PARAMS);
        }
      };
      return document.createNodeIterator(rootNode, NodeFilter.SHOW_ELEMENT, filter, false);
    };

    HtmlOpParser.prototype.parse = function(rootNode, offset) {
      var blipOps, blipParams, container, element, iterator, op, ops, params, text;
      iterator = this._createIterator(rootNode);
      element = null;
      ops = [];
      while ((element = iterator.nextNode())) {
        if (element.dataset) {
          params = JSON.parse(element.dataset[DATA_VARS.PARAMS]);
        } else {
          params = JSON.parse(element.getAttribute(DATA_ATTRS.PARAMS));
        }
        switch (params[ParamsField.TYPE]) {
          case ModelType.TEXT:
            text = element.textContent;
            text = Utf16Util.traverseString(text);
            if (!text || !text.length) continue;
            op = {
              p: offset,
              ti: text,
              params: params
            };
            offset += text.length;
            break;
          case ModelType.BLIP:
            if (element.dataset) {
              blipParams = JSON.parse(element.dataset[DATA_VARS.BLIP_PARAMS]);
            } else {
              blipParams = JSON.parse(element.getAttribute(DATA_ATTRS.BLIP_PARAMS));
            }
            container = document.createElement('span');
            while (element.firstChild) {
              container.appendChild(element.firstChild);
            }
            blipOps = this.parse(container, 0);
            op = {
              p: offset,
              ti: ' ',
              params: params,
              blipParams: blipParams,
              ops: blipOps
            };
            offset += 1;
            break;
          default:
            op = {
              p: offset,
              ti: ' ',
              params: params
            };
            offset += 1;
        }
        ops.push(op);
      }
      return ops;
    };

    return HtmlOpParser;

  })();

  OpParsedElementProcessor = (function(_super) {

    __extends(OpParsedElementProcessor, _super);

    function OpParsedElementProcessor() {
      OpParsedElementProcessor.__super__.constructor.apply(this, arguments);
    }

    /*
        Реализация интерфейса для совершения действий с результатами парсинга для генерации операций
    */

    OpParsedElementProcessor.prototype.createParsedElement = function(text, params, offset) {
      /*
              Создает операцию или блок контента
              абстрактный метод
      */      return {
        p: offset,
        ti: text,
        params: params
      };
    };

    OpParsedElementProcessor.prototype.getParsedElementText = function(op) {
      /*
              Создает операцию или блок контента
              абстрактный метод
      */      return op != null ? op.ti : void 0;
    };

    OpParsedElementProcessor.prototype.setParsedElementText = function(op, text) {
      /*
              Создает операцию или блок контента
              абстрактный метод
      */      return op.ti = text;
    };

    return OpParsedElementProcessor;

  })(ParsedElementProcessor);

  module.exports.HtmlOpParser = HtmlOpParser;

  module.exports.OpParsedElementProcessor = new OpParsedElementProcessor();

  module.exports.DATA_VARS = DATA_VARS;

  module.exports.DATA_ATTRS = DATA_ATTRS;

}).call(this);

});

require.define("/lib/client/client/utils/string.js",function(require,module,exports,__dirname,__filename,process,global){(function() {

  module.exports = require('../../share/utils/string');

}).call(this);

});

require.define("/lib/client/share/utils/string.js",function(require,module,exports,__dirname,__filename,process,global){
/*
Утилиты для работы со строками общие для клиента и сервера.
*/

(function() {
  var Utf16Util, colonDoubleSlashScheme, colonScheme, isEmailRe, strip, urlRegExp;

  isEmailRe = /^[-a-z0-9!#$%&'*+/=?^_`{|}~]+(?:\.[-a-z0-9!#$%&'*+/=?^_`{|}~]+)*@(?:[a-z0-9]([-a-z0-9]{0,61}[a-z0-9])?\.)*(?:aero|arpa|asia|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|tel|travel|[a-z][a-z])$/i;

  module.exports.isEmail = function(str) {
    return isEmailRe.test(str);
  };

  exports.escapeHTML = function(str) {
    return str.replace(/&/g, '&amp;').replace(/>/g, '&gt;').replace(/</g, '&lt;').replace(/"/g, '&quot;');
  };

  strip = exports.strip = function(str) {
    return str.replace(/^\s+|\s+$/g, '');
  };

  exports.normalizeEmail = function(str) {
    return strip(str.toLowerCase());
  };

  Utf16Util = (function() {

    function Utf16Util() {}

    Utf16Util.REPLACEMENT_CHARACTER = String.fromCharCode(0xFFFD);

    Utf16Util.CHAR_TYPE = {
      OK: 0,
      BIDI: 1,
      CONTROL: 2,
      DEPRECATED: 3,
      IGNORABLE: 4,
      NONCHARACTER: 5,
      SUPPLEMENTARY: 6,
      SURROGATE: 7,
      TAG: 8
    };

    Utf16Util.isControl = function(cp) {
      /*
              Проверяет является ли codepoint упраляющим символом
      */      return (0 <= cp && cp <= 0x1F) || (0x7F <= cp && cp <= 0x9F);
    };

    Utf16Util.isSurrogate = function(cp) {
      /*
              Проверяет является ли codepoint суррогатным символом (обязательно состоящим из пары)
              @param c: int - строка из одного символа
              @returns: boolean
      */      return (0xD800 <= cp && cp <= 0xDFFF);
    };

    Utf16Util.isLowSurrogate = function(cp) {
      return (0xDC00 <= cp && cp <= 0xDFFF);
    };

    Utf16Util.isHighSurrogate = function(cp) {
      return (0xD800 <= cp && cp < 0xDC00);
    };

    Utf16Util.isSupplementary = function(cp) {
      /*
              Проверяет является ли codepoint символом в дополнительной таблице
      */      return cp >= 0x10000;
    };

    Utf16Util.isCodePoint = function(cp) {
      /*
              Проверяет является ли аргумент codepoint'ом
      */      return (0 <= cp && cp <= 0x10FFFF);
    };

    Utf16Util.isBidi = function(cp) {
      /*
              Проверяет является ли codepoint символом bidi формата
      */      if (cp === 0x200E || cp === 0x200F) return true;
      return (0x202A <= cp && cp <= 0x202E);
    };

    Utf16Util.isDefaultIgnorable = function(cp) {
      switch (cp) {
        case 0x200C:
        case 0x200D:
          return true;
        case 0x00AD:
          return true;
        case 0x2060:
        case 0xFEFF:
          return true;
        case 0x200B:
          return true;
        case 0x2061:
        case 0x2062:
        case 0x2063:
        case 0x2064:
          return true;
        case 0x115F:
        case 0x1160:
          return true;
        default:
          return false;
      }
    };

    Utf16Util.isOtherDefaultIgnorable = function(cp) {
      if (cp === 0xFF00) return true;
      if ((0xFFA0 <= cp && cp <= 0xFFDF)) return true;
      if ((0xFFE7 <= cp && cp <= 0xFFEF)) return true;
      return false;
    };

    Utf16Util.isDeprecated = function(cp) {
      return (0x206A <= cp && cp <= 0x206F);
    };

    Utf16Util.isValid = function(cp) {
      /*
              Проверяет валидность символа
              @param cp: int - строка из одного символа
              @returns: boolean - true, если символ валидный, false, если это non-character символ
      */
      var d;
      if (!this.isCodePoint(cp)) return false;
      d = cp & 0xFFFF;
      if (d === 0xFFFE || d === 0xFFFF) return false;
      if ((0xFDD0 <= cp && cp <= 0xFDEF)) return false;
      return true;
    };

    Utf16Util.getCharType = function(c) {
      var cp;
      cp = c.charCodeAt(0);
      if (!this.isValid(cp)) return this.CHAR_TYPE.NONCHARACTER;
      if (this.isControl(cp)) return this.CHAR_TYPE.CONTROL;
      if (this.isSurrogate(cp)) return this.CHAR_TYPE.SURROGATE;
      if (this.isDefaultIgnorable(cp)) return this.CHAR_TYPE.IGNORABLE;
      if (this.isDeprecated(cp)) return this.CHAR_TYPE.DEPRECATED;
      if (this.isBidi(cp)) return this.CHAR_TYPE.BIDI;
      if (this.isSupplementary(cp)) return this.CHAR_TYPE.SUPPLEMENTARY;
      return this.CHAR_TYPE.OK;
    };

    Utf16Util.unpairedSurrogate = function(c) {
      return Utf16Util.REPLACEMENT_CHARACTER;
    };

    Utf16Util.traverseString = function(str) {
      /*
              Traverse UTF16 string
      */
      var c, i, res, _len;
      res = '';
      for (i = 0, _len = str.length; i < _len; i++) {
        c = str[i];
        switch (this.getCharType(c)) {
          case this.CHAR_TYPE.OK:
            res += c;
            break;
          case this.CHAR_TYPE.CONTROL:
          case this.CHAR_TYPE.BIDI:
          case this.CHAR_TYPE.DEPRECATED:
          case this.CHAR_TYPE.IGNORABLE:
            continue;
          default:
            res += this.REPLACEMENT_CHARACTER;
        }
      }
      return res;
    };

    return Utf16Util;

  })();

  exports.Utf16Util = exports.StringUtil = Utf16Util;

  colonDoubleSlashScheme = ['ftp', 'https?', 'gopher', 'telnet'];

  colonScheme = ['mailto', 'tel', 'skype'];

  urlRegExp = RegExp("(((" + (colonScheme.join('|')) + "):)|((" + (colonDoubleSlashScheme.join('|')) + ")://))[^\\s]+([^\\(\\)\\{\\}\\[\\],\\.;:'\\\"\\s])", "ig");

  exports.matchUrls = function(str) {
    var exec, index, _results;
    urlRegExp.lastIndex = 0;
    _results = [];
    while (exec = urlRegExp.exec(str)) {
      index = exec.index;
      if (index && str.charAt(index - 1).match(/[a-z0-9]/i)) {
        urlRegExp.lastIndex = index + 1;
        continue;
      }
      _results.push({
        startIndex: index,
        endIndex: urlRegExp.lastIndex
      });
    }
    return _results;
  };

  exports.ucfirst = function(str) {
    return str.charAt(0).toUpperCase() + str.substr(1, str.length - 1);
  };

  exports.toCamelCase = function(str) {
    var part, parts;
    parts = str.split(/\-|_/);
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = parts.length; _i < _len; _i++) {
        part = parts[_i];
        _results.push(exports.ucfirst(part));
      }
      return _results;
    })()).join('');
  };

}).call(this);

});

require.define("/lib/client/client/editor/common.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var EventType;

  EventType = (function() {

    function EventType() {}

    EventType.INPUT = 'INPUT';

    EventType.NAVIGATION = 'NAVIGATION';

    EventType.DELETE = 'DELETE';

    EventType.LINE = 'LINE';

    EventType.TAB = 'TAB';

    EventType.DANGEROUS = 'DANGEROUS';

    EventType.NOEFFECT = 'NOEFFECT';

    return EventType;

  })();

  exports.EventType = EventType;

  exports.SPECIAL_INPUT = {
    '@': 'insertRecipient',
    '#': 'insertTag',
    '~': 'insertTaskRecipient'
  };

  exports.MAX_URL_LENGTH = 8 * 1024;

}).call(this);

});

require.define("/lib/client/share/parser.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var DomUtils, HtmlParser, LineLevelParams, ModelField, ModelType, ParamsField, ParsedElementProcessor, SKIP_TAGS, TextLevelParams, TextParser, Utf16Util, isSkippedElement, matchUrls, _ref,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  DomUtils = require('./utils/dom');

  _ref = require('./utils/string'), Utf16Util = _ref.Utf16Util, matchUrls = _ref.matchUrls;

  LineLevelParams = require('./model').LineLevelParams;

  ModelField = require('./model').ModelField;

  ModelType = require('./model').ModelType;

  ParamsField = require('./model').ParamsField;

  TextLevelParams = require('./model').TextLevelParams;

  /*
  small
  */

  SKIP_TAGS = {
    APPLET: null,
    AREA: null,
    AUDIO: null,
    CANVAS: null,
    COL: null,
    COLGROUP: null,
    COMMAND: null,
    DATALIST: null,
    EMBED: null,
    FRAME: null,
    FRAMESET: null,
    HEAD: null,
    IFRAME: null,
    INPUT: null,
    MAP: null,
    MENU: null,
    META: null,
    METER: null,
    NOFRAMES: null,
    NOSCRIPT: null,
    OBJECT: null,
    OPTGROUP: null,
    OPTION: null,
    PARAM: null,
    PROGRESS: null,
    RP: null,
    SCRIPT: null,
    SELECT: null,
    SOURCE: null,
    STYLE: null,
    TEXTAREA: null,
    TITLE: null,
    TRACK: null,
    VIDEO: null
  };

  isSkippedElement = function(element) {
    return element.tagName in SKIP_TAGS;
  };

  ParsedElementProcessor = (function() {

    function ParsedElementProcessor() {}

    /*
        Интерфейс для совершения действий с результатами парсинга
        от него должны наследоваться процессры операций и блоков снэпшота
    */

    ParsedElementProcessor.prototype.createParsedElement = function(text, params) {
      /*
              Создает операцию или блок контента
              абстрактный метод
      */      throw new Error('Not implemented yet');
    };

    ParsedElementProcessor.prototype.getParsedElementText = function(parsedElement) {
      /*
              Создает операцию или блок контента
              абстрактный метод
      */      throw new Error('Not implemented yet');
    };

    ParsedElementProcessor.prototype.setParsedElementText = function(parsedElement, text) {
      /*
              Создает операцию или блок контента
              абстрактный метод
      */      throw new Error('Not implemented yet');
    };

    return ParsedElementProcessor;

  })();

  TextParser = (function() {

    function TextParser(_parsedElementProcessor, _offset) {
      this._parsedElementProcessor = _parsedElementProcessor;
      this._offset = _offset;
    }

    TextParser.prototype.__insertTextOp = function(ops, text, textParams) {
      /*
              @param ops: Array
              @param text: string, traversed string
              @param textParams: Object
      */
      var endIndex, lastIndex, params, pushText, startIndex, url, urlText, urls, _i, _len;
      if (!text) return null;
      pushText = function(text, params) {
        var key, op, paramsCopy, val;
        if (params == null) params = {};
        if (!text) return;
        paramsCopy = JSON.parse(JSON.stringify(textParams));
        paramsCopy[ParamsField.TYPE] = ModelType.TEXT;
        for (key in params) {
          val = params[key];
          paramsCopy[key] = val;
        }
        op = this._parsedElementProcessor.createParsedElement(text, paramsCopy, this._offset);
        this._offset += text.length;
        return ops.push(op);
      };
      urls = matchUrls(text);
      lastIndex = 0;
      for (_i = 0, _len = urls.length; _i < _len; _i++) {
        url = urls[_i];
        startIndex = url.startIndex;
        endIndex = url.endIndex;
        if (lastIndex < startIndex) {
          pushText.call(this, text.substring(lastIndex, startIndex));
        }
        urlText = text.substring(startIndex, endIndex);
        params = {};
        if (!textParams[TextLevelParams.URL]) {
          params[TextLevelParams.URL] = urlText;
        }
        pushText.call(this, urlText, params);
        lastIndex = endIndex;
      }
      return pushText.call(this, text.substring(lastIndex));
    };

    TextParser.prototype.__insertLineOp = function(ops, lineParams) {
      var op, params;
      params = {};
      params[ParamsField.TYPE] = ModelType.LINE;
      params[ParamsField.RANDOM] = Math.random();
      if (lineParams[LineLevelParams.BULLETED] != null) {
        params[LineLevelParams.BULLETED] = lineParams[LineLevelParams.BULLETED];
      } else if (lineParams[LineLevelParams.NUMBERED] != null) {
        params[LineLevelParams.NUMBERED] = lineParams[LineLevelParams.NUMBERED];
      }
      op = this._parsedElementProcessor.createParsedElement(' ', params, this._offset);
      this._offset += 1;
      return ops.push(op);
    };

    TextParser.prototype.__pushOp = function(ops, op) {
      var _ref2;
      if (!op || !((_ref2 = this._parsedElementProcessor.getParsedElementText(op)) != null ? _ref2.length : void 0)) {
        return;
      }
      ops.push(op);
      return this._offset += this._parsedElementProcessor.getParsedElementText(op).length;
    };

    TextParser.prototype.__popOp = function(ops) {
      var op;
      if (!ops.length) return null;
      op = ops.pop();
      this._offset -= this._parsedElementProcessor.getParsedElementText(op).length;
      return op;
    };

    TextParser.prototype.parseText = function(ops, text, params) {
      var lastLine, line, lines, _i, _len;
      if (params == null) params = {};
      if (!text) return;
      text = text.replace(/\t/g, '    ');
      lines = text.split(/\r\n|\r|\n/g);
      lastLine = lines.pop();
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        if (line) this.__insertTextOp(ops, Utf16Util.traverseString(line), params);
        this.__insertLineOp(ops, {});
      }
      if (lastLine) {
        return this.__insertTextOp(ops, Utf16Util.traverseString(lastLine), params);
      }
    };

    return TextParser;

  })();

  HtmlParser = (function(_super) {

    __extends(HtmlParser, _super);

    function HtmlParser(_parsedElementProcessor, _offset) {
      this._parsedElementProcessor = _parsedElementProcessor;
      this._offset = _offset;
      this._blockNodeStarted = false;
      this._blockNodeEnded = false;
      this._isLastCharWhiteSpace = true;
    }

    HtmlParser.prototype.__insertTextOp = function(ops, text, textParams, preserveSpaces) {
      var textLength;
      if (preserveSpaces == null) preserveSpaces = true;
      if (preserveSpaces) {
        this._maybePushLine(ops);
        if (!text) return;
        this._isLastCharWhiteSpace = false;
        HtmlParser.__super__.__insertTextOp.call(this, ops, text, textParams);
        return;
      }
      if (!text) return;
      if (this._isLastCharWhiteSpace || this._isLastOpLine(ops) || this._needToPushLine(ops)) {
        text = text.replace(/^ /, '');
      }
      textLength = text.length;
      if (textLength) {
        this._maybePushLine(ops);
        HtmlParser.__super__.__insertTextOp.call(this, ops, text, textParams);
        return this._isLastCharWhiteSpace = text.charAt(textLength - 1) === ' ';
      }
    };

    HtmlParser.prototype.__insertLineOp = function(ops, lineParams) {
      this._tryRemoveLastSpace(ops);
      HtmlParser.__super__.__insertLineOp.call(this, ops, lineParams);
      return this._isLastCharWhiteSpace = true;
    };

    HtmlParser.prototype._insertOrReplaceLastLine = function(ops, lineParams) {
      var op, _ref2, _ref3;
      if (this._isLastOpLine(ops)) {
        op = this.__popOp(ops);
        if (((op != null ? (_ref2 = op.params) != null ? _ref2[LineLevelParams.BULLETED] : void 0 : void 0) != null) || ((op != null ? (_ref3 = op.params) != null ? _ref3[LineLevelParams.NUMBERED] : void 0 : void 0) != null)) {
          this.__pushOp(ops, op);
        }
      }
      return this.__insertLineOp(ops, lineParams);
    };

    HtmlParser.prototype.__insertImgOp = function(ops, url) {
      var op, params;
      params = {};
      params[ParamsField.TYPE] = ModelType.ATTACHMENT;
      params[ParamsField.URL] = url;
      params[ParamsField.RANDOM] = Math.random();
      op = this._parsedElementProcessor.createParsedElement(' ', params, this._offset);
      this._offset += 1;
      this._isLastCharWhiteSpace = false;
      return ops.push(op);
    };

    HtmlParser.prototype._mapStyle = function(name, value, params) {
      var values;
      switch (name) {
        case 'backgroundColor':
          if (value === 'transparent' || !value || value === 'inherit') return;
          params[TextLevelParams.BG_COLOR] = value;
          return params;
        case 'fontStyle':
          switch (value) {
            case 'normal':
              if (params[TextLevelParams.ITALIC] != null) {
                delete params[TextLevelParams.ITALIC];
              }
              break;
            case 'italic':
              params[TextLevelParams.ITALIC] = true;
          }
          return params;
        case 'fontWeight':
          switch (value) {
            case 'normal':
              if (params[TextLevelParams.BOLD] != null) {
                delete params[TextLevelParams.BOLD];
              }
              break;
            case 'bold':
            case 'bolder':
              params[TextLevelParams.BOLD] = true;
          }
          return params;
        case 'textDecoration':
          values = value.split(' ');
          if (values.indexOf('line-through') !== -1) {
            params[TextLevelParams.STRUCKTHROUGH] = true;
          } else {
            if (params[TextLevelParams.STRUCKTHROUGH] != null) {
              delete params[TextLevelParams.STRUCKTHROUGH];
            }
          }
          if (values.indexOf('underline') !== -1) {
            return params[TextLevelParams.UNDERLINED] = true;
          } else {
            if (params[TextLevelParams.UNDERLINED] != null) {
              return delete params[TextLevelParams.UNDERLINED];
            }
          }
          break;
        default:
          return params;
      }
    };

    HtmlParser.prototype._getElementStyles = function(element) {
      var params, style, styles, val;
      params = {};
      switch (element.tagName) {
        case 'U':
        case 'INS':
          params[TextLevelParams.UNDERLINED] = true;
          break;
        case 'I':
        case 'EM':
        case 'DFN':
        case 'VAR':
          params[TextLevelParams.ITALIC] = true;
          break;
        case 'B':
        case 'STRONG':
          params[TextLevelParams.BOLD] = true;
          break;
        case 'STRIKE':
        case 'DEL':
        case 'S':
          params[TextLevelParams.STRUCKTHROUGH] = true;
          break;
        case 'A':
          if (element.href) params[TextLevelParams.URL] = element.href;
      }
      styles = element.style;
      for (style in styles) {
        val = styles[style];
        this._mapStyle(style, val, params);
      }
      return params;
    };

    HtmlParser.prototype._maybePushLine = function(ops, notCheckLastOp) {
      if (notCheckLastOp == null) notCheckLastOp = false;
      if (this._blockNodeStarted || this._blockNodeEnded) {
        if (ops.length && (!this._isLastOpLine(ops) || notCheckLastOp)) {
          this.__insertLineOp(ops, {});
        }
        this._blockNodeStarted = false;
        return this._blockNodeEnded = false;
      }
    };

    HtmlParser.prototype._needToPushLine = function(ops) {
      return (this._blockNodeStarted || this._blockNodeEnded) && !this._isLastOpLine(ops);
    };

    HtmlParser.prototype._collapseText = function(text) {
      var textPart, textParts;
      if (!text) return '';
      textParts = text.split('\u00A0');
      textParts = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = textParts.length; _i < _len; _i++) {
          textPart = textParts[_i];
          _results.push(textPart.replace(/\s+/g, ' '));
        }
        return _results;
      })();
      return textParts.join('\u00A0');
    };

    HtmlParser.prototype._maybePushText = function(ops, text, textParams, preserveLines, preserveSpaces) {
      var lastLine, line, lines, _i, _len;
      if (!text) return;
      if (preserveSpaces) {
        this._maybePushLine(ops);
        this.parseText(ops, text, textParams);
        return;
      }
      if (preserveLines) {
        lines = text.split(/\r\n|\r|\n/g);
        lastLine = this._collapseText(lines.pop());
        this._maybePushLine(ops);
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          if (line) {
            this.__insertTextOp(ops, Utf16Util.traverseString(this._collapseText(line)), textParams, false);
          }
          this.__insertLineOp(ops, {});
        }
        if (lastLine) {
          this.__insertTextOp(ops, Utf16Util.traverseString(lastLine), textParams, false);
        }
        return;
      }
      text = this._collapseText(text);
      return this.__insertTextOp(ops, Utf16Util.traverseString(text), textParams, false);
    };

    HtmlParser.prototype._isLastOpLine = function(ops) {
      var _ref2;
      return ((_ref2 = ops[ops.length - 1]) != null ? _ref2.params[ParamsField.TYPE] : void 0) === ModelType.LINE;
    };

    HtmlParser.prototype._tryRemoveLastSpace = function(ops) {
      var lastOp, text, textLength;
      if (!this._isLastCharWhiteSpace) return;
      lastOp = ops[ops.length - 1];
      if (!lastOp) return;
      text = this._parsedElementProcessor.getParsedElementText(lastOp);
      textLength = text.length;
      if (!textLength) return;
      if (text.charAt(textLength - 1) !== ' ') return;
      if (lastOp.params[ParamsField.TYPE] !== ModelType.TEXT) return;
      if (textLength === 1) {
        ops.pop();
      } else {
        this._parsedElementProcessor.setParsedElementText(lastOp, text.substr(0, textLength - 1));
      }
      return this._offset -= 1;
    };

    HtmlParser.prototype._parseAttrs = function(attrs) {};

    HtmlParser.prototype._parseNode = function(node, ops, textParams, lineParams, preserveLines, preserveSpaces) {
      var child, isBlockElement, isList, key, lType, lvl, newLType, params, tagName, text, tmp, val, whiteSpace, _ref2, _results;
      if (textParams == null) textParams = {};
      if (lineParams == null) lineParams = {};
      if (preserveLines == null) preserveLines = false;
      if (preserveSpaces == null) preserveSpaces = false;
      if (DomUtils.isTextNode(node)) {
        text = node.data;
        if (!text) return;
        this._maybePushText(ops, text, textParams, preserveLines, preserveSpaces);
        return;
      }
      if (!DomUtils.isElement(node) || isSkippedElement(node)) return;
      if (node.tagName === 'BR') {
        this.__insertLineOp(ops, {});
        return;
      }
      if (node.tagName === 'IMG') {
        this._maybePushLine(ops);
        if (node.src) this.__insertImgOp(ops, node.src);
        return;
      }
      isBlockElement = false;
      isList = false;
      params = this._getElementStyles(node);
      if (DomUtils.isBlockElement(node)) {
        isBlockElement = true;
        this._blockNodeStarted = true;
        tagName = node.tagName;
        if (tagName === 'UL' || tagName === 'OL') {
          isList = true;
          if ((lvl = lineParams[LineLevelParams.BULLETED]) != null) {
            lType = LineLevelParams.BULLETED;
          } else if ((lvl = lineParams[LineLevelParams.NUMBERED]) != null) {
            lType = LineLevelParams.NUMBERED;
          } else {
            lvl = -1;
            lType = null;
          }
          if (lType) delete lineParams[lType];
          newLType = tagName === 'UL' ? LineLevelParams.BULLETED : LineLevelParams.NUMBERED;
          lineParams[newLType] = lvl + 1;
        } else if (tagName === 'LI') {
          this._insertOrReplaceLastLine(ops, lineParams);
        }
      }
      for (key in params) {
        if (!__hasProp.call(params, key)) continue;
        val = params[key];
        tmp = textParams[key];
        textParams[key] = val;
        params[key] = tmp || null;
      }
      child = node.firstChild;
      whiteSpace = ((_ref2 = node.style) != null ? _ref2.whiteSpace : void 0) || '';
      switch (whiteSpace) {
        case 'pre-line':
          preserveLines = true;
          preserveSpaces = false;
          break;
        case 'pre':
        case 'pre-wrap':
          preserveLines = true;
          preserveSpaces = true;
          break;
        case 'normal':
        case 'nowrap':
          preserveLines = false;
          preserveSpaces = false;
      }
      while (child) {
        this._parseNode(child, ops, textParams, lineParams, preserveLines, preserveSpaces);
        child = child.nextSibling;
      }
      if (isBlockElement) {
        this._blockNodeStarted = false;
        this._blockNodeEnded = true;
        if (isList) {
          delete lineParams[newLType];
          if (lType) lineParams[lType] = lvl;
        }
      }
      _results = [];
      for (key in params) {
        if (!__hasProp.call(params, key)) continue;
        val = params[key];
        val = params[key];
        if (val != null) {
          _results.push(textParams[key] = val);
        } else {
          _results.push(delete textParams[key]);
        }
      }
      return _results;
    };

    HtmlParser.prototype.parse = function(documentFragment) {
      var ops, tmpEl;
      ops = [];
      tmpEl = document.createElement('span');
      tmpEl.appendChild(documentFragment);
      this._parseNode(tmpEl, ops);
      return ops;
    };

    return HtmlParser;

  })(TextParser);

  module.exports = {
    TextParser: TextParser,
    HtmlParser: HtmlParser,
    ParsedElementProcessor: ParsedElementProcessor
  };

}).call(this);

});

require.define("/lib/client/client/editor/renderer.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var Attachment, BULLETED_LIST_LEVEL_COUNT, BULLETED_LIST_LEVEL_PADDING, BULLETED_LIST_START_PADDING, BlipThread, BrowserEvents, CURSOR_STYLE, DATA_ATTRS, DATA_KEY, DATA_VARS, DomUtils, File, LineLevelParams, MicroEvent, ModelField, ModelType, NAME_STYLE, ParamsField, Renderer, Tag, TextLevelParams, USER_COLORS, escapeHTML, globalCursors, removeArrayElement, _ref, _ref2,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = Array.prototype.slice;

  BrowserEvents = require('../utils/browser_events');

  DomUtils = require('../utils/dom');

  _ref = require('./model'), ModelField = _ref.ModelField, ParamsField = _ref.ParamsField, ModelType = _ref.ModelType, TextLevelParams = _ref.TextLevelParams, LineLevelParams = _ref.LineLevelParams;

  Attachment = require('./attachment').Attachment;

  File = require('./file').File;

  Tag = require('./tag').Tag;

  escapeHTML = require('../utils/string').escapeHTML;

  _ref2 = require('./parser'), DATA_VARS = _ref2.DATA_VARS, DATA_ATTRS = _ref2.DATA_ATTRS;

  BlipThread = require('../blip/blip_thread').BlipThread;

  MicroEvent = require('../utils/microevent');

  BULLETED_LIST_LEVEL_COUNT = 3;

  BULLETED_LIST_LEVEL_PADDING = 15;

  BULLETED_LIST_START_PADDING = 22;

  DATA_KEY = '__rizzoma_data_key';

  CURSOR_STYLE = {
    position: 'absolute',
    width: '2px'
  };

  NAME_STYLE = {
    position: 'absolute',
    top: '-9px',
    fontSize: '10px',
    lineHeight: 'normal',
    left: '-2px',
    color: 'white',
    padding: '1px 2px',
    whiteSpace: 'nowrap',
    maxWidth: '200px',
    textOverflow: 'ellipsis',
    overflow: 'hidden',
    backgroundColor: 'inherit'
  };

  USER_COLORS = ['#6AA84F', '#FF00FF', '#0000FF', '#C00', '#5B0F00', '#783F04', '#0C343D', '#4C1130', '#741B47', '#20124D', '#674EA7', '#90F', '#85200C', '#666', '#783F04', '#7F6000', '#274E13'];

  removeArrayElement = function(array, elem) {
    var index, _ref3;
    index = array.indexOf(elem);
    if (index === -1) return;
    return ([].splice.apply(array, [index, index - index + 1].concat(_ref3 = [])), _ref3);
  };

  globalCursors = {};

  Renderer = (function() {

    function Renderer() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._drawCursor = __bind(this._drawCursor, this);
      this._updateLightBox = __bind(this._updateLightBox, this);
      this._init.apply(this, args);
    }

    Renderer.prototype._init = function(_id, _config, _addInlineBlip, _removeInlineBlip, _getRecipient, _getTaskRecipient, _getNewInlineElement) {
      this._id = _id;
      this._config = _config;
      this._addInlineBlip = _addInlineBlip;
      this._removeInlineBlip = _removeInlineBlip;
      this._getRecipient = _getRecipient;
      this._getTaskRecipient = _getTaskRecipient;
      this._getNewInlineElement = _getNewInlineElement;
      this._recipients = [];
      return this._taskRecipients = [];
    };

    Renderer.prototype._paramsEqual = function(p1, p2) {
      var i;
      for (i in p1) {
        if (p1[i] !== p2[i]) return false;
      }
      for (i in p2) {
        if (p1[i] !== p2[i]) return false;
      }
      return true;
    };

    Renderer.prototype._data = function(element, key, value) {
      if (element[DATA_KEY] == null) element[DATA_KEY] = {};
      if (!(key != null)) return element[DATA_KEY];
      if (typeof key === 'object') return element[DATA_KEY] = key;
      if (!(value != null)) return element[DATA_KEY][key];
      return element[DATA_KEY][key] = value;
    };

    Renderer.prototype.renderContent = function(_container, content) {
      var $container, $curPar, $last, element, lastEl, lastThread, node, params, threadId, _i, _len;
      this._container = _container;
      /*
              Отрисовка содержимого редактора по снимку его содержимого
              @param _container: HTMLElement - элемент редактора, в который будет вставляться содержимое
              @param content: [Object] - снимок содержимого
      */
      $container = $(this._container);
      $container.empty();
      $curPar = null;
      lastEl = null;
      lastThread = null;
      for (_i = 0, _len = content.length; _i < _len; _i++) {
        element = content[_i];
        params = element[ModelField.PARAMS];
        node = this._renderElement(element[ModelField.TEXT], params);
        switch (params[ParamsField.TYPE]) {
          case ModelType.LINE:
            $curPar = $(node);
            $container.append(node);
            lastThread = null;
            break;
          case ModelType.BLIP:
            if ((threadId = params[ParamsField.THREAD_ID]) && lastThread && threadId === lastThread.getId()) {
              lastThread.appendBlipElement(node);
            } else {
              threadId = params[ParamsField.THREAD_ID] || params[ParamsField.ID];
              lastThread = new BlipThread(threadId, node);
              $last = $curPar.children().last();
              if ($last[0].tagName.toLowerCase() !== 'br') $last = $last.prev();
              $last.before(lastThread.getContainer());
            }
            break;
          default:
            $last = $curPar.children().last();
            if ($last[0].tagName.toLowerCase() !== 'br') $last = $last.prev();
            $last.before(node);
            lastThread = null;
        }
        lastEl = element;
      }
      this._updateLightBox();
      return this._updateLines();
    };

    Renderer.prototype.preventEventsPropagation = function(node) {
      return $(node).bind("" + (BrowserEvents.KEY_EVENTS.join(' ')) + " " + (BrowserEvents.CLIPBOARD_EVENTS.join(' ')) + " " + (BrowserEvents.INPUT_EVENTS.join(' ')), function(e) {
        return e.stopPropagation();
      });
    };

    Renderer.prototype.insertInlineElementAfter = function(element, elementAfter) {
      /*
              Вставит инлайновый элемент в offsetElement
              @param element: HTMLElement - элемент для вставки
              @param elementAfter: элемент, после которого следует вставить элемент
      */
      var type;
      type = this.getElementType(elementAfter);
      switch (type) {
        case ModelType.LINE:
          return elementAfter.insertBefore(element, elementAfter.firstChild);
        case ModelType.BLIP:
          return this._insertInlineElementAfterBlipThread(element, elementAfter);
        default:
          return DomUtils.insertNextTo(element, elementAfter);
      }
    };

    Renderer.prototype.createTextElement = function() {
      return this._createTextElement('', {});
    };

    Renderer.prototype.setParamsToElement = function(element, params) {
      return this._setParamsToElement(element, params);
    };

    Renderer.prototype.removeParamsFromElement = function(element) {
      return this._setParamsToElement(element, {});
    };

    Renderer.prototype.getCursorFromElement = function(element, offset) {
      return this._getCursorCoordFromElement(element, offset);
    };

    Renderer.prototype._renderElement = function(text, params) {
      switch (params[ParamsField.TYPE]) {
        case ModelType.TEXT:
          return this._createTextElement(text, params);
        case ModelType.LINE:
          return this._createLineElement(params);
        default:
          return this._createInlineElement(params);
      }
    };

    Renderer.prototype._setParamsToElement = function(node, params) {
      var data;
      data = this._data(node);
      data[ModelField.PARAMS] = params;
      return this._data(node, data);
    };

    Renderer.prototype._createTextElement = function(text, params) {
      /*
              Создает тексторый элемент и назначает ему параметры
              @param text: string - текст элемента
              @param params: Object - параметры объекта
              @returns: HTMLNode
      */
      var $res, decs, res, textNode;
      if (params[TextLevelParams.URL]) {
        res = document.createElement('a');
        res.href = params[TextLevelParams.URL];
      } else {
        res = document.createElement('span');
      }
      $res = $(res);
      if (params[TextLevelParams.BOLD]) $res.css('font-weight', 'bold');
      if (params[TextLevelParams.ITALIC]) $res.css('font-style', 'italic');
      decs = [];
      if (params[TextLevelParams.UNDERLINED] || params[TextLevelParams.URL]) {
        decs.push('underline');
      }
      if (params[TextLevelParams.STRUCKTHROUGH]) decs.push('line-through');
      if (decs.length) $res.css('text-decoration', decs.join(' '));
      if (params[TextLevelParams.BG_COLOR]) {
        $res.css('background-color', params[TextLevelParams.BG_COLOR]);
      }
      textNode = document.createTextNode(text);
      res.appendChild(textNode);
      this._setParamsToElement(res, params);
      return res;
    };

    Renderer.prototype._createLineElement = function(params) {
      /*
              Создает элемент типа Line и назначает ему параметры
              @param params: Object - параметры элемента
              @returns: HTMLNode
      */
      var bulleted, bulletedType, marker, res, val;
      bulleted = params[LineLevelParams.BULLETED];
      val = bulleted != null ? bulleted : params[LineLevelParams.NUMBERED];
      if (val != null) {
        res = document.createElement('li');
        res.style.marginLeft = "" + (BULLETED_LIST_START_PADDING + val * BULLETED_LIST_LEVEL_PADDING) + "px";
        if (bulleted != null) {
          bulletedType = bulleted % BULLETED_LIST_LEVEL_COUNT;
          res.className = "bulleted bulleted-type" + bulletedType;
        } else {
          res.className = 'numbered';
        }
      } else {
        res = document.createElement('div');
      }
      res.appendChild(document.createElement('br'));
      if (val != null) {
        res.appendChild(marker = document.createElement('span'));
        marker.className = 'js-draggable-marker marker';
        marker.draggable = true;
        marker.contentEditable = 'false';
      }
      this._setParamsToElement(res, params);
      return res;
    };

    Renderer.prototype._createInlineElement = function(params) {
      /*
              Создает инлайн элемент и назначает ему параметры
              @param params: Object - параметры элемента
              @returns: HTMLNode
      */
      var attachment, file, recipient, res, tag, url;
      switch (params[ParamsField.TYPE]) {
        case ModelType.BLIP:
          res = this._addInlineBlip(params[ParamsField.ID]);
          break;
        case ModelType.ATTACHMENT:
          url = params[ParamsField.URL];
          attachment = new Attachment(this._id, url);
          res = attachment.getContainer();
          this.preventEventsPropagation(res);
          break;
        case ModelType.RECIPIENT:
          recipient = this._getRecipient(params[ParamsField.ID]);
          res = recipient.getContainer();
          $(res).data('recipient', recipient);
          this._recipients.push(res);
          this.preventEventsPropagation(res);
          break;
        case ModelType.TASK_RECIPIENT:
          recipient = this._getTaskRecipient(params);
          res = recipient.getContainer();
          $(res).data('object', recipient);
          this._taskRecipients.push(res);
          this.preventEventsPropagation(res);
          break;
        case ModelType.FILE:
          file = new File(this._id, params[ParamsField.ID], this._updateLightBox);
          res = file.getContainer();
          this.preventEventsPropagation(res);
          break;
        case ModelType.TAG:
          tag = new Tag(params[ParamsField.TAG]);
          res = tag.getContainer();
          this.preventEventsPropagation(res);
          break;
        case ModelType.GADGET:
          res = this._getNewInlineElement(params).getContainer();
          break;
        default:
          res = document.createElement('span');
          res.contentEditable = 'false';
      }
      this._setParamsToElement(res, params);
      DomUtils.addClass(res, 'default-text');
      return res;
    };

    Renderer.prototype._updateLightBox = function() {
      var _this = this;
      if (this._updateLightBoxTimer != null) {
        clearTimeout(this._updateLightBoxTimer);
        this._updateLightBoxTimer = null;
      }
      return this._updateLightBoxTimer = setTimeout(function() {
        var _ref3;
        return $(_this._container).find('a[rel="' + escapeHTML(_this._id) + '"]').lightBox(((_ref3 = _this._config) != null ? _ref3.lightbox : void 0) || {});
      }, 500);
    };

    Renderer.prototype._insertInlineElementAfterBlip = function(element, blipAfter) {
      var thread;
      thread = BlipThread.getBlipThread(blipAfter);
      thread.splitAfterBlipNode(blipAfter);
      DomUtils.insertNextTo(element, thread.getContainer());
      return element;
    };

    Renderer.prototype._insertInlineElementAfterBlipThread = function(element, blipAfter) {
      var thread;
      thread = BlipThread.getBlipThread(blipAfter);
      DomUtils.insertNextTo(element, thread.getContainer());
      return element;
    };

    Renderer.prototype._insertInlineElementsAfterBlip = function(elements, blipAfter) {
      var thread;
      thread = BlipThread.getBlipThread(blipAfter);
      thread.splitAfterBlipNode(blipAfter);
      return DomUtils.moveNodesNextTo(elements, thread.getContainer());
    };

    Renderer.prototype._getElementAndOffset = function(index, node) {
      var curNode, offset;
      if (node == null) node = this._container;
      curNode = node = this.getNextElement(node);
      offset = this.getElementLength(curNode);
      while (curNode) {
        if (offset >= index) return [node, offset];
        curNode = this.getNextElement(curNode);
        if (curNode) {
          offset += this.getElementLength(curNode);
          node = curNode;
        }
      }
      return [node, offset];
    };

    Renderer.prototype.getElementAndOffset = function(index) {
      return this._getElementAndOffset(index);
    };

    Renderer.prototype.getElement = function(index) {
      return this.getNextElement(this._getElementAndOffset(index)[0]);
    };

    Renderer.prototype.getParagraphNode = function(node) {
      while (node !== this._container && this.getElementType(node) !== ModelType.LINE) {
        node = node.parentNode;
      }
      return node;
    };

    Renderer.prototype._splitTextElement = function(element, index, cachedRange) {
      /*
              Разбиваем текстовый элемент на два элемента по указанному индексу, если индекс указывает не на края элемента
              @param element: HTMLElement - разбиваемый элемент
              @param index: int - индекс, по которому произойдет разбиение
              @param cachedRange: CachedRange: текущее выделение
              @returns: [HTMLElement, HTMLElement]
      */
      var elLength, newElement;
      elLength = element.firstChild.length;
      if (elLength === index) return [element, null];
      if (index === 0) return [null, element];
      newElement = this._createTextElement(element.firstChild.data.substr(index), this.getElementParams(element));
      if (cachedRange) cachedRange.processSplitText(element, newElement, index);
      DomUtils.insertNextTo(newElement, element);
      element.firstChild.deleteData(index, elLength - index);
      return [element, newElement];
    };

    Renderer.prototype._insertText = function(text, params, element, index, offset, cachedRange, shiftCursor, user) {
      var elementParams, leftElement, newElement, rightElement, textLength, textNode, _ref3;
      elementParams = this.getElementParams(element);
      textLength = text.length;
      if (this._paramsEqual(params, elementParams)) {
        textNode = element.firstChild;
        textNode.insertData(offset, text);
        this._drawCursorSafely(element, text.length + offset, user);
        if (shiftCursor && cachedRange) {
          return cachedRange.setCursor(element, offset + textLength, index + textLength);
        } else if (cachedRange) {
          return cachedRange.processInsertText(element, offset, textLength, index);
        }
      } else {
        newElement = this._createTextElement(text, params);
        _ref3 = this._splitTextElement(element, offset, cachedRange), leftElement = _ref3[0], rightElement = _ref3[1];
        if (leftElement) {
          DomUtils.insertNextTo(newElement, leftElement);
        } else {
          rightElement.parentNode.insertBefore(newElement, rightElement);
        }
        this._drawCursorSafely(newElement, text.length, user);
        if (shiftCursor && cachedRange) {
          return cachedRange.setCursor(newElement, textLength, index + textLength);
        } else if (cachedRange) {
          return cachedRange.processInsertElement(index, textLength);
        }
      }
    };

    Renderer.prototype._handleTiOp = function(op, cachedRange, shiftCursor, user) {
      var element, index, newElement, nextElement, nextElementType, offset, offsetBefore, params, realOffset, text, type, _ref3;
      index = op.p;
      if (!index) throw new Error('trying to insert text at 0');
      text = op.ti;
      params = op.params;
      if (cachedRange && index === cachedRange.getStartIndex()) {
        element = cachedRange.getStartElement();
        if (!cachedRange.getStartOffset()) {
          element = this.getPreviousElement(element);
          cachedRange.setStart(element, this.getElementLength(element), index);
        }
        realOffset = cachedRange.getStartOffset();
      } else {
        _ref3 = this._getElementAndOffset(index), element = _ref3[0], offset = _ref3[1];
        offsetBefore = offset - this.getElementLength(element);
        realOffset = index - offsetBefore;
      }
      type = this.getElementType(element);
      switch (type) {
        case ModelType.TEXT:
          return this._insertText(text, params, element, index, realOffset, cachedRange, shiftCursor, user);
        default:
          nextElement = this.getNextElement(element);
          nextElementType = this.getElementType(nextElement);
          if (nextElementType === ModelType.TEXT) {
            return this._insertText(text, params, nextElement, index, 0, cachedRange, shiftCursor, user);
          } else {
            newElement = this._createTextElement(text, params);
            if (type === ModelType.LINE) {
              element.insertBefore(newElement, element.firstChild);
            } else if (type === ModelType.BLIP) {
              this._insertInlineElementAfterBlip(newElement, element);
            } else {
              DomUtils.insertNextTo(newElement, element);
            }
            this._drawCursorSafely(newElement, text.length, user);
            if (shiftCursor && cachedRange) {
              return cachedRange.setCursor(newElement, text.length, index + text.length);
            } else if (cachedRange) {
              return cachedRange.processInsertElement(index, text.length);
            }
          }
      }
    };

    Renderer.prototype._handleLineInsertOp = function(params, element, index, offset, cachedRange, shiftCursor, user) {
      var newElement, newElementLength, nodes, parNode, poped, startNode, thread, threadNode, type, _ref3, _ref4, _ref5;
      newElement = this._createLineElement(params);
      if (!index) throw new Error('trying to insert line at 0');
      type = this.getElementType(element);
      parNode = this.getParagraphNode(element);
      DomUtils.insertNextTo(newElement, parNode);
      switch (type) {
        case ModelType.TEXT:
          _ref3 = this._splitTextElement(element, offset, cachedRange), element = _ref3[0], startNode = _ref3[1];
          if (!startNode) startNode = element.nextSibling;
          break;
        case ModelType.BLIP:
          thread = BlipThread.getBlipThread(element);
          _ref4 = thread.splitAfterBlipNode(element), threadNode = _ref4[0], startNode = _ref4[1];
          if (!startNode) startNode = threadNode.nextSibling;
          break;
        case ModelType.LINE:
          startNode = element.firstChild;
          break;
        default:
          startNode = element.nextSibling;
      }
      nodes = DomUtils.getNodeAndNextSiblings(startNode);
      poped = nodes.pop();
      if (poped && ((_ref5 = poped.tagName) != null ? _ref5.toLowerCase() : void 0) !== 'br') {
        nodes.pop();
      }
      DomUtils.moveNodesToStart(newElement, nodes);
      newElementLength = this.getElementLength(newElement);
      this._drawCursorSafely(newElement, newElementLength, user);
      this._linesUpdated = true;
      if (shiftCursor && cachedRange) {
        return cachedRange.setCursor(newElement, newElementLength, index + newElementLength);
      } else if (cachedRange) {
        return cachedRange.processInsertElement(index, newElementLength);
      }
    };

    Renderer.prototype._handleLineDeleteOp = function(element, index, cachedRange) {
      var last, nextElement, nodes, parNode, poped, thread, _ref3, _ref4;
      nextElement = this.getNextElement(element);
      nodes = DomUtils.getNodeAndNextSiblings(nextElement.firstChild);
      poped = nodes.pop();
      if (poped && ((_ref3 = poped.tagName) != null ? _ref3.toLowerCase() : void 0) !== 'br') {
        nodes.pop();
      }
      parNode = this.getParagraphNode(element);
      last = parNode.lastChild;
      if (((_ref4 = last.tagName) != null ? _ref4.toLowerCase() : void 0) !== 'br') {
        last = last.previousSibling;
      }
      DomUtils.moveNodesBefore(nodes, last);
      if (cachedRange) {
        cachedRange.processDeleteElement(index, nextElement, this.getElementLength(nextElement), element, this.getElementLength(element));
      }
      $(nextElement).remove();
      this._linesUpdated = true;
      if (this.getElementType(element) !== ModelType.BLIP) return;
      thread = BlipThread.getBlipThread(element);
      return thread.mergeWithNext();
    };

    Renderer.prototype._handleInlineInsertOp = function(params, element, index, offset, cachedRange, shiftCursor, user) {
      var draw, elementLength, insert, insertElement, newElement, newThread, nextElement, nextThread, parNode, startNode, thread, threadId, type, _ref3;
      type = this.getElementType(element);
      newElement = this._createInlineElement(params);
      if (params[ParamsField.TYPE] === ModelType.BLIP && (nextElement = this.getNextElement(element)) && this.getElementType(nextElement) === ModelType.BLIP && (nextThread = BlipThread.getBlipThread(nextElement)).getId() === params[ParamsField.THREAD_ID]) {
        nextThread.insertBlipNodeBefore(newElement, nextElement);
      } else if (params[ParamsField.TYPE] === ModelType.BLIP && this.getElementType(element) === ModelType.BLIP && (thread = BlipThread.getBlipThread(element)).getId() === params[ParamsField.THREAD_ID]) {
        thread.insertBlipNodeAfter(newElement, element);
      } else {
        parNode = this.getParagraphNode(element);
        elementLength = this.getElementLength(newElement);
        if (params[ParamsField.TYPE] === ModelType.BLIP) {
          threadId = params[ParamsField.THREAD_ID] || params[ParamsField.ID];
          newThread = new BlipThread(threadId, newElement);
          insertElement = newThread.getContainer();
          draw = false;
        } else {
          insertElement = newElement;
          draw = true;
        }
        switch (type) {
          case ModelType.TEXT:
            _ref3 = this._splitTextElement(element, offset, cachedRange), element = _ref3[0], startNode = _ref3[1];
            if (element) {
              insert = DomUtils.insertNextTo;
            } else {
              element = startNode;
              insert = parNode.insertBefore;
            }
            while (element.parentNode !== parNode) {
              element = element.parentNode;
            }
            insert(insertElement, element);
            break;
          case ModelType.BLIP:
            this._insertInlineElementAfterBlip(insertElement, element);
            break;
          case ModelType.LINE:
            parNode.insertBefore(insertElement, parNode.firstChild);
            break;
          default:
            DomUtils.insertNextTo(insertElement, element);
        }
        if (draw) this._drawCursorSafely(newElement, elementLength, user);
      }
      if (params[ParamsField.TYPE] === ModelType.ATTACHMENT) {
        this._updateLightBox();
      }
      if (shiftCursor && cachedRange) {
        return cachedRange.setCursor(newElement, elementLength, index + elementLength);
      } else if (cachedRange) {
        return cachedRange.processInsertElement(index, elementLength);
      }
    };

    Renderer.prototype._handleInlineDeleteOp = function(element, index, cachedRange) {
      var nextElement, params, thread, type, _ref3, _ref4;
      nextElement = this.getNextElement(element);
      type = this.getElementType(nextElement);
      switch (type) {
        case ModelType.BLIP:
          params = this.getElementParams(nextElement);
          this._removeInlineBlip(params[ParamsField.ID]);
          break;
        case ModelType.RECIPIENT:
          if ((_ref3 = $(nextElement).data('recipient')) != null) _ref3.destroy();
          removeArrayElement(this._recipients, nextElement);
          break;
        case ModelType.TASK_RECIPIENT:
          if ((_ref4 = $(nextElement).data('object')) != null) _ref4.destroy();
          removeArrayElement(this._taskRecipients, nextElement);
          break;
        case ModelType.GADGET:
          try {
            this.emit('gadgetDelete', nextElement);
          } catch (e) {
            console.warn('Error while deleting inline element', e);
          }
      }
      if (cachedRange) {
        cachedRange.processDeleteElement(index, nextElement, this.getElementLength(nextElement), element, this.getElementLength(element));
      }
      $(nextElement).remove();
      if (this.getElementType(element) === ModelType.BLIP) {
        thread = BlipThread.getBlipThread(element);
        thread.mergeWithNext();
      }
      if (type === ModelType.ATTACHMENT) return this._updateLightBox();
    };

    Renderer.prototype._handleOiOp = function(op, cachedRange, shiftCursor, user) {
      var element, index, offset, offsetBefore, params, realOffset, _ref3;
      index = op.p;
      params = op.params;
      if (cachedRange && index === cachedRange.getStartIndex()) {
        element = cachedRange.getStartElement();
        if (!cachedRange.getStartOffset()) {
          element = this.getPreviousElement(element);
          cachedRange.setStart(element, this.getElementLength(element), index);
        }
        realOffset = cachedRange.getStartOffset();
      } else {
        _ref3 = this._getElementAndOffset(index), element = _ref3[0], offset = _ref3[1];
        offsetBefore = offset - this.getElementLength(element);
        realOffset = index - offsetBefore;
      }
      switch (params[ParamsField.TYPE]) {
        case ModelType.LINE:
          return this._handleLineInsertOp(params, element, index, realOffset, cachedRange, shiftCursor, user);
        default:
          return this._handleInlineInsertOp(params, element, index, realOffset, cachedRange, shiftCursor, user);
      }
    };

    Renderer.prototype._handleTdOp = function(op, cachedRange, shiftCursor, user) {
      var cursorElement, cursorElementLength, element, elementLength, index, nextElement, offset, offsetBefore, realOffset, textLength, thread, _, _ref3, _ref4, _ref5;
      index = op.p;
      textLength = op.td.length;
      if (!index) throw new Error('trying to delete 0 element');
      if (cachedRange && index === cachedRange.getStartIndex()) {
        element = cachedRange.getStartElement();
        realOffset = cachedRange.getStartOffset();
        if (this.getElementLength(element) === cachedRange.getStartOffset()) {
          element = this.getNextElement(element);
          realOffset = 0;
        }
      } else {
        _ref3 = this._getElementAndOffset(index), element = _ref3[0], offset = _ref3[1];
        offsetBefore = offset - this.getElementLength(element);
        if (this.getElementType(element) !== ModelType.TEXT || offset - index === 0) {
          element = this.getNextElement(element);
          realOffset = 0;
        } else {
          realOffset = index - offsetBefore;
        }
      }
      if (textLength + realOffset < element.textContent.length) {
        element.firstChild.deleteData(realOffset, textLength);
        this._drawCursorSafely(element, realOffset, user);
        if (!cachedRange) return;
        if (shiftCursor) {
          cachedRange.setCursor(element, realOffset, index);
        } else {
          cachedRange.processInsertText(element, realOffset, -textLength, index);
        }
        return;
      }
      _ref4 = this._splitTextElement(element, realOffset, cachedRange), _ = _ref4[0], element = _ref4[1];
      cursorElement = this.getPreviousElement(element);
      cursorElementLength = this.getElementLength(cursorElement);
      while (textLength) {
        nextElement = this.getNextElement(element);
        if (this.getElementType(element) !== ModelType.TEXT) {
          throw new Error('trying to delete non-text element in text operation');
        }
        elementLength = this.getElementLength(element);
        if (elementLength <= textLength) {
          textLength -= elementLength;
          if (!shiftCursor && cachedRange) {
            cachedRange.processDeleteElement(index, element, elementLength, cursorElement, cursorElementLength);
          }
        } else {
          _ref5 = this._splitTextElement(element, textLength, cachedRange), element = _ref5[0], _ = _ref5[1];
          textLength = 0;
        }
        $(element).remove();
        element = nextElement;
      }
      if (this.getElementType(cursorElement) === ModelType.BLIP) {
        thread = BlipThread.getBlipThread(cursorElement);
        thread.mergeWithNext();
        this._drawCursorSafely(this.getNextElement(cursorElement), 0, user);
      } else {
        this._drawCursorSafely(cursorElement, this.getElementLength(cursorElement), user);
      }
      if (shiftCursor && cachedRange) {
        return cachedRange.setCursor(cursorElement, this.getElementLength(cursorElement), index);
      }
    };

    Renderer.prototype._handleOdOp = function(op, cachedRange, user) {
      var element, index, params, _, _ref3;
      index = op.p;
      if (!index) throw new Error('trying to delete 0 element');
      params = op.params;
      if (cachedRange && index === cachedRange.getStartIndex()) {
        element = cachedRange.getStartElement();
        if (!cachedRange.getStartOffset()) {
          element = this.getPreviousElement(element);
          cachedRange.setStart(element, this.getElementLength(element), index);
        }
      } else {
        _ref3 = this._getElementAndOffset(index), element = _ref3[0], _ = _ref3[1];
      }
      switch (params[ParamsField.TYPE]) {
        case ModelType.LINE:
          this._handleLineDeleteOp(element, index, cachedRange);
          break;
        default:
          this._handleInlineDeleteOp(element, index, cachedRange);
      }
      return this._drawCursorSafely(element, this.getElementLength(element), user);
    };

    Renderer.prototype._getParamValue = function(params) {
      var param, value;
      for (param in params) {
        value = params[param];
        return [param, value];
      }
    };

    Renderer.prototype._handleParamsOp = function(op, shiftCursor, cachedRange, insert, user) {
      var element, index, length, offset, param, params, realOffset, type, value, _ref3, _ref4;
      index = op.p;
      length = op.len;
      params = insert ? op.paramsi : op.paramsd;
      if (cachedRange && index === cachedRange.getStartIndex()) {
        element = cachedRange.getStartElement();
        realOffset = cachedRange.getStartOffset();
        if (realOffset === this.getElementLength(element)) {
          element = this.getNextElement(element);
          realOffset = 0;
        }
      } else {
        _ref3 = this._getElementAndOffset(index), element = _ref3[0], offset = _ref3[1];
        if (index && (this.getElementType(element) !== ModelType.TEXT || offset - index === 0)) {
          element = this.getNextElement(element);
          realOffset = 0;
        } else {
          realOffset = index - offset + this.getElementLength(element);
        }
      }
      type = this.getElementType(element);
      _ref4 = this._getParamValue(params), param = _ref4[0], value = _ref4[1];
      switch (type) {
        case ModelType.TEXT:
          return this._handleTextParamOp(element, realOffset, cachedRange, index, length, param, value, insert, user);
        case ModelType.LINE:
          return this._handleLineParamOp(element, cachedRange, param, value, insert, user);
        case ModelType.TASK_RECIPIENT:
          return this._handleTaskRecipientParamOp(element, cachedRange, param, value, insert, user);
        case ModelType.GADGET:
          return this._handleGadgetParamOp(element, param, value, insert, user);
      }
    };

    Renderer.prototype._handleGadgetParamOp = function(element, param, value, insert, user) {
      var elementParams;
      elementParams = this.getElementParams(element);
      if (insert) {
        elementParams[param] = value;
      } else {
        delete elementParams[param];
        value = null;
      }
      this._setParamsToElement(element, elementParams);
      this.emit('gadgetParamChange', element, elementParams, param, value);
      return this._drawCursorSafely(element, this.getElementLength(element), user);
    };

    Renderer.prototype._handleTextParamOp = function(element, realOffset, cachedRange, index, length, param, value, insert, user) {
      var elLength, endIndex, newElement, params, startElement, type, _, _ref3;
      if (!TextLevelParams.isValid(param)) throw "unexpected text param: " + param;
      _ref3 = this._splitTextElement(element, realOffset, cachedRange), _ = _ref3[0], startElement = _ref3[1];
      endIndex = index + length;
      while (length) {
        type = this.getElementType(startElement);
        if (type !== ModelType.TEXT) {
          throw "text param could not be applied to " + type + " type";
        }
        elLength = this.getElementLength(startElement);
        if (elLength > length) {
          startElement = this._splitTextElement(startElement, length, cachedRange)[0];
          elLength = this.getElementLength(startElement);
        }
        params = this.getElementParams(startElement);
        if (insert) {
          params[param] = value;
        } else {
          delete params[param];
        }
        newElement = this._createTextElement(startElement.firstChild.data, params);
        DomUtils.insertNextTo(newElement, startElement);
        if (cachedRange) {
          cachedRange.processReplaceElement(startElement, newElement);
        }
        length -= elLength;
        $(startElement).remove();
        startElement = this.getNextElement(newElement);
      }
      return this._drawCursorSafely(newElement, this.getElementLength(newElement), user);
    };

    Renderer.prototype._handleLineParamOp = function(element, cachedRange, param, value, insert, user) {
      var newElement, nodes, params, poped, _ref3;
      if (!LineLevelParams.isValid(param)) throw "unexpected line param: " + param;
      params = this.getElementParams(element);
      if (insert) {
        params[param] = value;
      } else {
        delete params[param];
      }
      newElement = this._createLineElement(params);
      nodes = DomUtils.getNodeAndNextSiblings(element.firstChild);
      poped = nodes.pop();
      if (poped && ((_ref3 = poped.tagName) != null ? _ref3.toLowerCase() : void 0) !== 'br') {
        nodes.pop();
      }
      DomUtils.moveNodesToStart(newElement, nodes);
      DomUtils.insertNextTo(newElement, element);
      if (cachedRange) cachedRange.processReplaceElement(element, newElement);
      this._linesUpdated = true;
      $(element).remove();
      return this._drawCursorSafely(newElement, this.getElementLength(newElement), user);
    };

    Renderer.prototype._handleTaskRecipientParamOp = function(element, cachedRange, param, value, insert, user) {
      var newElement, params, _ref3;
      params = this.getElementParams(element);
      if (insert) {
        params[param] = value;
      } else {
        delete params[param];
      }
      if ((_ref3 = $(element).data('object')) != null) _ref3.destroy();
      removeArrayElement(this._taskRecipients, element);
      newElement = this._createInlineElement(params);
      DomUtils.insertNextTo(newElement, element);
      if (cachedRange) cachedRange.processReplaceElement(element, newElement);
      $(element).remove();
      return this._drawCursorSafely(newElement, this.getElementLength(newElement), user);
    };

    Renderer.prototype.getNextElement = function(node) {
      var child, firstNode, nextEl, nextNode, type;
      if (node == null) node = this._container;
      type = this.getElementType(node);
      if (type === ModelType.LINE || ((node === this._container || (typeof node.getAttribute === "function" ? node.getAttribute('contentEditable') : void 0) !== 'false') && !type) || node.rzContainer) {
        child = node.firstChild;
        while (child) {
          if (this.getElementType(child) != null) return child;
          firstNode = this.getNextElement(child);
          if (firstNode) return firstNode;
          child = child.nextSibling;
        }
      }
      while (node !== this._container) {
        nextNode = node.nextSibling;
        while (nextNode) {
          if (this.getElementType(nextNode) != null) return nextNode;
          nextEl = this.getNextElement(nextNode);
          if (nextEl) return nextEl;
          nextNode = nextNode.nextSibling;
        }
        node = node.parentNode;
      }
      return null;
    };

    Renderer.prototype.getDeepestLastNode = function(node) {
      /*
              Возвращает самого вложенного из последних наследников указнной ноды
              Возвращает саму ноду, если у нее нет наследников
              Не заходит внутрь нод, у которых contentEditable == false и не ялвяющихся тредом
              @param node: HTMLNode
              @return: HTMLNode
      */      if (((typeof node.getAttribute === "function" ? node.getAttribute('contentEditable') : void 0) === 'false') && node !== this._container && !node.rzContainer) {
        return node;
      }
      if (!node.lastChild) return node;
      return this.getDeepestLastNode(node.lastChild);
    };

    Renderer.prototype.getPreviousElement = function(node) {
      var deepest, prevNode;
      if (node == null) node = null;
      if (!node) {
        return this.getPreviousElement(this.getDeepestLastNode(this._container));
      }
      while (node !== this._container) {
        if (prevNode = node.previousSibling) {
          deepest = this.getDeepestLastNode(prevNode);
          if (this.getElementType(deepest) != null) return deepest;
          return this.getPreviousElement(deepest);
        }
        node = node.parentNode;
        if (this.getElementType(node) != null) return node;
      }
      return null;
    };

    Renderer.prototype.getElementType = function(element) {
      /*
              Возвращает тип указанного элемента
              @param element: HTMLElement - элемент, тип которого требуется получить
              @returns: null, если элемент не имеет типа, иначе string - одно из значений параметров класса ModelType
      */
      var _ref3;
      if (!element) return null;
      return ((_ref3 = this._data(element, ModelField.PARAMS)) != null ? _ref3[ParamsField.TYPE] : void 0) || null;
    };

    Renderer.prototype.getElementParams = function(element) {
      /*
              Возвращает копию параметров указанного элемента
              @param element: HTMLElement - элемент, параметры которого требуется получить
              @returns: Object - параметры данного элемента
      */
      var res;
      if (!element) return null;
      res = {};
      $.extend(res, this._data(element, ModelField.PARAMS));
      return res;
    };

    Renderer.prototype.getElementLength = function(element) {
      /*
              Возвращает длину элемента - смещение, которое задает элемент в снимке содержимого редактора
              @param: element - HTMLElement - элемент, длину которого требуется получить
              @returns: int - длина элемента
      */
      var type;
      type = this.getElementType(element);
      if (type == null) return 0;
      if (type !== ModelType.TEXT) return 1;
      return element.firstChild.data.length;
    };

    Renderer.prototype.insertNodeAt = function(node, index) {
      /*
              Вставляет указанную ноду по индексу в снимке содержимого, не проверяя параметры и не устанавливая параметры
              Нода будет вставлена после ноды, на которую попадает индекс
              @param node: HTMLNode - нода для вставки
              @param index: int - индекс, по котороуму следует вставить ноду
      */
      var elType, element, insert, navElement, offset, parNode, right, _ref3, _ref4;
      _ref3 = this._getElementAndOffset(index), element = _ref3[0], offset = _ref3[1];
      elType = this.getElementType(element);
      switch (elType) {
        case ModelType.TEXT:
          parNode = this.getParagraphNode(element);
          _ref4 = this._splitTextElement(element, index - offset + this.getElementLength(element)), navElement = _ref4[0], right = _ref4[1];
          if (navElement) {
            insert = DomUtils.insertNextTo;
          } else {
            navElement = right;
            insert = parNode.insertBefore;
          }
          return insert(node, navElement);
        case ModelType.LINE:
          return element.insertBefore(node, element.firstChild);
        case ModelType.BLIP:
          return this._insertInlineElementAfterBlip(node, element);
        default:
          return DomUtils.insertNextTo(node, element);
      }
    };

    Renderer.prototype.insertTemporaryBlipNodes = function(blipNodes, index, cachedRange) {
      var element, insert, navElement, offset, right, type, _ref3, _ref4;
      _ref3 = this._getElementAndOffset(index), element = _ref3[0], offset = _ref3[1];
      type = this.getElementType(element);
      switch (type) {
        case ModelType.TEXT:
          _ref4 = this._splitTextElement(element, index - offset + this.getElementLength(element), cachedRange), navElement = _ref4[0], right = _ref4[1];
          if (navElement) {
            insert = DomUtils.moveNodesNextTo;
          } else {
            navElement = right;
            insert = DomUtils.moveNodesBefore;
          }
          return insert(blipNodes, navElement);
        case ModelType.LINE:
          return DomUtils.moveNodesBefore(blipNodes, element.firstChild);
        case ModelType.BLIP:
          return this._insertInlineElementsAfterBlip(blipNodes, element);
        default:
          return DomUtils.moveNodesNextTo(blipNodes, element);
      }
    };

    Renderer.prototype.getRecipientNodes = function() {
      return this._recipients;
    };

    Renderer.prototype.getTaskRecipientNodes = function() {
      return this._taskRecipients;
    };

    Renderer.prototype.renderOps = function(ops, container, textData) {
      /*
              Отрисовка содержимого редактора в виде HTML по операциям, уходящим в буфер обмена
      */
      var currentLine, currentLineIndent, currentLineType, op, params, type, _i, _len, _ref3, _results;
      currentLine = null;
      currentLineIndent = -1;
      currentLineType = null;
      _results = [];
      for (_i = 0, _len = ops.length; _i < _len; _i++) {
        op = ops[_i];
        params = op[ModelField.PARAMS];
        type = params[ParamsField.TYPE];
        switch (type) {
          case ModelType.LINE:
            _results.push((_ref3 = this._renderLineHtmlElement(container, currentLine, currentLineIndent, currentLineType, params, textData), currentLine = _ref3[0], currentLineIndent = _ref3[1], currentLineType = _ref3[2], _ref3));
            break;
          case ModelType.TEXT:
            _results.push(this._renderTextHtmlElement(container, currentLine, op.ti, params, textData));
            break;
          default:
            _results.push(this._renderInlineHtmlElement(container, currentLine, op, textData));
        }
      }
      return _results;
    };

    Renderer.prototype._renderInlineHtmlElement = function(container, curLine, op, textData) {
      var element, ops, params, type;
      params = op[ModelField.PARAMS];
      type = params[ParamsField.TYPE];
      switch (type) {
        case ModelType.BLIP:
          element = document.createElement('span');
          ops = op.ops;
          if (!ops) return null;
          this.renderOps(ops, element, textData);
          this._addParamToElement('BLIP_PARAMS', element, op.blipParams);
          if (textData) textData.push('\n');
          break;
        case ModelType.ATTACHMENT:
          element = document.createElement('img');
          element.src = params[ParamsField.URL];
          break;
        case ModelType.FILE:
          element = document.createElement('a');
          element.href = params[ParamsField.URL];
          element.innerHTML = 'FILE';
          break;
        default:
          element = document.createElement('span');
      }
      this._addParamToElement('PARAMS', element, params);
      if (curLine) {
        return curLine.insertBefore(element, curLine.lastChild);
      } else {
        return container.appendChild(element);
      }
    };

    Renderer.prototype._renderLineHtmlElement = function(container, curLine, curIndent, currentType, params, textData) {
      var baseElement, element, indent, type;
      if (textData) textData.push('\n');
      if ((indent = params[LineLevelParams.BULLETED]) != null) {
        type = 'b';
      } else if ((indent = params[LineLevelParams.NUMBERED]) != null) {
        type = 'n';
      } else {
        type = null;
      }
      if (!type) {
        element = this._createLineHtmlElement('div');
        container.appendChild(element);
        curIndent = -1;
        type = null;
      } else {
        if (type !== currentType) {
          curLine = null;
          curIndent = -1;
        }
        baseElement = (curLine != null ? curLine.parentNode : void 0) || container;
        element = this._createLineHtmlElement('li');
        while (curIndent !== indent) {
          if (curIndent > indent) {
            curIndent -= 1;
            baseElement = baseElement.parentNode;
          } else {
            curIndent += 1;
            baseElement = baseElement.appendChild(document.createElement(type === 'b' ? 'ul' : 'ol'));
          }
        }
        baseElement.appendChild(element);
      }
      this._addParamToElement('PARAMS', element, params);
      return [element, curIndent, type];
    };

    Renderer.prototype._createLineHtmlElement = function(tagName) {
      var line;
      line = document.createElement(tagName);
      line.appendChild(document.createElement('br'));
      return line;
    };

    Renderer.prototype._renderTextHtmlElement = function(container, curLine, text, params, textData) {
      var element;
      if (textData) textData.push(text);
      element = this._createTextElement(text, params);
      this._addParamToElement('PARAMS', element, params);
      if (curLine) {
        return curLine.insertBefore(element, curLine.lastChild);
      } else {
        return container.appendChild(element);
      }
    };

    Renderer.prototype._addParamToElement = function(paramName, element, params) {
      if (element.dataset) {
        return element.dataset[DATA_VARS[paramName]] = JSON.stringify(params);
      } else {
        return element.setAttribute(DATA_ATTRS[paramName], JSON.stringify(params));
      }
    };

    Renderer.prototype._updateLines = function() {
      var bulleted, child, index, levels, numbered, params, _i, _len, _ref3, _results;
      index = -1;
      levels = [];
      _ref3 = this._container.children;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        child = _ref3[_i];
        params = this.getElementParams(child);
        numbered = params[LineLevelParams.NUMBERED];
        bulleted = params[LineLevelParams.BULLETED];
        if ((!(numbered != null) && !(bulleted != null)) || ((bulleted != null) && bulleted <= index)) {
          index = -1;
          levels = [];
          continue;
        }
        if (bulleted) continue;
        while (numbered > index) {
          index += 1;
          if (levels[index] == null) levels.push(0);
        }
        while (numbered < index) {
          levels[index--] = 0;
        }
        levels[index] += 1;
        _results.push(child.value = "" + levels[index]);
      }
      return _results;
    };

    Renderer.prototype._getRectFromNodeSelection = function(node, offset) {
      var r, rect;
      if (offset == null) offset = null;
      r = document.createRange();
      if (offset != null) {
        r.setStart(node, offset);
        r.setEnd(node, offset + 1);
      } else {
        r.selectNode(node);
      }
      rect = r.getBoundingClientRect();
      return {
        top: rect.top,
        left: rect.left,
        right: rect.right,
        bottom: rect.bottom
      };
    };

    Renderer.prototype._getCursorCoordFromText = function(element, offset) {
      var rect, toEnd;
      toEnd = offset === this.getElementLength(element);
      if (toEnd) offset -= 1;
      rect = this._getRectFromNodeSelection(element.firstChild, offset);
      if (toEnd) {
        rect.left = rect.right;
      } else {
        rect.right = rect.left;
      }
      return rect;
    };

    Renderer.prototype._getCursorCoordFromLine = function(line, offset) {
      var next, p, prev, rect, type;
      if (!offset) {
        prev = this.getPreviousElement(line);
        if (!prev) throw new Error('do not have prev element');
        return this._getCursorCoordFromElement(prev, this.getElementLength(prev));
      }
      next = this.getNextElement(line);
      if (next && (type = this.getElementType(next)) !== ModelType.LINE && type !== ModelType.BLIP) {
        return this._getCursorCoordFromElement(next, 0);
      }
      rect = this._getRectFromNodeSelection(line);
      p = parseInt(window.getComputedStyle(line).paddingLeft) || 0;
      rect.left += p;
      rect.right = rect.left;
      return rect;
    };

    Renderer.prototype._getCursorCoordFromInline = function(inline, offset) {
      var rect;
      rect = this._getRectFromNodeSelection(inline);
      if (offset) {
        rect.left = rect.right;
      } else {
        rect.right = rect.left;
      }
      return rect;
    };

    Renderer.prototype._getCursorCoordFromElement = function(element, offset) {
      var rect;
      switch (this.getElementType(element)) {
        case ModelType.TEXT:
          rect = this._getCursorCoordFromText(element, offset);
          break;
        case ModelType.LINE:
          rect = this._getCursorCoordFromLine(element, offset);
          break;
        case ModelType.BLIP:
          return null;
        default:
          rect = this._getCursorCoordFromInline(element, offset);
      }
      return rect;
    };

    Renderer.prototype._getCursorCoord = function(element, offset) {
      var rect;
      rect = this._getCursorCoordFromElement(element, offset);
      if (!rect) return null;
      DomUtils.convertWindowCoordsToRelative(rect, this._container.parentNode);
      return rect;
    };

    Renderer.prototype._drawCursorSafely = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      try {
        return this._drawCursor.apply(this, args);
      } catch (_error) {}
    };

    Renderer.prototype._drawCursor = function(element, offset, user) {
      var cursor, cursorObject, name, r, removeCursor, s, style, timerId,
        _this = this;
      if (!user) return;
      removeCursor = function() {
        DomUtils.remove(cursor);
        return delete globalCursors[user.id];
      };
      if (!element) return removeCursor();
      r = this._getCursorCoord(element, offset);
      if (!r) return removeCursor();
      cursor = (cursorObject = globalCursors[user.id]) ? cursorObject.node : document.createElement('div');
      style = cursor.style;
      style.top = "" + r.top + "px";
      style.left = "" + r.left + "px";
      style.height = "" + (r.bottom - r.top) + "px";
      timerId = setTimeout(removeCursor, 2000);
      if (cursorObject != null) {
        if (cursor.parentNode !== this._container.parentNode) {
          this._container.parentNode.appendChild(cursor);
        }
        clearTimeout(cursorObject.timerId);
        cursorObject.timerId = timerId;
        return;
      }
      style = cursor.style;
      style.backgroundColor = USER_COLORS[(parseInt(user.id.replace(/0_u_/, ''), 32) || 0) % USER_COLORS.length];
      for (s in CURSOR_STYLE) {
        style[s] = CURSOR_STYLE[s];
      }
      name = document.createElement('div');
      name.textContent = user.name || '';
      style = name.style;
      for (s in NAME_STYLE) {
        style[s] = NAME_STYLE[s];
      }
      cursor.appendChild(name);
      this._container.parentNode.appendChild(cursor);
      return globalCursors[user.id] = {
        node: cursor,
        timerId: timerId
      };
    };

    Renderer.prototype.applyOps = function(ops, cachedRange, shiftCursor, user) {
      var i, lIndex, op, u, _len;
      if (user == null) user = null;
      this._linesUpdated = false;
      lIndex = ops.length - 1;
      u = null;
      for (i = 0, _len = ops.length; i < _len; i++) {
        op = ops[i];
        if (i === lIndex) u = user;
        this._applyOp(op, cachedRange, shiftCursor, u);
      }
      if (this._linesUpdated) return this._updateLines();
    };

    Renderer.prototype.applyOp = function(op, cachedRange, shiftCursor, user) {
      if (user == null) user = null;
      this._linesUpdated = false;
      this._applyOp(op, cachedRange, shiftCursor, user);
      if (this._linesUpdated) return this._updateLines();
    };

    Renderer.prototype.setParamsToInlineElement = function(element, params) {
      DomUtils.addClass(element, 'default-text');
      return this._setParamsToElement(element, params);
    };

    Renderer.prototype.destroy = function() {
      var recipientNode, taskRecipient, _i, _j, _len, _len2, _ref3, _ref4, _ref5, _ref6;
      this.removeAllListeners();
      _ref3 = this._recipients;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        recipientNode = _ref3[_i];
        if ((_ref4 = $(recipientNode).data('recipient')) != null) _ref4.destroy();
      }
      _ref5 = this._taskRecipients;
      for (_j = 0, _len2 = _ref5.length; _j < _len2; _j++) {
        taskRecipient = _ref5[_j];
        if ((_ref6 = $(taskRecipient).data('object')) != null) _ref6.destroy();
      }
      delete this._addInlineBlip;
      delete this._removeInlineBlip;
      delete this._getRecipient;
      return delete this._getNewInlineElement;
    };

    Renderer.prototype._applyOp = function(op, cachedRange, shiftCursor, user) {
      if ((op.ti != null) && op[ModelField.PARAMS][ParamsField.TYPE] !== ModelType.TEXT) {
        return this._handleOiOp(op, cachedRange, shiftCursor, user);
      }
      if ((op.td != null) && op[ModelField.PARAMS][ParamsField.TYPE] !== ModelType.TEXT) {
        return this._handleOdOp(op, cachedRange, user);
      }
      if (op.ti) return this._handleTiOp(op, cachedRange, shiftCursor, user);
      if (op.td) return this._handleTdOp(op, cachedRange, shiftCursor, user);
      if (op.paramsi) {
        return this._handleParamsOp(op, shiftCursor, cachedRange, true, user);
      }
      if (op.paramsd) {
        return this._handleParamsOp(op, shiftCursor, cachedRange, false, user);
      }
    };

    return Renderer;

  })();

  MicroEvent.mixin(Renderer);

  exports.Renderer = Renderer;

  exports.BULLETED_LIST_LEVEL_COUNT = BULLETED_LIST_LEVEL_COUNT;

  exports.BULLETED_LIST_LEVEL_PADDING = BULLETED_LIST_LEVEL_PADDING;

  exports.BULLETED_LIST_START_PADDING = BULLETED_LIST_START_PADDING;

}).call(this);

});

require.define("/lib/client/client/editor/attachment/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var Attachment, attachmentTmpl, escapeHTML, renderAttachment,
    __slice = Array.prototype.slice;

  escapeHTML = require('../../utils/string').escapeHTML;

  attachmentTmpl = function() {
    return div('.attachment-content', function() {
      return a({
        href: h(this.src),
        rel: h(this.rel)
      }, function() {
        return img('.attachment-preview', {
          src: h(this.src),
          alt: ''
        });
      });
    });
  };

  renderAttachment = window.CoffeeKup.compile(attachmentTmpl);

  Attachment = (function() {

    function Attachment() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._init.apply(this, args);
    }

    Attachment.prototype._init = function(_rel, url) {
      this._rel = _rel;
      this._url = url;
      return this._createDom();
    };

    Attachment.prototype._createDom = function() {
      var params;
      this._container = document.createElement('span');
      this._container.contentEditable = 'false';
      params = {
        src: this._url,
        rel: this._rel
      };
      return $(this._container).append(renderAttachment(params));
    };

    Attachment.prototype.getContainer = function() {
      return this._container;
    };

    return Attachment;

  })();

  exports.Attachment = Attachment;

}).call(this);

});

require.define("/lib/client/client/editor/file/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BrowserSupportedImageTypes, File, FileStatus, SUPPORTED_EXTS, SUPPORTED_TYPES, Viewer, renderer, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = Array.prototype.slice;

  FileStatus = require('../../../share/file').FileStatus;

  BrowserSupportedImageTypes = require('../../../share/file').BrowserSupportedImageTypes;

  renderer = require('./template');

  _ref = require('./viewer'), Viewer = _ref.Viewer, SUPPORTED_TYPES = _ref.SUPPORTED_TYPES, SUPPORTED_EXTS = _ref.SUPPORTED_EXTS;

  File = (function() {

    function File() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._renderInfo = __bind(this._renderInfo, this);
      this._init.apply(this, args);
    }

    File.prototype._init = function(_rel, id, _relUpdateCallback) {
      var FileProcessor;
      this._rel = _rel;
      this._relUpdateCallback = _relUpdateCallback;
      this._container = document.createElement('span');
      this._container.contentEditable = 'false';
      FileProcessor = require('../../file/processor').instance;
      FileProcessor.getFileInfo(id, this._renderInfo);
      return this._renderInfo();
    };

    File.prototype._renderInfo = function(info) {
      var $container, data, fileSize, fileType, name, params, showThumbnail, status, viewer;
      $container = $(this._container).empty();
      status = info != null ? info.status : void 0;
      switch (status) {
        case FileStatus.READY:
          data = info.data;
          showThumbnail = BrowserSupportedImageTypes.indexOf(data.mime) >= 0;
          params = {
            name: (name = data.name),
            link: data.link,
            mime: (fileType = data.mime),
            size: (fileSize = data.size),
            userId: data.userId
          };
          if (showThumbnail && data.thumbnail) {
            params.rel = this._rel;
            params.thumbnail = data.thumbnail;
            $container.append(renderer.renderImage(params));
            if (this._relUpdateCallback) this._relUpdateCallback();
          } else {
            if (((viewer = SUPPORTED_TYPES[fileType]) != null) && viewer.limit >= fileSize || SUPPORTED_EXTS.indexOf(name.substr(name.lastIndexOf('.')).toLowerCase()) !== -1 && ((viewer = SUPPORTED_EXTS.viewer) != null)) {
              params.viewText = 'View' + viewer.additionalString;
              $container.append(renderer.renderPreviewableFile(params));
              $container.find('.js-view').on('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                return Viewer.open(fileType, "" + location.protocol + "//" + location.host + data.link, name);
              });
            } else {
              $container.append(renderer.renderFile(params));
            }
          }
          if (this._relUpdateCallback) delete this._relUpdateCallback;
          return this._container.setAttribute('rzUrl', data.link);
        case FileStatus.ERROR:
          $container.append(renderer.renderErrorFile());
          return delete this._relUpdateCallback;
        case FileStatus.UPLOADING:
          return $container.append(renderer.renderUploadingFile());
        case FileStatus.PROCESSING:
          return $container.append(renderer.renderProcessingFile());
        default:
          return $container.append(renderer.renderLoadingFile());
      }
    };

    File.prototype.getContainer = function() {
      return this._container;
    };

    return File;

  })();

  exports.File = File;

}).call(this);

});

require.define("/lib/client/client/editor/file/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ck, errorFileTmpl, fileTmpl, imgTmpl, loadingFileTmpl, previewableFileTmpl, processingFileTmpl, uploadFormModalTmpl, uploadFormTmpl, uploadingFileTmpl;

  ck = window.CoffeeKup;

  uploadFormTmpl = function() {
    return div('file-window-body', function() {
      div('js-image-insert-container', function() {
        div(function() {
          div({
            style: 'padding-bottom: 5px;'
          }, function() {
            return label({
              "for": 'insertAttachmentInput'
            }, 'Insert URL of picture on other site');
          });
          return div({
            style: 'position: relative;'
          }, function() {
            input('.outer-input', {
              id: 'insertAttachmentInput',
              type: 'text'
            });
            return button('.js-insert-attachment-button.inner-button', {
              type: 'button'
            }, ' Insert ');
          });
        });
        return div({
          style: 'height: 1px; margin: 10px 0; background: rgba(0, 0, 0, 0.25);'
        });
      });
      return div(function() {
        form('upload-form centered', {
          method: 'post',
          action: '#',
          enctype: 'multipart/form-data',
          id: 'uploadForm',
          style: 'position: relative;'
        }, function() {
          label('js-upload-form-file-label', {
            "for": 'uploadFormFileInput'
          });
          input('js-upload-form-file-input.file-input', {
            type: 'file',
            name: 'file',
            id: 'uploadFormFileInput',
            multiple: true
          });
          button('js-browse-button.button.browse-button', {
            type: 'button'
          }, 'Browse');
          return input('js-upload-form-id-input', {
            type: 'hidden',
            name: 'id'
          });
        });
        div('upload-quota centered', function() {
          span('js-upload-quota', '');
          return a({
            href: 'https://rizzoma.com/topic/c9a2f62e63536a0fb0ed5b6681c195d4/',
            target: '_blank'
          }, 'Get more space');
        });
        return div('You can also drag & drop files from your desktop');
      });
    });
  };

  uploadFormModalTmpl = function() {
    return div('upload-form-modal', function() {
      div("Loading file \"" + (h(this.file)) + "\"");
      div('.progress');
      return div({
        style: 'test-align: center; margin-top: 10px;'
      }, function() {
        return button('.js-cancel-button.button', 'Cancel');
      });
    });
  };

  imgTmpl = function() {
    return div('.file-content', function() {
      a({
        href: h(this.link),
        target: '_blank',
        rel: h(this.rel)
      }, function() {
        return img('.file-preview', {
          src: h(this.thumbnail),
          alt: h(this.name)
        });
      });
      return div('.caption', function() {
        return a({
          href: h(this.link),
          target: '_blank'
        }, h(this.name) || 'File');
      });
    });
  };

  fileTmpl = function() {
    return div('.file-content', function() {
      div('.file-preview', function() {
        return h2('.file-ext', h(this.name.substr(this.name.lastIndexOf('.'))) || 'File');
      });
      return div('.caption', function() {
        return a({
          href: h(this.link),
          target: '_blank'
        }, h(this.name) || 'File');
      });
    });
  };

  previewableFileTmpl = function() {
    return div('.file-content', function() {
      div('.file-preview', function() {
        h2('.file-ext', h(this.name.substr(this.name.lastIndexOf('.'))) || 'File');
        return div('.caption', function() {
          return a('.js-view', {
            href: '#'
          }, h(this.viewText));
        });
      });
      return div('.caption', function() {
        return a({
          href: h(this.link),
          target: '_blank'
        }, h(this.name) || 'File');
      });
    });
  };

  processingFileTmpl = function() {
    return div('.file-content', {
      style: "background: green;"
    }, 'Processing');
  };

  errorFileTmpl = function() {
    return div('.file-content', {
      style: "background: red;"
    }, 'Error');
  };

  uploadingFileTmpl = function() {
    return div('.file-content', {
      style: "background: yellow;"
    }, 'Uploading');
  };

  loadingFileTmpl = function() {
    return div('.file-content', 'Loading');
  };

  module.exports = {
    renderUploadForm: ck.compile(uploadFormTmpl),
    renderUploadFormModal: ck.compile(uploadFormModalTmpl),
    renderFile: ck.compile(fileTmpl),
    renderPreviewableFile: ck.compile(previewableFileTmpl),
    renderImage: ck.compile(imgTmpl),
    renderProcessingFile: ck.compile(processingFileTmpl),
    renderErrorFile: ck.compile(errorFileTmpl),
    renderUploadingFile: ck.compile(uploadingFileTmpl),
    renderLoadingFile: ck.compile(loadingFileTmpl)
  };

}).call(this);

});

require.define("/lib/client/client/editor/file/viewer.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var DocsViewer, DomUtils, ModalWindow, PROP_ID, SUPPORTED_EXTS, SUPPORTED_TYPES, SimpleViewer, Viewer, WarnWindow, docsViewer, exts, renderWarnContent, warningTmpl,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  ModalWindow = require('../../widget/window/modal_window').ModalWindow;

  DomUtils = require('../../utils/dom');

  warningTmpl = function() {
    div({
      style: 'font-size: 16px; text-align: center;'
    }, function() {
      span('You are going to open file with external service.');
      br('');
      span('By using this service you acknowledge that you have read and');
      br('');
      span('agreed to the ');
      return a({
        href: 'https://docs.google.com/viewer',
        target: '_blank'
      }, 'Google Docs Viewer Terms of Service');
    });
    div({
      style: 'font-size: 13px; color: #818588; text-align: center;'
    }, function() {
      input({
        type: 'checkbox',
        style: 'vertical-align: middle; margin-right: 5px;',
        id: 'docsViewerDoNotShow'
      });
      return label({
        "for": 'docsViewerDoNotShow'
      }, "Don't show this warning");
    });
    return div({
      style: 'text-align: center;'
    }, function() {
      button('button js-open-button', {
        style: 'margin: 5px 15px;'
      }, 'Open document');
      return button('button js-cancel-button', {
        style: 'margin: 5px 15px;'
      }, 'Cancel');
    });
  };

  renderWarnContent = window.CoffeeKup.compile(warningTmpl);

  PROP_ID = 'gDocsViewerNoWarn';

  SimpleViewer = (function(_super) {

    __extends(SimpleViewer, _super);

    function SimpleViewer() {
      SimpleViewer.__super__.constructor.apply(this, arguments);
    }

    SimpleViewer.prototype.open = function(url) {
      return SimpleViewer.__super__.open.call(this);
    };

    return SimpleViewer;

  })(ModalWindow);

  WarnWindow = (function(_super) {

    __extends(WarnWindow, _super);

    function WarnWindow() {
      this._handleCancelBtn = __bind(this._handleCancelBtn, this);
      this._handleOpenBtn = __bind(this._handleOpenBtn, this);
      var params;
      params = {
        title: 'Warning',
        closeOnOutsideAction: true,
        closeOnEsc: true
      };
      WarnWindow.__super__.constructor.call(this, params);
    }

    WarnWindow.prototype._handleOpenBtn = function() {
      this.emit('accept');
      return this.destroy();
    };

    WarnWindow.prototype._handleCancelBtn = function() {
      _gaq.push(['_trackEvent', 'Topic content', 'Cancel preview attach']);
      return this.destroy();
    };

    WarnWindow.prototype.destroy = function() {
      var checked, prefs, _ref;
      this.removeAllListeners('accept');
      this._openButton.removeEventListener('click', this._handleOpenBtn, false);
      this._cancelButton.removeEventListener('click', this._handleCancelBtn, false);
      checked = document.getElementById('docsViewerDoNotShow').checked;
      prefs = (_ref = require('../../user/processor').instance) != null ? _ref.getMyPrefs() : void 0;
      if (checked && (prefs != null) && prefs[PROP_ID] !== checked) {
        prefs[PROP_ID] = checked;
        require('../../wave/processor').instance.setUserClientOption(PROP_ID, checked, function() {});
      }
      return WarnWindow.__super__.destroy.call(this);
    };

    WarnWindow.prototype.open = function() {
      var child, f, parent;
      f = DomUtils.parseFromString(renderWarnContent());
      child = f.firstChild;
      this.setContent(f);
      parent = child.parentNode;
      this._openButton = parent.getElementsByClassName('js-open-button')[0];
      this._cancelButton = parent.getElementsByClassName('js-cancel-button')[0];
      this._openButton.addEventListener('click', this._handleOpenBtn, false);
      this._cancelButton.addEventListener('click', this._handleCancelBtn, false);
      this.on('close', function() {
        return this.destroy();
      });
      return WarnWindow.__super__.open.call(this);
    };

    return WarnWindow;

  })(ModalWindow);

  DocsViewer = (function(_super) {

    __extends(DocsViewer, _super);

    function DocsViewer() {
      var params;
      params = {
        title: 'Insert attachment',
        closeButton: true,
        closeOnOutsideAction: true,
        closeOnEsc: true
      };
      DocsViewer.__super__.constructor.call(this, params);
    }

    DocsViewer.prototype.open = function(url, name) {
      var accept, wnd, _ref, _ref2,
        _this = this;
      url += "/" + (encodeURIComponent(name));
      accept = function() {
        var content;
        content = document.createElement('iframe');
        content.src = "https://docs.google.com/viewer?url=" + (encodeURIComponent(url)) + "&embedded=true";
        content.width = '100%';
        content.height = '100%';
        content.style.border = 'none';
        _this.getBodyEl().style.height = '100%';
        _this.setContent(content);
        return DocsViewer.__super__.open.call(_this, url);
      };
      if ((_ref = require('../../user/processor').instance) != null ? (_ref2 = _ref.getMyPrefs()) != null ? _ref2[PROP_ID] : void 0 : void 0) {
        return accept();
      } else {
        wnd = new WarnWindow();
        wnd.on('accept', accept);
        return wnd.open();
      }
    };

    return DocsViewer;

  })(SimpleViewer);

  docsViewer = {
    cls: DocsViewer,
    limit: 25 * 1024 * 1024,
    additionalString: ' in Google Docs'
  };

  module.exports.SUPPORTED_EXTS = SUPPORTED_EXTS = exts = ['.txt', '.css', '.html', '.php', '.c', '.cpp', '.h', '.hpp', '.js', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.pdf', '.pages', '.ai', '.psd', '.tiff', '.dxf', '.svg', '.eps', '.ps', '.ttf', '.xps', '.log'];

  SUPPORTED_EXTS.viewer = docsViewer;

  module.exports.SUPPORTED_TYPES = SUPPORTED_TYPES = {
    'application/javascript': docsViewer,
    'application/illustrator': docsViewer,
    'application/msword': docsViewer,
    'application/oxps': docsViewer,
    'application/pdf': docsViewer,
    'application/postscript': docsViewer,
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': docsViewer,
    'application/vnd.ms-excel': docsViewer,
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': docsViewer,
    'application/vnd.ms-powerpoint': docsViewer,
    'application/vnd.openxmlformats-officedocument.presentationml.presentation': docsViewer,
    'application/vnd.oasis.opendocument.text': docsViewer,
    'application/vnd.oasis.opendocument.presentation': docsViewer,
    'application/x-font-ttf': docsViewer,
    'application/x-iwork-pages-sffpages': docsViewer,
    'image/vnd.adobe.photoshop': docsViewer,
    'image/vnd.dxf': docsViewer,
    'image/svg+xml': docsViewer,
    'image/tiff': docsViewer,
    'image/x-eps': docsViewer,
    'text/plain': docsViewer,
    'text/css': docsViewer,
    'text/html': docsViewer,
    'text/x-csrc': docsViewer,
    'text/x-c++src': docsViewer,
    'text/x-chdr': docsViewer,
    'text/javascript': docsViewer
  };

  Viewer = (function() {

    function Viewer() {}

    Viewer.prototype.open = function(type, url, name) {
      var onClose, style, viewer, wnd;
      if (!(viewer = SUPPORTED_TYPES[type] || (viewer = SUPPORTED_EXTS.viewer))) {
        return;
      }
      wnd = new viewer.cls();
      style = wnd.getWindow().style;
      style.width = '90%';
      style.height = '90%';
      wnd.getBodyEl().style.border = 'none';
      wnd.open(url, name);
      _gaq.push(['_trackEvent', 'Topic content', 'Preview attach', type]);
      onClose = function() {
        this.removeListener('close', onClose);
        return this.destroy();
      };
      return wnd.on('close', onClose);
    };

    return Viewer;

  })();

  module.exports.Viewer = new Viewer();

}).call(this);

});

require.define("/lib/client/client/widget/window/modal_window.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var CenteredWindow, ModalWindow,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  CenteredWindow = require('./centered_window').CenteredWindow;

  ModalWindow = (function(_super) {

    __extends(ModalWindow, _super);

    function ModalWindow() {
      ModalWindow.__super__.constructor.apply(this, arguments);
    }

    /*
        Shows modal window over the page.
    */

    ModalWindow.prototype.__createDom = function(params) {
      ModalWindow.__super__.__createDom.call(this, params);
      return $(this._container).addClass('modal');
    };

    return ModalWindow;

  })(CenteredWindow);

  exports.ModalWindow = ModalWindow;

}).call(this);

});

require.define("/lib/client/client/widget/window/centered_window.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var CenteredWindow, Window, renderCenteredWindowBg,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  Window = require('./').Window;

  renderCenteredWindowBg = require('./template').renderCenteredWindowBg;

  CenteredWindow = (function(_super) {

    __extends(CenteredWindow, _super);

    function CenteredWindow() {
      this.close = __bind(this.close, this);
      CenteredWindow.__super__.constructor.apply(this, arguments);
    }

    CenteredWindow.prototype.__createDom = function(params) {
      var tmpEl;
      CenteredWindow.__super__.__createDom.call(this, params);
      tmpEl = document.createElement('span');
      $(tmpEl).append(renderCenteredWindowBg());
      this._container = tmpEl.firstChild;
      return this._container.appendChild(this._wnd);
    };

    CenteredWindow.prototype.__addGlobalListeners = function() {
      return this._container.addEventListener('mousedown', this.__handleOutsideEvent, false);
    };

    CenteredWindow.prototype.__removeGlobalListeners = function() {
      return this._container.removeEventListener('mousedown', this.__handleOutsideEvent, false);
    };

    CenteredWindow.prototype.getContainer = function() {
      return this._container;
    };

    CenteredWindow.prototype.destroy = function() {
      CenteredWindow.__super__.destroy.call(this);
      $(this._container).remove();
      return delete this._container;
    };

    CenteredWindow.prototype.open = function() {
      document.body.appendChild(this._container);
      CenteredWindow.__super__.open.call(this);
      return $(this._container).show();
    };

    CenteredWindow.prototype.close = function(force) {
      if (force == null) force = false;
      CenteredWindow.__super__.close.call(this, force);
      return $(this._container).hide();
    };

    return CenteredWindow;

  })(Window);

  exports.CenteredWindow = CenteredWindow;

}).call(this);

});

require.define("/lib/client/client/widget/window/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var MicroEvent, Window, renderBaseWindow,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  renderBaseWindow = require('./template').renderBaseWindow;

  MicroEvent = require('../../utils/microevent');

  Window = (function() {
    /*
        Базовый класс
        @params {Object} params:
            title: string
            closeButton: bool
            closeOnOutsideAction: bool - закрывает окно при событиях mousedown, keydown вне окна
            closeOnEsc: bool
            onClose: Function - Если возвращает false, то окно не будет закрыто
    */
    function Window(params) {
      if (params == null) params = {};
      this.close = __bind(this.close, this);
      this.__handleOutsideEvent = __bind(this.__handleOutsideEvent, this);
      this._keyHandler = __bind(this._keyHandler, this);
      this.__createDom(params);
      this._closeOnOutsideAction = params['closeOnOutsideAction'] || false;
      this._destroyOnClose = params['destroyOnClose'] || false;
    }

    Window.prototype.__createDom = function(params) {
      var $wnd, tmpEl, wndParams,
        _this = this;
      wndParams = {
        title: params['title'] || '',
        closeButton: params['closeButton'] || false
      };
      tmpEl = document.createElement('span');
      $(tmpEl).append(renderBaseWindow(wndParams));
      this._wnd = tmpEl.firstChild;
      $wnd = $(this._wnd);
      this._body = $wnd.find('.js-window-body')[0];
      if (params['closeButton']) {
        $wnd.find('.js-window-close-btn').bind('click', function() {
          return _this.close();
        });
      }
      if (params['closeOnEsc']) $wnd.bind('keydown', this._keyHandler);
      if ($.isFunction(params['onClose'])) {
        return this._onClose = params['onClose'];
      }
    };

    Window.prototype.__addGlobalListeners = function() {
      window.addEventListener('mousedown', this.__handleOutsideEvent, true);
      return window.addEventListener('keydown', this.__handleOutsideEvent, true);
    };

    Window.prototype.__removeGlobalListeners = function() {
      window.removeEventListener('mousedown', this.__handleOutsideEvent, true);
      return window.removeEventListener('keydown', this.__handleOutsideEvent, true);
    };

    Window.prototype._keyHandler = function(event) {
      /*
              Обработчик клавиатурных событий keypress, keydown
              @param node: Event | KeyEvent
      */      if (event.keyCode === 27) {
        this.close();
        event.preventDefault();
        return event.stopPropagation();
      }
    };

    Window.prototype.__handleOutsideEvent = function(event) {
      if (!$.contains(this._wnd, event.target)) return this.close();
    };

    Window.prototype.setContent = function(content) {
      return $(this._body).empty().append(content);
    };

    Window.prototype.destroy = function() {
      delete this._destroyOnClose;
      this.close(true);
      $(this._wnd).remove();
      delete this._wnd;
      return delete this._onClose;
    };

    Window.prototype.getWindow = function() {
      return this._wnd;
    };

    Window.prototype.getBodyEl = function() {
      return this._body;
    };

    Window.prototype.setWidth = function(width) {
      /*
              @param width: int
      */      return $(this._wnd).css('width', width);
    };

    Window.prototype.open = function() {
      if (this._closeOnOutsideAction) this.__addGlobalListeners();
      return $(this._wnd).show();
    };

    Window.prototype.close = function(force) {
      if (force == null) force = false;
      if (this._closeOnOutsideAction) this.__removeGlobalListeners();
      try {
        this.emit('close');
      } catch (_error) {}
      this.removeAllListeners('close');
      if (!force && this._onClose && !this._onClose()) return;
      $(this._wnd).hide();
      if (this._destroyOnClose) this.destroy();
      return true;
    };

    return Window;

  })();

  MicroEvent.mixin(Window);

  exports.Window = Window;

}).call(this);

});

require.define("/lib/client/client/widget/window/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var baseWindowTmpl, centeredWindowBgTmpl, ck;

  ck = window.CoffeeKup;

  baseWindowTmpl = function() {
    return div('.widget-window', function() {
      if (this.title) {
        div('.widget-window-header.js-window-header', function() {
          span('', h(this.title));
          if (this.closeButton) return span('.close-icon.js-window-close-btn', '');
        });
      }
      return div('.widget-window-body.js-window-body', '');
    });
  };

  centeredWindowBgTmpl = function() {
    return div('.widget-centered-window-bg', '');
  };

  exports.renderBaseWindow = ck.compile(baseWindowTmpl);

  exports.renderCenteredWindowBg = ck.compile(centeredWindowBgTmpl);

}).call(this);

});

require.define("/lib/client/client/editor/tag/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var Tag, TagInput, badCharacters, badCharactersRegExp, ck, renderTag, renderTagInput,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  ck = window.CoffeeKup;

  renderTag = ck.compile(function() {
    return span('.blip-tag-container', function() {
      return span('.js-blip-tag.blip-tag', function() {
        return span('.blip-tag-text', "#" + (h(this.text)));
      });
    });
  });

  renderTagInput = ck.compile(function() {
    return span('.tag-input-container', function() {
      input('.js-tag-input .tag-input', {
        type: "text",
        tabindex: "0"
      });
      return span({
        style: "position: absolute; left: 3px;"
      }, '#');
    });
  });

  badCharacters = require('../../tag/constants').badCharacters;

  badCharactersRegExp = new RegExp("[" + badCharacters + "]", 'g');

  Tag = (function() {

    function Tag(_text) {
      this._text = _text;
      this._container = document.createElement('span');
      this._container.contentEditable = 'false';
      $(this._container).append(renderTag({
        text: this._text
      }));
      this._processor = require('../../tag/processor').instance;
      this._processor.addTag(this._text);
      this._init();
    }

    Tag.prototype.getContainer = function() {
      return this._container;
    };

    Tag.prototype._init = function() {
      var _this = this;
      if (!window.loggedIn) return;
      $(this._container).find('.js-blip-tag').addClass('clickable');
      return $(this._container).on('mousedown', function(e) {
        return e.preventDefault();
      }).on('click', function() {
        return _this._processor.getCurWave(function(curWave) {
          var sharedState;
          sharedState = curWave.getModel().getSharedState();
          return _this._processor.findTopicListByTagText(_this._text, sharedState);
        });
      });
    };

    return Tag;

  })();

  TagInput = (function() {

    function TagInput() {
      this._destroyInputField = __bind(this._destroyInputField, this);
      this._filterInput = __bind(this._filterInput, this);
      var $container;
      this._container = document.createElement('span');
      this._container.contentEditable = 'false';
      $container = $(this._container);
      $container.append(renderTagInput());
      this._input = $container.find('.js-tag-input')[0];
      this._tagProcessor = require('../../tag/processor').instance;
      this._activateInputField();
    }

    TagInput.prototype._insertTag = function(tag) {
      if (!tag) return this._destroyInputField();
      $(this._container).trigger('tagInserted', tag);
      return _gaq.push(['_trackEvent', 'Tag', 'Tag creation', this.insertionEventLabel || 'Hotkey']);
    };

    TagInput.prototype._filterInput = function() {
      var curVal;
      curVal = $(this._input).val();
      return $(this._input).val(curVal.replace(badCharactersRegExp, ''));
    };

    TagInput.prototype._activateInputField = function() {
      var $input, autocompleter,
        _this = this;
      $input = $(this._input);
      autocompleter = $input.val('').autocomplete({
        getData: this._tagProcessor.getTags,
        onItemSelect: function(item) {
          return _this._insertTag(item.value);
        },
        matchInside: true,
        minChars: 0,
        preventDefaultTab: true,
        autoWidth: null,
        onFinish: this._destroyInputField,
        delimiterKeyCode: -1,
        delay: 0
      }).data('autocompleter');
      $input.keypress(function(e) {
        if (e.keyCode !== 13 && e.keyCode !== 32) return;
        _this._insertTag($input.val());
        e.stopPropagation();
        return e.preventDefault();
      });
      $input.on('input', this._filterInput);
      $input.blur(function() {
        return window.setTimeout(function() {
          return _this._destroyInputField();
        }, 200);
      });
      return autocompleter.activate();
    };

    TagInput.prototype._destroyInputField = function() {
      var autocompleter;
      autocompleter = $(this._input).data('autocompleter');
      if (!autocompleter) return;
      autocompleter.deactivate(false);
      return $(this._container).trigger('blur');
    };

    TagInput.prototype.getContainer = function() {
      return this._container;
    };

    TagInput.prototype.focus = function() {
      return this._input.focus();
    };

    TagInput.prototype.getValue = function() {
      return $(this._input).val();
    };

    TagInput.prototype.destroy = function() {
      var _ref;
      delete this._tagProcessor;
      if ((_ref = $(this._input).data('autocompleter')) != null) {
        _ref.dom.$results.remove();
      }
      return $(this._container).remove();
    };

    return TagInput;

  })();

  module.exports = {
    Tag: Tag,
    TagInput: TagInput
  };

}).call(this);

});

require.define("/lib/client/client/tag/constants.js",function(require,module,exports,__dirname,__filename,process,global){(function() {

  module.exports.badCharacters = "()|\\\-!@~&\/^$=№%#+*?,.:; ";

}).call(this);

});

require.define("/lib/client/client/editor/link_editor/link_popup.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BE, DomUtils, History, LinkPopup, renderLinkPopup,
    __slice = Array.prototype.slice;

  renderLinkPopup = require('./template').renderLinkPopup;

  BE = require('../../utils/browser_events');

  DomUtils = require('../../utils/dom');

  History = require('../../utils/history_navigation');

  LinkPopup = (function() {
    var MAX_OFFSET;

    MAX_OFFSET = 50;

    function LinkPopup() {
      var $tmpNode, args,
        _this = this;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      $tmpNode = $(document.createElement('span'));
      $tmpNode.append(renderLinkPopup());
      this._anchor = $tmpNode.find('.js-link-anchor')[0];
      this._anchorText = $(this._anchor).find('.js-link-text');
      this._changeButton = $tmpNode.find('.js-link-popup-change')[0];
      this._anchorImg = $tmpNode.find('.js-link-img');
      this._changeButton.addEventListener('click', function(e) {
        e.stopPropagation();
        if (_this._changeCallback) _this._changeCallback();
        return _this.hide();
      }, false);
      this._container = $tmpNode[0].firstChild;
      BE.addBlocker(this._container, BE.MOUSE_DOWN_EVENT);
      BE.addBlocker(this._container, BE.MOUSE_UP_EVENT);
    }

    LinkPopup.prototype._setText = function(text) {
      return this._anchorText.empty().text(text);
    };

    LinkPopup.prototype._setUrl = function(url, originalUrl) {
      this._anchor.href = url;
      return this._anchor.hrefOriginal = originalUrl;
    };

    LinkPopup.prototype._setExternal = function() {
      this._anchor.target = '_blank';
      this._anchorImg.removeClass('internal');
      return this._anchorImg.addClass('external');
    };

    LinkPopup.prototype._setInternal = function() {
      this._anchor.removeAttribute('target');
      this._anchorImg.removeClass('external');
      return this._anchorImg.addClass('internal');
    };

    LinkPopup.prototype.getContainer = function() {
      return this._container;
    };

    LinkPopup.prototype.hide = function() {
      this._container.style.display = 'none';
      this._changeCallback = null;
      this._lastTop = null;
      return this._lastLeft = null;
    };

    LinkPopup.prototype.show = function(url, rect, _changeCallback, showAtBottom) {
      var containerHeight, containerWidth, left, originalUrl, parent, parentHeight, parentWidth, posTop, res, top, urlParams;
      this._changeCallback = _changeCallback;
      this._setText(url);
      originalUrl = url;
      urlParams = History.getUrlParams(url);
      if (urlParams.host && urlParams.waveId) {
        this._setInternal();
        originalUrl = url;
        res = url.split(window.HOST);
        if (res.length > 1) url = res[1];
      } else {
        this._setExternal();
      }
      this._setUrl(url, originalUrl);
      top = rect.top;
      left = rect.left;
      this._container.style.display = 'block';
      containerWidth = this._container.offsetWidth;
      containerHeight = this._container.offsetHeight;
      parent = this._container.parentNode;
      parentWidth = parent.offsetWidth;
      parentHeight = parent.offsetHeight;
      posTop = top + rect.bottom - rect.top + 4;
      if (left + containerWidth > parentWidth) left = parentWidth - containerWidth;
      if (!showAtBottom && (posTop + containerHeight > parentHeight)) {
        posTop = top - containerHeight - 4;
      }
      if (posTop !== this._lastTop || Math.abs(left - this._lastLeft) > MAX_OFFSET) {
        this._lastTop = posTop;
        this._lastLeft = left;
        this._container.style.top = posTop + 'px';
        return this._container.style.left = left + 'px';
      }
    };

    LinkPopup.get = function() {
      var _ref;
      return (_ref = this.instance) != null ? _ref : this.instance = new this;
    };

    return LinkPopup;

  })();

  exports.LinkPopup = LinkPopup;

}).call(this);

});

require.define("/lib/client/client/editor/link_editor/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ck, linkEditorTmpl, linkPopupTmpl;

  ck = window.CoffeeKup;

  linkEditorTmpl = function() {
    return div('.link-editor-body', function() {
      div({
        style: 'font-size: 14px;'
      }, 'Insert link');
      return table('.link-editor-content', function() {
        tr('.link-name', function() {
          td('', 'Text');
          return td('', function() {
            label(function() {
              return input('.js-link-editor-text-input .text-input', {
                type: 'text'
              });
            });
            return div('.js-link-editor-text-div', '');
          });
        });
        tr('.link-url', function() {
          td('', 'URL');
          return td('', function() {
            return label(function() {
              return input('.js-link-editor-url-input .text-input', {
                type: 'text'
              });
            });
          });
        });
        return tr('', function() {
          td('', '');
          return td('', function() {
            button('.js-link-editor-update-btn.button', {
              title: 'Accept changes'
            }, 'Submit');
            return button('.js-link-editor-remove-btn.button', {
              title: 'Remove link'
            }, 'Remove');
          });
        });
      });
    });
  };

  linkPopupTmpl = function() {
    return div('.js-link-popup.link-popup', {
      tabIndex: '0'
    }, function() {
      a('.js-link-anchor', function() {
        div('.js-link-img', '');
        return span('.js-link-text', '');
      });
      return button('.js-link-popup-change.button', 'Change');
    });
  };

  exports.renderLinkEditor = ck.compile(linkEditorTmpl);

  exports.renderLinkPopup = ck.compile(linkPopupTmpl);

}).call(this);

});

require.define("/lib/client/client/editor/link_editor/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var Action, CenteredWindow, KeyCodes, LinkEditor, MAX_URL_LENGTH, WarnWindow, instance, renderLinkEditor,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  CenteredWindow = require('../../widget/window/centered_window').CenteredWindow;

  WarnWindow = require('../../widget/window/warning');

  KeyCodes = require('../../utils/key_codes').KeyCodes;

  renderLinkEditor = require('./template').renderLinkEditor;

  MAX_URL_LENGTH = require('../common').MAX_URL_LENGTH;

  Action = {
    MARK_LINK: 'markLink',
    INSERT_TEXT: 'insertText'
  };

  LinkEditor = (function(_super) {

    __extends(LinkEditor, _super);

    function LinkEditor() {
      this._inputKeyPressHandler = __bind(this._inputKeyPressHandler, this);
      this._remove = __bind(this._remove, this);
      this._update = __bind(this._update, this);
      var params;
      params = {
        title: 'Insert link',
        closeButton: true,
        closeOnOutsideAction: true,
        closeOnEsc: true
      };
      LinkEditor.__super__.constructor.call(this, params);
    }

    LinkEditor.prototype.close = function() {
      LinkEditor.__super__.close.call(this);
      this._$textInput.hide();
      this._$textDiv.hide();
      delete this._updateLink;
      return delete this._insertText;
    };

    LinkEditor.prototype.open = function(text, url, editable, _updateLink, _insertText) {
      this._updateLink = _updateLink;
      this._insertText = _insertText;
      this._clear();
      LinkEditor.__super__.open.call(this);
      this._initialText = text || '';
      this._setText(this._initialText);
      this._setUrl(url || '');
      if (editable) {
        this._$textInput.show();
        this._action = Action.INSERT_TEXT;
        if (this._initialText) {
          this._$urlInput.select();
        } else {
          this._$textInput.select();
        }
        return;
      }
      this._action = Action.MARK_LINK;
      this._$textDiv.show();
      return this._$urlInput.select();
    };

    LinkEditor.prototype.__createDom = function(params) {
      var $c, tmp;
      LinkEditor.__super__.__createDom.call(this, params);
      tmp = document.createElement('span');
      $(tmp).append(renderLinkEditor());
      this._body.appendChild(tmp.firstChild);
      $c = $(this._body);
      this._$textInput = $c.find('.js-link-editor-text-input').on('keypress', this._inputKeyPressHandler);
      this._$textDiv = $c.find('.js-link-editor-text-div');
      this._$urlInput = $c.find('.js-link-editor-url-input').on('keypress', this._inputKeyPressHandler);
      $c.find('.js-link-editor-update-btn').on('click', this._update);
      return $c.find('.js-link-editor-remove-btn').on('click', this._remove);
    };

    LinkEditor.get = function() {
      var _ref;
      return (_ref = this.instance) != null ? _ref : this.instance = new this;
    };

    LinkEditor.prototype._normalizeLink = function(link) {
      link = link.replace(/^\s+|\s+$/g, '');
      if (/^(javascript|vbscript):/.test(link)) return 'http://' + link;
      if (!/^([a-zA-Z0-9\-]+):/.test(link)) return 'http://' + link;
      return link;
    };

    LinkEditor.prototype._clear = function() {
      this._$textInput.val('');
      return this._$urlInput.val('');
    };

    LinkEditor.prototype._update = function() {
      /*
              Обработчик нажатия кнопки Update
      */
      var text, url;
      url = this._$urlInput.val();
      if (!url) return this._remove();
      url = this._normalizeLink(url);
      if (url.length > MAX_URL_LENGTH) {
        return new WarnWindow('Your URL is too long');
      }
      if (this._action === Action.MARK_LINK) {
        this._updateLink(url);
      } else {
        text = this._$textInput.val();
        if (!text) return this._$textInput.focus();
        if (this._initialText === text) {
          this._updateLink(url);
        } else {
          this._insertText(text, url);
        }
      }
      return this.close();
    };

    LinkEditor.prototype._remove = function() {
      /*
              Обработчик нажатия кнопки Remove
      */      this._updateLink(null);
      return this.close();
    };

    LinkEditor.prototype._inputKeyPressHandler = function(event) {
      /*
              Обработчик клавиатурных событий keypress
              @param node: Event | KeyEvent
      */      if (event.keyCode === KeyCodes.KEY_ENTER) {
        this._update();
        event.preventDefault();
        return event.stopPropagation();
      }
    };

    LinkEditor.prototype._setText = function(text) {
      this._$textInput.val(text);
      return this._$textDiv.text(text);
    };

    LinkEditor.prototype._setUrl = function(url) {
      return this._$urlInput.val(url);
    };

    return LinkEditor;

  })(CenteredWindow);

  instance = null;

  exports.LinkEditor = {
    get: function() {
      return instance != null ? instance : instance = new LinkEditor();
    }
  };

}).call(this);

});

require.define("/lib/client/client/widget/window/warning.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var DomUtils, KeyCodes, ModalWindow, WarningWindow, contentTmpl, renderContent,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  ModalWindow = require('./modal_window').ModalWindow;

  DomUtils = require('../../utils/dom');

  KeyCodes = require('../../utils/key_codes').KeyCodes;

  contentTmpl = function() {
    h1("" + this.msg);
    return div('centered', function() {
      return button('js-ok-button button', 'Ok');
    });
  };

  renderContent = window.CoffeeKup.compile(contentTmpl);

  WarningWindow = (function(_super) {

    __extends(WarningWindow, _super);

    function WarningWindow(msg, title) {
      var params;
      if (title == null) title = '';
      params = {
        title: title || 'Warning',
        closeButton: true,
        closeOnEsc: true,
        destroyOnClose: true,
        msg: msg
      };
      WarningWindow.__super__.constructor.call(this, params);
      this.open();
    }

    WarningWindow.prototype.__createDom = function(params) {
      var btn, content, p, wnd;
      WarningWindow.__super__.__createDom.call(this, params);
      p = {
        msg: params.msg
      };
      content = DomUtils.parseFromString(renderContent(p));
      this.setContent(content);
      wnd = this.getWindow();
      DomUtils.addClass(wnd, 'warning-window');
      btn = wnd.getElementsByClassName('js-ok-button')[0];
      btn.addEventListener('click', this.close, false);
      btn.addEventListener('keydown', function(e) {
        if (e.keyCode === KeyCodes.KEY_TAB) return e.preventDefault();
      }, false);
      return this.getContainer().addEventListener('mousedown', function(e) {
        var _ref;
        e.preventDefault();
        return (_ref = this.getElementsByClassName('js-ok-button')[0]) != null ? _ref.focus() : void 0;
      }, false);
    };

    WarningWindow.prototype.open = function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      WarningWindow.__super__.open.apply(this, args);
      return (_ref = this.getWindow().getElementsByClassName('js-ok-button')[0]) != null ? _ref.focus() : void 0;
    };

    WarningWindow.prototype.destroy = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.getWindow().getElementsByClassName('js-ok-button')[0].removeEventListener('click', this.close, false);
      return WarningWindow.__super__.destroy.apply(this, args);
    };

    return WarningWindow;

  })(ModalWindow);

  module.exports = WarningWindow;

}).call(this);

});

require.define("/lib/client/client/search_panel/task/constants.js",function(require,module,exports,__dirname,__filename,process,global){(function() {

  module.exports = {
    NOT_PERFORMED_TASK: 1,
    PERFORMED_TASK: 2
  };

}).call(this);

});

require.define("/lib/client/client/blip/task_recipient/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var NOT_PERFORMED_TASK, PERFORMED_TASK, TaskRecipient, TaskRecipientPopup, TaskRecipientStub, ck, convertDate, convertDateTimeToClient, convertDatetime, formatAsShortenedDate, formatAsShortenedDateTime, popup, recipientTmpl, renderRecipient, renderRecipientTmpl, setUserPopupBehaviour, _ref, _ref2, _ref3,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = Array.prototype.slice;

  setUserPopupBehaviour = require('../../popup/user_popup').setUserPopupBehaviour;

  popup = require('../../popup').popup;

  TaskRecipientPopup = require('./popup').TaskRecipientPopup;

  _ref = require('../../../share/utils/datetime'), formatAsShortenedDate = _ref.formatAsShortenedDate, formatAsShortenedDateTime = _ref.formatAsShortenedDateTime;

  _ref2 = require('../../../share/utils/date_converter'), convertDate = _ref2.convertDate, convertDatetime = _ref2.convertDatetime, convertDateTimeToClient = _ref2.convertDateTimeToClient;

  _ref3 = require('../../search_panel/task/constants'), NOT_PERFORMED_TASK = _ref3.NOT_PERFORMED_TASK, PERFORMED_TASK = _ref3.PERFORMED_TASK;

  ck = window.CoffeeKup;

  recipientTmpl = function() {
    return span('task-recipient-container', function() {
      span('editor-el-split', '|');
      span('task-recipient', function() {
        var id, inputParams;
        id = 'task-recipient-completed' + Math.random();
        inputParams = {
          type: 'checkbox',
          id: id
        };
        if (this.isStub) inputParams.disabled = 'disabled';
        if (this.isCompleted) inputParams.checked = 'checked';
        input('js-task-completed custom', inputParams);
        label({
          "for": id
        }, '');
        return span('js-recipient-task-info', function() {
          span('task-recipient-text', h(this.name));
          if (this.deadline) {
            return span('task-recipient-deadline', h(this.deadline));
          }
        });
      });
      return span('editor-el-split', '|');
    });
  };

  renderRecipientTmpl = ck.compile(recipientTmpl);

  renderRecipient = function(name, deadlineDate, deadlineDatetime, status, isStub) {
    var params;
    params = {
      name: name,
      isCompleted: status === PERFORMED_TASK,
      isStub: isStub
    };
    if (deadlineDate != null) {
      params.deadline = formatAsShortenedDate(convertDate(deadlineDate));
    }
    if (deadlineDatetime != null) {
      params.deadline = formatAsShortenedDateTime(convertDatetime(deadlineDatetime));
    }
    return renderRecipientTmpl(params);
  };

  TaskRecipient = (function() {

    function TaskRecipient() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.convert = __bind(this.convert, this);
      this.update = __bind(this.update, this);
      this.remove = __bind(this.remove, this);
      this._updateUserInfo = __bind(this._updateUserInfo, this);
      this._canConvert = __bind(this._canConvert, this);
      this._canDelete = __bind(this._canDelete, this);
      this._canChangeFields = __bind(this._canChangeFields, this);
      this._canChangeRecipient = __bind(this._canChangeRecipient, this);
      this._init.apply(this, args);
    }

    TaskRecipient.prototype._init = function(_waveViewModel, _data, _updateCallback, _removeCallback, _convertCallback, _updateTaskSearchInfo, _canEditBlip) {
      this._waveViewModel = _waveViewModel;
      this._data = _data;
      this._updateCallback = _updateCallback;
      this._removeCallback = _removeCallback;
      this._convertCallback = _convertCallback;
      this._updateTaskSearchInfo = _updateTaskSearchInfo;
      this._canEditBlip = _canEditBlip;
      this._render();
      this._waveViewModel.on('usersInfoUpdate', this._updateUserInfo);
      return this._initCompleted();
    };

    TaskRecipient.prototype._canChangeRecipient = function() {
      return this._canEditBlip() && this._waveViewModel.haveEmails();
    };

    TaskRecipient.prototype._canChangeFields = function() {
      var _ref4;
      return this._canEditBlip() || this._data.recipientId === ((_ref4 = window.userInfo) != null ? _ref4.id : void 0);
    };

    TaskRecipient.prototype._canDelete = function() {
      var _ref4;
      return this._canEditBlip() || this._data.recipientId === ((_ref4 = window.userInfo) != null ? _ref4.id : void 0);
    };

    TaskRecipient.prototype._canConvert = function() {
      return this._canEditBlip();
    };

    TaskRecipient.prototype._updateUserInfo = function(userIds) {
      var userId, _i, _len;
      for (_i = 0, _len = userIds.length; _i < _len; _i++) {
        userId = userIds[_i];
        if (this._data.recipientId === userId) return this._render();
      }
    };

    TaskRecipient.prototype._render = function() {
      var $c, popupArea, user;
      this._container || (this._container = document.createElement('span'));
      this._container.contentEditable = 'false';
      $c = $(this._container);
      $c.empty();
      user = this._waveViewModel.getUser(this._data.recipientId);
      $c.append(renderRecipient(user.getName(), this._data.deadlineDate, this._data.deadlineDatetime, this._data.status));
      popupArea = $c.find('.js-recipient-task-info');
      return setUserPopupBehaviour(popupArea, TaskRecipientPopup, this._data, this._waveViewModel, this._canChangeRecipient, this._canChangeFields, this._canDelete, this._canConvert, this.update, this.remove, this.convert);
    };

    TaskRecipient.prototype._initCompleted = function() {
      var _this = this;
      return $(this._container).click('.js-task-completed', function() {
        var completedCheckbox, data, p, _i, _len, _ref4;
        if (!_this._canChangeFields()) return false;
        completedCheckbox = $(_this._container).find('.js-task-completed')[0];
        data = {
          status: completedCheckbox.checked ? PERFORMED_TASK : NOT_PERFORMED_TASK
        };
        _ref4 = ['recipientId', 'deadlineDate', 'deadlineDatetime'];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          p = _ref4[_i];
          data[p] = _this._data[p];
        }
        _gaq.push(['_trackEvent', 'Task', 'Task state changed from text', _this._getStatusLabel(data.status)]);
        return _this._update(data);
      });
    };

    TaskRecipient.prototype._getStatusLabel = function(status) {
      if (status === PERFORMED_TASK) {
        return 'complete';
      } else {
        return 'uncomplete';
      }
    };

    TaskRecipient.prototype.remove = function() {
      _gaq.push(['_trackEvent', 'Task', 'Remove task with popup']);
      return typeof this._removeCallback === "function" ? this._removeCallback() : void 0;
    };

    TaskRecipient.prototype.update = function(data) {
      var changedFields, date, orgDate, orgTime, time, _ref4, _ref5;
      changedFields = [];
      _ref4 = convertDateTimeToClient(this._data.deadlineDate, this._data.deadlineDatetime), orgDate = _ref4[0], orgTime = _ref4[1];
      _ref5 = convertDateTimeToClient(data.deadlineDate, data.deadlineDatetime), date = _ref5[0], time = _ref5[1];
      if (orgDate !== date) changedFields.push('date');
      if (orgTime !== time) changedFields.push('time');
      if (this._data.recipientId !== data.recipientId) {
        changedFields.push('recipient');
      }
      if (this._data.status !== data.status) {
        changedFields.push(this._getStatusLabel(data.status));
      }
      _gaq.push(['_trackEvent', 'Task', 'Task changed', changedFields.join(',')]);
      return this._update(data);
    };

    TaskRecipient.prototype.convert = function() {
      _gaq.push(['_trackEvent', 'Task', 'Convert to Mention']);
      return this._convertCallback();
    };

    TaskRecipient.prototype._update = function(data) {
      data.senderId = this._data.senderId;
      this._updateTaskSearchInfo(data);
      return this._updateCallback(data);
    };

    TaskRecipient.prototype.getRecipientId = function() {
      return this._data.recipientId;
    };

    TaskRecipient.prototype.markAsInvalid = function(message) {
      return $(this._container).children().css('border', '1px inset red').attr('title', message);
    };

    TaskRecipient.prototype.markAsValid = function(message) {
      return $(this._container).children().css('border', 'none');
    };

    TaskRecipient.prototype.getContainer = function() {
      return this._container;
    };

    TaskRecipient.prototype.destroy = function() {
      var _ref4;
      if ((_ref4 = this._waveViewModel) != null) {
        _ref4.removeListener('usersInfoUpdate', this._updateUserInfo);
      }
      return delete this._waveViewModel;
    };

    TaskRecipient.prototype.getData = function() {
      return this._data;
    };

    TaskRecipient.prototype.showPopup = function() {
      popup.hide();
      popup.render(new TaskRecipientPopup(this._data, this._waveViewModel, this._canChangeRecipient, this._canChangeFields, this._canDelete, this._canConvert, this.update, this.remove, this.convert), this._container);
      return popup.show();
    };

    return TaskRecipient;

  })();

  TaskRecipientStub = (function() {

    function TaskRecipientStub(name, date, datetime) {
      var $container, deadline;
      this._container = document.createElement('span');
      this._container.contentEditable = 'false';
      $container = $(this._container);
      deadline = convertDateTimeToClient(date, datetime)[0];
      $container.append(renderRecipient(name, date, datetime, NOT_PERFORMED_TASK, true));
    }

    TaskRecipientStub.prototype.destroy = function() {
      return $(this._container).remove();
    };

    TaskRecipientStub.prototype.getContainer = function() {
      return this._container;
    };

    return TaskRecipientStub;

  })();

  module.exports = {
    TaskRecipient: TaskRecipient,
    TaskRecipientStub: TaskRecipientStub
  };

}).call(this);

});

require.define("/lib/client/client/popup/user_popup/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var PopupContent, UserPopup, popup, renderUserBottomPopup, renderUserComnonPopup, renderUserTopPopup, setUserPopupBehaviour, _ref, _ref2,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  _ref = require('../'), PopupContent = _ref.PopupContent, popup = _ref.popup;

  _ref2 = require('./template'), renderUserComnonPopup = _ref2.renderUserComnonPopup, renderUserBottomPopup = _ref2.renderUserBottomPopup, renderUserTopPopup = _ref2.renderUserTopPopup;

  UserPopup = (function(_super) {

    __extends(UserPopup, _super);

    function UserPopup() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.bottomBlockRender = __bind(this.bottomBlockRender, this);
      this._init.apply(this, args);
    }

    UserPopup.prototype._init = function(_user) {
      this._user = _user;
      return this._render();
    };

    UserPopup.prototype._render = function() {
      this._container = document.createElement('span');
      this._commonBlockRender();
      this.topBlockRender();
      return this.bottomBlockRender();
    };

    UserPopup.prototype._commonBlockRender = function() {
      /*
              Рендерим блоки с инфой о юзере
      */      return $(this._container).append(renderUserComnonPopup());
    };

    UserPopup.prototype.topBlockRender = function() {
      /*
              Рендерим верхний с инфой о юзере
      */
      var top_block;
      top_block = $(this._container).find('.js-user-popup-menu-top-block')[0];
      return $(top_block).append(renderUserTopPopup(this._user.toObject()));
    };

    UserPopup.prototype.bottomBlockRender = function() {};

    UserPopup.prototype.destroy = function() {
      $(this._container).remove();
      return this._container = null;
    };

    UserPopup.prototype.getContainer = function() {
      if (!this._container) this._render();
      return this._container;
    };

    return UserPopup;

  })(PopupContent);

  setUserPopupBehaviour = function() {
    var UserPopupClass, args, delay, node, timeout;
    node = arguments[0], UserPopupClass = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    timeout = null;
    delay = 500;
    $(node).bind('click', function(event) {
      if (timeout != null) {
        clearTimeout(timeout);
        timeout = null;
      }
      popup.hide();
      popup.render((function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return typeof result === "object" ? result : child;
      })(UserPopupClass, args, function() {}), event.target);
      popup.show();
      return false;
    });
    return $(node).bind('mousedown', function() {
      return false;
    });
  };

  exports.setUserPopupBehaviour = setUserPopupBehaviour;

  exports.UserPopup = UserPopup;

}).call(this);

});

require.define("/lib/client/client/popup/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var Popup, PopupContent, renderPopup,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = Array.prototype.slice;

  renderPopup = require('./template').renderPopup;

  Popup = (function() {

    function Popup() {
      this.hide = __bind(this.hide, this);
      this._scrollHandler = __bind(this._scrollHandler, this);
      this._windowResize = __bind(this._windowResize, this);
      this._destroy = __bind(this._destroy, this);
      this._remove = __bind(this._remove, this);
      this._windowClickHandler = __bind(this._windowClickHandler, this);
    }

    /*
        Класс для работы с меню
    */

    Popup.POPUP_INDENT = 2;

    Popup.prototype.render = function(_content, _target) {
      this._content = _content;
      this._target = _target;
      /*
              @content: PopupContent - экземпляр класса, который нужно отрисовать
              @_target: область, в которую кликнули
              Отрисовываем менюшку внутри контейнера попапа и навешиваем
              обработчики на события клика и изменения размеров окна
      */
      $(document.body).append(renderPopup());
      this._container = $(document.body).find('.js-popup-menu-container');
      this._internalContainer = this._container.find('.js-internal-container > *');
      this._internalContainer.empty().append(this._content.getContainer());
      this._internalContainer.addClass(this._content.getInternalContainerClass);
      this.setContainerPosition(this._getPosition());
      window.addEventListener('click', this._windowClickHandler, true);
      window.addEventListener('resize', this._windowResize, false);
      return window.addEventListener('scroll', this._scrollHandler, true);
    };

    Popup.prototype._windowClickHandler = function(event) {
      if (!this._container) return;
      if (event.target === this._target) {
        this._destroy();
        event.stopPropagation();
        return;
      }
      if ($.contains(this._container[0], event.target)) return;
      if (!this._content.shouldCloseWhenClicked(event.target)) return;
      return this._destroy();
    };

    Popup.prototype.getContainer = function() {
      return this._internalContainer;
    };

    Popup.prototype.getEventTarget = function() {
      return this._target;
    };

    Popup.prototype.setContainerPosition = function(pos) {
      /*
              @pos: Object
              Устанавливаем позицию контейнеру менюшки
      */      this._lastPos = pos;
      if (pos.top != null) {
        this._container.css('bottom', "auto");
        this._container.css('top', "" + pos.top + "px");
      }
      if (pos.right != null) {
        this._container.css('left', "auto");
        this._container.css('right', "" + pos.right + "px");
      }
      if (pos.bottom != null) {
        this._container.css('top', "auto");
        this._container.css('bottom', "" + pos.bottom + "px");
      }
      if (pos.left != null) {
        this._container.css('right', "auto");
        return this._container.css('left', "" + pos.left + "px");
      }
    };

    Popup.prototype._remove = function() {
      if (this._container) this._container.remove();
      return delete this._container;
    };

    Popup.prototype._destroy = function() {
      /*
              Если клик мыши был за пределами контейнера, то
              удаляем ноду контейнера и отписываемся от событий клика и ресайза окна
      */      if (this._content != null) {
        this._content.destroy();
        delete this._content;
      }
      if (this._internalContainer) {
        this._internalContainer.remove();
        delete this._internalContainer;
      }
      this._remove();
      window.removeEventListener('click', this._windowClickHandler, true);
      window.removeEventListener('resize', this._windowResize, false);
      return window.removeEventListener('scroll', this.hide, true);
    };

    Popup.prototype._windowResize = function(event) {
      return this.setContainerPosition(this._getPosition());
    };

    Popup.prototype._scrollHandler = function() {
      var curPos, measure, measures, _i, _len;
      if (!this._lastPos) return this.hide();
      curPos = this._getPosition;
      measures = ['top', 'right', 'bottom', 'left'];
      for (_i = 0, _len = measures.length; _i < _len; _i++) {
        measure = measures[_i];
        if (curPos[measure] !== this._lastPos[measure]) return this.hide;
      }
    };

    Popup.prototype._getPosition = function() {
      /*
              Определяем как расположить контейнер в зависимости от координат
              элемента, на который кликнул пользователь
      */
      var centerX, centerY, offset, pos;
      offset = $(this._target).offset();
      centerX = $(window).width() / 2;
      centerY = $(window).height() / 2;
      pos = {};
      if (offset.left <= centerX) {
        pos.left = offset.left + $(this._target).width() * 0.2;
      } else {
        pos.right = $(window).width() - offset.left - $(this._target).width() * (1 - 0.2);
      }
      if (offset.top <= centerY) {
        pos.top = offset.top + $(this._target).height() + Popup.POPUP_INDENT;
      } else {
        pos.bottom = $(window).height() - offset.top + Popup.POPUP_INDENT;
      }
      return pos;
    };

    Popup.prototype.addExtendedClass = function(addingClass) {
      return $(this._container).addClass(addingClass);
    };

    Popup.prototype.show = function() {
      return this._container.show();
    };

    Popup.prototype.hide = function() {
      return this._destroy();
    };

    Popup.prototype.getContent = function() {
      return this._content;
    };

    return Popup;

  })();

  PopupContent = (function() {

    function PopupContent() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      /*
              В конструкторе отрисовываем меню и, если нужно, вешаем обработчики
      */
    }

    PopupContent.prototype.destroy = function() {
      /*
              В этом методе отписываемся от событий на которые были подписаны
              элементы меню, производим действия, необходимые при удалении объекта меню
              Метод необходимо переопределять в наследнике даже если он там неиспользуется
      */      throw new Error("Menu method 'destroy' not implemented");
    };

    PopupContent.prototype.getContainer = function() {
      /*
              В этом методе возвращается коренвая нода
      */      throw new Error("Menu method 'getContainer' not implemented");
    };

    PopupContent.prototype.shouldCloseWhenClicked = function(element) {
      /*
              Возвращает true, если при клике на указанный элемент нужно закрыть попап
              @param element: HTMLNode
              @return: boolean
      */      return true;
    };

    PopupContent.prototype.getInternalContainerClass = function() {
      return 'internal-container';
    };

    return PopupContent;

  })();

  exports.popup = new Popup();

  exports.PopupContent = PopupContent;

}).call(this);

});

require.define("/lib/client/client/popup/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ck, gadgetPopupTmpl, popupTmpl;

  ck = window.CoffeeKup;

  popupTmpl = function() {
    return div('.js-popup-menu-container.popup-menu-container', function() {
      return div('.js-internal-container', function() {
        return div('');
      });
    });
  };

  gadgetPopupTmpl = function() {
    return div('.js-gadget-popup-menu-container.popup-menu-container', function() {
      return div('.js-internal-container', function() {
        return div('');
      });
    });
  };

  exports.renderPopup = ck.compile(popupTmpl);

  exports.renderGadgetPopup = ck.compile(gadgetPopupTmpl);

}).call(this);

});

require.define("/lib/client/client/popup/user_popup/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BrowserSupport, ck, getOtherUrl, orgRenderUserTopPopup, renderUserTopPopup, userComnonPopupTmpl, userTopPopupTmpl;

  ck = window.CoffeeKup;

  BrowserSupport = require('../../utils/browser_support');

  getOtherUrl = require('../../utils/url').getOtherUrl;

  userComnonPopupTmpl = function() {
    return div('.js-user-popup-menu-top-block.user-popup-menu-top-block', '');
  };

  userTopPopupTmpl = function() {
    return div(function() {
      div('.wave-participant-avatar.avatar', {
        style: "background-image: url(" + (h(this.fixedAvatar || this.avatar)) + ")"
      }, h(this.initials));
      div('.wave-participant-name-email', function() {
        var skypeId;
        div('.wave-participant-name', h(this.name));
        div('.wave-participant-email', h(this.email));
        if (this.skypeId) {
          skypeId = h(this.skypeId);
          a('.skype-call-link', {
            href: "skype:" + skypeId + "?call",
            title: "Call skype",
            target: 'skype-call-iframe'
          }, function() {
            text(skypeId);
            return img('.skype-status-ico', {
              src: "http://mystatus.skype.com/smallicon/" + skypeId
            });
          });
        }
        return div('.js-user-popup-menu-remove-block.user-popup-menu-remove-block', '');
      });
      return div('.clearer', '');
    });
  };

  exports.renderUserComnonPopup = ck.compile(userComnonPopupTmpl);

  renderUserTopPopup = ck.compile(userTopPopupTmpl);

  if (BrowserSupport.isMozilla()) {
    orgRenderUserTopPopup = renderUserTopPopup;
    renderUserTopPopup = function(params) {
      if (params == null) params = {};
      params.fixedAvatar = getOtherUrl(params.avatar);
      return orgRenderUserTopPopup(params);
    };
  }

  exports.renderUserTopPopup = renderUserTopPopup;

}).call(this);

});

require.define("/lib/client/client/utils/url.js",function(require,module,exports,__dirname,__filename,process,global){(function() {

  exports.getQuery = function() {
    var m, queryString, re, res;
    res = {};
    queryString = location.search.substring(1);
    re = /([^&=]+)=([^&]*)/g;
    while (m = re.exec(queryString)) {
      res[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
    }
    return res;
  };

  exports.getOtherUrl = function(url) {
    if (!url) return url;
    return url + '#bsParam=big';
  };

}).call(this);

});

require.define("/lib/client/client/blip/task_recipient/popup.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var DateTimePicker, NOT_PERFORMED_TASK, PERFORMED_TASK, PopupContent, TaskRecipientPopup, UserPicker, ck, convertDateTimeToClient, convertDateTimeToServer, popup, renderTaskRecipientPopup, strip, _ref, _ref2, _ref3,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  _ref = require('../../popup'), popup = _ref.popup, PopupContent = _ref.PopupContent;

  UserPicker = require('../user_picker').UserPicker;

  _ref2 = require('../../../share/utils/date_converter'), convertDateTimeToClient = _ref2.convertDateTimeToClient, convertDateTimeToServer = _ref2.convertDateTimeToServer;

  strip = require('../../utils/string').strip;

  DateTimePicker = require('../../utils/date_time_picker').DateTimePicker;

  _ref3 = require('../../search_panel/task/constants'), NOT_PERFORMED_TASK = _ref3.NOT_PERFORMED_TASK, PERFORMED_TASK = _ref3.PERFORMED_TASK;

  ck = window.CoffeeKup;

  renderTaskRecipientPopup = ck.compile(function() {
    return div('.task-recipient-popup', function() {
      div('.task-recipient-info', function() {
        div('.js-task-recipient-icon.task-recipient-avatar.avatar', {
          style: "background-image: url(" + (h(this.user.getAvatar())) + ")"
        }, h(this.user.getInitials()));
        return div('.task-recipient-input-container', function() {
          var params;
          params = {
            type: 'text',
            tabindex: '1',
            value: this.user.getEmail() || this.user.getName()
          };
          if (!this.canChangeRecipient) params.disabled = 'disabled';
          return input('.js-task-recipient-input.task-recipient-input', params);
        });
      });
      div('.task-date-container', function() {
        var date, dateParams, time, timeParams;
        date = this.deadline.date || '';
        time = this.deadline.time || '';
        dateParams = {
          type: 'text',
          tabindex: '2',
          value: date
        };
        timeParams = {
          type: 'text',
          tabindex: '3',
          value: time
        };
        if (!this.canChangeFields) {
          dateParams.disabled = timeParams.disabled = 'disabled';
        }
        div('.date-icon.js-date-icon', '');
        input('.js-task-date-input.task-date-input', dateParams);
        div('.time-icon.js-time-icon', '');
        return input('.js-task-time-input.task-time-input', timeParams);
      });
      div('.task-is-completed-container', function() {
        var completeParams;
        completeParams = {
          type: 'checkbox',
          id: 'task-popup-is-complete'
        };
        if (this.completed) completeParams.checked = 'checked';
        if (!this.canChangeFields) completeParams.disabled = 'disabled';
        input('.js-task-complete.custom', completeParams);
        return label('.task-recipient-complete', {
          "for": 'task-popup-is-complete'
        }, 'Complete');
      });
      return div('.task-bottom-container', function() {
        var convertParams, deleteParams;
        deleteParams = {};
        if (!this.canDelete) deleteParams.disabled = 'disabled';
        button('.js-remove-task-recipient.remove-task-recipient', deleteParams, 'Delete');
        convertParams = {};
        if (!this.canConvert) convertParams.disabled = 'disabled';
        button('.js-convert-to-mention', convertParams, 'Convert to @');
        return button('.js-close.close-popup', 'Close');
      });
    });
  });

  TaskRecipientPopup = (function(_super) {

    __extends(TaskRecipientPopup, _super);

    function TaskRecipientPopup(taskData, _waveViewModel, _canChangeRecipient, _canChangeFields, _canDelete, _canConvert, _updateCallback, _remove, _convertCallback) {
      this._waveViewModel = _waveViewModel;
      this._canChangeRecipient = _canChangeRecipient;
      this._canChangeFields = _canChangeFields;
      this._canDelete = _canDelete;
      this._canConvert = _canConvert;
      this._updateCallback = _updateCallback;
      this._remove = _remove;
      this._convertCallback = _convertCallback;
      this._removeTaskRecipient = __bind(this._removeTaskRecipient, this);
      this._save = __bind(this._save, this);
      this._convert = __bind(this._convert, this);
      this._validateDateTime = __bind(this._validateDateTime, this);
      this._processEmailChange = __bind(this._processEmailChange, this);
      this._userPicker = new UserPicker(this._waveViewModel);
      this._dateTimePicker = new DateTimePicker();
      this._render(taskData);
    }

    TaskRecipientPopup.prototype._render = function(taskData) {
      var $container, date, templateData, time, user, _ref4;
      this._container = document.createElement('span');
      user = this._waveViewModel.getUser(taskData.recipientId);
      templateData = {
        user: user,
        completed: taskData.status === PERFORMED_TASK,
        canChangeRecipient: this._canChangeRecipient(),
        canChangeFields: this._canChangeFields(),
        canDelete: this._canDelete(),
        canConvert: this._canConvert()
      };
      _ref4 = convertDateTimeToClient(taskData.deadlineDate, taskData.deadlineDatetime), date = _ref4[0], time = _ref4[1];
      templateData.deadline = {
        date: date,
        time: time
      };
      $container = $(this._container);
      $container.append(renderTaskRecipientPopup(templateData));
      this._initRecipientInput();
      this._initDateTimeInputs();
      this._taskIsCompleteInput = $container.find('.js-task-complete')[0];
      $(this._taskIsCompleteInput).click(this._save);
      $(this._container).find('.js-convert-to-mention').click(this._convert);
      $(this._container).find('.js-remove-task-recipient').click(this._removeTaskRecipient);
      return $(this._container).find('.js-close').click(function() {
        return popup.hide();
      });
    };

    TaskRecipientPopup.prototype._initRecipientInput = function() {
      var $container,
        _this = this;
      $container = $(this._container);
      this._recipientInput = $container.find('.js-task-recipient-input')[0];
      this._userPicker.activate(this._recipientInput);
      this._userPicker.on('select-contact', function(contact) {
        return _this._processEmailChange(contact.email);
      });
      return this._userPicker.on('select-email', this._processEmailChange);
    };

    TaskRecipientPopup.prototype._processEmailChange = function(email) {
      var participant;
      if (!this._validateRecipientEmail(email)) return;
      $(this._recipientInput).val(email).blur();
      if (!this._save()) return;
      participant = this._waveViewModel.getParticipantByEmail(email);
      $(this._container).find('.js-task-recipient-icon').css("background-image", "url(" + (participant.getAvatar()) + ")");
      return $(this._container).find('.js-task-recipient-icon').text(participant.getInitials());
    };

    TaskRecipientPopup.prototype._validateRecipientEmail = function(email) {
      if (this._userPicker.isValid(email)) return true;
      this._waveViewModel.showWarning('Enter valid e-mail');
      return false;
    };

    TaskRecipientPopup.prototype._initDateTimeInputs = function() {
      var $container, dateInput, timeInput,
        _this = this;
      if (!this._canChangeFields()) return;
      $container = $(this._container);
      dateInput = $container.find('.js-task-date-input')[0];
      timeInput = $container.find('.js-task-time-input')[0];
      this._dateTimePicker.init(dateInput, timeInput);
      $container.find('.js-date-icon').click(function() {
        return $(dateInput).focus();
      });
      $container.find('.js-time-icon').click(function() {
        return $(timeInput).focus();
      });
      return this._dateTimePicker.on('change', function(date, time) {
        if (_this._validateDateTime(date, time)) return _this._save();
      });
    };

    TaskRecipientPopup.prototype._validateDateTime = function(date, time) {
      var dateIsValid, timeIsValid, _ref4;
      _ref4 = this._dateTimePicker.validate(date, time), dateIsValid = _ref4[0], timeIsValid = _ref4[1];
      if (!dateIsValid) {
        this._waveViewModel.showWarning('Enter valid date (day.month.year)');
        return false;
      }
      if (!timeIsValid) {
        this._waveViewModel.showWarning('Enter valid time (hours:minutes)');
        return false;
      }
      return true;
    };

    TaskRecipientPopup.prototype._update = function(data) {
      /*
              Обновляет поля в task'е. Если сам объект задачи изменился, получает из него функции обновления и удаления.
              @return: boolean, можно ли оставить popup открытым после
      */
      var newTask;
      newTask = this._updateCallback(data);
      if (!(newTask != null)) return false;
      this._updateCallback = newTask.update;
      this._remove = newTask.remove;
      this._convertCallback = newTask.convert;
      return true;
    };

    TaskRecipientPopup.prototype._convert = function() {
      this._convertCallback();
      return popup.hide();
    };

    TaskRecipientPopup.prototype._save = function() {
      var date, datetime, email, newTaskData, participant, status, time, _ref4, _ref5;
      email = strip($(this._recipientInput).val());
      _ref4 = this._dateTimePicker.get(), date = _ref4[0], time = _ref4[1];
      status = this._taskIsCompleteInput.checked ? PERFORMED_TASK : NOT_PERFORMED_TASK;
      if (!this._validateAll(email, date, time)) return false;
      participant = this._waveViewModel.getParticipantByEmail(email);
      if (!participant) {
        if (!window.confirm("This user is not participant of the topic. Add " + email + " to the topic?")) {
          return false;
        }
      }
      newTaskData = {
        status: status
      };
      if (participant) {
        newTaskData.recipientId = participant.getId();
      } else {
        newTaskData.recipientEmail = email;
      }
      _ref5 = convertDateTimeToServer(date, time), date = _ref5[0], datetime = _ref5[1];
      newTaskData.deadlineDate = date;
      newTaskData.deadlineDatetime = datetime;
      if (!this._update(newTaskData)) {
        popup.hide();
        return false;
      }
      return true;
    };

    TaskRecipientPopup.prototype._validateAll = function(email, date, time) {
      if (!this._validateRecipientEmail(email)) return false;
      if (!this._validateDateTime(date, time)) return false;
      return true;
    };

    TaskRecipientPopup.prototype._removeTaskRecipient = function() {
      this._remove();
      return popup.hide();
    };

    TaskRecipientPopup.prototype.destroy = function() {
      var _ref4, _ref5;
      if ((_ref4 = this._userPicker) != null) _ref4.destroy();
      delete this._userPicker;
      if ((_ref5 = this._dateTimePicker) != null) _ref5.destroy();
      delete this._dateTimePicker;
      $(this._container).remove();
      delete this._container;
      delete this._remove;
      delete this._updateCallback;
      return delete this._convertCallback;
    };

    TaskRecipientPopup.prototype.getContainer = function() {
      if (!this._container) this._render();
      return this._container;
    };

    TaskRecipientPopup.prototype.shouldCloseWhenClicked = function(e) {
      var autocomplete;
      autocomplete = this._userPicker.getAutocompleteContainer();
      if (!(autocomplete != null)) return true;
      return !$.contains(autocomplete, e);
    };

    return TaskRecipientPopup;

  })(PopupContent);

  module.exports = {
    TaskRecipientPopup: TaskRecipientPopup
  };

}).call(this);

});

require.define("/lib/client/client/blip/user_picker.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var MicroEvent, UserPicker, compareContacts, isEmail, renderContact,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  renderContact = require('../user/template').renderContact;

  isEmail = require('../utils/string').isEmail;

  MicroEvent = require('../utils/microevent');

  compareContacts = require('../user/utils').compareContactsByParticipanceNameAndEmail;

  UserPicker = (function() {
    /*
        Класс для выбора участника. Дополняет input autocomplete'ом, показывая участников из блипа и из списка
        контактов пользователя.
    */
    function UserPicker(_waveViewModel) {
      this._waveViewModel = _waveViewModel;
      this._getData = __bind(this._getData, this);
      this._contacts = [];
      this._data = null;
      this._getContactList();
    }

    UserPicker.prototype._getContactList = function() {
      var _this = this;
      return require('../wave/processor').instance.getUserContacts(function(err, users) {
        if (err) {
          return console.warn("User picker could not get user contacts:", err);
        }
        return _this._contacts = users;
      });
    };

    UserPicker.prototype.activate = function(_input, autocompleteContainer) {
      var $input, autocompleter,
        _this = this;
      this._input = _input;
      $input = $(this._input);
      autocompleter = $input.autocomplete({
        getData: this._getData,
        onItemSelect: function(item) {
          return _this.emit('select-contact', item.data[0]);
        },
        onFinish: function() {
          return _this.emit('finish');
        },
        sortFunction: function(a, b) {
          return compareContacts(a.data[0], b.data[0]);
        },
        selectFirst: true,
        matchInside: true,
        minChars: 0,
        preventDefaultTab: true,
        showResult: renderContact,
        autoWidth: null,
        delimiterKeyCode: -1,
        delay: 0,
        resultsContainer: autocompleteContainer,
        autoPosition: !autocompleteContainer,
        autoFocus: false
      }).data('autocompleter');
      $input.keypress(function(e) {
        if (e.keyCode !== 13) return;
        e.stopPropagation();
        e.preventDefault();
        return _this.emit('select-email', $input.val());
      });
      $input.blur(function() {
        return window.setTimeout(function() {
          return _this.emit('finish');
        }, 200);
      });
      return $input.focus(function() {
        return autocompleter.activate();
      });
    };

    UserPicker.prototype._getData = function() {
      var contact, emailsAreEqual, isUnique, p, participant, participants, uniqueContacts, user, _i, _j, _k, _l, _len, _len2, _len3, _len4, _len5, _m, _ref;
      if (this._data != null) return this._data;
      participants = this._waveViewModel.getParticipants();
      emailsAreEqual = function(first, second) {
        if (typeof first !== 'string' || typeof second !== 'string') return;
        return first.toLowerCase() === second.toLowerCase();
      };
      uniqueContacts = [];
      _ref = this._contacts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        contact = _ref[_i];
        isUnique = true;
        for (_j = 0, _len2 = participants.length; _j < _len2; _j++) {
          participant = participants[_j];
          if (emailsAreEqual(contact.getEmail(), participant.getEmail())) {
            isUnique = false;
            break;
          }
        }
        if (isUnique) uniqueContacts.push(contact);
      }
      for (_k = 0, _len3 = participants.length; _k < _len3; _k++) {
        p = participants[_k];
        p.isParticipant = true;
      }
      this._data = [];
      for (_l = 0, _len4 = participants.length; _l < _len4; _l++) {
        user = participants[_l];
        if (!user.isAnonymous()) {
          this._data.push([user.getSearchString(), user.getDataForAutocomplete(true)]);
        }
      }
      for (_m = 0, _len5 = uniqueContacts.length; _m < _len5; _m++) {
        user = uniqueContacts[_m];
        if (!user.isAnonymous()) {
          this._data.push([user.getSearchString(), user.getDataForAutocomplete(false)]);
        }
      }
      return this._data;
    };

    UserPicker.prototype.isValid = function(email) {
      return isEmail(email);
    };

    UserPicker.prototype.getAutocompleteContainer = function() {
      var _ref, _ref2;
      return (_ref = $(this._input).data('autocompleter')) != null ? (_ref2 = _ref.dom) != null ? _ref2.$results[0] : void 0 : void 0;
    };

    UserPicker.prototype.destroy = function() {
      var autocompleter;
      this.removeListeners('select-email');
      this.removeListeners('select-contact');
      this.removeListeners('finish');
      autocompleter = $(this._input).data('autocompleter');
      if (!autocompleter) return;
      autocompleter.deactivate(false);
      return autocompleter.dom.$results.remove();
    };

    return UserPicker;

  })();

  MicroEvent.mixin(UserPicker);

  module.exports = {
    UserPicker: UserPicker
  };

}).call(this);

});

require.define("/lib/client/client/user/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ROLES, ck, contactTmpl, participantTmpl, renderContact, renderParticipant;

  ck = window.CoffeeKup;

  ROLES = require('../wave/participants/constants').ROLES;

  contactTmpl = function() {
    var data, participantClass;
    data = this.data[0];
    div('.avatar', {
      style: "background-image: url(" + (h(data.avatar)) + ")"
    }, '');
    participantClass = data.isParticipant ? '.participant' : '';
    return span(participantClass, function() {
      span('.name', h(data.name));
      if (data.email) return span('.email', h("<" + data.email + ">"));
    });
  };

  participantTmpl = function() {
    var role, roleName, _i, _len, _ref;
    input("", {
      type: "checkbox",
      checked: this.user.checked ? "checked" : void 0
    });
    div('.avatar', {
      style: "background-image: url(" + (h(this.user.data.avatar)) + ")"
    }, h(this.user.data.initials));
    div('.info', {
      title: "" + (h(this.user.data.name)) + " " + (h(this.user.data.email))
    }, function() {
      span('.name', h(this.user.data.name));
      if (h(this.user.data.email)) {
        return span('.email', h("<" + this.user.data.email + ">"));
      }
    });
    roleName = 'Default';
    _ref = this.roles;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      role = _ref[_i];
      if (this.user.data.roleId !== role.id) continue;
      roleName = role.name;
    }
    return span('.participant-role', roleName);
  };

  renderContact = ck.compile(contactTmpl);

  renderParticipant = ck.compile(participantTmpl);

  exports.renderContact = function(value, data) {
    return renderContact({
      value: value,
      data: data
    });
  };

  exports.renderParticipant = function(user) {
    return renderParticipant({
      user: user,
      roles: ROLES
    });
  };

}).call(this);

});

require.define("/lib/client/client/wave/participants/constants.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ROLES, ROLE_COMMENTATOR, ROLE_EDITOR, ROLE_NO_ROLE, ROLE_OWNER, ROLE_READER;

  ROLE_OWNER = 1;

  ROLE_EDITOR = 2;

  ROLE_COMMENTATOR = 3;

  ROLE_READER = 4;

  ROLE_NO_ROLE = 65536;

  ROLES = [
    {
      name: 'Owner',
      id: ROLE_OWNER
    }, {
      name: 'Editor',
      id: ROLE_EDITOR
    }, {
      name: 'Commenter',
      id: ROLE_COMMENTATOR
    }, {
      name: 'Reader',
      id: ROLE_READER
    }
  ];

  module.exports = {
    ROLES: ROLES,
    ROLE_OWNER: ROLE_OWNER,
    ROLE_EDITOR: ROLE_EDITOR,
    ROLE_COMMENTATOR: ROLE_COMMENTATOR,
    ROLE_READER: ROLE_READER,
    ROLE_NO_ROLE: ROLE_NO_ROLE
  };

}).call(this);

});

require.define("/lib/client/client/user/utils.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var compareContactsByNameAndEmail, compareContactsByParticipanceNameAndEmail, contactsConstants;

  contactsConstants = require('../../share/contacts/constants');

  exports.compareContactsByNameAndEmail = compareContactsByNameAndEmail = function(a, b) {
    var aLowerName, bLowerName;
    aLowerName = a.name.toLowerCase();
    bLowerName = b.name.toLowerCase();
    if (aLowerName !== bLowerName) return aLowerName.localeCompare(bLowerName);
    return a.email.toLowerCase().localeCompare(b.name.toLowerCase());
  };

  exports.compareContactsByParticipanceNameAndEmail = compareContactsByParticipanceNameAndEmail = function(a, b) {
    if (a.isParticipant !== b.isParticipant) {
      return (+b.isParticipant) - (+a.isParticipant);
    }
    return compareContactsByNameAndEmail(a, b);
  };

  exports.getContactSources = function(userContacts) {
    var res, user, _i, _len;
    res = {
      google: false,
      facebook: false
    };
    for (_i = 0, _len = userContacts.length; _i < _len; _i++) {
      user = userContacts[_i];
      if (user.data.source === contactsConstants.SOURCE_NAME_GOOGLE) {
        res.google = true;
      }
      if (user.data.source === contactsConstants.SOURCE_NAME_FACEBOOK) {
        res.facebook = true;
      }
    }
    return res;
  };

}).call(this);

});

require.define("/lib/client/client/utils/date_time_picker.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var DateTimePicker, KeyCodes, MicroEvent, allUniversalRegexps, calendricalDateRegexp, ck, dateRegexp, formatAsClientDate, timeRegexp, universalDateRegexps, universalRegexps;

  formatAsClientDate = require('../../share/utils/date_converter').formatAsClientDate;

  KeyCodes = require('./key_codes').KeyCodes;

  ck = window.CoffeeKup;

  MicroEvent = require('./microevent');

  calendricalDateRegexp = /\d{1,2}\/\d{1,2}\/\d{4}/;

  dateRegexp = /\d{1,2}\.\d{1,2}\.\d{4}/;

  timeRegexp = /\d{1,2}:\d{1,2}/;

  universalRegexps = [
    {
      name: 'datetime_with_year',
      regexp: /\d{1,2}\.\d{1,2}\.\d{2,4}\s+\d{1,2}:\d{1,2}/
    }, {
      name: 'datetime',
      regexp: /\d{1,2}\.\d{1,2}\s+\d{1,2}:\d{1,2}/
    }, {
      name: 'time',
      regexp: /\d{1,2}:\d{1,2}/
    }
  ];

  universalDateRegexps = [
    {
      name: 'date_with_year',
      regexp: /\d{1,2}\.\d{1,2}\.\d{2,4}/
    }, {
      name: 'date',
      regexp: /\d{1,2}\.\d{1,2}/
    }, {
      name: 'calendrical_date',
      regexp: /\d{1,2}\/\d{1,2}\/\d{4}/
    }, {
      name: 'add_days',
      regexp: /\+\d{1,2}/
    }, {
      name: 'day',
      regexp: /\d{1,2}/
    }
  ];

  allUniversalRegexps = universalRegexps.concat(universalDateRegexps);

  DateTimePicker = (function() {

    function DateTimePicker() {}

    DateTimePicker.prototype.init = function(_dateInput, _timeInput, positionInBody) {
      var $date, $time,
        _this = this;
      this._dateInput = _dateInput;
      this._timeInput = _timeInput;
      if (positionInBody == null) positionInBody = false;
      $date = $(this._dateInput);
      $date.calendricalDate({
        positionInBody: positionInBody
      });
      $date.change(function() {
        return _this._processDateChange($date.val(), $time.val());
      });
      $time = $(this._timeInput);
      $time.calendricalTime({
        isoTime: true,
        positionInBody: positionInBody
      });
      return $time.change(function() {
        return _this._processTimeChange($date.val(), $time.val());
      });
    };

    DateTimePicker.prototype.initUniversalInput = function(_universalInput, positionInBody) {
      var $input, processInput,
        _this = this;
      this._universalInput = _universalInput;
      if (positionInBody == null) positionInBody = false;
      $input = $(this._universalInput);
      $input.calendricalDate({
        positionInBody: positionInBody
      });
      processInput = function() {
        var date, res, time;
        res = _this._parseUniversalInput($input.val(), allUniversalRegexps);
        if (res) {
          date = res[0], time = res[1];
          return _this.emit('universal-change', null, date, time);
        } else {
          return _this.emit('universal-change', true);
        }
      };
      $input.change(processInput);
      return $input.keypress(function(e) {
        if (e.keyCode !== KeyCodes.KEY_ENTER) return;
        e.stopPropagation();
        e.preventDefault();
        return processInput();
      });
    };

    DateTimePicker.prototype._findFormat = function(str, regexps) {
      var name, regexp, res, _i, _len, _ref;
      if (!str) return ['empty'];
      for (_i = 0, _len = regexps.length; _i < _len; _i++) {
        _ref = regexps[_i], name = _ref.name, regexp = _ref.regexp;
        res = str.match(regexp);
        if (res) return [name, res[0]];
      }
      return ['wrong'];
    };

    DateTimePicker.prototype._parseDate = function(date, curYear, divider) {
      var count, elems, year;
      if (divider == null) divider = '.';
      /*
              @param date: строка даты в формате dd.mm или dd.mm.yy или dd.mm.yyyy
              @param today: текущее время
              @return: [year, month, day]
      */
      curYear += '';
      elems = date.split(divider);
      count = elems.length;
      if (count === 2) {
        year = curYear;
      } else {
        year = elems[2];
        if (year.length === 2) year = curYear.slice(0, 2) + year;
      }
      return formatAsClientDate(new Date(year, elems[1] - 1, elems[0]));
    };

    DateTimePicker.prototype._parseUniversalInput = function(str, regexps) {
      /*
              @param tag_datetime_str: строка даты может содержать:
              - 5 день (если текущий день месяца больше указанного дня,
                то возвращаем указанный день следующего месяца);
              - +5 количество прибавляемых дней;
              - 20.06 день, месяц;
              - 20.06.11/2011 день, месяц, год;
              - 20.06 15:00 день, месяц, время;
              - 20.06.11/2011 15:00 день, месяц, год, время;
              - 15:00 время
              Возвращаем объект datetime.datetime, время серверное,
              если вермя не указано то время 00:00:00.
              Если tag_datetime_str неудовлетворяет условиям постановки даты
              возвращаем None
      */
      var curDay, curMonth, curYear, date, formatName, matchedString, now, res, startOfDay, time, _ref, _ref2, _ref3;
      now = new Date();
      curYear = now.getFullYear();
      curMonth = now.getMonth();
      curDay = now.getDate();
      _ref = this._findFormat(str, regexps), formatName = _ref[0], matchedString = _ref[1];
      switch (formatName) {
        case 'empty':
          return [null];
        case 'day':
          res = new Date(curYear, curMonth, matchedString);
          startOfDay = new Date(now).clearTime();
          if (res < startOfDay) res.addMonths(1);
          return [formatAsClientDate(res)];
        case 'add_days':
          res = new Date(now);
          res.addDays(matchedString - 0);
          return [formatAsClientDate(res)];
        case 'date':
          return [this._parseDate(matchedString, curYear)];
        case 'calendrical_date':
          return [this._parseDate(matchedString, curYear, '/')];
        case 'date_with_year':
          return [this._parseDate(matchedString, curYear)];
        case 'datetime':
          _ref2 = matchedString.split(' '), date = _ref2[0], time = _ref2[1];
          return [this._parseDate(date, curYear), time];
        case 'datetime_with_year':
          _ref3 = matchedString.split(' '), date = _ref3[0], time = _ref3[1];
          return [this._parseDate(date, curYear), time];
        case 'time':
          return [formatAsClientDate(now), matchedString];
      }
      return null;
    };

    DateTimePicker.prototype._processDateChange = function(date, time) {
      var res;
      if (!date) {
        time = '';
      } else {
        res = this._parseUniversalInput(date, universalDateRegexps);
        if (res) date = res[0];
      }
      $(this._dateInput).val(date);
      $(this._timeInput).val(time);
      return this.emit('change', date, time);
    };

    DateTimePicker.prototype._processTimeChange = function(date, time) {
      if (!!time && !date) {
        date = formatAsClientDate(new Date());
        $(this._dateInput).val(date);
      }
      return this.emit('change', date, time);
    };

    DateTimePicker.prototype.validate = function(date, time) {
      return [this._dateIsValid(date), this._timeIsValid(date, time)];
    };

    DateTimePicker.prototype.get = function() {
      return [$(this._dateInput).val(), $(this._timeInput).val()];
    };

    DateTimePicker.prototype._dateIsValid = function(date) {
      if (!(date != null) || date === '') return true;
      if (!date.match(dateRegexp)) return false;
      return true;
    };

    DateTimePicker.prototype._timeIsValid = function(date, time) {
      if (!(time != null) || time === '') return true;
      if (!time.match(timeRegexp)) return false;
      return true;
    };

    DateTimePicker.prototype.destroy = function() {
      $('.calendricalDatePopup,.calendricalDatePopup').remove();
      return this.removeListeners('change');
    };

    return DateTimePicker;

  })();

  MicroEvent.mixin(DateTimePicker);

  module.exports = {
    DateTimePicker: DateTimePicker
  };

}).call(this);

});

require.define("/lib/client/client/editor/file/upload_form.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var CenteredWindow, DomUtils, FileError, KeyCodes, MAX_FILE_SIZE, MAX_URL_LENGTH, MicroEvent, ModalWindow, UploadForm, UploadFormModal, UploadLimitExceededErrorFormModal, WarnWindow, fileProcessor, getFileProcessor, getPrettySizeString, instance, renderUploadForm, renderUploadFormModal,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  renderUploadForm = require('./template').renderUploadForm;

  renderUploadFormModal = require('./template').renderUploadFormModal;

  CenteredWindow = require('../../widget/window/centered_window').CenteredWindow;

  ModalWindow = require('../../widget/window/modal_window').ModalWindow;

  WarnWindow = require('../../widget/window/warning');

  DomUtils = require('../../utils/dom');

  MicroEvent = require('../../utils/microevent');

  KeyCodes = require('../../utils/key_codes').KeyCodes;

  FileError = require('../../../share/file').Error;

  fileProcessor = null;

  MAX_URL_LENGTH = require('../common').MAX_URL_LENGTH;

  getFileProcessor = function() {
    return fileProcessor || (fileProcessor = require('../../file/processor').instance);
  };

  MAX_FILE_SIZE = 10 * 1024 * 1024 - 1024 * 10;

  getPrettySizeString = function(size) {
    var index, sizes;
    sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
    index = 0;
    while (size > 1000 && index < sizes.length - 1) {
      size /= 1024;
      index += 1;
    }
    return "" + (size.toFixed(1)) + " " + sizes[index];
  };

  UploadFormModal = (function(_super) {

    __extends(UploadFormModal, _super);

    function UploadFormModal(fileName) {
      this._onClose = __bind(this._onClose, this);
      var params;
      params = {
        title: 'Uploading File',
        closeButton: true,
        onClose: this._onClose,
        fileName: fileName
      };
      UploadFormModal.__super__.constructor.call(this, params);
    }

    UploadFormModal.prototype.__createDom = function(params) {
      var content;
      UploadFormModal.__super__.__createDom.call(this, params);
      content = document.createElement('h1');
      content.textContent = "File: '" + params.fileName + "' is uploading";
      return this.setContent(content);
    };

    UploadFormModal.prototype._onClose = function() {
      if (window.confirm('Are you sure you want to cancel uploading?')) {
        this.emit('cancel');
        true;
      }
      return false;
    };

    UploadFormModal.prototype.destroy = function() {
      UploadFormModal.__super__.destroy.call(this);
      return this.removeListeners('cancel');
    };

    return UploadFormModal;

  })(ModalWindow);

  UploadLimitExceededErrorFormModal = (function(_super) {

    __extends(UploadLimitExceededErrorFormModal, _super);

    function UploadLimitExceededErrorFormModal() {
      var params;
      params = {
        title: 'Error',
        closeButton: true
      };
      UploadLimitExceededErrorFormModal.__super__.constructor.call(this, params);
    }

    UploadLimitExceededErrorFormModal.prototype.showMessage = function(msg) {
      var _this = this;
      this.setContent("<h1>" + msg + " <a href=\"https://rizzoma.com/topic/c9a2f62e63536a0fb0ed5b6681c195d4/\" target=\"_blank\">Get more space</a></h1><div style=\"text-align: center;\"><button id=\"uploadLimitExceededErrorCloseBtn\" class=\"button\">Close</button></div>");
      $(this.getBodyEl()).find('#uploadLimitExceededErrorCloseBtn').on('click', function() {
        _this.close();
        return _this.destroy();
      });
      return this.open();
    };

    return UploadLimitExceededErrorFormModal;

  })(ModalWindow);

  MicroEvent.mixin(UploadFormModal);

  UploadForm = (function(_super) {

    __extends(UploadForm, _super);

    function UploadForm() {
      this._processUrlInputKeyPressEvent = __bind(this._processUrlInputKeyPressEvent, this);
      this._insertAsAttachment = __bind(this._insertAsAttachment, this);
      this._submitForm = __bind(this._submitForm, this);
      var params;
      params = {
        title: 'Insert attachment',
        closeButton: true,
        closeOnOutsideAction: true,
        closeOnEsc: true
      };
      UploadForm.__super__.constructor.call(this, params);
    }

    UploadForm.prototype.__createDom = function(params) {
      var $c, tmp,
        _this = this;
      UploadForm.__super__.__createDom.call(this, params);
      tmp = document.createElement('span');
      $(tmp).append(renderUploadForm());
      this._body.appendChild(tmp.firstChild);
      $c = $(this._body);
      this._submitButton = $c.find('.js-upload-form-submit')[0];
      this._urlInput = $c.find('#insertAttachmentInput').bind('keypress', this._processUrlInputKeyPressEvent)[0];
      $c.find('.js-insert-attachment-button').click(this._insertAsAttachment);
      this._idInput = $c.find('.js-upload-form-id-input')[0];
      this._browseButton = $c.find('.js-browse-button').bind('click', function() {
        return _this._fileInput.click();
      })[0];
      this._fileLabel = $c.find('.js-upload-form-file-label')[0];
      this._$imageInsertContainer = $c.find('.js-image-insert-container');
      this._$form = $c.find('#uploadForm');
      this._fileInput = $c.find('.js-upload-form-file-input').bind('change', this._submitForm)[0];
      return this._uploadQuota = $c.find('.js-upload-quota')[0];
    };

    UploadForm.prototype._submitForm = function(file) {
      var _this = this;
      return this._$form.ajaxSubmit({
        url: '/files/',
        dataType: 'json',
        beforeSubmit: function(arr) {
          var a, fileSize, files, _i, _len;
          if (arr.length === 1) {
            if (arr[0].name === 'id' && (arr[0].value != null) && file) {
              arr.unshift({
                name: 'file',
                value: file
              });
            } else {
              return false;
            }
          } else if (arr.length === 2) {
            if (!arr[0].value || !arr[1].value) return false;
          } else {
            files = [];
            for (_i = 0, _len = arr.length; _i < _len; _i++) {
              a = arr[_i];
              if (a.name && a.name === 'file' && a.value) files.push(a.value);
            }
            _this.openImmediateUpload(_this._editor, files, _this._callback);
            delete _this._callback;
            return false;
          }
          file = arr[0].value;
          fileSize = file.size;
          if (fileSize > MAX_FILE_SIZE) {
            alert("Your file " + (file.name || '') + " is too large (Max file size: 10 MB)");
            return false;
          }
          _this.close(false);
          _this._modalWindow = new UploadFormModal(file.name || '#file');
          _this._modalWindow.on('cancel', function() {
            var _ref;
            if ((_ref = _this._xhr) != null) _ref.abort();
            return _this.close();
          });
          return _this._modalWindow.open();
        },
        beforeSend: function(_xhr) {
          _this._xhr = _xhr;
        },
        uploadProgress: function(event, position, total, percentComplete) {},
        error: function(data) {
          return _this._renderError(data);
        },
        success: function(data) {
          if (data.error) return _this._renderError(data.error);
          _this._editor.insertFile(data.res);
          return _this.close();
        }
      });
    };

    UploadForm.prototype._insertAsAttachment = function() {
      var url;
      url = this._urlInput.value;
      if (!url) return;
      if (url.length > MAX_URL_LENGTH) {
        return new WarnWindow('Your URL is too long');
      }
      this._editor.insertAttachment(url);
      return this.close();
    };

    UploadForm.prototype._processUrlInputKeyPressEvent = function(event) {
      if (event.keyCode === KeyCodes.KEY_ENTER) {
        this._insertAsAttachment();
        event.preventDefault();
        return event.stopPropagation();
      }
    };

    UploadForm.prototype._renderError = function(err) {
      var errorWnd, msg;
      this.close();
      if ((err != null ? err.statusText : void 0) === 'abort') return;
      console.error(err);
      if (typeof err === 'string') {
        msg = err;
      } else if (err.msg != null) {
        msg = err.msg;
      } else if (err.message != null) {
        msg = err.message;
      } else {
        msg = '_renderError (UF)';
      }
      _gaq.push(['_trackEvent', 'Error', '    Client error', msg]);
      if (err.code === FileError.FILE_UPLOAD_LIMIT_EXCEEDED_ERROR) {
        errorWnd = new UploadLimitExceededErrorFormModal();
        return errorWnd.showMessage(err.msg);
      }
      if (typeof err === 'string') return alert(err);
      return alert('Error occurred. Please try again later.');
    };

    UploadForm.prototype._clear = function() {
      this._urlInput.value = '';
      return this._$form.resetForm();
    };

    UploadForm.prototype._updateQuota = function() {
      var error, settings, success,
        _this = this;
      this._uploadQuota.textContent = 'Retrieving remaining space';
      success = function(data, textStatus, jqXHR) {
        if (data.error != null) {
          console.warn(data);
          return error();
        }
        _this._uploadQuota.textContent = "You upload quota is approximately: " + (getPrettySizeString(data.res));
        return delete _this._quotaXhr;
      };
      error = function(xhr, textStatus, errorThrown) {
        console.error(xhr, textStatus, errorThrown);
        _this._uploadQuota.textContent = 'Failed to get remaining space';
        return delete _this._quotaXhr;
      };
      settings = {
        url: '/files/getremainingspace/',
        type: "GET",
        dataType: "json",
        error: error,
        success: success
      };
      return this._quotaXhr = $.ajax(settings);
    };

    UploadForm.prototype.close = function(deleteEditor) {
      if (deleteEditor == null) deleteEditor = true;
      if (this._quotaXhr) {
        this._quotaXhr.abort();
        delete this._quotaXhr;
      }
      if (this._modalWindow) {
        this._modalWindow.destroy();
        delete this._modalWindow;
      }
      if (deleteEditor && this._editor) {
        delete this._editor;
        if (this._callback) {
          this._callback();
          delete this._callback;
        }
      }
      return UploadForm.__super__.close.call(this);
    };

    UploadForm.prototype.openImmediateUpload = function(editor, files, callback) {
      var doIteration, i,
        _this = this;
      i = 0;
      doIteration = function() {
        _this._editor = editor;
        _this.removeListener('close', doIteration);
        if (i >= files.length) return callback();
        _this._clear();
        getFileProcessor().getRandomId(function(id) {
          return _this._idInput.value = id;
        });
        return setTimeout(function() {
          var file;
          file = files[i];
          _this._submitForm(file);
          i += 1;
          return _this.on('close', doIteration);
        }, 10);
      };
      return doIteration();
    };

    UploadForm.prototype.open = function(_editor, insertImage, _callback) {
      var _this = this;
      this._editor = _editor;
      this._callback = _callback;
      UploadForm.__super__.open.call(this);
      this._clear();
      this._updateQuota();
      if (insertImage) {
        this._$imageInsertContainer.show();
        this._fileLabel.textContent = 'Or upload picture from your computer';
        this._urlInput.focus();
      } else {
        this._$imageInsertContainer.hide();
        this._fileLabel.textContent = 'Upload file from your computer';
        this._browseButton.focus();
      }
      getFileProcessor().getRandomId(function(id) {
        return _this._idInput.value = id;
      });
      return this;
    };

    return UploadForm;

  })(CenteredWindow);

  exports.UploadForm = UploadForm;

  instance = null;

  exports.getInstance = function() {
    return instance || (instance = new UploadForm());
  };

  exports.removeInstance = function() {
    if (instance != null) instance.destroy();
    return instance = null;
  };

}).call(this);

});

require.define("/lib/client/client/editor/gadget/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var Gadget, MicroEvent, ck, getOpenSocial, render;

  MicroEvent = require('../utils/microevent');

  getOpenSocial = require('../wave/opensocial').get;

  ck = window.CoffeeKup;

  render = ck.compile(function() {
    return div('.gadget-outer-container', {
      contentEditable: 'false'
    }, function() {
      div('.gadget-error-message', function() {
        text("Can't load gadget");
        return button('Try again');
      });
      return div('.gadget-container', '');
    });
  });

  Gadget = (function() {

    function Gadget(url, state, editMode) {
      var _ref;
      this._createContainer();
      if ((_ref = getOpenSocial()) != null) {
        _ref.loadGadget(url, state, editMode, this);
      }
    }

    Gadget.prototype.destroy = function() {
      var _ref;
      return (_ref = getOpenSocial()) != null ? _ref.unloadGadget(this) : void 0;
    };

    Gadget.prototype._createContainer = function() {
      var container,
        _this = this;
      container = $(render());
      container.find('.gadget-error-message button').click(function() {
        var _ref;
        container.removeClass('gadget-error').addClass('gadget-loading');
        return (_ref = getOpenSocial()) != null ? _ref.reloadGadget(_this) : void 0;
      });
      container.addClass('gadget-loading');
      return this._container = container[0];
    };

    Gadget.prototype.onLoad = function() {
      return $(this._container).removeClass('gadget-loading gadget-error');
    };

    Gadget.prototype.onError = function() {
      return $(this._container).removeClass('gadget-loading').addClass('gadget-error');
    };

    Gadget.prototype.getContainer = function() {
      return this._container;
    };

    Gadget.prototype.getGadgetContainer = function() {
      return $(this._container).find('.gadget-container')[0];
    };

    Gadget.prototype.setStateDelta = function(delta) {
      var _ref;
      return (_ref = getOpenSocial()) != null ? _ref.setStateDelta(this, delta) : void 0;
    };

    Gadget.prototype.setMode = function(editMode) {
      var _ref;
      return (_ref = getOpenSocial()) != null ? _ref.setMode(this, editMode) : void 0;
    };

    return Gadget;

  })();

  Gadget = MicroEvent.mixin(Gadget);

  exports.Gadget = Gadget;

}).call(this);

});

require.define("/lib/client/client/wave/opensocial.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ANONYMOUS_USER_ID, OpenSocial, fixShindig, openSocial, _,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  _ = require('underscore');

  ANONYMOUS_USER_ID = 'anonymous';

  fixShindig = function() {
    var CustomContainer, CustomGadget, CustomLayoutManager;
    CustomGadget = (function(_super) {

      __extends(CustomGadget, _super);

      function CustomGadget(params) {
        shindig.Gadget.call(this, params);
        this.setServerBase(window.gadget.shindigUrl + '/gadgets/');
      }

      CustomGadget.prototype.getTitleBarContent = function(callback) {
        return callback('');
      };

      CustomGadget.prototype.getMainContent = shindig.IfrGadget.getMainContent;

      CustomGadget.prototype.finishRender = function(chrome) {
        var iframe;
        iframe = $(chrome).find('iframe:first');
        return iframe.attr('src', this.getIframeUrl());
      };

      CustomGadget.prototype.getIframeUrl = shindig.IfrGadget.getIframeUrl;

      return CustomGadget;

    })(shindig.BaseIfrGadget);
    CustomLayoutManager = (function(_super) {

      __extends(CustomLayoutManager, _super);

      function CustomLayoutManager() {
        shindig.LayoutManager.call(this);
        this._containers = {};
      }

      CustomLayoutManager.prototype.setGadgetChrome = function(gadgetId, container) {
        return this._containers[gadgetId] = container;
      };

      CustomLayoutManager.prototype.getGadgetChrome = function(gadget) {
        return this._containers[gadget.id];
      };

      CustomLayoutManager.prototype.unsetGadgetChrome = function(gadgetId) {
        return delete this._containers[gadgetId];
      };

      return CustomLayoutManager;

    })(shindig.LayoutManager);
    CustomContainer = (function(_super) {

      __extends(CustomContainer, _super);

      function CustomContainer() {
        shindig.IfrContainer.call(this);
        this.gadgetClass = CustomGadget;
        this.layoutManager = new CustomLayoutManager();
        this.setNoCache(0);
        this.setParentUrl("" + location.protocol + "//" + window.HOST);
      }

      CustomContainer.prototype.getGadgets = function() {
        return this.gadgets_;
      };

      CustomContainer.prototype.removeGadget = function(toRemove) {
        var gadget, key, _ref, _results;
        _ref = this.gadgets_;
        _results = [];
        for (key in _ref) {
          gadget = _ref[key];
          if (gadget === toRemove) {
            delete this.gadgets_[key];
            break;
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      return CustomContainer;

    })(shindig.IfrContainer);
    return shindig.container = new CustomContainer();
  };

  OpenSocial = (function() {

    OpenSocial.prototype.LOADING_TIMEOUT = 15;

    function OpenSocial() {
      this._gadgets = {};
      this._subscribeToParticipants();
      this._subscribeToWaveEnabled();
      this._subscribeToGadgetState();
    }

    OpenSocial.prototype._subscribeToParticipants = function() {
      var userProcessor,
        _this = this;
      userProcessor = require('../user/processor').instance;
      return userProcessor.on('update', function() {
        var key, _results;
        _results = [];
        for (key in _this._gadgets) {
          _results.push(_this._triggerParticipants(key));
        }
        return _results;
      });
    };

    OpenSocial.prototype._getParticipants = function() {
      var wave, _ref;
      wave = require('../modules/wave_base').instance;
      return (_ref = wave.getCurrentWave()) != null ? _ref.getParticipants() : void 0;
    };

    OpenSocial.prototype._getUserId = function() {
      var _ref;
      return ((_ref = window.userInfo) != null ? _ref.id : void 0) || ANONYMOUS_USER_ID;
    };

    OpenSocial.prototype._triggerParticipants = function(key) {
      var data, id, participant, participants, userId, _i, _len;
      participants = this._getParticipants();
      if (!participants) return;
      userId = this._getUserId();
      data = {
        myId: userId,
        authorId: userId,
        participants: {}
      };
      for (_i = 0, _len = participants.length; _i < _len; _i++) {
        participant = participants[_i];
        id = participant.getId();
        data.participants[id] = {
          id: id,
          displayName: participant.getName(),
          thumbnailUrl: participant.getAvatar()
        };
      }
      return gadgets.rpc.call(key, 'wave_participants', null, data);
    };

    OpenSocial.prototype._triggerMode = function(key) {
      var editMode;
      editMode = this._gadgets[key].editMode ? '1' : '0';
      return gadgets.rpc.call(key, 'wave_gadget_mode', null, {
        '${playback}': '0',
        '${edit}': editMode
      });
    };

    OpenSocial.prototype._triggerState = function(key) {
      var state;
      state = this._gadgets[key].state;
      return gadgets.rpc.call(key, 'wave_gadget_state', null, state);
    };

    OpenSocial.prototype._triggerGadgetLoaded = function(key) {
      return this._gadgets[key].gadget.onLoad();
    };

    OpenSocial.prototype._subscribeToWaveEnabled = function() {
      var self;
      self = this;
      return gadgets.rpc.register('wave_enable', function() {
        var key;
        key = this.f;
        self._triggerParticipants(key);
        self._triggerMode(key);
        self._triggerState(key);
        self._triggerGadgetLoaded(key);
        return self._stopLoadingCheck(key);
      });
    };

    OpenSocial.prototype._subscribeToGadgetState = function() {
      var self;
      self = this;
      return gadgets.rpc.register('wave_gadget_state', function(data) {
        var info, userId;
        info = self._gadgets[this.f];
        if (!info) return;
        userId = self._getUserId();
        if (userId === ANONYMOUS_USER_ID) return;
        return info.gadget.emit('update', data);
      });
    };

    OpenSocial.prototype._getGadgetKey = function(gadget) {
      var item, key, _ref;
      _ref = this._gadgets;
      for (key in _ref) {
        item = _ref[key];
        if (gadget === item.gadget) return key;
      }
      return null;
    };

    OpenSocial.prototype._getGadgetInfo = function(gadget) {
      var key;
      key = this._getGadgetKey(gadget);
      return this._gadgets[key];
    };

    OpenSocial.prototype._startLoadingCheck = function(key) {
      var info;
      info = this._gadgets[key];
      return info.checkTimeout = setTimeout(function() {
        _gaq.push(['_trackEvent', 'Error', 'Client error', 'Gadget loading timeout']);
        return info.gadget.onError();
      }, this.LOADING_TIMEOUT * 1000);
    };

    OpenSocial.prototype._stopLoadingCheck = function(key) {
      return clearTimeout(this._gadgets[key].checkTimeout);
    };

    OpenSocial.prototype.loadGadget = function(url, state, editMode, gadget) {
      var container, key, shindigGadget;
      container = shindig.container;
      shindigGadget = container.createGadget({
        specUrl: url
      });
      shindigGadget.getAdditionalParams = function() {
        return '&wave=1&waveId=1';
      };
      container.addGadget(shindigGadget);
      container.layoutManager.setGadgetChrome(shindigGadget.id, gadget.getGadgetContainer());
      container.renderGadget(shindigGadget);
      key = shindigGadget.getIframeId();
      this._gadgets[key] = {
        gadget: gadget,
        shindig: shindigGadget,
        url: url,
        state: state,
        editMode: editMode
      };
      return this._startLoadingCheck(key);
    };

    OpenSocial.prototype.reloadGadget = function(gadget) {
      var info;
      info = this._getGadgetInfo(gadget);
      this.unloadGadget(gadget);
      return this.loadGadget(info.url, info.state, info.editMode, gadget);
    };

    OpenSocial.prototype.unloadGadget = function(gadget) {
      var container, info, key;
      info = this._getGadgetInfo(gadget);
      container = shindig.container;
      container.layoutManager.unsetGadgetChrome(info.shindig.id);
      container.removeGadget(info.shindig);
      key = this._getGadgetKey(gadget);
      this._stopLoadingCheck(key);
      return delete this._gadgets[key];
    };

    OpenSocial.prototype._updateInitialState = function(state, delta) {
      var key, value, _results;
      _.extend(state, delta);
      _results = [];
      for (key in state) {
        value = state[key];
        if (value === null) {
          _results.push(delete state[key]);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    OpenSocial.prototype.setStateDelta = function(gadget, delta) {
      var key;
      key = this._getGadgetKey(gadget);
      this._updateInitialState(this._gadgets[key].state, delta);
      return gadgets.rpc.call(key, 'wave_state_delta', null, delta);
    };

    OpenSocial.prototype.setMode = function(gadget, editMode) {
      var key;
      key = this._getGadgetKey(gadget);
      this._gadgets[key].editMode = editMode;
      return this._triggerMode(key);
    };

    return OpenSocial;

  })();

  if (window.gadget.enabled) fixShindig();

  openSocial = null;

  exports.get = function() {
    if (window.gadget.enabled && !openSocial) openSocial = new OpenSocial();
    return openSocial;
  };

}).call(this);

});

require.define("/node_modules/underscore/package.json",function(require,module,exports,__dirname,__filename,process,global){module.exports = {"main":"underscore.js"}
});

require.define("/node_modules/underscore/underscore.js",function(require,module,exports,__dirname,__filename,process,global){//     Underscore.js 1.3.3
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore is freely distributable under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var slice            = ArrayProto.slice,
      unshift          = ArrayProto.unshift,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) { return new wrapper(obj); };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root['_'] = _;
  }

  // Current version.
  _.VERSION = '1.3.3';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    if (obj.length === +obj.length) results.length = obj.length;
    return results;
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError('Reduce of empty array with no initial value');
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var reversed = _.toArray(obj).reverse();
    if (context && !initial) iterator = _.bind(iterator, context);
    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    each(obj, function(value, index, list) {
      if (!iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if a given value is included in the array or object using `===`.
  // Aliased as `contains`.
  _.include = _.contains = function(obj, target) {
    var found = false;
    if (obj == null) return found;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    found = any(obj, function(value) {
      return value === target;
    });
    return found;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Return the maximum element or (element-based computation).
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var shuffled = [], rand;
    each(obj, function(value, index, list) {
      rand = Math.floor(Math.random() * (index + 1));
      shuffled[index] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, val, context) {
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      if (a === void 0) return 1;
      if (b === void 0) return -1;
      return a < b ? -1 : a > b ? 1 : 0;
    }), 'value');
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, val) {
    var result = {};
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    each(obj, function(value, index) {
      var key = iterator(value, index);
      (result[key] || (result[key] = [])).push(value);
    });
    return result;
  };

  // Use a comparator function to figure out at what index an object should
  // be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator) {
    iterator || (iterator = _.identity);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >> 1;
      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj)                                     return [];
    if (_.isArray(obj))                           return slice.call(obj);
    if (_.isArguments(obj))                       return slice.call(obj);
    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    return _.isArray(obj) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especcialy useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail`.
  // Especially useful on the arguments object. Passing an **index** will return
  // the rest of the values in the array from that index onward. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = function(array, index, guard) {
    return slice.call(array, (index == null) || guard ? 1 : index);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, function(value){ return !!value; });
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return _.reduce(array, function(memo, value) {
      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));
      memo[memo.length] = value;
      return memo;
    }, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator) {
    var initial = iterator ? _.map(array, iterator) : array;
    var results = [];
    // The `isSorted` flag is irrelevant if the array only contains two elements.
    if (array.length < 3) isSorted = true;
    _.reduce(initial, function (memo, value, index) {
      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {
        memo.push(value);
        results.push(array[index]);
      }
      return memo;
    }, []);
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays. (Aliased as "intersect" for back-compat.)
  _.intersection = _.intersect = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = _.flatten(slice.call(arguments, 1), true);
    return _.filter(array, function(value){ return !_.include(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) results[i] = _.pluck(args, "" + i);
    return results;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i, l;
    if (isSorted) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item) {
    if (array == null) return -1;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
    var i = array.length;
    while (i--) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Binding with arguments is also known as `curry`.
  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
  // We check for `func.bind` first, to fail fast when `func` is undefined.
  _.bind = function bind(func, context) {
    var bound, args;
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, throttling, more, result;
    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);
    return function() {
      context = this; args = arguments;
      var later = function() {
        timeout = null;
        if (more) func.apply(context, args);
        whenDone();
      };
      if (!timeout) timeout = setTimeout(later, wait);
      if (throttling) {
        more = true;
      } else {
        result = func.apply(context, args);
      }
      whenDone();
      throttling = true;
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      if (immediate && !timeout) func.apply(context, args);
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      return memo = func.apply(this, arguments);
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func].concat(slice.call(arguments, 0));
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) { return func.apply(this, arguments); }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    return _.map(obj, _.identity);
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var result = {};
    each(_.flatten(slice.call(arguments, 1)), function(key) {
      if (key in obj) result[key] = obj[key];
    });
    return result;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        if (obj[prop] == null) obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function.
  function eq(a, b, stack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a._chain) a = a._wrapped;
    if (b._chain) b = b._wrapped;
    // Invoke a custom `isEqual` method if one is provided.
    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);
    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = stack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (stack[length] == a) return true;
    }
    // Add the first object to the stack of traversed objects.
    stack.push(a);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          // Ensure commutative equality for sparse arrays.
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent.
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    stack.pop();
    return result;
  }

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType == 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Is a given variable an arguments object?
  _.isArguments = function(obj) {
    return toString.call(obj) == '[object Arguments]';
  };
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Is a given value a function?
  _.isFunction = function(obj) {
    return toString.call(obj) == '[object Function]';
  };

  // Is a given value a string?
  _.isString = function(obj) {
    return toString.call(obj) == '[object String]';
  };

  // Is a given value a number?
  _.isNumber = function(obj) {
    return toString.call(obj) == '[object Number]';
  };

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return _.isNumber(obj) && isFinite(obj);
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    // `NaN` is the only value for which `===` is not reflexive.
    return obj !== obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value a date?
  _.isDate = function(obj) {
    return toString.call(obj) == '[object Date]';
  };

  // Is the given value a regular expression?
  _.isRegExp = function(obj) {
    return toString.call(obj) == '[object RegExp]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Has own property?
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function (n, iterator, context) {
    for (var i = 0; i < n; i++) iterator.call(context, i);
  };

  // Escape a string for HTML interpolation.
  _.escape = function(string) {
    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g,'&#x2F;');
  };

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object, ensuring that
  // they're correctly added to the OOP wrapper as well.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      addToWrapper(name, _[name] = obj[name]);
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /.^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    '\\': '\\',
    "'": "'",
    'r': '\r',
    'n': '\n',
    't': '\t',
    'u2028': '\u2028',
    'u2029': '\u2029'
  };

  for (var p in escapes) escapes[escapes[p]] = p;
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
  var unescaper = /\\(\\|'|r|n|t|u2028|u2029)/g;

  // Within an interpolation, evaluation, or escaping, remove HTML escaping
  // that had been previously added.
  var unescape = function(code) {
    return code.replace(unescaper, function(match, escape) {
      return escapes[escape];
    });
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    settings = _.defaults(settings || {}, _.templateSettings);

    // Compile the template source, taking care to escape characters that
    // cannot be included in a string literal and then unescape them in code
    // blocks.
    var source = "__p+='" + text
      .replace(escaper, function(match) {
        return '\\' + escapes[match];
      })
      .replace(settings.escape || noMatch, function(match, code) {
        return "'+\n_.escape(" + unescape(code) + ")+\n'";
      })
      .replace(settings.interpolate || noMatch, function(match, code) {
        return "'+\n(" + unescape(code) + ")+\n'";
      })
      .replace(settings.evaluate || noMatch, function(match, code) {
        return "';\n" + unescape(code) + "\n;__p+='";
      }) + "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __p='';" +
      "var print=function(){__p+=Array.prototype.join.call(arguments, '')};\n" +
      source + "return __p;\n";

    var render = new Function(settings.variable || 'obj', '_', source);
    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for build time
    // precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' +
      source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // The OOP Wrapper
  // ---------------

  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.
  var wrapper = function(obj) { this._wrapped = obj; };

  // Expose `wrapper.prototype` as `_.prototype`
  _.prototype = wrapper.prototype;

  // Helper function to continue chaining intermediate results.
  var result = function(obj, chain) {
    return chain ? _(obj).chain() : obj;
  };

  // A method to easily add functions to the OOP wrapper.
  var addToWrapper = function(name, func) {
    wrapper.prototype[name] = function() {
      var args = slice.call(arguments);
      unshift.call(args, this._wrapped);
      return result(func.apply(_, args), this._chain);
    };
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      var wrapped = this._wrapped;
      method.apply(wrapped, arguments);
      var length = wrapped.length;
      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];
      return result(wrapped, this._chain);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      return result(method.apply(this._wrapped, arguments), this._chain);
    };
  });

  // Start chaining a wrapped Underscore object.
  wrapper.prototype.chain = function() {
    this._chain = true;
    return this;
  };

  // Extracts the result from a wrapped and chained object.
  wrapper.prototype.value = function() {
    return this._wrapped;
  };

}).call(this);

});

require.define("/lib/client/client/modules/wave_base.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BaseModule, History, LocalStorage, Request, UrlUtil, WAVE_SHARED_STATE_LINK_PUBLIC, WAVE_SHARED_STATE_PRIVATE, WAVE_SHARED_STATE_PUBLIC, WaveBase, WaveViewModel, trackTopicCreatedAndUserAdded, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BaseModule = require('../../share/base_module').BaseModule;

  History = require('../utils/history_navigation');

  UrlUtil = require('../utils/url');

  Request = require('../../share/communication').Request;

  LocalStorage = require('../utils/localStorage').LocalStorage;

  trackTopicCreatedAndUserAdded = require('../analytics/ping').trackTopicCreatedAndUserAdded;

  _ref = require('../wave/model'), WAVE_SHARED_STATE_PUBLIC = _ref.WAVE_SHARED_STATE_PUBLIC, WAVE_SHARED_STATE_LINK_PUBLIC = _ref.WAVE_SHARED_STATE_LINK_PUBLIC, WAVE_SHARED_STATE_PRIVATE = _ref.WAVE_SHARED_STATE_PRIVATE;

  WaveViewModel = require('../wave/index_base').WaveViewModelBase;

  WaveBase = (function(_super) {

    __extends(WaveBase, _super);

    function WaveBase(rootRouter, __waveContainer) {
      var query;
      this.__waveContainer = __waveContainer;
      this.__processCreateWaveResponse = __bind(this.__processCreateWaveResponse, this);
      this.__createWaveButtonHandler = __bind(this.__createWaveButtonHandler, this);
      WaveBase.__super__.constructor.call(this, rootRouter);
      query = UrlUtil.getQuery();
      if (query.grant_access_to != null) {
        window.grantAccess = {
          user: query.grant_access_to
        };
      }
      this.__openCount = 0;
      this.__waveProcessor = require('../wave/processor').instance;
      this._initSessionPings();
      if (!module.exports.instance) module.exports.instance = this;
    }

    WaveBase.prototype._initSessionPings = function() {
      return setInterval(function() {
        var r;
        r = new XMLHttpRequest();
        r.open('GET', "/ping/?t=" + (Date.now()));
        return r.send(null);
      }, window.expressSession.refreshInterval || 1200000);
    };

    WaveBase.prototype._updateBlipIdInUrl = function(blipId) {
      return History.changeBlipId(blipId);
    };

    WaveBase.prototype.__showWaveLoadingError = function(err) {
      /*
              Отображает сообщение об ошибке загрузки топика
      */      throw new Error('not implemented');
    };

    WaveBase.prototype.__showWaveCreatingError = function(err) {
      /*
              Отображает сообщение об ошибке создания топика
      */      throw new Error('not implemented');
    };

    WaveBase.prototype.__showWave = function(waveData, waveBlips, socialSharingUrl) {
      /*
              Строит отображение волны в DOM. Должен вернуть экземпляр текущей волны
              @returns WaveViewModel
      */      throw new Error('not implemented');
    };

    WaveBase.prototype.__showTopicCreatingWait = function() {
      throw new Error('not implemented');
    };

    WaveBase.prototype.__showTopicLoadingWait = function() {
      throw new Error('not implemented');
    };

    WaveBase.prototype.__createWaveButtonHandler = function(e, analyticsProp) {
      /*
              Обрабатывает событие нажатия кнопки CreateWave. Создает волну и сразу ее открывает
      */
      var doCreate,
        _this = this;
      _gaq.push(['_trackEvent', 'Topic creation', 'Create topic', analyticsProp, 1]);
      doCreate = function() {
        _this.__waveProcessor.createWave(function(err, waveId) {
          return _this.__processCreateWaveResponse(err, waveId, doCreate);
        });
        return _this.__showTopicCreatingWait();
      };
      doCreate();
      return e.stopPropagation();
    };

    WaveBase.prototype.__processCreateWaveResponse = function(err, waveId, retry) {
      /*
              Обрабатывает ответ на операцию создания волны
      */      if (err) return this.__showWaveCreatingError(err, retry);
      return this.__processCreateWaveSuccessResponse(waveId);
    };

    WaveBase.prototype.__processCreateWaveSuccessResponse = function(waveId) {
      this.__newWave = true;
      trackTopicCreatedAndUserAdded(0, 1);
      LocalStorage.incTopicsCreated();
      return History.navigateTo(waveId);
    };

    WaveBase.prototype.__openWave = function(waveId, serverBlipId) {
      var _this = this;
      if (!this.__openCount) this._firstTopicLoadStartTime = new Date();
      this.__openCount += 1;
      if (this._curWaveOpenRequest != null) {
        this._cancelNetworkRequest(this._curWaveOpenRequest);
      }
      return this._curWaveOpenRequest = this.__waveProcessor.getWaveWithBlips(waveId, function(err, waveData, waveBlips, socialSharingUrl) {
        _this._curWaveOpenRequest = null;
        if (err) {
          return _this.__processOpenWaveErrorResponse(err, waveId, serverBlipId);
        }
        return _this.__processOpenWaveSuccessResponse(waveId, serverBlipId, waveData, waveBlips, socialSharingUrl);
      });
    };

    WaveBase.prototype._cancelNetworkRequest = function(requestToCancel) {
      var request;
      if (!requestToCancel.callId) {
        console.error("Tried to cancel network request, but it does not have callId", requestToCancel);
        return;
      }
      request = new Request({
        callId: requestToCancel.callId
      }, function(err) {
        if (err) return console.warn("Could not remove network request", err);
      });
      return this._rootRouter.handle('network.wave.removeCall', request);
    };

    WaveBase.prototype.__processOpenWaveErrorResponse = function(err, waveId, serverBlipId) {
      var prefix;
      switch (err.code) {
        case 'wave_permission_denied':
          prefix = '/permissiondenied/topic/';
          break;
        case 'wave_document_does_not_exists':
          prefix = '/notfound/topic/';
          break;
        case 'wave_anonymous_permission_denied':
          prefix = '/unauthorized/topic/';
          break;
        default:
          prefix = '/' + err.code + '/topic/';
      }
      _gaq.push(['_trackPageview', prefix + waveId + '/' + document.location.search]);
      if (document.location.search && window.cleanupAnalytics) {
        _gaq.push(window.cleanupAnalytics);
      }
      return this.__showWaveLoadingError(err, waveId, serverBlipId);
    };

    WaveBase.prototype.__processOpenWaveSuccessResponse = function(waveId, serverBlipId, waveData, waveBlips, socialSharingUrl) {
      var access, curWave, label, prefix, processWaveLoaded, sharedState, time, waveServerId,
        _this = this;
      curWave = this.__showWave(waveData, waveBlips, socialSharingUrl);
      curWave.on(WaveViewModel.Events.ACTIVE_BLIP_CHANGE, this._updateBlipIdInUrl);
      sharedState = curWave.getModel().getSharedState();
      prefix = '/unknown';
      switch (sharedState) {
        case WAVE_SHARED_STATE_PRIVATE:
          if (window.loggedIn) prefix = '/private';
          break;
        case WAVE_SHARED_STATE_PUBLIC:
          if (window.loggedIn) {
            prefix = '/public';
          } else {
            prefix = '/anonymous';
            this.__showLikeButtons();
          }
          break;
        case WAVE_SHARED_STATE_LINK_PUBLIC:
          if (window.loggedIn) prefix = '/bylink';
      }
      _gaq.push(['_trackPageview', prefix + '/topic/' + waveId + '/' + document.location.search]);
      if (!window.loggedIn) {
        if (sharedState === WAVE_SHARED_STATE_PUBLIC) {
          mixpanel.track('Visit landing', {
            "landing name": 'public'
          });
        } else {
          mixpanel.track('Visit landing', {
            "landing name": '/topic/id'
          });
        }
      }
      serverBlipId || (serverBlipId = curWave.getRootBlipId());
      _this = this;
      if (this.__openCount === 1 && ((access = window.grantAccess) != null)) {
        waveServerId = curWave.getModel().serverId;
        setTimeout(function() {
          curWave.showGrantAccessForm(access.user, function(role, callback) {
            return _this.__waveProcessor.addParticipant(waveServerId, access.user, parseInt(role), callback);
          });
          return delete window.grantAccess;
        }, 250);
      }
      if (this.__openCount === 1) {
        time = new Date() - this._firstTopicLoadStartTime;
        label = Math.round(time / 250) * 250;
        _gaq.push(['_trackEvent', 'Timings', 'Get topic by url', label + '', time]);
      }
      processWaveLoaded = function() {
        _this.__processWaveLoadedEvent(this, waveId, serverBlipId);
        return this.removeListener('waveLoaded', processWaveLoaded);
      };
      return curWave.on('waveLoaded', processWaveLoaded);
    };

    WaveBase.prototype.__showLikeButtons = function() {};

    WaveBase.prototype.__processWaveLoadedEvent = function(curWave, waveId, serverBlipId) {
      History.setPageTitle(curWave.getTitle());
      if (!curWave.hasLoadedBlip(serverBlipId)) {
        this.showWaveWarning("Requested location not found.");
        serverBlipId = curWave.getRootBlipId();
      }
      curWave.activateBlip(serverBlipId);
      if (this.__newWave || UrlUtil.getQuery().enableEditMode === '1') {
        curWave.focusActiveBlip();
        return this.__newWave = false;
      }
    };

    WaveBase.prototype.__closeCurWave = function() {
      /*
              Закрывает текущий открытый топик и сообщение на месте топика
      */
      var _ref2, _ref3;
      if ((_ref2 = this.__curWave) != null) _ref2.destroy();
      delete this.__curWave;
      if ((_ref3 = this.__curMessage) != null) _ref3.destroy();
      return delete this.__curMessage;
    };

    WaveBase.prototype.__activateBlip = function(wave, blipId) {
      /*
              Активирует блип, когда он будет загружен
              @param wave: WaveViewModel
              @param blipId: string
      */
      var _this = this;
      return wave.onBlipLoaded(blipId, function() {
        return wave.activateBlip(blipId);
      });
    };

    WaveBase.prototype.getWaveContainer = function() {
      return $('#wave')[0];
    };

    WaveBase.prototype.getCurrentWave = function() {
      return this.__curWave;
    };

    WaveBase.prototype.getCurWave = function(request, args, callback) {
      return request.callback(this.__curWave);
    };

    WaveBase.prototype.showWaveWarning = function(message) {
      throw "Must be implemented";
    };

    WaveBase.prototype.showWaveError = function(err) {
      throw "Must be implemented";
    };

    WaveBase.prototype.showTopicCreatingWait = function() {
      return this.__showTopicCreatingWait();
    };

    return WaveBase;

  })(BaseModule);

  exports.WaveBase = WaveBase;

}).call(this);

});

require.define("/lib/client/client/wave/model.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var EmitModel, ROLE_NO_ROLE, WAVE_SHARED_STATE_LINK_PUBLIC, WAVE_SHARED_STATE_PRIVATE, WAVE_SHARED_STATE_PUBLIC, WaveModel,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  WAVE_SHARED_STATE_PUBLIC = 1;

  WAVE_SHARED_STATE_LINK_PUBLIC = 2;

  WAVE_SHARED_STATE_PRIVATE = 3;

  ROLE_NO_ROLE = require('./participants/constants').ROLE_NO_ROLE;

  EmitModel = require('../utils/emit_model');

  WaveModel = (function(_super) {

    __extends(WaveModel, _super);

    WaveModel.EDITABLE_CHANGE = 'editableChange';

    WaveModel.ACTIVE_BLIP_CHANGE = 'activeBlipChange';

    WaveModel.PROPS = ['_editable', '_activeBlip'];

    function WaveModel(_doc, socialSharingUrl) {
      this._doc = _doc;
      WaveModel.__super__.constructor.call(this);
      this._init(this._doc, socialSharingUrl);
    }

    WaveModel.prototype._init = function(_doc, socialSharingUrl) {
      this._doc = _doc;
      this.__props = ['_editable', '_activeBlip'];
      this._rootBlipId = this._doc.snapshot.rootBlipId;
      this._containerBlipId = this._doc.snapshot.containerBlipId;
      this.socialSharingUrl = socialSharingUrl;
      this.id = this._doc.name;
      this.serverId = this._doc.serverId;
      return this._editable = false;
    };

    WaveModel.prototype.getVersion = function() {
      return this._doc.version;
    };

    WaveModel.prototype.getServerId = function() {
      return this.serverId;
    };

    WaveModel.prototype.getSharedState = function() {
      /*
              Возвращает true, если в волна доступна всем пользователям
              @return: boolean
      */      return this._doc.snapshot.sharedState;
    };

    WaveModel.prototype.getRootBlipId = function() {
      return this._rootBlipId;
    };

    WaveModel.prototype.getContainerBlipId = function() {
      return this._containerBlipId;
    };

    WaveModel.prototype.getRole = function(participantId, noRoleIfNotAdded) {
      var p, _i, _len, _ref;
      if (noRoleIfNotAdded == null) noRoleIfNotAdded = true;
      _ref = this._doc.snapshot.participants;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        if (p.id === participantId) return p.role;
      }
      if (noRoleIfNotAdded) {
        return ROLE_NO_ROLE;
      } else {
        return null;
      }
    };

    WaveModel.prototype.getDefaultRole = function() {
      return this._doc.snapshot.defaultRole;
    };

    WaveModel.prototype.setActiveBlip = function(blip) {
      return this.__setProperty(this.constructor.ACTIVE_BLIP_CHANGE, '_activeBlip', blip);
    };

    WaveModel.prototype.getActiveBlip = function() {
      return this._activeBlip;
    };

    WaveModel.prototype.setEditable = function(editable) {
      return this.__setProperty(this.constructor.EDITABLE_CHANGE, '_editable', editable);
    };

    WaveModel.prototype.getEditable = function() {
      return this._editable;
    };

    WaveModel.prototype.getGDriveId = function() {
      return this._doc.snapshot.gDriveId;
    };

    WaveModel.prototype.getGDriveShareUrl = function() {
      var gDriveId;
      if (gDriveId = this._doc.snapshot.gDriveId) {
        return "https://drive.google.com/file/d/" + gDriveId + "/edit?userstoinvite=%20";
      } else {
        return null;
      }
    };

    WaveModel.prototype.destroy = function() {
      WaveModel.__super__.destroy.call(this);
      delete this._doc;
      return delete this._activeBlip;
    };

    return WaveModel;

  })(EmitModel);

  module.exports = {
    WaveModel: WaveModel,
    WAVE_SHARED_STATE_PUBLIC: WAVE_SHARED_STATE_PUBLIC,
    WAVE_SHARED_STATE_LINK_PUBLIC: WAVE_SHARED_STATE_LINK_PUBLIC,
    WAVE_SHARED_STATE_PRIVATE: WAVE_SHARED_STATE_PRIVATE
  };

}).call(this);

});

require.define("/lib/client/client/utils/emit_model.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var EmitModel, MicroEvent;

  MicroEvent = require('./microevent');

  EmitModel = (function() {

    function EmitModel() {}

    EmitModel.PROPS = [];

    EmitModel.prototype.__setProperty = function(eventName, prop, value) {
      if (this.constructor.PROPS.indexOf(prop) < 0) {
        throw new Error("Property " + prop + " doesn't belong to allowed prop list");
      }
      if (value === this[prop]) return;
      this.emit(eventName, value, this[prop]);
      return this[prop] = value;
    };

    EmitModel.prototype.destroy = function() {
      return this.removeAllListeners();
    };

    return EmitModel;

  })();

  MicroEvent.mixin(EmitModel);

  module.exports = EmitModel;

}).call(this);

});

require.define("/lib/client/client/wave/index_base.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipViewModel, MIN_BLIP_COUNT_SET_READ_TO_FOLLOW, MicroEvent, ROLE_EDITOR, ROLE_NO_ROLE, ROLE_OWNER, STATE_CLOSING, STATE_LOADED, STATE_LOADING, WAVE_SHARED_STATE_PUBLIC, WaveModel, WaveView, WaveViewModel, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  WaveModel = require('./model').WaveModel;

  WaveView = require('./view_base');

  BlipViewModel = require('../blip/index_base');

  MicroEvent = require('../utils/microevent');

  _ref = require('./participants/constants'), ROLE_OWNER = _ref.ROLE_OWNER, ROLE_EDITOR = _ref.ROLE_EDITOR, ROLE_NO_ROLE = _ref.ROLE_NO_ROLE;

  WAVE_SHARED_STATE_PUBLIC = require('./model').WAVE_SHARED_STATE_PUBLIC;

  STATE_LOADING = 0;

  STATE_LOADED = 1;

  STATE_CLOSING = 2;

  MIN_BLIP_COUNT_SET_READ_TO_FOLLOW = 3;

  WaveViewModel = (function() {

    WaveViewModel.Events = {
      ACTIVE_BLIP_CHANGE: 'activeBlipChange',
      BLIP_DESTROYED: 'blipDestroyed'
    };

    function WaveViewModel(waveProcessor, waveData, waveBlips, socialSharingUrl, parent) {
      this._readAllBlips = __bind(this._readAllBlips, this);
      this.getUsers = __bind(this.getUsers, this);
      this.goToNextUnreadBlip = __bind(this.goToNextUnreadBlip, this);
      this._processUsersInfoUpdate = __bind(this._processUsersInfoUpdate, this);
      this._processRemoteOps = __bind(this._processRemoteOps, this);      this._init(waveProcessor, waveData, waveBlips, socialSharingUrl, parent);
    }

    WaveViewModel.prototype._init = function(_processor, waveData, blipCache, socialSharingUrl, _parent) {
      var _this = this;
      this._processor = _processor;
      this.blipCache = blipCache;
      this._parent = _parent;
      this._unreadBlipsCount = 0;
      this._totalBlipsCount = 0;
      this._unloadBlipsCount = 0;
      this._state = STATE_LOADING;
      this._unreadBlips = {};
      this._loadedBlips = {};
      this._requestedBlips = {};
      this._loadBlipsCallbacks = {};
      this._childBlips = {};
      this._userProcessor = require('../user/processor').instance;
      this._userProcessor.on('update', this._processUsersInfoUpdate);
      this.__model = this._model = new WaveModel(waveData, socialSharingUrl);
      this.__view = null;
      this.__initView(this._processor, waveData.snapshot.participants, this._parent.getWaveContainer());
      this.on(this.constructor.Events.BLIP_DESTROYED, function(blip) {
        return this._removeChildBlip(blip);
      });
      this.__view.on('goToNextUnread', this.goToNextUnreadBlip);
      this.__view.on(WaveView.Events.READ_ALL, this._readAllBlips);
      this.__model.on(WaveModel.EDITABLE_CHANGE, function(editable) {
        var _base;
        return typeof (_base = _this.__view).processEditableChange === "function" ? _base.processEditableChange(editable) : void 0;
      }).on(WaveModel.ACTIVE_BLIP_CHANGE, function(newActive, lastActive) {
        return _this.__emitActiveBlipIdChange(newActive);
      });
      waveData.on('remoteop', this._processRemoteOps);
      this._waveData = waveData;
      this.__initBlipProcessor();
      this.__initLocalStorage();
      this._blipsSetAsRead = {};
      return this._blipsSetAsReadCount = 0;
    };

    WaveViewModel.prototype._getNextUnreadBlip = function(blip, startIndex) {
      var parent, unreadBlip;
      if (startIndex == null) startIndex = 0;
      while (blip) {
        unreadBlip = blip.getNextUnread(startIndex);
        if (unreadBlip) return unreadBlip;
        parent = blip.getParent();
        if (!parent) return null;
        startIndex = parent.getChildIndex(blip) + 1;
        blip = parent;
      }
      return null;
    };

    WaveViewModel.prototype.__initLocalStorage = function() {};

    WaveViewModel.prototype.__initView = function(processor, participants, container) {};

    WaveViewModel.prototype.__initBlipProcessor = function() {
      throw new Error('not implemented');
    };

    WaveViewModel.prototype._processRemoteOps = function(ops) {
      var op, root, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = ops.length; _i < _len; _i++) {
        op = ops[_i];
        root = op.p.shift();
        if (root === 'participants') {
          this.__view.applyParticipantOp(op);
          this.emit('participant-update');
        }
        if (root === 'sharedState' || root === 'defaultRole') {
          this.__view.updatePublicState();
          this.updateParticipants();
          _results.push(this.__view.updateInterfaceAccordingToRole());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    WaveViewModel.prototype._processUsersInfoUpdate = function(userIds) {
      /*
              Проксирует событие обновление пользователей от процессора в событие 'usersInfoUpdate'
      */      return this.emit('usersInfoUpdate', userIds);
    };

    WaveViewModel.prototype.__activateBlip = function(blip) {
      return this.__view.activateBlip(blip);
    };

    WaveViewModel.prototype.__activateNextUnreadBlip = function() {
      var activeBlip, index, startIndex, unreadBlip;
      activeBlip = this.__model.getActiveBlip();
      unreadBlip = null;
      if (activeBlip) {
        index = activeBlip.getCursorIndex();
        startIndex = index ? index + 1 : 0;
        unreadBlip = this._getNextUnreadBlip(activeBlip, startIndex);
      }
      if (!unreadBlip) {
        unreadBlip = this._getNextUnreadBlip(this.__view.getRootBlip(), 0);
      }
      if (!unreadBlip) return;
      return this.__activateBlip(unreadBlip);
    };

    WaveViewModel.prototype.__focusBlip = function(blip) {
      if (!blip) return;
      blip.focus();
      return this.__view.runCheckRange();
    };

    WaveViewModel.prototype.__emitActiveBlipIdChange = function(blip) {
      var blipId;
      blipId = blip.getNearestServerId();
      return this.emit(this.constructor.Events.ACTIVE_BLIP_CHANGE, blipId);
    };

    WaveViewModel.prototype.activateBlip = function(blipId) {
      var blip;
      blip = this._loadedBlips[blipId];
      if (blip) return this.__activateBlip(blip);
    };

    WaveViewModel.prototype.focusActiveBlip = function() {
      return this.__focusBlip(this.__model.getActiveBlip());
    };

    WaveViewModel.prototype.goToNextUnreadBlip = function() {
      return this.__activateNextUnreadBlip();
    };

    WaveViewModel.prototype.getUser = function(userId, force) {
      if (force == null) force = false;
      /*
              Возвращает модель пользователя
              @param userId: string, идентификатор пользователя
              @returns: User
      */
      return this.getUsers([userId], force)[0];
    };

    WaveViewModel.prototype.getUsers = function(userIds, force) {
      if (force == null) force = false;
      /*
              Возвращает массив моделей пользователя
              @param userIds: [string], массив идентификаторов пользователей
              @returns: [User]
      */
      return this._userProcessor.getUsers(userIds, this._model.serverId, force);
    };

    WaveViewModel.prototype.getParticipants = function() {
      /*
              Возвращает пользователей волны
              @return: [User]
      */      return this.getUsers(this.__view.getParticipantIds());
    };

    WaveViewModel.prototype.updateParticipants = function() {
      return this.getUsers(this.__view.getParticipantIds(), true);
    };

    WaveViewModel.prototype.getParticipantByEmail = function(email) {
      /*
              Возвращает пользователя волны по его email.
              @param email: string
              @return: User|null
      */
      var p, participants, _i, _len;
      participants = this.getParticipants();
      email = email.toLowerCase();
      for (_i = 0, _len = participants.length; _i < _len; _i++) {
        p = participants[_i];
        if (p.getEmail().toLowerCase() === email) return p;
      }
      return null;
    };

    WaveViewModel.prototype.updateUserInfo = function(user) {
      return this._userProcessor.addOrUpdateUsersInfo([user]);
    };

    WaveViewModel.prototype.getView = function() {
      return this.__view;
    };

    WaveViewModel.prototype.getModel = function() {
      /*
              Возвращает модель блипа
              @return WaveModel
      */      return this._model;
    };

    WaveViewModel.prototype.getId = function() {
      return this._model.id;
    };

    WaveViewModel.prototype.getServerId = function() {
      return this._model.serverId;
    };

    WaveViewModel.prototype.getRootBlipId = function() {
      return this.__model.getRootBlipId();
    };

    WaveViewModel.prototype.showGrantAccessForm = function(user, add) {
      return this.__view.showGrantAccessForm(this.getTitle(), user, this._model.getDefaultRole(), add);
    };

    WaveViewModel.prototype.enableEditing = function() {
      var _ref2;
      this.__model.setEditable(true);
      return (_ref2 = this.__model.getActiveBlip()) != null ? _ref2.setEditable(true) : void 0;
    };

    WaveViewModel.prototype.hasLoadedBlip = function(blipId) {
      return blipId in this._loadedBlips;
    };

    WaveViewModel.prototype.destroy = function() {
      var blipId;
      this._state = STATE_CLOSING;
      if (this._subscriptionCallId) {
        this._processor.closeWave(this._model.serverId, this._subscriptionCallId, this._model.id);
      }
      this._userProcessor.removeListener('update', this._processUsersInfoUpdate);
      this.removeListeners('usersInfoUpdate');
      this.removeListeners('waveLoaded');
      this.removeAllListeners();
      if (this.__view.rootBlip) this.__view.rootBlip.destroy();
      delete this._unreadBlips;
      delete this._loadedBlips;
      delete this._requestedBlips;
      for (blipId in this._loadBlipsCallbacks) {
        delete this._loadBlipsCallbacks[blipId];
      }
      delete this._loadBlipsCallbacks;
      delete this._childBlips;
      try {
        this.__view.destroy();
      } catch (e) {
        console.warn('WaveView closed with error');
        console.warn(e.stack);
      }
      delete this.__view;
      this._model.destroy();
      delete this._model;
      delete this.__model;
      this._waveData.removeListener('remoteop', this._processRemoteOps);
      delete this._waveData;
      return this.__deinitLocalStorage();
    };

    WaveViewModel.prototype.__deinitLocalStorage = function() {};

    WaveViewModel.prototype._getChildBlipByServerId = function(id) {
      var blip, blipId, _ref2;
      _ref2 = this._childBlips;
      for (blipId in _ref2) {
        blip = _ref2[blipId];
        if (blip.getModel().serverId === id) return blip;
      }
    };

    WaveViewModel.prototype.setBlipAsRead = function(serverBlipId) {
      if (!this._unreadBlips.hasOwnProperty(serverBlipId)) return;
      delete this._unreadBlips[serverBlipId];
      this._unreadBlipsCount -= 1;
      return this.__updateUnreadBlipsCount();
    };

    WaveViewModel.prototype._needCheckPublicFollow = function() {
      /*
              Возвращает true, если в топике нужно следить за прочитанными блипами для автоматического добавления в него
      */      if (!window.loggedIn) return false;
      if (this._hasAddedSelf) return false;
      if (this._model.getSharedState() !== WAVE_SHARED_STATE_PUBLIC) return false;
      if (!this._userWasAdded) {
        this._userWasAdded = this._model.getRole(window.userInfo.id, false) != null;
      }
      if (this._userWasAdded) return false;
      return true;
    };

    WaveViewModel.prototype.checkBlipSetAsRead = function(serverBlipId) {
      /*
              Если пользовтель прочитает в публичном топике определенное количество блипов, то добавится в участники
      */      if (serverBlipId === this.__model.getRootBlipId()) return;
      if (!this._needCheckPublicFollow()) return;
      this._blipsSetAsReadCount++;
      this._blipsSetAsRead[serverBlipId] = true;
      if (this._blipsSetAsReadCount >= MIN_BLIP_COUNT_SET_READ_TO_FOLLOW) {
        return this._followPublicTopic();
      }
    };

    WaveViewModel.prototype._followPublicTopic = function() {
      this._hasAddedSelf = true;
      return this._processor.addParticipant(this._model.serverId, window.userInfo.email, this._model.getDefaultRole(), function(err) {
        if (err) return;
        return _gaq.push(['_trackEvent', 'Topic content', 'Follow topic', 'Make followed public auto']);
      });
    };

    WaveViewModel.prototype.setBlipAsUnread = function(serverBlipId) {
      if (this._unreadBlips.hasOwnProperty(serverBlipId)) return;
      this._unreadBlips[serverBlipId] = '';
      this._unreadBlipsCount += 1;
      return this.__updateUnreadBlipsCount();
    };

    WaveViewModel.prototype.getUnreadBlipsCount = function() {
      return this._unreadBlipsCount;
    };

    WaveViewModel.prototype.__updateUnreadBlipsCount = function() {
      /*
              Устанавливает количество непрочитанных сообщений
              @param count: int
      */      if (this._state !== STATE_LOADED) return;
      return this.emit('unread-blips-count', this._unreadBlipsCount);
    };

    WaveViewModel.prototype.setBlipAsLoaded = function(blip) {
      /*
              Помечает блип загруженным, вызывает зарегистрированные обработчики
              @param blip: BlipViewModel
      */
      var blipId, callback, _i, _len, _ref2;
      blipId = blip.getModel().serverId;
      if (blipId in this._loadedBlips) return;
      this._loadedBlips[blipId] = blip;
      this._subscribeBlip(blip);
      this._totalBlipsCount += 1;
      this.__updateTotalBlipsCount();
      this._unloadBlipsCount -= 1;
      if (this._unloadBlipsCount < 1) {
        if (this._state === STATE_LOADING) {
          this._state = STATE_LOADED;
          this.emit('waveLoaded');
          this._subscribe();
          this.blipCache = {};
          this.__initLoadedWave();
        }
        this.__updateUnreadBlipsCount();
        this.removeListeners('waveLoaded');
      }
      if (!(blipId in this._loadBlipsCallbacks)) return;
      _ref2 = this._loadBlipsCallbacks[blipId];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        callback = _ref2[_i];
        callback(blip);
      }
      return delete this._loadBlipsCallbacks[blipId];
    };

    WaveViewModel.prototype._subscribeBlip = function(blip) {
      if (this._state === STATE_LOADED) {
        return this.__blipProcessor.subscribeBlip(blip.getModel(), this._subscriptionCallId);
      }
    };

    WaveViewModel.prototype.__initLoadedWave = function() {};

    WaveViewModel.prototype.__updateTotalBlipsCount = function() {
      /*
              Оповещает все компоненты об изменившемся количестве блипов в топике
              @param count: int
      */
    };

    WaveViewModel.prototype.getTotalUsableBlipsCount = function() {
      return this._totalBlipsCount - 1;
    };

    WaveViewModel.prototype._subscribe = function() {
      /*
              Подписывается на изменения этой волны
      */      return this._subscriptionCallId = this._processor.subscribeForWaveData(this);
    };

    WaveViewModel.prototype.getWaveAndBlipsVersions = function() {
      /*
              Возвращает объект с версиями волны и блипов, необходимые для подписки
              @return: object {wave: {id, version}, blips: {blipId: blipVersion}}
      */
      var blip, blipId, model, versions, _ref2;
      versions = {
        wave: {
          id: this._model.serverId,
          version: this._model.getVersion()
        },
        blips: {}
      };
      _ref2 = this._loadedBlips;
      for (blipId in _ref2) {
        blip = _ref2[blipId];
        model = blip.getModel();
        if (!(model.serverId != null)) continue;
        versions.blips[model.serverId] = model.getVersion();
      }
      return versions;
    };

    WaveViewModel.prototype.setBlipAsRemoved = function(serverBlipId) {
      /*
              Помечает блип удаленным
              @param serverBlipId: string
      */      if (!(serverBlipId in this._requestedBlips)) {
        return console.warn("Blip " + serverBlipId + " set as removed but it was not requested");
      }
      delete this._requestedBlips[serverBlipId];
      delete this._loadedBlips[serverBlipId];
      this._totalBlipsCount -= 1;
      this.setBlipAsRead(serverBlipId);
      return this.__updateTotalBlipsCount();
    };

    WaveViewModel.prototype.setBlipAsRequested = function(serverBlipId) {
      this._unloadBlipsCount += 1;
      return this._requestedBlips[serverBlipId] = true;
    };

    WaveViewModel.prototype.addChildBlip = function(blip) {
      var blipId,
        _this = this;
      blipId = blip.getModel().id;
      if (!(blip.getModel().serverId != null)) {
        blip.on('set-server-id', function() {
          if (_this.__model.getActiveBlip() === blip) {
            return _this.__emitActiveBlipIdChange(blip);
          }
        });
      }
      blip.on('remote-ops', function() {
        var _ref2;
        return (_ref2 = _this.__view) != null ? typeof _ref2.updateRangePos === "function" ? _ref2.updateRangePos() : void 0 : void 0;
      });
      blip.on(BlipViewModel.Events.DESTROYED, function(blip) {
        return _this.emit(_this.constructor.Events.BLIP_DESTROYED, blip);
      });
      return this._childBlips[blipId] = blip;
    };

    WaveViewModel.prototype._removeChildBlip = function(blipViewModel) {
      var blipId, serverId;
      serverId = blipViewModel.getServerId();
      if (serverId) this.setBlipAsRead(serverId);
      blipId = blipViewModel.getModel().id;
      return delete this._childBlips[blipId];
    };

    WaveViewModel.prototype.isBlipRequested = function(serverBlipId) {
      return serverBlipId in this._requestedBlips;
    };

    WaveViewModel.prototype.onBlipLoaded = function(serverBlipId, callback) {
      /*
              Вызовет callback, когда будет загружен блип с серверным id serverBlipId
              Если этот блип уже загружен, вызовет callback сразу
                  callback(BlipViewModel)
              @param serverBlipId: string
              @param callback: function
      */      if (serverBlipId in this._loadedBlips) {
        callback(this._loadedBlips[serverBlipId]);
        return;
      }
      if (!(serverBlipId in this._loadBlipsCallbacks)) {
        this._loadBlipsCallbacks[serverBlipId] = [];
      }
      return this._loadBlipsCallbacks[serverBlipId].push(callback);
    };

    WaveViewModel.prototype.getLoadedBlip = function(blipId) {
      if (blipId in this._loadedBlips) return this._loadedBlips[blipId];
    };

    WaveViewModel.prototype.getTitle = function() {
      var _ref2, _ref3, _ref4;
      return ((_ref2 = this._loadedBlips[(_ref3 = this.getModel()) != null ? _ref3.getRootBlipId() : void 0]) != null ? (_ref4 = _ref2.getModel()) != null ? _ref4.title : void 0 : void 0) || '';
    };

    WaveViewModel.prototype.getRole = function() {
      /*
              Возвращает роль текущего залогиненного участника
      */
      var role;
      if (window.testAsOwner) return ROLE_OWNER;
      if (!(window.userInfo != null)) return ROLE_NO_ROLE;
      role = this._model.getRole(window.userInfo.id);
      if (role === ROLE_NO_ROLE && this._model.getSharedState() === WAVE_SHARED_STATE_PUBLIC) {
        role = this._model.getDefaultRole();
      }
      return role;
    };

    WaveViewModel.prototype.isLoaded = function() {
      return this._state !== STATE_LOADING;
    };

    WaveViewModel.prototype.haveEmails = function() {
      var _ref2;
      return ((_ref2 = this.getRole()) === ROLE_OWNER || _ref2 === ROLE_EDITOR) || this._model.getSharedState() !== WAVE_SHARED_STATE_PUBLIC;
    };

    WaveViewModel.prototype._readAllBlips = function() {
      var _this = this;
      return this._processor.updateReaderForAllBlips(this._model.serverId, function(err) {
        var rootBlip;
        if (err) return _this.showWarning(err.message);
        rootBlip = _this.__view.getRootBlip();
        rootBlip.markAsReadRecursively();
        if (_this._needCheckPublicFollow()) return _this._followPublicTopic();
      });
    };

    WaveViewModel.prototype.showWarning = function(message) {
      return this._parent.showWaveWarning(message);
    };

    WaveViewModel.prototype.showError = function(err) {
      return this._parent.showWaveError(err);
    };

    WaveViewModel.prototype.getBlipByServerId = function(id) {
      return this._loadedBlips[id];
    };

    return WaveViewModel;

  })();

  MicroEvent.mixin(WaveViewModel);

  exports.WaveViewModelBase = WaveViewModel;

  exports.STATE_LOADING = STATE_LOADING;

  exports.STATE_LOADED = STATE_LOADED;

  exports.STATE_CLOSING = STATE_CLOSING;

}).call(this);

});

require.define("/lib/client/client/wave/view_base.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var MicroEvent, WaveView;

  MicroEvent = require('../utils/microevent');

  WaveView = (function() {

    function WaveView() {}

    WaveView.Events = {
      READ_ALL: 'readAll'
    };

    WaveView.prototype.__activateBlip = function(blip) {
      return this.markActiveBlip(blip.getView());
    };

    WaveView.prototype.markActiveBlip = function() {};

    WaveView.prototype.__scrollToBlipContainer = function(blipContainer) {};

    WaveView.prototype.activateBlip = function(blip) {
      blip.unfoldToRoot();
      this.__activateBlip(blip);
      return this.__scrollToBlipContainer(blip.getContainer());
    };

    WaveView.prototype.showGrantAccessForm = function(title, user, role, add) {
      var wnd;
      wnd = new (require('./grant_access_window'));
      return wnd.open(title, user, role, add);
    };

    WaveView.prototype.destroy = function() {
      return this.removeAllListeners();
    };

    return WaveView;

  })();

  MicroEvent.mixin(WaveView);

  module.exports = WaveView;

}).call(this);

});

require.define("/lib/client/client/wave/grant_access_window.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var GrantAccessWindow, ModalWindow, ROLES, ROLE_OWNER, render, tmpl, _ref,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  ModalWindow = require('../widget/window/modal_window').ModalWindow;

  _ref = require('./participants/constants'), ROLES = _ref.ROLES, ROLE_OWNER = _ref.ROLE_OWNER;

  tmpl = function() {
    return div('grant-access-wnd', function() {
      div(function() {
        span("Add ");
        span('user', "" + (h(this.user)));
        span(" as ");
        select(function() {
          var attr, role, _i, _len, _ref2, _results;
          _ref2 = this.ROLES;
          _results = [];
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            role = _ref2[_i];
            if (!(role.id !== this.ROLE_OWNER)) continue;
            attr = {
              value: role.id
            };
            if (role.id === this.role) attr.selected = true;
            _results.push(option(attr, role.name.toLowerCase()));
          }
          return _results;
        });
        if (this.title) return span(" to topic:");
      });
      div('title', "" + (h(this.title || '')));
      return div('button-block', function() {
        button('js-add button', 'Add');
        return button('js-cancel button', 'Cancel');
      });
    });
  };

  render = window.CoffeeKup.compile(tmpl);

  GrantAccessWindow = (function(_super) {

    __extends(GrantAccessWindow, _super);

    function GrantAccessWindow() {
      var params;
      params = {
        title: 'Grand access',
        closeButton: true,
        closeOnOutsideAction: true
      };
      GrantAccessWindow.__super__.constructor.call(this, params);
    }

    GrantAccessWindow.prototype.open = function(title, user, role, add) {
      var $body, params,
        _this = this;
      params = {
        user: user,
        title: title,
        role: role,
        ROLES: ROLES,
        ROLE_OWNER: ROLE_OWNER
      };
      this.setContent(render(params));
      $body = $(this.getBodyEl());
      $body.find('.js-cancel').on('click', function() {
        return _this.destroy();
      });
      $body.find('.js-add').on('click', function() {
        add($body.find('select').val(), function() {});
        return _this.destroy();
      });
      return GrantAccessWindow.__super__.open.call(this);
    };

    return GrantAccessWindow;

  })(ModalWindow);

  module.exports = GrantAccessWindow;

}).call(this);

});

require.define("/lib/client/client/editor/gadget/gadget_link_editor.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var CenteredWindow, DomUtils, GadgetLinkEditor, KeyCodes, ck, gadgetLinkEditorTmpl, renderLinkEditor,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  ck = window.CoffeeKup;

  gadgetLinkEditorTmpl = function() {
    return div('.link-editor-body', function() {
      div({
        style: 'font-size: 14px;'
      }, 'Insert link');
      return table('.link-editor-content', function() {
        tr('.link-url', function() {
          td('', 'URL');
          return td('', function() {
            return label(function() {
              return input('.js-link-editor-url-input .text-input', {
                type: 'text'
              });
            });
          });
        });
        return tr('', function() {
          td('', '');
          return td('', function() {
            return button('.js-link-editor-update-btn.button', {
              title: 'Accept changes'
            }, 'Submit');
          });
        });
      });
    });
  };

  renderLinkEditor = ck.compile(gadgetLinkEditorTmpl);

  DomUtils = require('../../utils/dom');

  CenteredWindow = require('../../widget/window/centered_window').CenteredWindow;

  KeyCodes = require('../../utils/key_codes').KeyCodes;

  GadgetLinkEditor = (function(_super) {

    __extends(GadgetLinkEditor, _super);

    function GadgetLinkEditor() {
      this._inputKeyPressHandler = __bind(this._inputKeyPressHandler, this);
      this._update = __bind(this._update, this);
      var params;
      params = {
        title: 'Insert gadget',
        closeButton: true,
        closeOnOutsideAction: true,
        closeOnEsc: true
      };
      GadgetLinkEditor.__super__.constructor.call(this, params);
    }

    GadgetLinkEditor.prototype.__createDom = function(params) {
      var $c, tmp;
      GadgetLinkEditor.__super__.__createDom.call(this, params);
      tmp = document.createElement('span');
      $(tmp).append(renderLinkEditor());
      this._body.appendChild(tmp.firstChild);
      $c = $(this._body);
      this._$urlInput = $c.find('.js-link-editor-url-input').on('keypress', this._inputKeyPressHandler);
      return $c.find('.js-link-editor-update-btn').bind('click', this._update);
    };

    GadgetLinkEditor.get = function() {
      var _ref;
      return (_ref = this.instance) != null ? _ref : this.instance = new this;
    };

    GadgetLinkEditor.prototype._normalizeLink = function(link) {
      if (!/^[a-zA-Z0-9\-]+:/.test(link)) return 'http://' + link;
      return link;
    };

    GadgetLinkEditor.prototype._clear = function() {
      return this._$urlInput.val('');
    };

    GadgetLinkEditor.prototype._update = function() {
      /*
              Обработчик нажатия кнопки Update
      */
      var url;
      url = this._$urlInput.val();
      url = this._normalizeLink(url);
      this._editor.insertGadget(url);
      return this.close();
    };

    GadgetLinkEditor.prototype._inputKeyPressHandler = function(event) {
      /*
              Обработчик клавиатурных событий keypress
              @param node: Event | KeyEvent
      */      if (event.keyCode === KeyCodes.KEY_ENTER) {
        this._update();
        event.preventDefault();
        return event.stopPropagation();
      }
    };

    GadgetLinkEditor.prototype.close = function() {
      GadgetLinkEditor.__super__.close.call(this);
      if (this._editor) {
        this._editor.resumeSetRange(true, true);
        return delete this._editor;
      }
    };

    GadgetLinkEditor.prototype.open = function(_editor) {
      var range;
      this._editor = _editor;
      /*
              Показывает окно редактирования url
              @param editor: Editor, объект, в котором редактируется ссылка
              @param range: DOM range, выделенный фрагмент
      */
      this._clear();
      range = this._editor.getRange();
      if (!range) {
        delete this._editor;
        return;
      }
      GadgetLinkEditor.__super__.open.call(this);
      this._editor.pauseSetRange(true);
      return this._$urlInput.select();
    };

    return GadgetLinkEditor;

  })(CenteredWindow);

  exports.get = function() {
    return GadgetLinkEditor.get();
  };

}).call(this);

});

require.define("/lib/client/client/blip/contributors/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var Contributors, ParticipantPopup, ROLE_NO_ROLE, UserPopup, canEditParticipant, canRemoveParticipant, renderContributor, renderContributorsContainer, setUserPopupBehaviour, _ref, _ref2,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = Array.prototype.slice;

  renderContributorsContainer = require('./template').renderContributorsContainer;

  renderContributor = require('./template').renderContributor;

  _ref = require('../../wave/participants'), ParticipantPopup = _ref.ParticipantPopup, canEditParticipant = _ref.canEditParticipant, canRemoveParticipant = _ref.canRemoveParticipant;

  _ref2 = require('../../popup/user_popup'), setUserPopupBehaviour = _ref2.setUserPopupBehaviour, UserPopup = _ref2.UserPopup;

  ROLE_NO_ROLE = require('../../wave/participants/constants').ROLE_NO_ROLE;

  Contributors = (function() {

    function Contributors() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._processResponse = __bind(this._processResponse, this);
      this._changeParticipantRole = __bind(this._changeParticipantRole, this);
      this._removeParticipant = __bind(this._removeParticipant, this);
      this._canRemoveParticipant = __bind(this._canRemoveParticipant, this);
      this._canEditParticipant = __bind(this._canEditParticipant, this);
      this._updateContributorsInfo = __bind(this._updateContributorsInfo, this);
      this._hideBlipContributors = __bind(this._hideBlipContributors, this);
      this._processParticiapntsChange = __bind(this._processParticiapntsChange, this);
      this._init.apply(this, args);
    }

    Contributors.prototype._init = function(_waveViewModel, contributors, _author) {
      var contributor, _i, _len;
      this._waveViewModel = _waveViewModel;
      this._author = _author;
      this._contributors = [];
      for (_i = 0, _len = contributors.length; _i < _len; _i++) {
        contributor = contributors[_i];
        this._contributors.push(contributor.id);
      }
      this._waveProcessor = require('../../wave/processor').instance;
      this._createDom();
      this._initContributors();
      this._waveViewModel.on('participant-update', this._processParticiapntsChange);
      this._waveViewModel.on('usersInfoUpdate', this._updateContributorsInfo);
      return this._bindAuthorPopup();
    };

    Contributors.prototype._processParticiapntsChange = function() {
      return this._updateContributorsInfo(this._contributors);
    };

    Contributors.prototype._createDom = function() {
      var $container;
      this._container = document.createElement('span');
      $container = $(this._container);
      $container.append(renderContributorsContainer());
      return this._contributorsContainer = $container.find('.js-contributors-container')[0];
    };

    Contributors.prototype._initContributors = function() {
      var $container, contributorId, index, user, users, _ref3, _results;
      $container = $(this._contributorsContainer);
      users = this._waveViewModel.getUsers(this._contributors);
      _ref3 = this._contributors;
      _results = [];
      for (index in _ref3) {
        contributorId = _ref3[index];
        _results.push((function() {
          var _i, _len, _results2;
          _results2 = [];
          for (_i = 0, _len = users.length; _i < _len; _i++) {
            user = users[_i];
            if (user.getId() !== contributorId) continue;
            this._insertContributor(index, user);
            break;
          }
          return _results2;
        }).call(this));
      }
      return _results;
    };

    Contributors.prototype._insertContributor = function(index, user) {
      var $container, $insertedNode, $node;
      if (this._contributorsContainer.childNodes.length <= index) {
        $container = $(this._contributorsContainer);
        $container.append(renderContributor(user.toObject()));
        $insertedNode = $container.children().last();
      } else {
        $node = $(this._contributorsContainer.childNodes[index]);
        $node.before(renderContributor(user.toObject()));
        $insertedNode = $node.prev();
      }
      this._setContributorParams($insertedNode, user);
      if (this._contributorsContainer.childNodes.length === 2) {
        return this._bindContributorsContainer(user.getId());
      }
    };

    Contributors.prototype._bindAuthorPopup = function() {
      if (this._contributors.length > 1) return;
      return this._setContributorParams($(this._author.getAvatarContainer()), this._waveViewModel.getUser(this._contributors[0]));
    };

    Contributors.prototype._bindContributorsContainer = function(addUserId) {
      var _this = this;
      if (addUserId == null) addUserId = null;
      if (addUserId) this._author.setIndicator(addUserId);
      $(this._author.getAvatarContainer()).bind('click', function() {
        $('.js-contributors-container:visible').hide();
        $(_this._contributorsContainer).show();
        $(window).bind('click', _this._hideBlipContributors);
        return false;
      });
      return $(this._author.getAvatarContainer()).bind('mousedown', function() {
        return false;
      });
    };

    Contributors.prototype._hideBlipContributors = function(event) {
      if ($(this._contributorsContainer).is(':visible') && !$.contains(this._contributorsContainer, event.target) && this._contributorsContainer !== event.target) {
        $(this._contributorsContainer).hide();
        $(window).unbind('click', this._hideBlipContributors);
      }
      return false;
    };

    Contributors.prototype._updateContributorsInfo = function(userIds) {
      var $insertedNode, $node, id, node, user, _i, _j, _len, _len2, _ref3;
      this._author.updateAuthorInfo(userIds);
      for (_i = 0, _len = userIds.length; _i < _len; _i++) {
        id = userIds[_i];
        _ref3 = this._contributorsContainer.childNodes;
        for (_j = 0, _len2 = _ref3.length; _j < _len2; _j++) {
          node = _ref3[_j];
          $node = $(node);
          if ($node.data('contributorId') !== id) continue;
          user = this._waveViewModel.getUser(id);
          $node.after(renderContributor(user.toObject()));
          $insertedNode = $node.next();
          this._setContributorParams($insertedNode, user);
          $node.remove();
          break;
        }
      }
      if (this._contributorsContainer.childNodes.length > 1) {
        return this._bindContributorsContainer();
      } else {
        return this._bindAuthorPopup();
      }
    };

    Contributors.prototype._canEditParticipant = function(userId) {
      return canEditParticipant(this._waveViewModel, userId);
    };

    Contributors.prototype._canRemoveParticipant = function(userId) {
      return canRemoveParticipant(this._waveViewModel, userId);
    };

    Contributors.prototype._setContributorParams = function($node, user) {
      var canEdit, canRemove, getRole, role, userId,
        _this = this;
      userId = user.getId();
      $node.data('contributorId', userId);
      role = this._waveViewModel.getModel().getRole(userId);
      if (role === ROLE_NO_ROLE) {
        return setUserPopupBehaviour($node, UserPopup, user);
      } else {
        canEdit = function() {
          return _this._canEditParticipant(userId);
        };
        canRemove = function() {
          return _this._canRemoveParticipant(userId);
        };
        getRole = function() {
          return _this._waveViewModel.getModel().getRole(userId);
        };
        return setUserPopupBehaviour($node, ParticipantPopup, user, canEdit, canRemove, getRole, this._changeParticipantRole, this._removeParticipant);
      }
    };

    Contributors.prototype._removeParticipant = function(userId) {
      return this._waveProcessor.removeParticipant(this._waveViewModel.getServerId(), userId, this._processResponse);
    };

    Contributors.prototype._changeParticipantRole = function(userId, roleId) {
      return this._waveProcessor.changeParticipantRole(this._waveViewModel.getServerId(), userId, roleId, this._processResponse);
    };

    Contributors.prototype._processResponse = function(err) {
      if (err) return this._waveProcessor.showPageError(err);
    };

    Contributors.prototype._add = function(contributor, index) {
      var user;
      this._contributors.splice(index, 0, contributor.id);
      user = this._waveViewModel.getUser(contributor.id);
      return this._insertContributor(index, user);
    };

    Contributors.prototype._remove = function(contributor, index) {
      this._contributors.splice(index, 1);
      return $(this._contributorsContainer.childNodes[index]).remove();
    };

    Contributors.prototype.getContainer = function() {
      return this._container;
    };

    Contributors.prototype.applyOp = function(op) {
      if (op.ld) this._remove(op.ld, op.p.shift());
      if (op.li) return this._add(op.li, op.p.shift());
    };

    Contributors.prototype.destroy = function() {
      delete this._author;
      this._waveViewModel.removeListener('participant-update', this._processParticiapntsChange);
      this._waveViewModel.removeListener('usersInfoUpdate', this._updateContributorsInfo);
      return delete this._waveViewModel;
    };

    return Contributors;

  })();

  exports.Contributors = Contributors;

}).call(this);

});

require.define("/lib/client/client/blip/contributors/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var authorTmpl, ck, contributorTmpl, contributorsContainerTmpl;

  ck = window.CoffeeKup;

  contributorTmpl = function() {
    return span('.contributor.avatar', {
      style: "background-image: url(" + (h(this.avatar)) + ")"
    }, h(this.initials));
  };

  contributorsContainerTmpl = function() {
    return div('.js-contributors-container.contributors', '');
  };

  authorTmpl = function() {
    if (this.users[1]) {
      div('.shown-contributor.back-contributor.avatar', {
        style: "background-image: url(" + (h(this.users[1].avatar)) + ")"
      }, h(this.users[1].initials));
    }
    return div('.shown-contributor.js-shown-contributor-avatar.avatar', {
      style: "background-image: url(" + (h(this.users[0].avatar)) + ")"
    }, h(this.users[0].initials));
  };

  exports.renderContributor = ck.compile(contributorTmpl);

  exports.renderContributorsContainer = ck.compile(contributorsContainerTmpl);

  exports.renderAuthor = ck.compile(authorTmpl);

}).call(this);

});

require.define("/lib/client/client/wave/participants/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ManageParticipantsForm, ManageParticipantsPopup, ParticipantPopup, Participants, ROLES, ROLE_EDITOR, ROLE_NO_ROLE, ROLE_OWNER, UserPopup, canEditParticipant, canRemoveParticipant, normalizeEmail, popup, renderBottomPopup, renderParticipant, renderParticipantsContainer, setUserPopupBehaviour, _ref, _ref2, _ref3,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = Array.prototype.slice;

  _ref = require('./template'), renderParticipantsContainer = _ref.renderParticipantsContainer, renderParticipant = _ref.renderParticipant, renderBottomPopup = _ref.renderBottomPopup;

  popup = require('../../popup').popup;

  setUserPopupBehaviour = require('../../popup/user_popup').setUserPopupBehaviour;

  UserPopup = require('../../popup/user_popup').UserPopup;

  _ref2 = require('./manage_participants'), ManageParticipantsForm = _ref2.ManageParticipantsForm, ManageParticipantsPopup = _ref2.ManageParticipantsPopup;

  normalizeEmail = require('../../utils/string').normalizeEmail;

  _ref3 = require('./constants'), ROLES = _ref3.ROLES, ROLE_OWNER = _ref3.ROLE_OWNER, ROLE_EDITOR = _ref3.ROLE_EDITOR, ROLE_NO_ROLE = _ref3.ROLE_NO_ROLE;

  canEditParticipant = function(waveViewModel, userId) {
    var _ref4, _ref5;
    return ((_ref4 = waveViewModel.getRole()) === ROLE_OWNER || _ref4 === ROLE_EDITOR) && (userId !== ((_ref5 = window.userInfo) != null ? _ref5.id : void 0)) && waveViewModel.getModel().getRole(userId) !== ROLE_OWNER;
  };

  canRemoveParticipant = function(waveViewModel, userId) {
    var _ref4, _ref5;
    if (userId === ((_ref4 = window.userInfo) != null ? _ref4.id : void 0)) {
      return true;
    }
    if (waveViewModel.getModel().getRole(userId) === ROLE_OWNER) return false;
    return (_ref5 = waveViewModel.getRole()) === ROLE_OWNER || _ref5 === ROLE_EDITOR;
  };

  ParticipantPopup = (function(_super) {

    __extends(ParticipantPopup, _super);

    function ParticipantPopup() {
      ParticipantPopup.__super__.constructor.apply(this, arguments);
    }

    ParticipantPopup.prototype._init = function(user, _canEdit, _canRemove, _getRole, _changeParticipantRole, _removeParticipant) {
      this._canEdit = _canEdit;
      this._canRemove = _canRemove;
      this._getRole = _getRole;
      this._changeParticipantRole = _changeParticipantRole;
      this._removeParticipant = _removeParticipant;
      return ParticipantPopup.__super__._init.call(this, user);
    };

    ParticipantPopup.prototype.bottomBlockRender = function() {
      /*
              Рендерим блок с ссылкой на удаление
      */
      var $c, bottomBlock, delLink, params,
        _this = this;
      $c = $(this.getContainer());
      bottomBlock = $c.find('.js-user-popup-menu-remove-block');
      params = {
        user: this._user,
        roleId: this._getRole(),
        roles: ROLES,
        skipRole: ROLE_OWNER,
        canRemove: this._canRemove()
      };
      bottomBlock.append(renderBottomPopup(params));
      delLink = $c.find('.js-delete-from-wave');
      delLink.bind('click', function(event) {
        if (window.confirm("Delete user from this topic: " + (_this._user.getName()) + "?")) {
          _this._removeParticipant(_this._user.getId());
          return popup.hide();
        }
      });
      this._roleSelect = $c.find('.js-role-select')[0];
      $(this._roleSelect).selectBox().change(function() {
        return _this._changeParticipantRole(_this._user.getId(), $(_this._roleSelect).val() - 0);
      });
      if (!this._canEdit()) return $(this._roleSelect).selectBox('disable');
    };

    ParticipantPopup.prototype.shouldCloseWhenClicked = function(element) {
      return $(element).closest('.role-select-selectBox-dropdown-menu').length === 0;
    };

    ParticipantPopup.prototype.destroy = function() {
      $(this._roleSelect).selectBox('destroy');
      delete this._removeParticipant;
      return ParticipantPopup.__super__.destroy.call(this);
    };

    return ParticipantPopup;

  })(UserPopup);

  Participants = (function() {
    var LOAD_PARTICIPANTS_COUNT, MAX_SHOWED_PARTICIPANTS;

    LOAD_PARTICIPANTS_COUNT = 20;

    MAX_SHOWED_PARTICIPANTS = 5;

    function Participants() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._processResponse = __bind(this._processResponse, this);
      this._createWaveWithParticipants = __bind(this._createWaveWithParticipants, this);
      this._changeParticipantRole = __bind(this._changeParticipantRole, this);
      this._removeParticipants = __bind(this._removeParticipants, this);
      this._removeParticipant = __bind(this._removeParticipant, this);
      this._updateParticipantsInfo = __bind(this._updateParticipantsInfo, this);
      this._canRemoveParticipant = __bind(this._canRemoveParticipant, this);
      this._canEditParticipant = __bind(this._canEditParticipant, this);
      this._init.apply(this, args);
    }

    Participants.prototype._init = function(_waveViewModel, _processor, _modelId, _participants, _allowRemove, gDriveShareUrl) {
      this._waveViewModel = _waveViewModel;
      this._processor = _processor;
      this._modelId = _modelId;
      this._participants = _participants;
      this._allowRemove = _allowRemove;
      this._createDom(gDriveShareUrl);
      this._initParticipants();
      this._waveViewModel.on('usersInfoUpdate', this._updateParticipantsInfo);
      return this._hideCreateTopicForSelectedButton = false;
    };

    Participants.prototype._createDom = function(gDriveShareUrl) {
      var $container, getManageForm,
        _this = this;
      this._container = document.createElement('div');
      $container = $(this._container);
      $container.append(renderParticipantsContainer());
      this._participantsContainer = $container.find('.js-participant-container')[0];
      this._moreParticipantsButton = $(this._container).find('.js-show-more-participants');
      this._manageForm = null;
      this._roleSelect = $container.find('.js-participant-role-select');
      this._roleSelect.selectBox();
      getManageForm = function() {
        if (_this._manageForm == null) {
          _this._manageForm = new ManageParticipantsForm(_this._waveViewModel, _this._participants, _this._removeParticipants, _this._canRemoveParticipant, _this._createWaveWithParticipants, _this._changeParticipantRole, _this._canEditParticipant, _this._hideCreateTopicForSelectedButton, gDriveShareUrl);
        }
        return _this._manageForm;
      };
      return setUserPopupBehaviour(this._moreParticipantsButton, ManageParticipantsPopup, getManageForm);
    };

    Participants.prototype._getParticipantsIds = function(checkRole) {
      var participant, participantIds, _i, _len, _ref4;
      if (checkRole == null) checkRole = false;
      participantIds = [];
      _ref4 = this._participants;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        participant = _ref4[_i];
        if (checkRole && participant.role === ROLE_NO_ROLE) continue;
        participantIds.push(participant.id);
      }
      return participantIds;
    };

    Participants.prototype._initParticipants = function() {
      var i, index, participant, u, user, userIdsWithoutEmails, _i, _len, _ref4, _ref5;
      this._participants = JSON.parse(JSON.stringify(this._participants));
      this._users = this._waveViewModel.getUsers(this._getParticipantsIds(true));
      i = 0;
      _ref4 = this._participants;
      for (index in _ref4) {
        participant = _ref4[index];
        _ref5 = this._users;
        for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
          user = _ref5[_i];
          if (user.getId() !== participant.id) continue;
          if (participant.role !== ROLE_NO_ROLE) {
            this._insertParticipant(index, user, true);
          }
          if (participant.role !== ROLE_NO_ROLE) i += 1;
          participant.showed = true;
          break;
        }
        if (i === LOAD_PARTICIPANTS_COUNT) break;
      }
      if (!this._waveViewModel.haveEmails()) return;
      userIdsWithoutEmails = (function() {
        var _j, _len2, _ref6, _results;
        _ref6 = this._users;
        _results = [];
        for (_j = 0, _len2 = _ref6.length; _j < _len2; _j++) {
          u = _ref6[_j];
          if (!u.getEmail()) _results.push(u.getId());
        }
        return _results;
      }).call(this);
      if (!userIdsWithoutEmails.length) return;
      return this._waveViewModel.getUsers(userIdsWithoutEmails, true);
    };

    Participants.prototype._getNodeIndexByParticipantIndex = function(index) {
      /*
              Возвращает ближайший предшествующий индекс видимой ноды участника топика если он есть
              иначе возвращает -1
      */
      var i, id, node, prevShowedIndex, _i, _len, _ref4;
      i = index - 1;
      prevShowedIndex = null;
      while (i >= 0) {
        if ((this._participants[i].showed != null) && this._participants[i].showed) {
          prevShowedIndex = i;
          break;
        }
        i -= 1;
      }
      if (prevShowedIndex !== null) {
        id = this._participants[prevShowedIndex].id;
      } else {
        return -1;
      }
      _ref4 = this._participantsContainer.childNodes;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        node = _ref4[_i];
        if (id === $(node).data('participantId')) return $(node).index();
      }
    };

    Participants.prototype._insertParticipant = function(index, user, init) {
      var $container, $insertedNode, $node;
      if (init == null) init = false;
      $container = $(this._participantsContainer);
      if (init) {
        $container.append(renderParticipant(user.toObject()));
        $insertedNode = $container.children().last();
      } else {
        index = this._getNodeIndexByParticipantIndex(index);
        if (index !== -1) {
          $node = $($container.children()[index]);
          $node.after(renderParticipant(user.toObject()));
          $insertedNode = $node.next();
        } else {
          $container.prepend(renderParticipant(user.toObject()));
          $insertedNode = $container.children().first();
        }
      }
      $insertedNode.data('participantId', user.getId());
      return this._setParticipantHandlers($insertedNode);
    };

    Participants.prototype._getParticipantById = function(id) {
      var participant, _i, _len, _ref4;
      _ref4 = this._participants;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        participant = _ref4[_i];
        if (participant.id === id) return participant;
      }
    };

    Participants.prototype._removeNodes = function(fromIndex, toIndex) {
      var $nodes, i, participant, _results;
      $nodes = $(this._participantsContainer).children();
      i = fromIndex;
      _results = [];
      while (i <= toIndex) {
        participant = this._getParticipantById($($nodes[i]).data('participantId'));
        if (participant) delete participant['showed'];
        $($nodes[i]).remove();
        _results.push(i += 1);
      }
      return _results;
    };

    Participants.prototype._addNodes = function(countNodes) {
      var added, i, participant, user, _results;
      participant = this._getParticipantById($(this._participantsContainer).children().last().data('participantId'));
      i = this._participants.indexOf(participant) + 1;
      added = 0;
      _results = [];
      while (i < this._participants.length && added < countNodes) {
        if (this._participants[i].role !== ROLE_NO_ROLE) {
          user = this._waveViewModel.getUser(this._participants[i].id);
          this._insertParticipant(i, user, true);
          this._participants[i].showed = true;
          added += 1;
        }
        _results.push(i += 1);
      }
      return _results;
    };

    Participants.prototype.setParticipantsWidth = function(width) {
      var containerWidth, moreButtonWidth, participantNode, participantWidth, showedParticipants, visibleParticipants;
      this.width = width;
      moreButtonWidth = 38;
      $(this._participantsContainer).removeAttr('style');
      visibleParticipants = $(this._participantsContainer).find("span");
      participantNode = visibleParticipants[0];
      participantWidth = $(participantNode).outerWidth(true) || 34;
      containerWidth = this.width - moreButtonWidth;
      showedParticipants = (containerWidth - containerWidth % participantWidth) / participantWidth || 0;
      showedParticipants = Math.min(showedParticipants, MAX_SHOWED_PARTICIPANTS);
      if (visibleParticipants.length > showedParticipants) {
        this._removeNodes(showedParticipants, visibleParticipants.length - 1);
      } else if (visibleParticipants.length < showedParticipants) {
        this._addNodes(showedParticipants - visibleParticipants.length);
      }
      if (this._users.length <= showedParticipants) {
        this._moreParticipantsButton.removeClass('number-shown');
      } else {
        this._moreParticipantsButton.find('span').text("+" + (this._users.length - showedParticipants));
        this._moreParticipantsButton.addClass('number-shown');
      }
      return this._moreParticipantsButton.show();
    };

    Participants.prototype._setParticipantHandlers = function($participantNode) {
      var canEdit, canRemove, getRole, participant, role, user, _i, _len, _ref4,
        _this = this;
      user = this._waveViewModel.getUser($participantNode.data('participantId'));
      role = null;
      _ref4 = this._participants;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        participant = _ref4[_i];
        if (participant.id === user.getId()) role = participant.role;
      }
      getRole = function() {
        return role;
      };
      canRemove = function() {
        return _this._canRemoveParticipant(user.getId());
      };
      canEdit = function() {
        return _this._canEditParticipant(user.getId());
      };
      if (user.isLoaded()) {
        return setUserPopupBehaviour($participantNode, ParticipantPopup, user, canEdit, canRemove, getRole, this._changeParticipantRole, this._removeParticipant);
      }
    };

    Participants.prototype._canEditParticipant = function(userId) {
      return canEditParticipant(this._waveViewModel, userId);
    };

    Participants.prototype._canRemoveParticipant = function(userId) {
      return canRemoveParticipant(this._waveViewModel, userId);
    };

    Participants.prototype._updateNodeForParticipant = function(user) {
      var $insertedNode, $node, $nodes, node, _i, _len;
      $nodes = $(this._participantsContainer).children();
      for (_i = 0, _len = $nodes.length; _i < _len; _i++) {
        node = $nodes[_i];
        if ($(node).data('participantId') === user.getId()) {
          $node = $(node);
          $node.after(renderParticipant(user.toObject()));
          $insertedNode = $node.next();
          $insertedNode.data('participantId', user.getId());
          this._setParticipantHandlers($insertedNode);
          $node.remove();
          return;
        }
      }
    };

    Participants.prototype._updateParticipantsInfo = function(userIds) {
      var id, participant, user, users, _i, _j, _len, _len2, _ref4, _ref5;
      users = [];
      for (_i = 0, _len = userIds.length; _i < _len; _i++) {
        id = userIds[_i];
        _ref4 = this._participants;
        for (_j = 0, _len2 = _ref4.length; _j < _len2; _j++) {
          participant = _ref4[_j];
          if (participant.id !== id) continue;
          user = this._waveViewModel.getUser(id);
          if (user) users.push(user);
          if (participant.showed) this._updateNodeForParticipant(user);
          break;
        }
      }
      if (users.length) {
        return (_ref5 = this._manageForm) != null ? _ref5.updateParticipants(users) : void 0;
      }
    };

    Participants.prototype._add = function(participant, index) {
      var user, _ref4, _ref5;
      [].splice.apply(this._participants, [index, index - index].concat(_ref4 = [participant])), _ref4;
      this._participants[index].showed = participant.role !== ROLE_NO_ROLE;
      user = this._waveViewModel.getUser(participant.id);
      if (participant.role !== ROLE_NO_ROLE) this._insertParticipant(index, user);
      this._users = this._waveViewModel.getUsers(this._getParticipantsIds(true));
      this.setParticipantsWidth(this.width);
      return (_ref5 = this._manageForm) != null ? _ref5.addParticipant(participant) : void 0;
    };

    Participants.prototype._remove = function(participant, index) {
      var _ref4;
      $(this._participantsContainer.childNodes[this._getNodeIndexByParticipantIndex(index) + 1]).remove();
      if (!(popup.getContent() instanceof ManageParticipantsPopup)) popup.hide();
      if (this._manageForm != null) {
        this._manageForm.removeParticipant(participant);
      }
      [].splice.apply(this._participants, [index, index - index + 1].concat(_ref4 = [])), _ref4;
      this._users = this._waveViewModel.getUsers(this._getParticipantsIds(true));
      return this.setParticipantsWidth(this.width);
    };

    Participants.prototype._removeParticipant = function(userId) {
      return this._processor.removeParticipant(this._modelId, userId, this._processResponse);
    };

    Participants.prototype._removeParticipants = function(userIds) {
      var _this = this;
      return this._processor.removeParticipants(this._modelId, userIds, function(err, res) {
        return _this._processResponse(err, res);
      });
    };

    Participants.prototype._changeParticipantRole = function(userId, roleId) {
      return this._processor.changeParticipantRole(this._modelId, userId, roleId, this._processResponse);
    };

    Participants.prototype._createWaveWithParticipants = function(userIds) {
      return this._processor.initCreateWaveWithParticipants(userIds);
    };

    Participants.prototype._processResponse = function(err) {
      /*
              Обрабатывает результат изменения участника в топике
              @param err: object|null
      */      if (!err) return;
      return this._waveViewModel.showWarning(err.message);
    };

    Participants.prototype.hideCreateTopicForSelectedButton = function() {
      if (this._manageForm) this._manageForm.hideCreateTopicForSelectedButton();
      return this._hideCreateTopicForSelectedButton = true;
    };

    Participants.prototype.showCreateTopicForSelectedButton = function() {
      if (this._manageForm) this._manageForm.showCreateTopicForSelectedButton();
      return this._hideCreateTopicForSelectedButton = false;
    };

    Participants.prototype.all = function() {
      /*
              Возвращает массив идентификаторов текущих участников волны
      */      return this._getParticipantsIds(true);
    };

    Participants.prototype.getContainer = function() {
      return this._container;
    };

    Participants.prototype.applyOp = function(op) {
      var index;
      index = op.p.shift();
      if (op.ld) this._remove(op.ld, index);
      if (op.li) return this._add(op.li, index);
    };

    Participants.prototype.destroy = function() {
      var _ref4;
      this._roleSelect.selectBox('destroy');
      if ((_ref4 = this._manageForm) != null) _ref4.destroy();
      delete this._manageForm;
      delete this._removeParticipant;
      delete this._waveViewModel;
      delete this._processor;
      return delete this._participants;
    };

    return Participants;

  })();

  module.exports = {
    Participants: Participants,
    ParticipantPopup: ParticipantPopup,
    canEditParticipant: canEditParticipant,
    canRemoveParticipant: canRemoveParticipant
  };

}).call(this);

});

require.define("/lib/client/client/wave/participants/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ck, manageParticipantsFormTmpl, participantTmpl, participantsContainerTmpl, userBottomPopupTmpl;

  ck = window.CoffeeKup;

  participantTmpl = function() {
    return span('.wave-participant.avatar', {
      style: "background-image: url(" + (h(this.avatar)) + ")"
    }, h(this.initials));
  };

  participantsContainerTmpl = function() {
    var buttonParams;
    div('.js-participant-container.participants', {
      style: 'width: 210px;'
    }, '');
    buttonParams = {
      title: 'Manage topic members'
    };
    button('.js-show-more-participants.show-more-participants', buttonParams, function() {
      span('', '');
      return div('.more-participants-image', '');
    });
    return div('.clearer', '');
  };

  manageParticipantsFormTmpl = function() {
    var className;
    className = '.manage-participants-form';
    if (this.isAnonymous) className += '.anonymous';
    return div(className, function() {
      input('.js-showing-participants-id.showing-participants-id', {
        type: "text",
        value: ""
      });
      br('', '');
      div('.js-selected-count.selected-count', function() {
        input('#select-all-participants.js-select-all-checkboxes.select-all-checkboxes', {
          type: "checkbox"
        });
        return label({
          "for": 'select-all-participants'
        }, function() {
          span('0');
          return text(' topic members selected');
        });
      });
      div('.js-autocomplete-results.autocomplete-results', '');
      div('.js-control-container.control-container', function() {
        select('.button-like.js-participant-role-select', function() {
          var role, _i, _len, _ref, _results;
          option({
            selected: "selected",
            value: '-1'
          }, 'Select role');
          _ref = this.roles;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            role = _ref[_i];
            if (role.id !== this.skipRole) {
              _results.push(option({
                value: role.id
              }, role.name));
            }
          }
          return _results;
        });
        button('.js-create-topic-for-selected', {
          title: "Create new topic with selected members"
        }, 'New topic with selected');
        return button('.js-remove-selected.remove-selected', {
          title: "Delete selected members"
        }, 'Remove');
      });
      if (!this.gDriveShareUrl) return;
      hr('');
      return div(function() {
        span('This topic was shared via Google Drive ');
        return a('button', {
          target: '_blank',
          href: h(this.gDriveShareUrl)
        }, 'Settings');
      });
    });
  };

  userBottomPopupTmpl = function() {
    return div('', function() {
      var params;
      if (this.roles) {
        select('.js-role-select.role-select.button-like', function() {
          var params, role, _i, _len, _ref, _results;
          _ref = this.roles;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            role = _ref[_i];
            params = {
              value: role.id
            };
            if (role.id === this.roleId) {
              params.selected = 'selected';
            } else if (role.id === this.skipRole) {
              continue;
            }
            _results.push(option(params, role.name));
          }
          return _results;
        });
      }
      params = {};
      if (!this.canRemove) params.disabled = 'disabled';
      button('.js-delete-from-wave.delete-from-wave', params, 'Remove');
      return div('.clearer', '');
    });
  };

  exports.renderBottomPopup = ck.compile(userBottomPopupTmpl);

  exports.renderParticipant = ck.compile(participantTmpl);

  exports.renderParticipantsContainer = ck.compile(participantsContainerTmpl);

  exports.renderManageParticipantsForm = ck.compile(manageParticipantsFormTmpl);

}).call(this);

});

require.define("/lib/client/client/wave/participants/manage_participants.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ManageParticipantsForm, ManageParticipantsPopup, PopupContent, ROLES, ROLE_NO_ROLE, ROLE_OWNER, compareContacts, renderManageParticipantsForm, renderParticipant, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = Array.prototype.slice,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  renderParticipant = require('../../user/template').renderParticipant;

  renderManageParticipantsForm = require('./template').renderManageParticipantsForm;

  compareContacts = require('../../user/utils').compareContactsByNameAndEmail;

  _ref = require('./constants'), ROLES = _ref.ROLES, ROLE_NO_ROLE = _ref.ROLE_NO_ROLE, ROLE_OWNER = _ref.ROLE_OWNER;

  PopupContent = require('../../popup').PopupContent;

  ManageParticipantsForm = (function() {

    function ManageParticipantsForm() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._selectAllHandler = __bind(this._selectAllHandler, this);
      this._filterParticipantsHandler = __bind(this._filterParticipantsHandler, this);
      this._participantSelectHandler = __bind(this._participantSelectHandler, this);
      this._createForSelectedHandler = __bind(this._createForSelectedHandler, this);
      this._changeRoleHandler = __bind(this._changeRoleHandler, this);
      this._deleteSelectedHandler = __bind(this._deleteSelectedHandler, this);
      this._init.apply(this, args);
    }

    ManageParticipantsForm.prototype._init = function(_waveViewModel, _participantsData, _removeParticipants, _canRemove, _createWaveWithParticipants, _changeRole, _canEdit, _hideCreateTopicForSelectedButton, gDriveShareUrl) {
      var params;
      this._waveViewModel = _waveViewModel;
      this._participantsData = _participantsData;
      this._removeParticipants = _removeParticipants;
      this._canRemove = _canRemove;
      this._createWaveWithParticipants = _createWaveWithParticipants;
      this._changeRole = _changeRole;
      this._canEdit = _canEdit;
      this._hideCreateTopicForSelectedButton = _hideCreateTopicForSelectedButton;
      params = {
        roles: ROLES,
        skipRole: ROLE_OWNER,
        isAnonymous: !window.loggedIn,
        gDriveShareUrl: gDriveShareUrl
      };
      this._showParticipantsForm = $(renderManageParticipantsForm(params));
      this._resultsContainer = this._showParticipantsForm.find('.js-autocomplete-results');
      this._users = this._getParticipantsData();
      this._initParticipantsInput();
      this._initUserSelection();
      this._initButtons();
      return this._showList();
    };

    ManageParticipantsForm.prototype._initParticipantsInput = function() {
      this._showParticipantsInput = this._showParticipantsForm.find('.js-showing-participants-id');
      return this._showParticipantsInput.keyup(this._filterParticipantsHandler);
    };

    ManageParticipantsForm.prototype._initUserSelection = function() {
      this._selectedCountBlock = this._showParticipantsForm.find('.js-selected-count span');
      this._selectedUsersCount = 0;
      this._selectAll = this._showParticipantsForm.find('.js-select-all-checkboxes');
      this._selectAll.click(this._selectAllHandler);
      return this._resultsContainer.on('click', '.js-results-list li', this._participantSelectHandler);
    };

    ManageParticipantsForm.prototype._initButtons = function() {
      this._deleteButton = this._showParticipantsForm.find('.js-remove-selected');
      this._deleteButton.click(this._deleteSelectedHandler);
      this._createTopicForSelectedButton = this._showParticipantsForm.find('.js-create-topic-for-selected');
      this._createTopicForSelectedButton.click(this._createForSelectedHandler);
      if (this._hideCreateTopicForSelectedButton) {
        this.hideCreateTopicForSelectedButton();
      }
      this._changeRoleSelect = this._showParticipantsForm.find('.js-participant-role-select');
      this._changeRoleSelect.selectBox().change(this._changeRoleHandler);
      return this._disableButtons();
    };

    ManageParticipantsForm.prototype._updateButtonsState = function() {
      var canEdit, canRemove, commonRoleId, p, selectedParticipants, _i, _j, _len, _len2;
      selectedParticipants = this._getSelectedParticipants();
      if (!selectedParticipants.length) return this._disableButtons();
      this._enableButtons();
      canRemove = canEdit = false;
      for (_i = 0, _len = selectedParticipants.length; _i < _len; _i++) {
        p = selectedParticipants[_i];
        if (this._canRemove(p.id)) canRemove = true;
        if (this._canEdit(p.id)) canEdit = true;
      }
      if (!canRemove) this._deleteButton.attr('disabled', 'disabled');
      if (!canEdit) this._changeRoleSelect.selectBox('disable');
      commonRoleId = null;
      for (_j = 0, _len2 = selectedParticipants.length; _j < _len2; _j++) {
        p = selectedParticipants[_j];
        if (commonRoleId == null) {
          commonRoleId = p.roleId === ROLE_OWNER ? -1 : p.roleId;
        }
        if (commonRoleId !== p.roleId) commonRoleId = -1;
      }
      return this._changeRoleSelect.selectBox('value', commonRoleId);
    };

    ManageParticipantsForm.prototype._enableButtons = function() {
      this._deleteButton.removeAttr('disabled');
      this._createTopicForSelectedButton.removeAttr('disabled');
      return this._changeRoleSelect.selectBox('enable');
    };

    ManageParticipantsForm.prototype._disableButtons = function() {
      this._deleteButton.attr('disabled', 'disabled');
      this._createTopicForSelectedButton.attr('disabled', 'disabled');
      return this._changeRoleSelect.selectBox('disable');
    };

    ManageParticipantsForm.prototype.prepareShow = function() {
      this._updateButtonsState();
      this._showParticipantsForm.show();
      return this._showParticipantsInput.select();
    };

    ManageParticipantsForm.prototype.hideCreateTopicForSelectedButton = function() {
      this._createTopicForSelectedButton.hide();
      return this._deleteButton.removeClass('remove-selected');
    };

    ManageParticipantsForm.prototype.showCreateTopicForSelectedButton = function() {
      this._createTopicForSelectedButton.show();
      return this._deleteButton.addClass('remove-selected');
    };

    ManageParticipantsForm.prototype._deleteSelectedHandler = function() {
      var canRemove, cantRemove, message, selectedParticipants, sp, u, _i, _len;
      selectedParticipants = this._getSelectedParticipants();
      canRemove = [];
      cantRemove = [];
      for (_i = 0, _len = selectedParticipants.length; _i < _len; _i++) {
        sp = selectedParticipants[_i];
        if (!this._canRemove(sp.id)) {
          cantRemove.push(sp);
        } else {
          canRemove.push(sp);
        }
      }
      message = "Delete " + canRemove.length + " users?";
      if (cantRemove.length) {
        if (cantRemove.length <= 5) {
          message += " Users " + (((function() {
            var _j, _len2, _results;
            _results = [];
            for (_j = 0, _len2 = cantRemove.length; _j < _len2; _j++) {
              u = cantRemove[_j];
              _results.push(u.email);
            }
            return _results;
          })()).join(', ')) + " will not be deleted";
        } else {
          message += " " + cantRemove.length + " users will not be deleted";
        }
      }
      if (window.confirm(message)) {
        this._removeParticipants((function() {
          var _j, _len2, _results;
          _results = [];
          for (_j = 0, _len2 = canRemove.length; _j < _len2; _j++) {
            u = canRemove[_j];
            _results.push(u.id);
          }
          return _results;
        })());
        return this._showList();
      }
    };

    ManageParticipantsForm.prototype._changeRoleHandler = function() {
      var canEdit, cantEdit, changeRole, p, roleId, selectedParticipants, u, _i, _len,
        _this = this;
      roleId = this._changeRoleSelect.val() - 0;
      if (roleId === -1) return;
      selectedParticipants = this._getSelectedParticipants();
      canEdit = [];
      cantEdit = [];
      for (_i = 0, _len = selectedParticipants.length; _i < _len; _i++) {
        p = selectedParticipants[_i];
        if (this._canEdit(p.id)) {
          canEdit.push(p);
        } else {
          cantEdit.push(p);
        }
      }
      changeRole = function() {
        var sp, _j, _len2, _results;
        _results = [];
        for (_j = 0, _len2 = canEdit.length; _j < _len2; _j++) {
          sp = canEdit[_j];
          _results.push(_this._changeRole(sp.id, roleId));
        }
        return _results;
      };
      if (!cantEdit.length) return changeRole();
      if (window.confirm("Cannot change " + (((function() {
        var _j, _len2, _results;
        _results = [];
        for (_j = 0, _len2 = cantEdit.length; _j < _len2; _j++) {
          u = cantEdit[_j];
          _results.push(u.email);
        }
        return _results;
      })()).join(', ')) + " role, change role anyway?")) {
        return changeRole();
      }
    };

    ManageParticipantsForm.prototype._createForSelectedHandler = function() {
      var hasSelf, selectedParticipants, sp, userIds, _i, _len;
      selectedParticipants = this._getSelectedParticipants();
      userIds = [];
      hasSelf = false;
      for (_i = 0, _len = selectedParticipants.length; _i < _len; _i++) {
        sp = selectedParticipants[_i];
        userIds.push(sp.id);
        hasSelf || (hasSelf = sp.id === window.userInfo.id);
      }
      if (!hasSelf) userIds.push(window.userInfo.id);
      _gaq.push(['_trackEvent', 'Topic creation', 'Create topic', 'With this team', userIds.length]);
      this._createWaveWithParticipants(userIds);
      return $(document).off('click.manageParticipants');
    };

    ManageParticipantsForm.prototype._getParticipantsData = function() {
      var curUser, user, users, waveUsers, _i, _len;
      waveUsers = this._waveViewModel.getParticipants();
      users = [];
      for (_i = 0, _len = waveUsers.length; _i < _len; _i++) {
        user = waveUsers[_i];
        curUser = {
          searchString: user.getSearchString(),
          data: user.getDataForAutocomplete(),
          checked: false,
          show: true
        };
        curUser.data.roleId = this._getUserRole(user.getId());
        users.push(curUser);
      }
      users.sort(this._compareContacts);
      return users;
    };

    ManageParticipantsForm.prototype._compareContacts = function(a, b) {
      return compareContacts(a.data, b.data);
    };

    ManageParticipantsForm.prototype._checkParticipantInput = function(checked) {
      if (checked) {
        this._selectedUsersCount += 1;
        if (this._selectedUsersCount === this._users.length) {
          this._selectAll.attr('checked', true);
        }
      } else {
        this._selectedUsersCount -= 1;
        this._selectAll.removeAttr('checked');
      }
      this._selectedCountBlock.text(this._selectedUsersCount);
      return this._updateButtonsState();
    };

    ManageParticipantsForm.prototype._showList = function() {
      var user, _i, _len, _ref2, _ref3;
      if ((_ref2 = this._resultsList) != null) _ref2.remove();
      this._selectedUsersCount = 0;
      this._resultsList = $('<ul></ul>').hide().addClass('js-results-list results-list');
      _ref3 = this._users;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        user = _ref3[_i];
        if (user.show) {
          this._resultsList.append($('<li>' + renderParticipant(user) + '</li>').data('id', user.data.id));
        }
        if (user.checked) this._selectedUsersCount += 1;
      }
      this._resultsContainer.append(this._resultsList);
      this._resultsList.show();
      return this._selectedCountBlock.text(this._selectedUsersCount);
    };

    ManageParticipantsForm.prototype._participantSelectHandler = function(event) {
      var checked, id, input, user, _i, _len, _ref2;
      id = $(event.currentTarget).data('id');
      _ref2 = this._users;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        user = _ref2[_i];
        if (id !== user.data.id) continue;
        input = $(event.currentTarget).find('input');
        if (input[0] === event.target) {
          checked = input.attr('checked') === 'checked';
          user.checked = checked;
          this._checkParticipantInput(checked);
        } else if (input.attr('checked') === 'checked') {
          input.removeAttr('checked');
          user.checked = false;
          this._checkParticipantInput(user.checked);
        } else {
          input.attr('checked', true);
          user.checked = true;
          this._checkParticipantInput(user.checked);
        }
        return;
      }
    };

    ManageParticipantsForm.prototype._filterParticipants = function(filterString) {
      var checked, user, _i, _len, _ref2;
      checked = true;
      _ref2 = this._users;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        user = _ref2[_i];
        if (user.searchString.search(filterString) === -1) {
          user.show = false;
        } else {
          user.show = true;
          if (!user.checked) checked = false;
        }
      }
      if (checked) {
        return this._selectAll.attr('checked', true);
      } else {
        return this._selectAll.removeAttr('checked');
      }
    };

    ManageParticipantsForm.prototype._filterParticipantsHandler = function(event) {
      var currentString;
      currentString = $(event.currentTarget).val().toLowerCase();
      this._filterParticipants(currentString);
      return this._showList();
    };

    ManageParticipantsForm.prototype._selectAllHandler = function(event) {
      var input, user, _i, _j, _len, _len2, _ref2, _ref3, _results, _results2;
      input = $(event.currentTarget);
      if (input.attr('checked') === 'checked') {
        this._resultsList.find('li input').attr('checked', true);
        _ref2 = this._users;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          user = _ref2[_i];
          if (user.show && !user.checked) {
            user.checked = true;
            _results.push(this._checkParticipantInput(user.checked));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      } else {
        this._resultsList.find('li input').removeAttr('checked');
        _ref3 = this._users;
        _results2 = [];
        for (_j = 0, _len2 = _ref3.length; _j < _len2; _j++) {
          user = _ref3[_j];
          if (user.show && user.checked) {
            user.checked = false;
            _results2.push(this._checkParticipantInput(user.checked));
          } else {
            _results2.push(void 0);
          }
        }
        return _results2;
      }
    };

    ManageParticipantsForm.prototype._getSelectedParticipants = function() {
      var u, _i, _len, _ref2, _results;
      _ref2 = this._users;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        u = _ref2[_i];
        if (u.checked) _results.push(u.data);
      }
      return _results;
    };

    ManageParticipantsForm.prototype.removeParticipant = function(user) {
      var id, listNodes, _i, _len, _ref2;
      id = user.id;
      _ref2 = this._users;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        user = _ref2[_i];
        if (user.data.id === id) {
          this._users.splice(this._users.indexOf(user), 1);
          break;
        }
      }
      listNodes = this._resultsList.find('li');
      return this._showList();
    };

    ManageParticipantsForm.prototype._getUserRole = function(userId) {
      var p, _i, _len, _ref2;
      _ref2 = this._participantsData;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        p = _ref2[_i];
        if (p.id !== userId) continue;
        return p.role;
      }
    };

    ManageParticipantsForm.prototype.updateParticipants = function(users) {
      var u, user, _i, _j, _len, _len2, _ref2;
      for (_i = 0, _len = users.length; _i < _len; _i++) {
        user = users[_i];
        _ref2 = this._users;
        for (_j = 0, _len2 = _ref2.length; _j < _len2; _j++) {
          u = _ref2[_j];
          if (!(u.data.id === user.getId())) continue;
          u.data = user.getDataForAutocomplete();
          u.data.roleId = this._getUserRole(u.data.id);
          u.searchString = user.getSearchString();
          break;
        }
      }
      this._filterParticipants(this._showParticipantsInput.val());
      return this._showList();
    };

    ManageParticipantsForm.prototype.addParticipant = function(participant) {
      var user, userData;
      if (participant.role !== ROLE_NO_ROLE) {
        user = this._waveViewModel.getUser(participant.id, true);
        userData = {
          searchString: user.getSearchString(),
          data: user.getDataForAutocomplete(),
          checked: false,
          show: false
        };
        userData.data.roleId = participant.role;
        return this._users.push(userData);
      }
    };

    ManageParticipantsForm.prototype.destroy = function() {
      this._showParticipantsForm.remove();
      this._changeRoleSelect.selectBox('detach');
      this._resultsContainer.remove();
      delete this._waveViewModel;
      delete this._participantsData;
      delete this._removeParticipants;
      delete this._canRemove;
      delete this._createWaveWithParticipants;
      delete this._changeRole;
      delete this._canEdit;
      return delete this._hideCreateTopicForSelectedButton;
    };

    ManageParticipantsForm.prototype.getContainer = function() {
      return this._showParticipantsForm;
    };

    return ManageParticipantsForm;

  })();

  ManageParticipantsPopup = (function(_super) {

    __extends(ManageParticipantsPopup, _super);

    /*
        Оболочка над ManageParticipantsForm, нужна, чтобы не пересоздавать форму при каждом открытии.
    */

    function ManageParticipantsPopup(getForm) {
      this._manageParticipantsForm = getForm();
    }

    ManageParticipantsPopup.prototype.destroy = function() {
      this._manageParticipantsForm.getContainer().detach();
      return delete this._manageParticipantsForm;
    };

    ManageParticipantsPopup.prototype.shouldCloseWhenClicked = function(element) {
      return $(element).closest('.js-participant-role-select-selectBox-dropdown-menu').length === 0;
    };

    ManageParticipantsPopup.prototype.getContainer = function() {
      this._manageParticipantsForm.prepareShow();
      return this._manageParticipantsForm.getContainer();
    };

    return ManageParticipantsPopup;

  })(PopupContent);

  module.exports = {
    ManageParticipantsForm: ManageParticipantsForm,
    ManageParticipantsPopup: ManageParticipantsPopup
  };

}).call(this);

});

require.define("/lib/client/client/blip/contributors/author.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var Author, renderAuthor,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = Array.prototype.slice;

  renderAuthor = require('./template').renderAuthor;

  Author = (function() {

    function Author() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.updateAuthorInfo = __bind(this.updateAuthorInfo, this);
      this._init.apply(this, args);
    }

    Author.prototype._init = function(_waveViewModel, _ids) {
      this._waveViewModel = _waveViewModel;
      this._ids = _ids;
      return this._createDom();
    };

    Author.prototype._createDom = function() {
      this._container = document.createElement('span');
      return this._render();
    };

    Author.prototype._render = function() {
      var params, user;
      $(this._container).empty().unbind();
      user = this._waveViewModel.getUser(this._ids[0]);
      params = {
        users: [user.toObject()]
      };
      if (this._ids[1]) {
        params.users.push(this._waveViewModel.getUser(this._ids[1]).toObject());
      }
      $(this._container).append(renderAuthor(params));
      return this._avatarContainer = $(this._container).find('.js-shown-contributor-avatar');
    };

    Author.prototype.updateAuthorInfo = function(userIds) {
      if ($.inArray(this._ids[0], userIds) === -1 && $.inArray(this._ids[1], userIds) === -1) {
        return;
      }
      return this._render();
    };

    Author.prototype.setIndicator = function(userId) {
      this._ids[1] = userId;
      return this._render();
    };

    Author.prototype.getContainer = function() {
      return this._container;
    };

    Author.prototype.getAvatarContainer = function() {
      return this._avatarContainer;
    };

    return Author;

  })();

  exports.Author = Author;

}).call(this);

});

require.define("/lib/client/client/blip/task_recipient/input.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BrowserEvents, DateTimePicker, KeyCodes, MicroEvent, NOT_PERFORMED_TASK, TaskRecipientInput, TaskRecipientStub, UserPicker, ck, convertDateTimeToServer, formatAsClientDate, renderRecipientInput, renderTaskRecipientName, strip, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  UserPicker = require('../user_picker').UserPicker;

  DateTimePicker = require('../../utils/date_time_picker').DateTimePicker;

  strip = require('../../utils/string').strip;

  MicroEvent = require('../../utils/microevent');

  BrowserEvents = require('../../utils/browser_events');

  KeyCodes = require('../../utils/key_codes').KeyCodes;

  TaskRecipientStub = require('./index').TaskRecipientStub;

  _ref = require('../../../share/utils/date_converter'), convertDateTimeToServer = _ref.convertDateTimeToServer, formatAsClientDate = _ref.formatAsClientDate;

  NOT_PERFORMED_TASK = require('../../search_panel/task/constants').NOT_PERFORMED_TASK;

  ck = window.CoffeeKup;

  renderRecipientInput = ck.compile(function() {
    return span('.task-recipient-creation-form.js-task-recipient-creation-form', function() {
      input({
        type: 'checkbox',
        disabled: 'disabled'
      });
      input('.js-task-recipient-input .task-recipient-input', {
        type: "text",
        tabindex: "0"
      });
      return input('.js-task-recipient-deadline-input', {
        type: "text",
        tabindex: "0",
        style: 'display: none'
      });
    });
  });

  renderTaskRecipientName = ck.compile(function() {
    return span('.task-recipient-text', h(this.name));
  });

  TaskRecipientInput = (function() {

    function TaskRecipientInput(_waveViewModel, _updateTaskSearchInfo) {
      var c;
      this._waveViewModel = _waveViewModel;
      this._updateTaskSearchInfo = _updateTaskSearchInfo;
      this._processDeadline = __bind(this._processDeadline, this);
      this._container = document.createElement('span');
      this._container.contentEditable = 'false';
      c = $(this._container);
      c.append(renderRecipientInput());
      this._state = 'start';
      this._taskData = {
        status: NOT_PERFORMED_TASK,
        senderId: window.userInfo.id
      };
      this._activateRecipientInput();
    }

    TaskRecipientInput.prototype._activateRecipientInput = function() {
      var _this = this;
      this._recipientInput = $(this._container).find('.js-task-recipient-input')[0];
      this._userPicker = new UserPicker(this._waveViewModel);
      this._userPicker.activate(this._recipientInput);
      this._userPicker.on('select-contact', function(contact) {
        if (contact.id) return _this._selectRecipientById(contact.id);
        return _this._selectRecipientByEmail(contact.email);
      });
      this._userPicker.on('select-email', function(email) {
        return _this._selectRecipientByEmail(strip(email));
      });
      this._userPicker.on('finish', function() {
        if (_this._state === 'recipient-input') {
          return _this._cancelTask(_this.getValue());
        }
      });
      return this._state = 'recipient-input';
    };

    TaskRecipientInput.prototype._cancelInput = function(state, callback, reason) {
      var _this = this;
      return window.setTimeout(function() {
        if (_this._state !== state) return;
        return callback(reason);
      }, 200);
    };

    TaskRecipientInput.prototype._bindCancel = function(item, state, skipClass, callback) {
      var _this = this;
      $(item).bind(BrowserEvents.KEY_EVENTS.join(' '), function(event) {
        if (event.keyCode !== KeyCodes.KEY_ESCAPE && event.keyCode !== KeyCodes.KEY_TAB) {
          return;
        }
        return _this._cancelInput(state, callback, 'key');
      });
      this._bodyClickCallback = function(e) {
        var curElement;
        if (!e.target) return;
        curElement = e.target;
        while (curElement) {
          if ($(curElement).is(skipClass)) return;
          curElement = curElement.parentNode;
        }
        _this._cancelInput(state, callback, 'blur');
        return $('body').off('click', _this._bodyClickCallback);
      };
      return $('body').on('click', this._bodyClickCallback);
    };

    TaskRecipientInput.prototype._cancelTask = function(text) {
      return this.emit('cancel', text);
    };

    TaskRecipientInput.prototype._replaceRecipientInput = function(name) {
      var recipientName, _ref2;
      if ((_ref2 = this._userPicker) != null) _ref2.destroy();
      recipientName = renderTaskRecipientName({
        name: name
      });
      return $(this._recipientInput).replaceWith(recipientName);
    };

    TaskRecipientInput.prototype._trackRecipientInsertion = function() {
      return _gaq.push(['_trackEvent', 'Task', 'Task creation', this.insertionEventLabel || 'Hotkey']);
    };

    TaskRecipientInput.prototype._trackRecipientCancel = function() {
      return _gaq.push(['_trackEvent', 'Task', 'Task cancellation']);
    };

    TaskRecipientInput.prototype._selectRecipientById = function(id) {
      var name;
      if (this._selecting) return;
      this._selecting = true;
      this._taskData.recipientId = id;
      name = this._waveViewModel.getUser(this._taskData.recipientId).getName();
      this._replaceRecipientInput(name);
      this._activateDeadlineInput();
      return this._selecting = false;
    };

    TaskRecipientInput.prototype._selectRecipientByEmail = function(email) {
      var insert, user,
        _this = this;
      if (this._selecting) return;
      this._selecting = true;
      insert = function() {
        return _this._selectEmail(email);
      };
      if (this._waveViewModel.haveEmails()) {
        user = this._waveViewModel.getParticipantByEmail(email);
        if (user) {
          this._selectEmail(email);
        } else {
          if (this._userPicker.isValid(email)) {
            if (window.confirm("This user is not participant of the topic. Add " + email + " to the topic?")) {
              insert();
            } else {
              this._trackRecipientCancel();
              this._cancelTask();
            }
          } else {
            this._waveViewModel.showWarning('Enter valid e-mail');
          }
        }
      } else {
        insert();
      }
      return this._selecting = false;
    };

    TaskRecipientInput.prototype._selectEmail = function(email) {
      this._taskData.recipientEmail = email;
      this._replaceRecipientInput(email);
      return this._activateDeadlineInput();
    };

    TaskRecipientInput.prototype._activateDeadlineInput = function() {
      var _this = this;
      this._state = 'deadline-input';
      this._deadlineInput = $(this._container).find('.js-task-recipient-deadline-input')[0];
      this._bindCancel(this._deadlineInput, 'deadline-input', '.js-task-recipient-creation-form, .calendricalDatePopup, .acResults', function() {
        return _this._selectDeadline(null);
      });
      return window.setTimeout(function() {
        _this._dateTimePicker = new DateTimePicker();
        _this._dateTimePicker.initUniversalInput(_this._deadlineInput, true);
        $(_this._deadlineInput).show();
        $(_this._deadlineInput).val(formatAsClientDate(new Date()));
        $(_this._deadlineInput).select();
        $(_this._deadlineInput).focus();
        return _this._dateTimePicker.on('universal-change', _this._processDeadline);
      }, 0);
    };

    TaskRecipientInput.prototype._processDeadline = function(hasError, date, time) {
      var datetime, _ref2;
      if (hasError) {
        this._waveViewModel.showWarning('Enter valid date');
        return;
      }
      _ref2 = convertDateTimeToServer(date, time), date = _ref2[0], datetime = _ref2[1];
      return this._selectDeadline(date, datetime);
    };

    TaskRecipientInput.prototype._selectDeadline = function(date, datetime) {
      if (this._state !== 'deadline-input') return;
      this._state = 'finish';
      this._taskData.deadlineDate = date;
      this._taskData.deadlineDatetime = datetime;
      this._trackRecipientInsertion();
      this._updateTaskSearchInfo(this._taskData);
      return this.emit('finish', this._taskData);
    };

    TaskRecipientInput.prototype.stub = function() {
      var stub;
      stub = new TaskRecipientStub(this._taskData.recipientEmail, this._taskData.deadlineDate, this._taskData.deadlineDatetime);
      $(this._container).replaceWith(stub.getContainer());
      return stub;
    };

    TaskRecipientInput.prototype.getContainer = function() {
      return this._container;
    };

    TaskRecipientInput.prototype.getValue = function() {
      return $(this._recipientInput).val();
    };

    TaskRecipientInput.prototype.focus = function() {
      return this._recipientInput.focus();
    };

    TaskRecipientInput.prototype.destroy = function() {
      var _ref2, _ref3;
      delete this._waveViewModel;
      if ((_ref2 = this._userPicker) != null) _ref2.destroy();
      delete this._userPicker;
      if ((_ref3 = this._dateTimePicker) != null) _ref3.destroy();
      delete this._dateTimePicker;
      $(this._container).remove();
      this.removeListeners('cancel');
      this.removeListeners('finish');
      return $('body').off('click', this._bodyClickCallback);
    };

    return TaskRecipientInput;

  })();

  MicroEvent.mixin(TaskRecipientInput);

  module.exports = {
    TaskRecipientInput: TaskRecipientInput
  };

}).call(this);

});

require.define("/lib/client/client/blip/recipient/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var KeyCodes, KeyEventNames, PopupContent, Recipient, RecipientInput, RecipientPopup, RecipientStub, UserPicker, popup, renderRecipient, renderRecipientInput, renderRecipientPopup, setUserPopupBehaviour, strip, _ref, _ref2,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = Array.prototype.slice;

  _ref = require('./template'), renderRecipient = _ref.renderRecipient, renderRecipientInput = _ref.renderRecipientInput, renderRecipientPopup = _ref.renderRecipientPopup;

  UserPicker = require('../user_picker').UserPicker;

  strip = require('../../utils/string').strip;

  setUserPopupBehaviour = require('../../popup/user_popup').setUserPopupBehaviour;

  _ref2 = require('../../popup'), popup = _ref2.popup, PopupContent = _ref2.PopupContent;

  KeyCodes = require('../utils/key_codes').KeyCodes;

  KeyEventNames = require('../utils/browser_events').KEY_EVENTS.join(' ');

  RecipientPopup = (function(_super) {

    __extends(RecipientPopup, _super);

    function RecipientPopup(user, _canDelete, _canConvert, _removeCallback, _convertCallback) {
      this._canDelete = _canDelete;
      this._canConvert = _canConvert;
      this._removeCallback = _removeCallback;
      this._convertCallback = _convertCallback;
      this._render(user);
    }

    RecipientPopup.prototype._render = function(user) {
      var $container, params,
        _this = this;
      this._container = document.createElement('span');
      $container = $(this._container);
      params = {
        avatar: user.getAvatar(),
        initials: user.getInitials(),
        name: user.getName(),
        email: user.getEmail(),
        canDelete: this._canDelete(user.getId()),
        canConvert: this._canConvert(user.getId()),
        showConvertButton: require('../../account_setup_wizard/processor').instance.isBusinessUser()
      };
      $container.append(renderRecipientPopup(params));
      $container.find('.js-remove-recipient').on('click', function() {
        _this._removeCallback();
        return popup.hide();
      });
      return $container.find('.js-convert-to-task').on('click', function() {
        _this._convertCallback();
        return popup.hide();
      });
    };

    RecipientPopup.prototype.getContainer = function() {
      if (!this._container) this._render();
      return this._container;
    };

    RecipientPopup.prototype.destroy = function() {
      delete this._container;
      delete this._removeCallback;
      return delete this._convertCallback;
    };

    return RecipientPopup;

  })(PopupContent);

  RecipientInput = (function() {

    function RecipientInput(_waveViewModel) {
      var c;
      this._waveViewModel = _waveViewModel;
      this._checkEscKey = __bind(this._checkEscKey, this);
      this._cancelRecipientInput = __bind(this._cancelRecipientInput, this);
      this._emailSelectHandler = __bind(this._emailSelectHandler, this);
      this._contactSelectHandler = __bind(this._contactSelectHandler, this);
      this._container = document.createElement('span');
      this._container.contentEditable = 'false';
      c = $(this._container);
      c.append(renderRecipientInput());
      this._input = c.find('.js-recipient-input')[0];
      this._userPicker = new UserPicker(this._waveViewModel);
      this._userPicker.activate(this._input);
      this._userPicker.on('select-contact', this._contactSelectHandler);
      this._userPicker.on('select-email', this._emailSelectHandler);
      this._userPicker.on('finish', this._cancelRecipientInput);
      $(this._container).on(KeyEventNames, this._checkEscKey);
      this._state = 'input';
    }

    RecipientInput.prototype._contactSelectHandler = function(contact) {
      if (contact.id) return this._insertRecipientById(contact.id);
      return this._insertRecipientByEmail(strip(contact.email));
    };

    RecipientInput.prototype._emailSelectHandler = function(email) {
      return this._insertRecipientByEmail(strip(email));
    };

    RecipientInput.prototype._trackRecipientInsertion = function() {
      _gaq.push(['_trackEvent', 'Mention', 'Mention creation', this.insertionEventLabel || 'Hotkey']);
      return mixpanel.track('Create mention');
    };

    RecipientInput.prototype._trackRecipientCancel = function() {
      return _gaq.push(['_trackEvent', 'Mention', 'Mention cancellation']);
    };

    RecipientInput.prototype._insertRecipientById = function(id) {
      this._state = 'inserted';
      $(this._container).trigger('itemSelected', id);
      return this._trackRecipientInsertion();
    };

    RecipientInput.prototype._cancelRecipientInput = function() {
      return $(this._container).trigger('cancel', this.getValue());
    };

    RecipientInput.prototype._checkEscKey = function(event) {
      if ((event.keyCode != null) && event.keyCode !== KeyCodes.KEY_ESCAPE) return;
      return this._cancelRecipientInput();
    };

    RecipientInput.prototype._insertRecipientByEmail = function(email) {
      var insert, user,
        _this = this;
      if (this._state !== 'input') return;
      insert = function() {
        $(_this._container).trigger('emailSelected', email);
        _this._trackRecipientInsertion();
        return _this._state = 'inserted';
      };
      if (!this._waveViewModel.haveEmails()) return insert();
      user = this._waveViewModel.getParticipantByEmail(email);
      if (user) return this._insertRecipientById(user.getId());
      if (!this._userPicker.isValid(email)) {
        this._state = 'input';
        return this._waveViewModel.showWarning('Enter valid e-mail');
      }
      $(this._container).off(KeyEventNames, this._checkEscKey);
      this._userPicker.removeListener('finish', this._cancelRecipientInput);
      this._state = 'confirming';
      if (window.confirm("This user is not participant of the topic. Add " + email + " to the topic?")) {
        return insert();
      } else {
        $(this._container).trigger('cancel');
        this._trackRecipientCancel();
        return this._state = 'canceled';
      }
    };

    RecipientInput.prototype.getContainer = function() {
      return this._container;
    };

    RecipientInput.prototype.getValue = function() {
      return $(this._input).val();
    };

    RecipientInput.prototype.stub = function(email) {
      var stubbedRecipient;
      stubbedRecipient = new RecipientStub(email);
      $(this._container).replaceWith(stubbedRecipient.getContainer());
      return stubbedRecipient;
    };

    RecipientInput.prototype.focus = function() {
      return this._input.focus();
    };

    RecipientInput.prototype.destroy = function() {
      var _ref3;
      delete this._waveViewModel;
      if ((_ref3 = this._userPicker) != null) _ref3.destroy();
      delete this._userPicker;
      return $(this._container).remove();
    };

    return RecipientInput;

  })();

  RecipientStub = (function() {

    function RecipientStub(email) {
      this._container = document.createElement('span');
      this._container.contentEditable = 'false';
      $(this._container).append(renderRecipient({
        name: email
      }));
    }

    RecipientStub.prototype.destroy = function() {
      return $(this._container).remove();
    };

    RecipientStub.prototype.getContainer = function() {
      return this._container;
    };

    return RecipientStub;

  })();

  Recipient = (function() {

    function Recipient() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._convert = __bind(this._convert, this);
      this._remove = __bind(this._remove, this);
      this._updateUserInfo = __bind(this._updateUserInfo, this);
      this._init.apply(this, args);
    }

    Recipient.prototype._init = function(_waveViewModel, _canDelete, _canConvert, _id, _removeCallback, _convertCallback) {
      this._waveViewModel = _waveViewModel;
      this._canDelete = _canDelete;
      this._canConvert = _canConvert;
      this._id = _id;
      this._removeCallback = _removeCallback;
      this._convertCallback = _convertCallback;
      this._createDom();
      return this._waveViewModel.on('usersInfoUpdate', this._updateUserInfo);
    };

    Recipient.prototype._updateUserInfo = function(userIds) {
      var userId, _i, _len;
      for (_i = 0, _len = userIds.length; _i < _len; _i++) {
        userId = userIds[_i];
        if (this._id === userId) return this.render();
      }
    };

    Recipient.prototype._createDom = function() {
      this._container || (this._container = document.createElement('span'));
      this._container.contentEditable = 'false';
      $(this._container).empty();
      return this._renderRecipient();
    };

    Recipient.prototype._remove = function() {
      _gaq.push(['_trackEvent', 'Mention', 'Remove mention with popup']);
      return typeof this._removeCallback === "function" ? this._removeCallback(this) : void 0;
    };

    Recipient.prototype._convert = function() {
      var recipient;
      _gaq.push(['_trackEvent', 'Mention', 'Convert to Task']);
      recipient = this._convertCallback(this);
      return window.setTimeout(function() {
        return recipient.showPopup();
      }, 0);
    };

    Recipient.prototype._renderRecipient = function() {
      var $c, user;
      $c = $(this._container);
      user = this._waveViewModel.getUser(this._id);
      $c.append(renderRecipient({
        name: user.getName()
      }));
      return setUserPopupBehaviour($c, RecipientPopup, user, this._canDelete, this._canConvert, this._remove, this._convert);
    };

    Recipient.prototype.render = function() {
      return this._createDom();
    };

    Recipient.prototype.getContainer = function() {
      return this._container;
    };

    Recipient.prototype.getId = function() {
      return this._id;
    };

    Recipient.prototype.markAsInvalid = function(message) {
      return $(this._container).children().css('border', '1px inset red').attr('title', message);
    };

    Recipient.prototype.destroy = function() {
      this._waveViewModel.removeListener('usersInfoUpdate', this._updateUserInfo);
      delete this._waveViewModel;
      delete this._removeCallback;
      return delete this._convertCallback;
    };

    return Recipient;

  })();

  exports.Recipient = Recipient;

  exports.RecipientInput = RecipientInput;

}).call(this);

});

require.define("/lib/client/client/blip/recipient/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ck, recipientInputTmpl, recipientPopupTmpl, recipientTmpl;

  ck = window.CoffeeKup;

  recipientTmpl = function() {
    return span('blip-recipient-container', function() {
      span('editor-el-split', '|');
      span('blip-recipient', function() {
        return span('blip-recipient-text', "@" + (h(this.name)));
      });
      return span('editor-el-split', '|');
    });
  };

  recipientInputTmpl = function() {
    return span('.recipient-input-container', function() {
      input('.js-recipient-input .recipient-input', {
        type: "text",
        tabindex: "0"
      });
      return span({
        style: "position: absolute; left: 3px;"
      }, '@');
    });
  };

  recipientPopupTmpl = function() {
    return div('.mention-recipient-popup', function() {
      div('.recipient-info', function() {
        div('.avatar', {
          style: "background-image: url(" + (h(this.avatar)) + ")"
        }, h(this.initials));
        return div('.wave-participant-name-email', function() {
          div('.wave-participant-name', h(this.name));
          return div('.wave-participant-email', h(this.email));
        });
      });
      return div('.mention-bottom-container', function() {
        var params;
        params = {};
        if (!this.canDelete) params.disabled = 'disabled';
        button('.js-remove-recipient.remove-recipient', params, 'Delete');
        if (this.showConvertButton) {
          params = {};
          if (!this.canConvert) params.disabled = 'disabled';
          return button('.js-convert-to-task.convert-to-task-button', params, 'Convert to');
        }
      });
    });
  };

  exports.renderRecipient = ck.compile(recipientTmpl);

  exports.renderRecipientInput = ck.compile(recipientInputTmpl);

  exports.renderRecipientPopup = ck.compile(recipientPopupTmpl);

}).call(this);

});

require.define("/lib/client/client/blip/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var blipTmpl, ck;

  ck = window.CoffeeKup;

  blipTmpl = function() {
    if (!this.isRoot) {
      div('.js-blip-menu-container.blip-menu-container', '');
      div('.js-blip-info-container.blip-info', function() {
        span('.js-shown-contributor', '');
        return div(function() {
          return div('.edit-date', {
            title: h(this.fullDatetime)
          }, h(this.datetime));
        });
      });
    }
    div('.js-editor-container.editor-container', function() {
      if (!this.isRoot) {
        return div('.js-blip-unread-indicator.unread-indicator', {
          style: 'display: none;'
        }, function() {});
      }
    });
    if (!this.isAnonymous) {
      return div('.js-bottom-blip-menu.bottom-blip-menu', function() {
        button('js-finish-edit finish-edit-button', {
          title: 'Done (Ctrl+E, Shift+Enter)',
          onMouseDown: "_gaq.push(['_trackEvent', 'Blip usage', 'To read mode', 'bottom button']);"
        }, 'Done');
        return button('.js-blip-reply-button.blip-reply-button', {
          title: 'Write a reply to this thread'
        }, function() {
          div('.text', 'Write a reply...');
          div('.avatar', {
            style: "background-image: url(" + (h(window.userInfo.avatar)) + ")"
          }, '');
          return div('.gradient', '');
        });
      });
    }
  };

  exports.renderBlip = ck.compile(blipTmpl);

}).call(this);

});

require.define("/lib/client/client/blip/menu/range_menu.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BrowserEvents, DEFAULT_LINE_HEIGHT, DomUtils, LEFT_SHIFT, RangeMenu, instance, render, tmpl,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  DomUtils = require('../../utils/dom');

  BrowserEvents = require('../../utils/browser_events');

  tmpl = function() {
    return div('range-menu hidden', function() {
      button('button', {
        title: 'Edit (Ctrl+E)'
      }, function() {
        return div('icon edit-icon', '');
      });
      return button('button', {
        title: 'Insert comment (Ctrl+Enter)'
      }, function() {
        div('icon comment-icon', '');
        return span('Comment');
      });
    });
  };

  render = window.CoffeeKup.compile(tmpl);

  DEFAULT_LINE_HEIGHT = 12;

  LEFT_SHIFT = 28;

  RangeMenu = (function() {

    function RangeMenu() {
      this._handleWndEvent = __bind(this._handleWndEvent, this);
      this._handleComment = __bind(this._handleComment, this);
      this._handleEdit = __bind(this._handleEdit, this);      this._createDom();
      this._resetCounter();
      this._hidden = true;
    }

    RangeMenu.prototype._createDom = function() {
      var fr,
        _this = this;
      fr = DomUtils.parseFromString(render());
      this._container = fr.firstChild;
      BrowserEvents.addBlocker(this._container, BrowserEvents.MOUSE_DOWN_EVENT);
      this._editBtn = this._container.firstChild;
      this._commentBtn = this._container.lastChild;
      $(this._editBtn).on('click', function() {
        return _gaq.push(['_trackEvent', 'Blip usage', 'To edit mode', 'context menu']);
      });
      return $(this._commentBtn).on('click', function() {
        return _gaq.push(['_trackEvent', 'Blip usage', 'Insert reply', 'Re in blip context menu']);
      });
    };

    RangeMenu.prototype._showBtn = function(btn) {
      return btn.style.removeProperty('display');
    };

    RangeMenu.prototype._hideBtn = function(btn) {
      return btn.style.display = 'none';
    };

    RangeMenu.prototype._resetBtn = function(btn, handler, callback) {
      if (!callback) return this._hideBtn(btn);
      btn.addEventListener(BrowserEvents.CLICK_EVENT, handler, false);
      return this._showBtn(btn);
    };

    RangeMenu.prototype._removeHandlers = function() {
      this._commentBtn.removeEventListener(BrowserEvents.CLICK_EVENT, this._handleComment, false);
      this._editBtn.removeEventListener(BrowserEvents.CLICK_EVENT, this._handleEdit, false);
      window.removeEventListener(BrowserEvents.MOUSE_DOWN_EVENT, this._handleWndEvent, true);
      this._editCallback = null;
      return this._commentCallback = null;
    };

    RangeMenu.prototype._addHandlers = function(_commentCallback, _editCallback) {
      this._commentCallback = _commentCallback;
      this._editCallback = _editCallback;
      this._resetBtn(this._commentBtn, this._handleComment, this._commentCallback);
      this._resetBtn(this._editBtn, this._handleEdit, this._editCallback);
      return window.addEventListener(BrowserEvents.MOUSE_DOWN_EVENT, this._handleWndEvent, true);
    };

    RangeMenu.prototype._handleEdit = function() {
      try {
        if (this._editCallback) this._editCallback();
      } catch (_error) {}
      return this.hide();
    };

    RangeMenu.prototype._handleComment = function() {
      try {
        if (this._commentCallback) this._commentCallback();
      } catch (_error) {}
      return this.hide();
    };

    RangeMenu.prototype._handleWndEvent = function(e) {
      if (DomUtils.contains(this._container, e.target)) return;
      return this.hide();
    };

    RangeMenu.prototype._resetCounter = function() {
      this._id = '';
      return this._counter = 0;
    };

    RangeMenu.prototype._setPos = function(rect) {
      var height;
      if (this._hidden) return;
      height = rect.bottom - rect.top;
      if (height <= 0) height = DEFAULT_LINE_HEIGHT;
      rect.left -= this._editCallback ? LEFT_SHIFT : this._container.offsetWidth / 2;
      rect.top += 5 + height;
      return this._container.setAttribute('style', "top: " + rect.top + "px; left: " + rect.left + "px;");
    };

    RangeMenu.prototype.hide = function() {
      if (this._hidden) return;
      this._hidden = true;
      this._resetCounter();
      DomUtils.addClass(this._container, 'hidden');
      return this._removeHandlers();
    };

    RangeMenu.prototype.show = function(id, rect, parent, commentCallback, editCallback) {
      this._hidden = false;
      if (id === this._id) {
        this._counter += 1;
      } else {
        this._id = id;
        this._counter = 1;
      }
      if (this._counter % 2) return;
      this._removeHandlers();
      if (editCallback) {
        DomUtils.addClass(this._container, 'edit');
      } else {
        DomUtils.removeClass(this._container, 'edit');
      }
      this._addHandlers(commentCallback, editCallback);
      DomUtils.removeClass(this._container, 'hidden');
      parent.appendChild(this._container);
      return this._setPos(rect);
    };

    RangeMenu.prototype.update = function(rect) {
      return this._setPos(rect);
    };

    return RangeMenu;

  })();

  instance = null;

  module.exports.get = function() {
    return instance != null ? instance : instance = new RangeMenu();
  };

}).call(this);

});

require.define("/node_modules/async/package.json",function(require,module,exports,__dirname,__filename,process,global){module.exports = {"main":"./index"}
});

require.define("/node_modules/async/index.js",function(require,module,exports,__dirname,__filename,process,global){// This file is just added for convenience so this repository can be
// directly checked out into a project's deps folder
module.exports = require('./lib/async');

});

require.define("/node_modules/async/lib/async.js",function(require,module,exports,__dirname,__filename,process,global){/*global setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root = this,
        previous_async = root.async;

    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    else {
        root.async = async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    //// cross-browser compatiblity functions ////

    var _forEach = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _forEach(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _forEach(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        async.nextTick = function (fn) {
            setTimeout(fn, 0);
        };
    }
    else {
        async.nextTick = process.nextTick;
    }

    async.forEach = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _forEach(arr, function (x) {
            iterator(x, function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed === arr.length) {
                        callback();
                    }
                }
            });
        });
    };

    async.forEachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed === arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    
    async.forEachLimit = function (arr, limit, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length || limit <= 0) {
            return callback(); 
        }
        var completed = 0;
        var started = 0;
        var running = 0;
        
        (function replenish () {
          if (completed === arr.length) {
              return callback();
          }
          
          while (running < limit && started < arr.length) {
            iterator(arr[started], function (err) {
              if (err) {
                  callback(err);
                  callback = function () {};
              }
              else {
                  completed += 1;
                  running -= 1;
                  if (completed === arr.length) {
                      callback();
                  }
                  else {
                      replenish();
                  }
              }
            });
            started += 1;
            running += 1;
          }
        })();
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.forEach].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.forEachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);


    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.forEachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.forEach(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.forEach(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _forEach(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _forEach(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                if (err) {
                    callback(err);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    taskComplete();
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.nextTick(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    async.parallel = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.forEach(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.forEachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.queue = function (worker, concurrency) {
        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _forEach(data, function(task) {
                    q.tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (q.saturated && q.tasks.length == concurrency) {
                        q.saturated();
                    }
                    async.nextTick(q.process);
                });
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if(q.empty && q.tasks.length == 0) q.empty();
                    workers += 1;
                    worker(task.data, function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if(q.drain && q.tasks.length + workers == 0) q.drain();
                        q.process();
                    });
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _forEach(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      }
    };

}());

});

require.define("/lib/client/client/wave/participants/utils.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var LocalStorage, User, trackTopicCreatedAndUserAdded;

  User = require('../../user/models').User;

  LocalStorage = require('../../utils/localStorage').LocalStorage;

  trackTopicCreatedAndUserAdded = require('../../analytics/ping').trackTopicCreatedAndUserAdded;

  module.exports.trackParticipantAddition = function(label, userData) {
    var user;
    user = new User(null, userData.email, userData.name, userData.avatar);
    if (user.isNewUser()) {
      _gaq.push(['_trackEvent', 'Topic participants', "Add participant new", label, 1]);
      mixpanel.track("Add participant", {
        "participant type": "new",
        "added via": label,
        "count": 1,
        "count new": 1,
        "count existing": 0
      });
      trackTopicCreatedAndUserAdded(1, 0);
      return LocalStorage.incUsersAdded();
    } else {
      _gaq.push(['_trackEvent', 'Topic participants', "Add participant existing", label, 1]);
      return mixpanel.track("Add participant", {
        "participant type": "existing",
        "added via": label,
        "count": 1,
        "count new": 0,
        "count existing": 1
      });
    }
  };

}).call(this);

});

require.define("/lib/client/client/blip/interactor/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipEventInteractor, BlipUndoRedo, CopyBlipLinkPopup, EventProcessor, Interactable, KeyInteractor, LineLevelParams, PopupContent, TEXT_MODIFIERS, TextLevelParams, popup, renderCopyBlipLinkPopup, _ref, _ref2,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  Interactable = require('../../utils/interactable').Interactable;

  BlipUndoRedo = require('../undoredo').BlipUndoRedo;

  EventProcessor = require('./blip_events').EventProcessor;

  KeyInteractor = require('./key_interactor').KeyInteractor;

  _ref = require('../../editor/model'), TextLevelParams = _ref.TextLevelParams, LineLevelParams = _ref.LineLevelParams;

  _ref2 = require('../../popup'), PopupContent = _ref2.PopupContent, popup = _ref2.popup;

  TEXT_MODIFIERS = require('../../menu').TEXT_MODIFIERS;

  renderCopyBlipLinkPopup = require('../menu/template').renderCopyBlipLinkPopup;

  BlipEventInteractor = (function() {

    function BlipEventInteractor(_blipViewModel, _blipView) {
      this._blipViewModel = _blipViewModel;
      this._blipView = _blipView;
      this._handleEvent = __bind(this._handleEvent, this);
      this._editable = false;
      this._interactables = [];
      this._editor = this._blipView.getEditor();
      this._undoRedo = new BlipUndoRedo(this._blipViewModel, this._blipView);
      this._keyInteractor = new KeyInteractor(this._blipView.getContainer());
      this._textModifiers = {};
      this._attach(this._keyInteractor);
    }

    BlipEventInteractor.prototype._handleEvent = function(event) {
      if (!(EventProcessor[event.type] != null)) {
        if (typeof console.trace === "function") console.trace();
        return console.warn("Event '" + event.type + "' is not supported");
      }
      try {
        return EventProcessor[event.type](this, event.args);
      } catch (e) {
        return console.error('Failed to handle event', e);
      }
    };

    BlipEventInteractor.prototype._attach = function(interactable) {
      if (this._interactables.indexOf(interactable) >= 0) return;
      interactable.on(Interactable.EVENT, this._handleEvent);
      return this._interactables.push(interactable);
    };

    BlipEventInteractor.prototype._detach = function(interactable) {
      var index;
      if ((index = this._interactables.indexOf(interactable)) < 0) return;
      this._interactables[index].removeListener(Interactable.EVENT, this._handleEvent);
      return this._interactables.splice(index, 1);
    };

    BlipEventInteractor.prototype._attachMenu = function(blipMenu, placeHolder, params) {
      if (this._blipMenu) return;
      this._keyInteractor.attach();
      placeHolder.appendChild(blipMenu.getContainer());
      blipMenu.reset(params);
      this._attach(blipMenu);
      this._blipMenu = blipMenu;
      this._updateEditingModifiers();
      return this._updateUndoRedoState();
    };

    BlipEventInteractor.prototype._detachMenu = function() {
      var menuElement, _ref3, _ref4;
      this._keyInteractor.detach();
      if (!this._blipMenu) return;
      menuElement = this._blipMenu.getContainer();
      if ((_ref3 = menuElement.parentNode) != null) _ref3.removeChild(menuElement);
      this._detach(this._blipMenu);
      if ((_ref4 = this._blipMenu) != null) _ref4.detach();
      return delete this._blipMenu;
    };

    BlipEventInteractor.prototype._updateUndoRedoState = function() {
      if (!this._blipMenu) return;
      this._blipMenu.setUndoButtonDisabled(!this._undoRedo.hasUndoOps());
      return this._blipMenu.setRedoButtonDisabled(!this._undoRedo.hasRedoOps());
    };

    BlipEventInteractor.prototype._cursorInText = function() {
      return this._blipViewModel.getWaveViewModel().getView().cursorIsInText();
    };

    BlipEventInteractor.prototype._setEditable = function(_editable) {
      var _ref3, _ref4;
      this._editable = _editable;
      if (this._editable) {
        if ((_ref3 = this._blipMenu) != null) _ref3.setEditMode();
        return this._keyInteractor.setEditModeKeyHandlers();
      } else {
        if ((_ref4 = this._blipMenu) != null) _ref4.setReadMode();
        return this._keyInteractor.setReadModeKeyHandlers();
      }
    };

    BlipEventInteractor.prototype._updateLineButtons = function() {
      var _ref3;
      return (_ref3 = this._blipMenu) != null ? _ref3.setLineParams(this._editor.getLineParams()) : void 0;
    };

    BlipEventInteractor.prototype._updateTextButtons = function() {
      var _ref3;
      return (_ref3 = this._blipMenu) != null ? _ref3.setTextParams(this._textModifiers) : void 0;
    };

    BlipEventInteractor.prototype._copyEditingModifiers = function(textParams) {
      var key, _results;
      _results = [];
      for (key in TEXT_MODIFIERS) {
        if (textParams[key] != null) {
          _results.push(this._textModifiers[key] = textParams[key]);
        } else {
          _results.push(this._textModifiers[key] = null);
        }
      }
      return _results;
    };

    BlipEventInteractor.prototype._updateEditingModifiers = function() {
      this._updateLineButtons();
      this._copyEditingModifiers(this._editor.getTextParams());
      return this._updateTextButtons();
    };

    BlipEventInteractor.prototype._toggleLineParam = function(name) {
      var param;
      param = this._editor.getLineParams()[name];
      this._editor.setRangeLineParam(name, param != null ? null : 0);
      return this._updateLineButtons();
    };

    BlipEventInteractor.prototype._toggleTextParam = function(name, value) {
      var range;
      if (value === void 0) {
        if (this._textModifiers[name]) {
          value = null;
        } else {
          value = true;
        }
      }
      this._textModifiers[name] = value;
      this._updateTextButtons();
      if (!(range = this._editor.getRange())) return;
      if (range.collapsed) {
        return this._editor.setEditingModifiers(this._textModifiers);
      } else {
        return this._editor.setRangeTextParam(name, this._textModifiers[name]);
      }
    };

    BlipEventInteractor.prototype._clearFormatting = function() {
      var range;
      this._copyEditingModifiers({});
      this._updateTextButtons();
      if (!(range = this._editor.getRange())) return;
      if (range.collapsed) {
        return this._editor.setEditingModifiers(this._textModifiers);
      } else {
        return this._editor.clearSelectedTextFormatting();
      }
    };

    BlipEventInteractor.prototype._finishUndoRedoProcess = function() {
      this._updateUndoRedoState();
      return this._updateEditingModifiers();
    };

    BlipEventInteractor.prototype.getBlip = function() {
      return this._blipView;
    };

    BlipEventInteractor.prototype.updateUndoRedoState = function() {
      return this._updateUndoRedoState();
    };

    BlipEventInteractor.prototype.attachMenu = function(blipMenu, placeHolder, params) {
      return this._attachMenu(blipMenu, placeHolder, params);
    };

    BlipEventInteractor.prototype.detachMenu = function() {
      return this._detachMenu();
    };

    BlipEventInteractor.prototype.changeMode = function() {
      return this._blipView.setEditable(!this._editable);
    };

    BlipEventInteractor.prototype.setEditableMode = function(editable) {
      return this._setEditable(editable);
    };

    BlipEventInteractor.prototype.isEditable = function() {
      return this._editable;
    };

    BlipEventInteractor.prototype.undo = function() {
      this._undoRedo.undo();
      return this._finishUndoRedoProcess();
    };

    BlipEventInteractor.prototype.redo = function() {
      this._undoRedo.redo();
      return this._finishUndoRedoProcess();
    };

    BlipEventInteractor.prototype.manageLink = function() {
      if (!this._cursorInText()) return;
      return this._blipView.getEditor().openLinkEditor();
    };

    BlipEventInteractor.prototype.insertFile = function() {
      return this._editor.openUploadForm(false);
    };

    BlipEventInteractor.prototype.insertImage = function() {
      return this._editor.openUploadForm(true);
    };

    BlipEventInteractor.prototype.toggleLineParam = function(name) {
      return this._toggleLineParam(name);
    };

    BlipEventInteractor.prototype.toggleTextParam = function(name, value) {
      return this._toggleTextParam(name, value);
    };

    BlipEventInteractor.prototype.clearFormatting = function() {
      return this._clearFormatting();
    };

    BlipEventInteractor.prototype.updateEditingModifiers = function() {
      return this._updateEditingModifiers();
    };

    BlipEventInteractor.prototype.toggleFoldedByDefault = function() {
      var folded, model, _ref3;
      model = this._blipViewModel.getModel();
      if (!model) return;
      folded = model.isFoldedByDefault();
      if (!folded) this._blipView.fold();
      model.setIsFoldedByDefault(!folded);
      return (_ref3 = this._blipMenu) != null ? _ref3.setFoldedByDefault(!folded) : void 0;
    };

    BlipEventInteractor.prototype.updateFoldedByDefault = function(folded) {
      var _ref3;
      return (_ref3 = this._blipMenu) != null ? _ref3.setFoldedByDefault(folded) : void 0;
    };

    BlipEventInteractor.prototype.isFoldedByDefault = function() {
      var _ref3;
      return (_ref3 = this._blipViewModel.getModel()) != null ? _ref3.isFoldedByDefault() : void 0;
    };

    BlipEventInteractor.prototype["delete"] = function() {
      return this._blipView.removeWithConfirm();
    };

    BlipEventInteractor.prototype.sendMessages = function() {
      var _this = this;
      this._blipMenu.updateSendButton('Sending…');
      return this._blipView.sendMessages(function(err) {
        if (!_this._blipMenu) return;
        if (err) return _this._blipMenu.updateSendButton('Error sending');
        return _this._blipMenu.updateSendButton('Sent');
      });
    };

    BlipEventInteractor.prototype.insertInlineBlip = function() {
      if (!this._cursorInText()) return;
      return this._blipView.initInsertInlineBlip();
    };

    BlipEventInteractor.prototype.foldAll = function() {
      return this._blipView.foldAllChildBlips();
    };

    BlipEventInteractor.prototype.unfoldAll = function() {
      return this._blipView.unfoldAllChildBlips();
    };

    BlipEventInteractor.prototype.copyBlip = function() {
      this._blipView.renderRecursively();
      return this._blipView.getParent().getEditor().copyElementToBuffer(this._blipView.getContainer());
    };

    BlipEventInteractor.prototype.pasteAsReply = function() {
      return this._blipView.getParent().getEditor().pasteBlipFromBufferAfter(this._blipViewModel.getView().getContainer());
    };

    BlipEventInteractor.prototype.pasteAtCursor = function() {
      return this._editor.pasteBlipFromBufferToCursor();
    };

    BlipEventInteractor.prototype.showBlipUrl = function(target) {
      var copyBlipLinkPopup;
      if (popup.getContainer()) return;
      copyBlipLinkPopup = new CopyBlipLinkPopup({
        url: this._blipView.getUrl()
      });
      popup.render(copyBlipLinkPopup, target);
      return popup.show();
    };

    BlipEventInteractor.prototype.setFoldable = function(foldable) {
      var _ref3;
      return (_ref3 = this._blipMenu) != null ? _ref3.setFoldable(foldable) : void 0;
    };

    BlipEventInteractor.prototype.setSendable = function(sendable) {
      var _ref3;
      return (_ref3 = this._blipMenu) != null ? _ref3.setSendable(sendable) : void 0;
    };

    BlipEventInteractor.prototype.setLastSent = function(lastSent, lastSender) {
      var _ref3;
      return (_ref3 = this._blipMenu) != null ? _ref3.setLastSent(lastSent, lastSender) : void 0;
    };

    BlipEventInteractor.prototype.setCanEdit = function(canEdit) {
      var _ref3;
      return (_ref3 = this._blipMenu) != null ? _ref3.setCanEdit(canEdit) : void 0;
    };

    BlipEventInteractor.prototype.showPlaybackView = function() {
      return this._blipView.showPlaybackView();
    };

    BlipEventInteractor.prototype.enableIdDependantButtons = function() {
      var _ref3;
      return (_ref3 = this._blipMenu) != null ? _ref3.enableIdDependantButtons() : void 0;
    };

    BlipEventInteractor.prototype.attach = function(interactable) {
      return this._attach(interactable);
    };

    BlipEventInteractor.prototype.detach = function(interactable) {
      return this._detach(interactable);
    };

    BlipEventInteractor.prototype.destroy = function() {
      var interactable, _i, _len, _ref3;
      this._detachMenu();
      delete this._blipViewModel;
      delete this._blipView;
      delete this._editor;
      delete this._blipMenu;
      this._undoRedo.destroy();
      delete this._undoRedo;
      this._keyInteractor.destroy();
      delete this._keyInteractor;
      _ref3 = this._interactables;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        interactable = _ref3[_i];
        interactable.removeListener(Interactable.EVENT, this._handleEvent);
      }
      return delete this._interactables;
    };

    return BlipEventInteractor;

  })();

  CopyBlipLinkPopup = (function(_super) {

    __extends(CopyBlipLinkPopup, _super);

    function CopyBlipLinkPopup(params) {
      this._container = document.createElement('span');
      this._render(params);
    }

    CopyBlipLinkPopup.prototype._render = function(params) {
      /*
              Рендерим блоки для копирования ссылки
      */      $(this._container).append(renderCopyBlipLinkPopup(params));
      return this._selectInputText();
    };

    CopyBlipLinkPopup.prototype._selectInputText = function() {
      var blipUrl,
        _this = this;
      blipUrl = $(this._container).find('.js-blip-link');
      setTimeout(function() {
        return blipUrl.select();
      }, 0);
      return blipUrl.bind('click', function() {
        return blipUrl.select();
      });
    };

    CopyBlipLinkPopup.prototype.destroy = function() {
      $(this._container).remove();
      return this._container = null;
    };

    CopyBlipLinkPopup.prototype.getContainer = function() {
      return this._container;
    };

    return CopyBlipLinkPopup;

  })(PopupContent);

  module.exports = {
    BlipEventInteractor: BlipEventInteractor
  };

}).call(this);

});

require.define("/lib/client/client/utils/interactable.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var Event, Interactable, MicroEvent;

  MicroEvent = require('./microevent');

  Event = (function() {

    function Event(type, args) {
      this.type = type;
      this.args = args;
      this._prevented = false;
    }

    Event.prototype.preventDefault = function() {
      return this._prevented = true;
    };

    Event.prototype.isPrevented = function() {
      return this._prevented;
    };

    return Event;

  })();

  Interactable = (function() {

    function Interactable() {}

    Interactable.EVENT = 'event';

    Interactable.prototype.contructor = function() {};

    Interactable.prototype.__dispatchEvent = function(type, args) {
      if (args == null) args = {};
      return this.emit(Interactable.EVENT, new Event(type, args));
    };

    return Interactable;

  })();

  MicroEvent.mixin(Interactable);

  module.exports = {
    Event: Event,
    Interactable: Interactable
  };

}).call(this);

});

require.define("/lib/client/client/blip/undoredo.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipUndoRedo, FText, ModelField, ModelType, OP_TYPE, Op, ParamsField, UNDO_GROUP_TIMEOUT, UNDO_OPERATION_LIMIT, clone, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ref = require('../editor/model'), ModelField = _ref.ModelField, ModelType = _ref.ModelType, ParamsField = _ref.ParamsField;

  FText = sharejs.types.ftext;

  clone = function(o) {
    return JSON.parse(JSON.stringify(o));
  };

  UNDO_GROUP_TIMEOUT = 3000;

  UNDO_OPERATION_LIMIT = 200;

  OP_TYPE = {
    BLIP_INSERT: 0,
    BLIP_DELETE: 1,
    TEXT_INSERT: 2,
    TEXT_DELETE: 3,
    OTHER: 4,
    EMPTY: 5
  };

  Op = (function() {

    function Op() {}

    Op.isTextOp = function(op) {
      return op[ModelField.PARAMS][ParamsField.TYPE] === ModelType.TEXT;
    };

    Op.isBlipOp = function(op) {
      return op[ModelField.PARAMS][ParamsField.TYPE] === ModelType.BLIP;
    };

    Op.getOpType = function(op) {
      switch (false) {
        case !((op.ti != null) && this.isBlipOp(op)):
          return OP_TYPE.BLIP_INSERT;
        case !((op.ti != null) && this.isTextOp(op)):
          return OP_TYPE.TEXT_INSERT;
        case !((op.td != null) && this.isTextOp(op)):
          return OP_TYPE.TEXT_DELETE;
        default:
          return OP_TYPE.OTHER;
      }
    };

    Op.getOpsType = function(ops) {
      /*
              Возвращает OP_TYPE.TEXT_INSERT, если все указанные операции являются операциями
                      вставки текста.
              Возвращает OP_TYPE.TEXT_DELETE, если все указанные операции являются операциями
                      вставки текста.
              Возвращает OP_TYPE.OTHER иначе
      */
      var firstOpType, op, opType, _i, _len, _ref2;
      if (!ops.length) return OP_TYPE.EMPTY;
      firstOpType = this.getOpType(ops[0]);
      if (firstOpType === OP_TYPE.OTHER) return OP_TYPE.OTHER;
      if (firstOpType === OP_TYPE.BLIP_INSERT) return OP_TYPE.BLIP_INSERT;
      _ref2 = ops.slice(1);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        op = _ref2[_i];
        opType = this.getOpType(op);
        if (opType === OP_TYPE.OTHER || opType !== firstOpType) {
          return OP_TYPE.OTHER;
        }
      }
      return firstOpType;
    };

    return Op;

  })();

  BlipUndoRedo = (function() {

    function BlipUndoRedo(_blipViewModel, blipView) {
      this._blipViewModel = _blipViewModel;
      this._addRedoOps = __bind(this._addRedoOps, this);
      this._transformUndoRedoOps = __bind(this._transformUndoRedoOps, this);
      this._addUndoOps = __bind(this._addUndoOps, this);
      this._addAndMergeUndoOps = __bind(this._addAndMergeUndoOps, this);
      this._undoOps = [];
      this._redoOps = [];
      blipView.on('ops', this._addAndMergeUndoOps);
      this._blipViewModel.on('remote-ops', this._transformUndoRedoOps);
    }

    BlipUndoRedo.prototype._shouldMergeOps = function(ops) {
      /*
              Возвращает true, если указанные операции стоит объединить с последними
              сделанными для отмены
              @param ops: [ShareJS operations]
              @return: boolean
      */
      var curTime, delta, lastOp, lastOps, type;
      if (this._undoOps.length === 0) return false;
      curTime = (new Date()).getTime();
      if (curTime > this._lastUndoGroupStartTime + UNDO_GROUP_TIMEOUT) {
        return false;
      }
      type = Op.getOpsType(ops);
      if (type !== OP_TYPE.TEXT_INSERT && type !== OP_TYPE.TEXT_DELETE) {
        return false;
      }
      if (type !== this._lastUndoGroupType) return false;
      lastOps = this._undoOps[this._undoOps.length - 1];
      lastOp = lastOps[0];
      if (!lastOp) return true;
      if (type === OP_TYPE.TEXT_INSERT) {
        delta = lastOp.td.length;
      } else {
        delta = -lastOp.ti.length;
      }
      if (ops[0].p !== lastOp.p + delta) return false;
      return true;
    };

    BlipUndoRedo.prototype._shouldSkipOps = function(ops) {
      return Op.getOpsType(ops) === OP_TYPE.BLIP_INSERT;
    };

    BlipUndoRedo.prototype._addAndMergeUndoOps = function(ops) {
      if (this._shouldSkipOps(ops)) return this._transformUndoRedoOps(ops);
      this._redoOps = [];
      if (this._shouldMergeOps(ops)) {
        return this._mergeUndoOps(ops);
      } else {
        this._addUndoOps(ops);
        this._lastUndoGroupType = Op.getOpsType(ops);
        return this._lastUndoGroupStartTime = (new Date()).getTime();
      }
    };

    BlipUndoRedo.prototype._addUndoOps = function(ops) {
      /*
              Добавляет новую группу undo-операций
              @param ops: [ShareJS operations]
      */      this._undoOps.push(FText.invert(ops));
      if (this._undoOps.length > UNDO_OPERATION_LIMIT) {
        return this._undoOps.shift();
      }
    };

    BlipUndoRedo.prototype._mergeUndoOps = function(ops) {
      /*
              Сливает указанные операции с последней группой undo-операций
              @param ops: [ShareJS operations]
      */
      var lastOps, _ref2;
      lastOps = this._undoOps[this._undoOps.length - 1];
      return ([].splice.apply(lastOps, [0, 0].concat(_ref2 = FText.invert(ops))), _ref2);
    };

    BlipUndoRedo.prototype._transformUndoRedoOps = function(ops) {
      this._transformOps(ops, this._undoOps);
      return this._transformOps(ops, this._redoOps);
    };

    BlipUndoRedo.prototype._transformOps = function(ops, blocks) {
      var block, i, _len;
      ops = clone(ops);
      blocks.reverse();
      for (i = 0, _len = blocks.length; i < _len; i++) {
        block = blocks[i];
        blocks[i] = FText.transform(block, ops, 'right');
        ops = FText.transform(ops, block, 'left');
      }
      return blocks.reverse();
    };

    BlipUndoRedo.prototype._addRedoOps = function(ops) {
      return this._redoOps.push(FText.invert(ops));
    };

    BlipUndoRedo.prototype._applyUndoRedo = function(ops, invertAction) {
      /*
              Применяет операцию undo или redo, содержит общую логику по ожиданию
              загрузки блипов
              @param ops: @_undoOps || @_redoOps
              @param invertAction: @_addRedoOps || @_addUndoOps
      */
      var block;
      block = ops.pop();
      if (!block) return;
      if (!block.length) return this._applyUndoRedo(ops, invertAction);
      this._blipViewModel.getModel().submitOps(block);
      this._blipViewModel.applyUndoRedoOps(block);
      return invertAction(block);
    };

    BlipUndoRedo.prototype.undo = function() {
      /*
              Отменяет последнюю совершенную пользователем операцию, которую
              еще можно отменить
      */      this._applyUndoRedo(this._undoOps, this._addRedoOps);
      return this._lastUndoGroupStartTime = 0;
    };

    BlipUndoRedo.prototype.redo = function() {
      /*
              Повторяет последнюю отмененную операцию, если после нее не было простого
              ввода текста.
      */      this._applyUndoRedo(this._redoOps, this._addUndoOps);
      return this._lastUndoGroupStartTime = 0;
    };

    BlipUndoRedo.prototype.hasUndoOps = function() {
      /*
              Возвращает true, если есть undo-операции
      */      return this._undoOps.length > 0;
    };

    BlipUndoRedo.prototype.hasRedoOps = function() {
      /*
              Возвращает true, если есть redo-операции
      */      return this._redoOps.length > 0;
    };

    BlipUndoRedo.prototype.destroy = function() {
      delete this._undoOps;
      delete this._redoOps;
      this._blipViewModel.getView().removeListener('ops', this._addAndMergeUndoOps);
      this._blipViewModel.removeListener('remote-ops', this._transformUndoRedoOps);
      return delete this._blipViewModel;
    };

    return BlipUndoRedo;

  })();

  module.exports = {
    BlipUndoRedo: BlipUndoRedo
  };

}).call(this);

});

require.define("/lib/client/client/blip/interactor/blip_events.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipEventTypes, BrowserEvents, EventProcessor, LineLevelParams, TextLevelParams, toggleTextParam, trackMakeTextEvent, _ref;

  BrowserEvents = require('../../utils/browser_events');

  _ref = require('../../editor/model'), TextLevelParams = _ref.TextLevelParams, LineLevelParams = _ref.LineLevelParams;

  BlipEventTypes = {
    CHANGE_MODE: '_changeMode',
    UNDO: '_undo',
    REDO: '_redo',
    MANAGE_LINK: '_manageLink',
    INSERT_FILE: '_insertFile',
    INSERT_IMAGE: '_insertImage',
    MAKE_BOLD: '_makeBold',
    MAKE_ITALIC: '_makeItalic',
    MAKE_UNDERLINED: '_makeUnderlined',
    MAKE_STRUCKTHROUGH: '_makeStruckthrough',
    SET_BG_COLOR: '_setBgColor',
    CLEAR_FORMATTING: '_clearFormatting',
    MAKE_BULLETED: '_makeBulleted',
    MAKE_NUMBERED: '_makeNumbered',
    SET_FOLDED_BY_DEFAULT: '_setFoldedByDefault',
    DELETE: '_delete',
    SEND: '_send',
    INSERT_INLINE_BLIP: '_insertInlineBlip',
    FOLD_ALL: '_foldAll',
    UNFOLD_ALL: '_unfoldAll',
    COPY_BLIP: '_copyBlip',
    PASTE_AT_CURSOR: '_pasteAtCursor',
    PASTE_AS_REPLY: '_pasteAsReply',
    SHOW_BLIP_URL: '_showBlipUrl',
    PLAYBACK: '_playback'
  };

  trackMakeTextEvent = function(name) {
    return _gaq.push(['_trackEvent', 'Blip usage', "Make text " + name]);
  };

  toggleTextParam = function(interactor, param) {
    trackMakeTextEvent(param);
    return interactor.toggleTextParam(param);
  };

  EventProcessor = (function() {

    function EventProcessor() {}

    EventProcessor.prototype._changeMode = function(blipInteractor) {
      return blipInteractor.changeMode();
    };

    EventProcessor.prototype._undo = function(blipInteractor, args) {
      /*
              Отменяет последнее сделанное пользователем действие
      */
      var _ref2;
      if (!blipInteractor.isEditable()) return;
      if ((args != null ? (_ref2 = args.event) != null ? _ref2.type : void 0 : void 0) === BrowserEvents.CLICK_EVENT) {
        _gaq.push(['_trackEvent', 'Blip usage', 'Undo', 'Button click']);
      } else {
        _gaq.push(['_trackEvent', 'Blip usage', 'Undo', 'Shortcut']);
      }
      return blipInteractor.undo();
    };

    EventProcessor.prototype._redo = function(blipInteractor, args) {
      /*
              Повторяет последнее отмененное пользователем действие
      */
      var _ref2;
      if (!blipInteractor.isEditable()) return;
      if ((args != null ? (_ref2 = args.event) != null ? _ref2.type : void 0 : void 0) === BrowserEvents.CLICK_EVENT) {
        _gaq.push(['_trackEvent', 'Blip usage', 'Redo', 'Button click']);
      } else {
        _gaq.push(['_trackEvent', 'Blip usage', 'Redo', 'Shortcut']);
      }
      return blipInteractor.redo();
    };

    EventProcessor.prototype._manageLink = function(blipInteractor) {
      _gaq.push(['_trackEvent', 'Blip usage', 'Insert link']);
      return blipInteractor.manageLink();
    };

    EventProcessor.prototype._insertFile = function(blipInteractor) {
      _gaq.push(['_trackEvent', 'Blip usage', 'Insert attach']);
      return blipInteractor.insertFile();
    };

    EventProcessor.prototype._insertImage = function(blipInteractor) {
      _gaq.push(['_trackEvent', 'Blip usage', 'Insert image']);
      return blipInteractor.insertImage();
    };

    EventProcessor.prototype._makeBold = function(blipInteractor) {
      return toggleTextParam(blipInteractor, TextLevelParams.BOLD);
    };

    EventProcessor.prototype._makeItalic = function(blipInteractor) {
      return toggleTextParam(blipInteractor, TextLevelParams.ITALIC);
    };

    EventProcessor.prototype._makeUnderlined = function(blipInteractor) {
      return toggleTextParam(blipInteractor, TextLevelParams.UNDERLINED);
    };

    EventProcessor.prototype._makeStruckthrough = function(blipInteractor) {
      return toggleTextParam(blipInteractor, TextLevelParams.STRUCKTHROUGH);
    };

    EventProcessor.prototype._setBgColor = function(blipInteractor, args) {
      return blipInteractor.toggleTextParam(TextLevelParams.BG_COLOR, args.value);
    };

    EventProcessor.prototype._clearFormatting = function(blipInteractor) {
      _gaq.push(['_trackEvent', 'Blip usage', 'Clear text formatting']);
      return blipInteractor.clearFormatting();
    };

    EventProcessor.prototype._makeBulleted = function(blipInteractor) {
      _gaq.push(['_trackEvent', 'Blip usage', 'Make text bulleted']);
      return blipInteractor.toggleLineParam(LineLevelParams.BULLETED);
    };

    EventProcessor.prototype._makeNumbered = function(blipInteractor) {
      _gaq.push(['_trackEvent', 'Blip usage', 'Make text numbered']);
      return blipInteractor.toggleLineParam(LineLevelParams.NUMBERED);
    };

    EventProcessor.prototype._setFoldedByDefault = function(blipInteractor) {
      if (!blipInteractor.isFoldedByDefault()) {
        _gaq.push(['_trackEvent', 'Blip usage', 'Set always hide']);
      }
      return blipInteractor.toggleFoldedByDefault();
    };

    EventProcessor.prototype._delete = function(blipInteractor) {
      return blipInteractor["delete"]();
    };

    EventProcessor.prototype._send = function(blipInteractor) {
      return blipInteractor.sendMessages();
    };

    EventProcessor.prototype._insertInlineBlip = function(blipInteractor) {
      _gaq.push(['_trackEvent', 'Blip usage', 'Insert reply', 'Shortcut']);
      return blipInteractor.insertInlineBlip();
    };

    EventProcessor.prototype._foldAll = function(blipInteractor) {
      _gaq.push(['_trackEvent', 'Blip usage', 'Hide replies', 'Reply menu']);
      return blipInteractor.foldAll();
    };

    EventProcessor.prototype._unfoldAll = function(blipInteractor) {
      _gaq.push(['_trackEvent', 'Blip usage', 'Show replies', 'Reply menu']);
      return blipInteractor.unfoldAll();
    };

    EventProcessor.prototype._copyBlip = function(blipInteractor) {
      _gaq.push(['_trackEvent', 'Blip usage', 'Copy blip']);
      return blipInteractor.copyBlip();
    };

    EventProcessor.prototype._pasteAsReply = function(blipInteractor) {
      _gaq.push(['_trackEvent', 'Blip usage', 'Paste blip', 'After blip']);
      return blipInteractor.pasteAsReply();
    };

    EventProcessor.prototype._pasteAtCursor = function(blipInteractor) {
      _gaq.push(['_trackEvent', 'Blip usage', 'Paste blip', 'At cursor']);
      return blipInteractor.pasteAtCursor();
    };

    EventProcessor.prototype._showBlipUrl = function(blipInteractor, args) {
      var _ref2;
      _gaq.push(['_trackEvent', 'Blip usage', 'Copy blip link']);
      return blipInteractor.showBlipUrl((_ref2 = args.event) != null ? _ref2.target : void 0);
    };

    EventProcessor.prototype._playback = function(blipInteractor) {
      _gaq.push(['_trackEvent', 'Blip usage', 'Playback']);
      return blipInteractor.showPlaybackView();
    };

    return EventProcessor;

  })();

  module.exports = {
    BlipEventTypes: BlipEventTypes,
    EventProcessor: new EventProcessor()
  };

}).call(this);

});

require.define("/lib/client/client/blip/interactor/key_interactor.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipEventTypes, EDIT_MODE_EVENTS, Event, Interactable, KeyInteractor, READ_MODE_EVENTS, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  _ref = require('../../utils/interactable'), Interactable = _ref.Interactable, Event = _ref.Event;

  BlipEventTypes = require('./blip_events').BlipEventTypes;

  EDIT_MODE_EVENTS = {
    CTRL_HANDLERS: {
      13: BlipEventTypes.INSERT_INLINE_BLIP,
      53: BlipEventTypes.MAKE_BULLETED,
      54: BlipEventTypes.MAKE_NUMBERED,
      66: BlipEventTypes.MAKE_BOLD,
      73: BlipEventTypes.MAKE_ITALIC,
      76: BlipEventTypes.MANAGE_LINK,
      85: BlipEventTypes.MAKE_UNDERLINED,
      89: BlipEventTypes.REDO,
      90: BlipEventTypes.UNDO
    },
    CTRL_SHIFT_HANDLERS: {
      90: BlipEventTypes.REDO
    }
  };

  READ_MODE_EVENTS = {
    CTRL_HANDLERS: {
      13: BlipEventTypes.INSERT_INLINE_BLIP,
      53: null,
      54: null,
      66: null,
      73: null,
      76: null,
      85: null,
      89: null,
      90: null
    },
    CTRL_SHIFT_HANDLERS: {
      90: null
    }
  };

  KeyInteractor = (function(_super) {

    __extends(KeyInteractor, _super);

    function KeyInteractor(_container) {
      this._container = _container;
      this._processKeyDownEvent = __bind(this._processKeyDownEvent, this);
      this._preProcessKeyDownEvent = __bind(this._preProcessKeyDownEvent, this);
      this._active = false;
    }

    KeyInteractor.prototype._initKeyHandler = function() {
      /*
              Инициализирует обработчик нажатий на клавиши в блипе
      */      return this._container.addEventListener('keydown', this._preProcessKeyDownEvent, true);
    };

    KeyInteractor.prototype._deinitKeyHandler = function() {
      /*
              Снимает обработчик нажатий на клавиши в блипе
      */      return this._container.removeEventListener('keydown', this._preProcessKeyDownEvent, true);
    };

    KeyInteractor.prototype._preProcessKeyDownEvent = function(e) {
      var handlers;
      handlers = e.shiftKey ? this._ctrlShiftHandlers : this._ctrlHandlers;
      return this._processKeyDownEvent(handlers, e);
    };

    KeyInteractor.prototype._processKeyDownEvent = function(handlers, e) {
      /*
              Обрабатывает нажатия клавиш внутри блипов
              @param e: DOM event
      */      if (!handlers) return console.warn('handler is not set');
      if ((!(e.ctrlKey || e.metaKey)) || e.altKey) return;
      if (!(e.keyCode in handlers)) return;
      e.preventDefault();
      e.stopPropagation();
      if (handlers[e.keyCode] != null) {
        return this.__dispatchEvent(handlers[e.keyCode]);
      }
    };

    KeyInteractor.prototype.setEditModeKeyHandlers = function() {
      this._ctrlHandlers = EDIT_MODE_EVENTS.CTRL_HANDLERS;
      return this._ctrlShiftHandlers = EDIT_MODE_EVENTS.CTRL_SHIFT_HANDLERS;
    };

    KeyInteractor.prototype.setReadModeKeyHandlers = function() {
      this._ctrlHandlers = READ_MODE_EVENTS.CTRL_HANDLERS;
      return this._ctrlShiftHandlers = READ_MODE_EVENTS.CTRL_SHIFT_HANDLERS;
    };

    KeyInteractor.prototype.attach = function() {
      return this._initKeyHandler();
    };

    KeyInteractor.prototype.detach = function() {
      return this._deinitKeyHandler();
    };

    KeyInteractor.prototype.destroy = function() {
      this._deinitKeyHandler();
      return delete this._container;
    };

    return KeyInteractor;

  })(Interactable);

  module.exports = {
    KeyInteractor: KeyInteractor
  };

}).call(this);

});

require.define("/lib/client/client/blip/menu/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ADDITIONAL_MENU_WIDTH, BUTTONS_ORDER, BUTTON_PARAMS, BlipEventTypes, BlipMenu, BrowserEvents, COLORS, DomUtils, FOLD_UNFOLD_BLOCK_HIDDEN_CLASS, Interactable, LINE_MODIFIERS_MAP, LineLevelParams, OVERFLOW_MENU_ADDITIONAL_WIDTH, TEXT_MODIFIERS, TOTAL_WIDTH, TextLevelParams, formatDate, getEditBlockTotalWidth, getMenuDom, getTotalWidth, renderBlipMenu, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  renderBlipMenu = require('./template').renderBlipMenu;

  _ref = require('../../editor/model'), TextLevelParams = _ref.TextLevelParams, LineLevelParams = _ref.LineLevelParams;

  formatDate = require('../../../share/utils/datetime').formatDate;

  BrowserEvents = require('../../utils/browser_events');

  DomUtils = require('../../utils/dom');

  Interactable = require('../../utils/interactable').Interactable;

  BlipEventTypes = require('../interactor/blip_events').BlipEventTypes;

  COLORS = [null, '#FFE066', '#B5EB5E', '#8AE5D6', '#AAB2F2', '#DAB6F2', '#F2A79D'];

  TEXT_MODIFIERS = {};

  TEXT_MODIFIERS[TextLevelParams.BOLD] = 'makeBoldButton';

  TEXT_MODIFIERS[TextLevelParams.ITALIC] = 'makeItalicButton';

  TEXT_MODIFIERS[TextLevelParams.UNDERLINED] = 'makeUnderlinedButton';

  TEXT_MODIFIERS[TextLevelParams.STRUCKTHROUGH] = 'makeStruckthroughButton';

  TEXT_MODIFIERS[TextLevelParams.BG_COLOR] = null;

  LINE_MODIFIERS_MAP = {};

  LINE_MODIFIERS_MAP[LineLevelParams.BULLETED] = 'makeBulletedListButton';

  LINE_MODIFIERS_MAP[LineLevelParams.NUMBERED] = 'makeNumberedListButton';

  BUTTONS_ORDER = ['makeUnderlinedButton', 'makeStruckthroughButton', 'delete', 'manageLinkButton', 'makeItalicButton', 'makeBoldButton', 'makeBulletedListButton', 'makeNumberedListButton', 'makeBgColorButton', 'clearFormattingButton', 'undoButton', 'redoButton', 'insertImageButton', 'insertFileButton', 'foldedByDefault'];

  FOLD_UNFOLD_BLOCK_HIDDEN_CLASS = 'fold-unfold-block-hidden';

  BUTTON_PARAMS = {
    changeMode: {
      selectionClass: 'js-change-mode',
      event: BlipEventTypes.CHANGE_MODE
    },
    undoButton: {
      hiddenClass: 'undo-button-hidden',
      selectionClass: 'js-undo',
      event: BlipEventTypes.UNDO
    },
    redoButton: {
      hiddenClass: 'redo-button-hidden',
      selectionClass: 'js-redo',
      event: BlipEventTypes.REDO
    },
    insertFileButton: {
      hiddenClass: 'insert-file-button-hidden',
      selectionClass: 'js-insert-file',
      event: BlipEventTypes.INSERT_FILE
    },
    insertImageButton: {
      hiddenClass: 'insert-image-button-hidden',
      selectionClass: 'js-insert-image',
      event: BlipEventTypes.INSERT_IMAGE
    },
    manageLinkButton: {
      hiddenClass: 'manage-link-button-hidden',
      selectionClass: 'js-manage-link',
      event: BlipEventTypes.MANAGE_LINK
    },
    makeBoldButton: {
      hiddenClass: 'bold-button-hidden',
      selectionClass: 'js-make-bold',
      event: BlipEventTypes.MAKE_BOLD
    },
    makeItalicButton: {
      hiddenClass: 'italic-button-hidden',
      selectionClass: 'js-make-italic',
      event: BlipEventTypes.MAKE_ITALIC
    },
    makeUnderlinedButton: {
      hiddenClass: 'underline-button-hidden',
      selectionClass: 'js-make-underlined',
      event: BlipEventTypes.MAKE_UNDERLINED
    },
    makeStruckthroughButton: {
      hiddenClass: 'struckthrough-button-hidden',
      selectionClass: 'js-make-struckthrough',
      event: BlipEventTypes.MAKE_STRUCKTHROUGH
    },
    makeBgColorButton: {
      hiddenClass: 'bg-color-button-hidden',
      selectionClass: 'js-make-background-color'
    },
    clearFormattingButton: {
      hiddenClass: 'clear-formatting-button-hidden',
      selectionClass: 'js-clear-formatting',
      event: BlipEventTypes.CLEAR_FORMATTING
    },
    makeBulletedListButton: {
      hiddenClass: 'bulleted-list-button-hidden',
      selectionClass: 'js-make-bulleted-list',
      event: BlipEventTypes.MAKE_BULLETED
    },
    makeNumberedListButton: {
      hiddenClass: 'numbered-list-button-hidden',
      selectionClass: 'js-make-numbered-list',
      event: BlipEventTypes.MAKE_NUMBERED
    },
    foldedByDefault: {
      hiddenClass: 'is-folded-by-default-button-hidden',
      selectionClass: 'js-is-folded-by-default',
      event: BlipEventTypes.SET_FOLDED_BY_DEFAULT
    },
    "delete": {
      hiddenClass: 'delete-button-hidden',
      selectionClass: 'js-delete-blip',
      event: BlipEventTypes.DELETE
    },
    copyLink: {
      selectionClass: 'js-copy-blip-link',
      event: BlipEventTypes.SHOW_BLIP_URL
    },
    foldAll: {
      selectionClass: 'js-hide-all-inlines',
      event: BlipEventTypes.FOLD_ALL
    },
    unfoldAll: {
      selectionClass: 'js-show-all-inlines',
      event: BlipEventTypes.UNFOLD_ALL
    },
    copyBlipButton: {
      selectionClass: 'js-copy-blip-button',
      event: BlipEventTypes.COPY_BLIP
    },
    pasteAsReply: {
      selectionClass: 'js-paste-after-blip-button',
      event: BlipEventTypes.PASTE_AS_REPLY
    },
    pasteAtCursor: {
      selectionClass: 'js-paste-at-cursor-button',
      event: BlipEventTypes.PASTE_AT_CURSOR
    },
    sendButton: {
      selectionClass: 'js-send-button',
      event: BlipEventTypes.SEND
    },
    playbackButton: {
      selectionClass: 'js-playback-button',
      event: BlipEventTypes.PLAYBACK
    }
  };

  OVERFLOW_MENU_ADDITIONAL_WIDTH = 60;

  ADDITIONAL_MENU_WIDTH = 15;

  TOTAL_WIDTH = null;

  getMenuDom = function() {
    var tmpEl;
    tmpEl = document.createElement('span');
    tmpEl.className = 'blip-menu';
    tmpEl.appendChild(DomUtils.parseFromString(renderBlipMenu()));
    return tmpEl;
  };

  getTotalWidth = function() {
    var b, buttons, editBlock, tmpEl, total, _i, _len;
    tmpEl = getMenuDom();
    document.body.appendChild(tmpEl);
    editBlock = tmpEl.getElementsByClassName('js-edit-block')[0];
    buttons = editBlock.children;
    total = 0;
    for (_i = 0, _len = buttons.length; _i < _len; _i++) {
      b = buttons[_i];
      total += b.offsetWidth;
    }
    document.body.removeChild(tmpEl);
    return total + ADDITIONAL_MENU_WIDTH;
  };

  getEditBlockTotalWidth = function() {
    if (TOTAL_WIDTH) return TOTAL_WIDTH;
    if (!DomUtils.isCssReady()) return 1;
    return TOTAL_WIDTH = getTotalWidth();
  };

  BlipMenu = (function(_super) {

    __extends(BlipMenu, _super);

    function BlipMenu() {
      this._handleBgColorButtonClick = __bind(this._handleBgColorButtonClick, this);
      this._hideColorPanel = __bind(this._hideColorPanel, this);
      this._handleClickWhileShowingColorPanel = __bind(this._handleClickWhileShowingColorPanel, this);
      this._bgColorButtonHandler = __bind(this._bgColorButtonHandler, this);
      this._resizeMenu = __bind(this._resizeMenu, this);
      this._handleGearWheelButtonClick = __bind(this._handleGearWheelButtonClick, this);
      this._handleClickForOtherMenu = __bind(this._handleClickForOtherMenu, this);
      this._handleButtonClick = __bind(this._handleButtonClick, this);
      var $editBlock;
      BlipMenu.__super__.constructor.call(this);
      this._hiddenEditButtons = [];
      this._container = getMenuDom();
      this._$container = $(this._container);
      this._editBlock = this._container.getElementsByClassName('js-edit-block')[0];
      this._readOnlyBlock = this._container.getElementsByClassName('js-read-only-block')[0];
      this._editBlockOtherBlipMenu = this._editBlock.getElementsByClassName('js-other-blipmenu-container')[0];
      this._readOnlyBlockOtherBlipMenu = this._readOnlyBlock.getElementsByClassName('js-other-blipmenu-container')[0];
      this._colorPanel = this._editBlock.getElementsByClassName('js-color-panel')[0];
      this._sendButton = this._editBlock.getElementsByClassName(BUTTON_PARAMS.sendButton.selectionClass)[0];
      this._foldAllButton = this._container.getElementsByClassName(BUTTON_PARAMS.foldAll.selectionClass);
      this._$bgColorButtonIcon = this._$container.find('.' + BUTTON_PARAMS.makeBgColorButton.selectionClass).find('.js-icon');
      this._$changeModeButton = this._$container.find('.' + BUTTON_PARAMS.changeMode.selectionClass);
      this._$foldedByDefaultButtons = this._$container.find('.' + BUTTON_PARAMS.foldedByDefault.selectionClass);
      $editBlock = $(this._editBlock);
      this._$undoButton = $editBlock.find('.' + BUTTON_PARAMS.undoButton.selectionClass);
      this._$redoButton = $editBlock.find('.' + BUTTON_PARAMS.redoButton.selectionClass);
      this._initButtons();
      BrowserEvents.addBlocker(this._container, BrowserEvents.MOUSE_DOWN_EVENT);
      BrowserEvents.addBlocker(this._container, BrowserEvents.MOUSE_UP_EVENT);
      BrowserEvents.addBlocker(this._container, BrowserEvents.CLICK_EVENT);
    }

    BlipMenu.prototype._initButtons = function() {
      this._$container.find('.js-make-background-color').click(this._handleBgColorButtonClick);
      this._$container.find('.js-gearwheel').click(this._handleGearWheelButtonClick);
      return this._$container.on('click', "button", this._handleButtonClick);
    };

    BlipMenu.prototype._getButtonBySelectionClass = function(button) {
      var key, props;
      if ((key = button.rzParamName) && (props = BUTTON_PARAMS[key])) return props;
      for (key in BUTTON_PARAMS) {
        props = BUTTON_PARAMS[key];
        if (DomUtils.hasClass(button, props.selectionClass)) {
          button.rzParamName = key;
          return props;
        }
      }
    };

    BlipMenu.prototype._handleButtonClick = function(e) {
      var button;
      button = this._getButtonBySelectionClass(e.currentTarget);
      if (button.event) {
        return this.__dispatchEvent(button.event, {
          event: e
        });
      }
    };

    BlipMenu.prototype._hideOtherMenu = function() {
      DomUtils.removeClass(this._container, 'show-other-menu');
      return document.removeEventListener(BrowserEvents.CLICK_EVENT, this._handleClickForOtherMenu, true);
    };

    BlipMenu.prototype._showOtherMenu = function() {
      DomUtils.addClass(this._container, 'show-other-menu');
      return document.addEventListener(BrowserEvents.CLICK_EVENT, this._handleClickForOtherMenu, true);
    };

    BlipMenu.prototype._handleClickForOtherMenu = function(e) {
      var target;
      target = e.target;
      if (this._editBlockOtherBlipMenu === target || this._readOnlyBlockOtherBlipMenu === target) {
        return;
      }
      if (DomUtils.contains(this._editBlockOtherBlipMenu, target)) return;
      if (DomUtils.contains(this._readOnlyBlockOtherBlipMenu, target)) return;
      e.stopPropagation();
      return this._hideOtherMenu();
    };

    BlipMenu.prototype._handleGearWheelButtonClick = function(e) {
      e.stopPropagation();
      if (DomUtils.hasClass(this._container, 'show-other-menu')) {
        return this._hideOtherMenu();
      } else {
        return this._showOtherMenu();
      }
    };

    BlipMenu.prototype._resizeMenu = function() {
      var blipWidth, menuWidth, _ref2, _ref3;
      menuWidth = getEditBlockTotalWidth();
      blipWidth = ((_ref2 = this._container.parentNode) != null ? (_ref3 = _ref2.parentNode) != null ? _ref3.offsetWidth : void 0 : void 0) || 0;
      if (menuWidth > blipWidth) {
        this._fitEditMenu(menuWidth - blipWidth);
      } else {
        this._fitEditMenu(0);
      }
      if (menuWidth + OVERFLOW_MENU_ADDITIONAL_WIDTH < blipWidth) {
        return DomUtils.removeClass(this._container, 'at-right');
      } else {
        return DomUtils.addClass(this._container, 'at-right');
      }
    };

    BlipMenu.prototype._getButtonToHide = function(index) {
      if (index >= BUTTONS_ORDER.length) return null;
      return BUTTON_PARAMS[BUTTONS_ORDER[index]];
    };

    BlipMenu.prototype._fitEditMenu = function(widthToHide) {
      var b, button, buttonsToHide, hiddenWidth, index, missedButtons, _i, _j, _len, _len2;
      hiddenWidth = 0;
      buttonsToHide = [];
      index = 0;
      while (hiddenWidth < widthToHide) {
        button = this._getButtonToHide(index);
        if (!button) break;
        buttonsToHide.push(button);
        hiddenWidth += 30;
        index += 1;
      }
      missedButtons = this._hiddenEditButtons.filter(function(b) {
        return buttonsToHide.indexOf(b) === -1;
      });
      for (_i = 0, _len = missedButtons.length; _i < _len; _i++) {
        b = missedButtons[_i];
        if (b.hiddenClass) DomUtils.removeClass(this._container, b.hiddenClass);
      }
      for (_j = 0, _len2 = buttonsToHide.length; _j < _len2; _j++) {
        b = buttonsToHide[_j];
        if (b.hiddenClass) DomUtils.addClass(this._container, b.hiddenClass);
      }
      return this._hiddenEditButtons = buttonsToHide;
    };

    BlipMenu.prototype._setPressed = function(buttonKey, isPressed) {
      var $element;
      $element = this._$container.find('.' + BUTTON_PARAMS[buttonKey].selectionClass);
      if (!$element) return;
      if (isPressed) {
        return $element.addClass('pressed');
      } else {
        return $element.removeClass('pressed');
      }
    };

    BlipMenu.prototype._updateLineButtonsState = function(params) {
      var buttonKey, key, _results;
      _results = [];
      for (key in LINE_MODIFIERS_MAP) {
        buttonKey = LINE_MODIFIERS_MAP[key];
        _results.push(this._setPressed(buttonKey, params[key] != null));
      }
      return _results;
    };

    BlipMenu.prototype._updateTextButtonsState = function(params) {
      var buttonKey, hasModifiers, key;
      hasModifiers = false;
      for (key in TEXT_MODIFIERS) {
        buttonKey = TEXT_MODIFIERS[key];
        if (buttonKey) this._setPressed(buttonKey, !!params[key]);
        hasModifiers || (hasModifiers = !!params[key]);
      }
      return this._updateBgColorButton(params[TextLevelParams.BG_COLOR]);
    };

    BlipMenu.prototype._updateBgColorButton = function(currentColor) {
      if (currentColor == null) currentColor = null;
      /*
              Обновляет цвет на фоне кнопки изменения цвета
      */
      this._currentBgColor = currentColor;
      if (currentColor) {
        return this._$bgColorButtonIcon.css('background-color', 'white');
      }
      return this._$bgColorButtonIcon.css('background-color', COLORS[this._lastColorChoice] || 'white');
    };

    BlipMenu.prototype._setBgColor = function(color) {
      if (color == null) color = null;
      return this.__dispatchEvent(BlipEventTypes.SET_BG_COLOR, {
        value: color
      });
    };

    BlipMenu.prototype._bgColorButtonHandler = function(choice) {
      var color;
      color = COLORS[choice];
      this._lastColorChoice = choice || 0;
      this._updateBgColorButton(color);
      this._setBgColor(color);
      return this._hideColorPanel();
    };

    BlipMenu.prototype._handleClickWhileShowingColorPanel = function(event) {
      var target;
      target = event.target;
      if (!(target === this._makeBgColorButton || target === this._colorPanel || $.contains(this._colorPanel, target))) {
        return this._hideColorPanel();
      }
    };

    BlipMenu.prototype._showColorPanel = function() {
      var choice, colorChoice, i,
        _this = this;
      if (!this._backgroundPanelInited) {
        i = 0;
        colorChoice = this._colorPanel.firstChild;
        while (colorChoice) {
          $(colorChoice).css('background-color', COLORS[i] || 'white').on('mousedown', (function(i) {
            return function() {
              return _this._bgColorButtonHandler(i);
            };
          })(i));
          colorChoice = colorChoice.nextSibling;
          i++;
        }
        this._backgroundPanelInited = true;
        this._lastColorChoice = COLORS.indexOf(this._currentBgColor || null);
      }
      if (this._lastColorChoice != null) {
        choice = this._colorPanel.childNodes[this._lastColorChoice];
      }
      $(this._colorPanel).find('.color-choice').removeClass('active');
      $(choice).addClass('active');
      this._colorPanel.style.display = 'block';
      window.addEventListener('mousedown', this._handleClickWhileShowingColorPanel, true);
      return window.addEventListener('keydown', this._hideColorPanel, true);
    };

    BlipMenu.prototype._hideColorPanel = function() {
      this._colorPanel.style.display = 'none';
      window.removeEventListener('mousedown', this._handleClickWhileShowingColorPanel, true);
      return window.removeEventListener('keydown', this._hideColorPanel, true);
    };

    BlipMenu.prototype._handleBgColorButtonClick = function(e) {
      var currentColor;
      e.stopPropagation();
      _gaq.push(['_trackEvent', 'Blip usage', 'Make text background colored']);
      currentColor = this._currentBgColor;
      if (currentColor || !this._lastColorChoice) {
        this._setBgColor();
        currentColor = null;
      } else {
        currentColor = COLORS[this._lastColorChoice];
        this._setBgColor(currentColor);
      }
      this._updateBgColorButton(currentColor);
      if (!$(this._colorPanel).is(':visible')) {
        this._showColorPanel(currentColor);
        return;
      }
      return this._hideColorPanel();
    };

    BlipMenu.prototype._updateFoldUnfoldButtons = function() {
      if (this._foldable) {
        return DomUtils.removeClass(this._container, FOLD_UNFOLD_BLOCK_HIDDEN_CLASS);
      } else {
        return DomUtils.addClass(this._container, FOLD_UNFOLD_BLOCK_HIDDEN_CLASS);
      }
    };

    BlipMenu.prototype._updateSendButton = function(text) {
      var lastSentStr;
      if (text == null) text = '';
      if (this._sendable) {
        DomUtils.removeClass(this._sendButton, 'hidden');
      } else {
        DomUtils.addClass(this._sendButton, 'hidden');
      }
      if (text) $(this._sendButton).text(text);
      if (this._lastSent) {
        if (this._lastSender) {
          lastSentStr = "Sent on " + (formatDate(this._lastSent)) + " by " + this._lastSender;
        } else {
          lastSentStr = "Automatically sent on " + (formatDate(this._lastSent));
        }
      } else {
        lastSentStr = 'Has not been sent yet';
      }
      return this._sendButton.title = lastSentStr;
    };

    BlipMenu.prototype._setCanEdit = function(canEdit) {
      this._canEdit = canEdit;
      if (canEdit) {
        DomUtils.removeClass(this._container, 'hide-copy-paste');
        DomUtils.removeClass(this._foldAllButton, 'start-blip-menu');
        this._$changeModeButton.show();
      } else {
        DomUtils.addClass(this._container, 'hide-copy-paste');
        DomUtils.addClass(this._foldAllButton, 'start-blip-menu');
        this._$changeModeButton.hide();
      }
      if (canEdit && !this._isRoot) {
        DomUtils.removeClass(this._container, 'is-folded-by-default-button-hidden-force');
        return DomUtils.removeClass(this._container, 'delete-button-hidden-force');
      } else {
        DomUtils.addClass(this._container, 'is-folded-by-default-button-hidden-force');
        return DomUtils.addClass(this._container, 'delete-button-hidden-force');
      }
    };

    BlipMenu.prototype._setDisabled = function($button, disabled) {
      if (disabled) {
        return $button.attr('disabled', 'disabled');
      } else {
        return $button.removeAttr('disabled');
      }
    };

    BlipMenu.prototype._setFoldedByDefault = function(folded) {
      if (folded === this._foldedByDefault) return;
      if (folded) {
        DomUtils.addClass(this._container, 'folded-by-default');
        this._$foldedByDefaultButtons.text('Hidden');
        this._$foldedByDefaultButtons.prop('title', 'This thread is collapsed by default. Click to change');
      } else {
        DomUtils.removeClass(this._container, 'folded-by-default');
        this._$foldedByDefaultButtons.text('Hide');
        this._$foldedByDefaultButtons.prop('title', 'Collapse this thread by default');
      }
      return this._foldedByDefault = folded;
    };

    BlipMenu.prototype._disableIdDependantButtons = function() {
      this._$container.find('.js-gearwheel').prop('disabled', true);
      return this._$container.find('.js-copy-blip-link').prop('disabled', true);
    };

    BlipMenu.prototype._enableIdDependantButtons = function() {
      this._$container.find('.js-gearwheel').prop('disabled', false);
      return this._$container.find('.js-copy-blip-link').prop('disabled', false);
    };

    BlipMenu.prototype.reset = function(params) {
      this._foldable = params.foldable;
      this._sendable = params.sendable;
      this._foldedByDefault = null;
      this._lastSent = params.lastSent;
      this._lastSender = params.lastSender;
      this._isRoot = params.isRoot;
      if (params.hasServerId) {
        this._enableIdDependantButtons();
      } else {
        this._disableIdDependantButtons();
      }
      this._setCanEdit(params.canEdit);
      this._setFoldedByDefault(params.foldedByDefault);
      this._hideOtherMenu();
      return this._updateSendButton('Send');
    };

    BlipMenu.prototype.setEditMode = function() {
      DomUtils.addClass(this._readOnlyBlock, 'hidden');
      DomUtils.removeClass(this._editBlock, 'hidden');
      this._resizeMenu();
      return $(window).on('resize resizeTopicByResizer', this._resizeMenu);
    };

    BlipMenu.prototype.setReadMode = function() {
      DomUtils.addClass(this._editBlock, 'hidden');
      DomUtils.removeClass(this._readOnlyBlock, 'hidden');
      $(window).off('resize resizeTopicByResizer', this._resizeMenu);
      return this._updateFoldUnfoldButtons();
    };

    BlipMenu.prototype.setFoldedByDefault = function(folded) {
      return this._setFoldedByDefault(folded);
    };

    BlipMenu.prototype.setCanEdit = function(canEdit) {
      return this._setCanEdit(canEdit);
    };

    BlipMenu.prototype.setLastSent = function(lastSent, lastSender) {
      if (lastSent === this._lastSent && lastSender === this._lastSender) return;
      this._lastSent = lastSent;
      this._lastSender = lastSender;
      return this._updateSendButton();
    };

    BlipMenu.prototype.setFoldable = function(foldable) {
      if (foldable === this._foldable) return;
      this._foldable = foldable;
      return this._updateFoldUnfoldButtons();
    };

    BlipMenu.prototype.setUndoButtonDisabled = function(disabled) {
      return this._setDisabled(this._$undoButton, disabled);
    };

    BlipMenu.prototype.setRedoButtonDisabled = function(disabled) {
      return this._setDisabled(this._$redoButton, disabled);
    };

    BlipMenu.prototype.setSendable = function(sendable) {
      if (sendable === this._sendable) return;
      this._sendable = sendable;
      return this._updateSendButton();
    };

    BlipMenu.prototype.updateSendButton = function(text) {
      return this._updateSendButton(text);
    };

    BlipMenu.prototype.setLineParams = function(params) {
      return this._updateLineButtonsState(params);
    };

    BlipMenu.prototype.setTextParams = function(params) {
      return this._updateTextButtonsState(params);
    };

    BlipMenu.prototype.getContainer = function() {
      return this._container;
    };

    BlipMenu.prototype.enableIdDependantButtons = function() {
      return this._enableIdDependantButtons();
    };

    BlipMenu.prototype.detach = function() {
      return $(window).off('resize resizeTopicByResizer', this._resizeMenu);
    };

    BlipMenu.prototype.destroy = function() {
      document.removeEventListener(BrowserEvents.CLICK_EVENT, this._handleMouseDownForOtherMenu, true);
      this.detach();
      delete this._editBlock;
      delete this._readOnlyBlock;
      delete this._editBlockOtherBlipMenu;
      delete this._readOnlyBlockOtherBlipMenu;
      delete this._colorPanel;
      delete this._$undoButton;
      delete this._$redoButton;
      delete this._sendButton;
      delete this._$changeModeButton;
      delete this._foldAllButton;
      delete this._$bgColorButtonIcon;
      delete this._container;
      this._$container.remove();
      delete this._$container;
      delete this._hiddenEditButtons;
      return delete this._$foldedByDefaultButtons;
    };

    return BlipMenu;

  })(Interactable);

  module.exports = {
    TEXT_MODIFIERS: TEXT_MODIFIERS,
    BlipMenu: BlipMenu
  };

}).call(this);

});

require.define("/lib/client/client/blip/menu/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var blipMenuTmpl, ck, copyBlipLinkPopup;

  ck = window.CoffeeKup;

  blipMenuTmpl = function() {
    div("js-read-only-block read-only-menu", function() {
      button("js-change-mode change-mode delimitered-right", {
        title: 'To edit mode (Ctrl+E)',
        onClick: "_gaq.push(['_trackEvent', 'Blip usage', 'To edit mode', 'top button']);"
      }, 'Edit');
      div('js-fold-unfold-block fold-unfold-block', function() {
        button("js-hide-all-inlines hide-all-inlines icon-button", {
          title: 'Hide comments (Ctrl+Shift+Up)'
        }, function() {
          return div('.icon', '');
        });
        return button('js-show-all-inlines show-all-inlines delimitered-right icon-button', {
          title: 'Show comments (Ctrl+Shift+Down)'
        }, function() {
          return div('.icon', '');
        });
      });
      button('js-copy-blip-link get-blip-link delimitered-right icon-button', {
        title: 'Get direct link'
      }, function() {
        return div('.icon', '');
      });
      button("js-is-folded-by-default is-folded-by-default delimitered-right icon-button", {
        title: 'Collapse this thread by default'
      }, 'Hide');
      button('js-delete-blip delete-blip delimitered-right icon-button', {
        title: 'Delete comment'
      }, function() {
        return div('icon', '');
      });
      return div('gearwheel-container', function() {
        button('js-gearwheel gearwheel icon-button', {
          title: 'Other'
        }, function() {
          return div('icon', '');
        });
        return div('js-other-blipmenu-container other-blipmenu-container other-blip-menu', function() {
          div('triangle', function() {
            return div(function() {
              return div('', '');
            });
          });
          div('list-menu-button', function() {
            return button('js-copy-blip-button copy-blip-button', {
              title: 'Copy comment'
            }, 'Copy comment');
          });
          div('.list-menu-button', function() {
            return button('js-paste-after-blip-button paste-as-reply', {
              title: 'Paste as reply'
            }, 'Paste as reply');
          });
          div('list-menu-button', function() {
            return button('js-paste-at-cursor-button paste-at-cursor', {
              title: 'Paste at cursor'
            }, 'Paste at cursor');
          });
          div('list-menu-button', function() {
            return button('js-copy-blip-link', {
              title: 'Copy link'
            }, 'Copy link');
          });
          return div('list-menu-button', function() {
            return button('js-playback-button', {
              title: 'Playback'
            }, 'Playback');
          });
        });
      });
    });
    return div('js-edit-block edit-menu', function() {
      button('js-change-mode change-mode delimitered-right', {
        title: 'Done, switch to read mode (Ctrl+E, Shift+Enter)',
        onMouseDown: "_gaq.push(['_trackEvent', 'Blip usage', 'To read mode', 'top button']);"
      }, 'Done');
      button("js-undo undo icon-button", {
        title: 'Undo (Ctrl+Z)'
      }, function() {
        return div('.icon', '');
      });
      button('js-redo redo delimitered-right icon-button', {
        title: 'Redo (Ctrl+Shift+Z, Ctrl+Y)'
      }, function() {
        return div('.icon', '');
      });
      button('js-manage-link add-url icon-button', {
        title: 'Insert link (Ctrl+L)'
      }, function() {
        return div('.icon', '');
      });
      button('js-insert-file insert-file icon-button', {
        title: 'Insert attachment'
      }, function() {
        return div('.icon', '');
      });
      button('js-insert-image insert-image delimitered-right icon-button', {
        title: 'Insert image'
      }, function() {
        return div('.icon', '');
      });
      button('js-make-bold make-bold icon-button', {
        title: 'Bold (Ctrl+B)'
      }, function() {
        return div('.icon', '');
      });
      button('js-make-italic italic icon-button', {
        title: 'Italic (Ctrl+I)'
      }, function() {
        return div('.icon', '');
      });
      button('js-make-underlined make-underlined icon-button', {
        title: 'Underline (Ctrl+U)'
      }, function() {
        return div('.icon', '');
      });
      button('js-make-struckthrough make-struckthrough icon-button', {
        title: 'Strikethrough'
      }, function() {
        return div('.icon', '');
      });
      span({
        style: 'position: relative;'
      }, function() {
        button('js-make-background-color make-background-color icon-button', {
          title: 'Text background color'
        }, function() {
          return div('js-icon icon', '');
        });
        return div('js-color-panel color-panel', function() {
          var i, _results;
          _results = [];
          for (i = 1; i <= 7; i++) {
            _results.push(button('color-choice', ''));
          }
          return _results;
        });
      });
      button('js-clear-formatting clear-formatting icon-button', {
        title: 'Clear formatting'
      }, function() {
        return div('icon', '');
      });
      button('js-make-bulleted-list bulleted icon-button', {
        title: 'Bulleted list'
      }, function() {
        return div('icon', '');
      });
      button('js-make-numbered-list numbered delimitered-right icon-button', {
        title: 'Numbered list'
      }, function() {
        return div('icon', '');
      });
      button("js-is-folded-by-default is-folded-by-default delimitered-right icon-button", {
        title: 'Collapse this thread by default'
      }, 'Hide');
      button('js-delete-blip delete-blip delimitered-right icon-button', {
        title: 'Delete comment'
      }, function() {
        return div('.icon', '');
      });
      return div('gearwheel-container', function() {
        button('js-gearwheel gearwheel icon-button', {
          title: 'Other'
        }, function() {
          return div('icon', '');
        });
        return div('js-other-blipmenu-container other-blipmenu-container other-blip-menu', function() {
          div('triangle', function() {
            return div(function() {
              return div('', '');
            });
          });
          div('list-menu-button', function() {
            return button('js-copy-blip-button copy-blip-button', {
              title: 'Copy comment'
            }, 'Copy comment');
          });
          div('list-menu-button', function() {
            return button('js-paste-after-blip-button paste-as-reply', {
              title: 'Paste as reply'
            }, 'Paste as reply');
          });
          div('list-menu-button', function() {
            return button('js-paste-at-cursor-button paste-at-cursor', {
              title: 'Paste at cursor'
            }, 'Paste at cursor');
          });
          div('list-menu-button', function() {
            return button('js-send-button send-message', {
              title: 'Send'
            }, 'Send');
          });
          div('list-menu-button', function() {
            return button('js-undo undo hidden', 'Undo');
          });
          div('list-menu-button', function() {
            return button('js-redo redo hidden', 'Redo');
          });
          div('list-menu-button', function() {
            return button('js-manage-link add-url hidden', 'Manage link');
          });
          div('list-menu-button', function() {
            return button('js-insert-file insert-file hidden', 'Insert file');
          });
          div('list-menu-button', function() {
            return button('js-insert-image insert-image hidden', 'Insert image');
          });
          div('list-menu-button', function() {
            return button('js-make-bold make-bold hidden', 'Make bold');
          });
          div('list-menu-button', function() {
            return button('js-make-italic italic hidden', 'Make italic');
          });
          div('list-menu-button', function() {
            return button('js-make-underlined make-underlined hidden', 'Make underlined');
          });
          div('list-menu-button', function() {
            return button('js-make-struckthrough make-struckthrough hidden', 'Make struckthrough');
          });
          div('list-menu-button', function() {
            return button('js-make-bulleted-list bulleted hidden', 'Make bulleted list');
          });
          div('list-menu-button', function() {
            return button('js-make-numbered-list numbered hidden', 'Make numbered list');
          });
          div('list-menu-button', function() {
            return button('js-clear-formatting clear-formatting hidden', 'Clear formatting');
          });
          div('list-menu-button', function() {
            return button('js-is-folded-by-default is-folded-by-default hidden', 'Hidden');
          });
          div('list-menu-button', function() {
            return button('js-delete-blip delete-blip hidden', 'Delete comment');
          });
          div('list-menu-button', function() {
            return button('js-copy-blip-link', {
              title: 'Copy link'
            }, 'Copy link');
          });
          return div('list-menu-button', function() {
            return button('js-playback-button', {
              title: 'Playback'
            }, 'Playback');
          });
        });
      });
    });
  };

  copyBlipLinkPopup = function() {
    return div('js-copy-blip-link.copy-blip-link', function() {
      return input('.js-blip-link', {
        value: h(this.url),
        readonly: "readonly"
      });
    });
  };

  exports.renderCopyBlipLinkPopup = ck.compile(copyBlipLinkPopup);

  exports.renderBlipMenu = ck.compile(blipMenuTmpl);

}).call(this);

});

require.define("/lib/client/client/playback/blip_view_model.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipViewModel, DIRECTION_BACK, DIRECTION_FORWARD, FAST_MODE_THRESHOLD, MODE_FAST, MODE_ONE_OP, MODE_TO_DATE, NO_MORE_OPERATIONS, PlaybackBlipModel, PlaybackBlipView, PlaybackBlipViewModel, SHOULD_LOAD_NEXT_PART, async, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BlipViewModel = require('../blip').BlipViewModel;

  PlaybackBlipView = require('./blip_view').PlaybackBlipView;

  PlaybackBlipModel = require('./blip_model').PlaybackBlipModel;

  _ref = require('./constants'), NO_MORE_OPERATIONS = _ref.NO_MORE_OPERATIONS, SHOULD_LOAD_NEXT_PART = _ref.SHOULD_LOAD_NEXT_PART;

  async = require('async');

  DIRECTION_FORWARD = 1;

  DIRECTION_BACK = 2;

  MODE_ONE_OP = 1;

  MODE_TO_DATE = 2;

  MODE_FAST = 3;

  FAST_MODE_THRESHOLD = 3000;

  PlaybackBlipViewModel = (function(_super) {

    __extends(PlaybackBlipViewModel, _super);

    function PlaybackBlipViewModel() {
      this._loadNextPart = __bind(this._loadNextPart, this);
      this.discoverBack = __bind(this.discoverBack, this);
      this.discoverForward = __bind(this.discoverForward, this);
      PlaybackBlipViewModel.__super__.constructor.apply(this, arguments);
    }

    PlaybackBlipViewModel.prototype._init = function(waveViewModel, _blipProcessor, blipData, container, parentBlip, isRead, waveId, timestamp, title) {
      this._blipProcessor = _blipProcessor;
      return PlaybackBlipViewModel.__super__._init.call(this, waveViewModel, this._blipProcessor, blipData, container, parentBlip, isRead, waveId, timestamp, title);
    };

    PlaybackBlipViewModel.prototype.__initView = function(waveViewModel, blipProcessor, model, timestamp, container, parentBlip, isRead) {
      return this.__view = new PlaybackBlipView(waveViewModel, blipProcessor, this, model, timestamp, container, parentBlip, isRead);
    };

    PlaybackBlipViewModel.prototype._initModel = function(blipData, waveId, isRead, title) {
      return this.__model = this._model = new PlaybackBlipModel(blipData, waveId, isRead, title);
    };

    PlaybackBlipViewModel.prototype.getWave = function() {
      return this._waveViewModel;
    };

    PlaybackBlipViewModel.prototype.executeOneForwardOp = function() {
      return this._execute(DIRECTION_FORWARD, MODE_ONE_OP);
    };

    PlaybackBlipViewModel.prototype.executeOneBackOp = function() {
      return this._execute(DIRECTION_BACK, MODE_ONE_OP);
    };

    PlaybackBlipViewModel.prototype.playToDate = function(date) {
      var currentDate;
      currentDate = this._model.getCurrentDate();
      if (!currentDate) return;
      if (date > currentDate) {
        return this._execute(DIRECTION_FORWARD, MODE_TO_DATE, date);
      } else {
        return this._execute(DIRECTION_BACK, MODE_TO_DATE, date);
      }
    };

    PlaybackBlipViewModel.prototype.executeFastForward = function(date) {
      return this._execute(DIRECTION_FORWARD, MODE_FAST, date);
    };

    PlaybackBlipViewModel.prototype.executeFastBack = function(date) {
      return this._execute(DIRECTION_BACK, MODE_FAST, date);
    };

    PlaybackBlipViewModel.prototype._execute = function(direction, mode, date) {
      var checkDate, checkFirstTime, discoverFunc, fastModeTest, index, isFirstTime, lastDate, lastOp, nextStepErr, oneOpModeTest, task, toDateModeTest,
        _this = this;
      index = null;
      lastOp = null;
      lastDate = null;
      nextStepErr = null;
      isFirstTime = true;
      checkFirstTime = function() {
        if (isFirstTime) {
          isFirstTime = false;
          return true;
        }
        return false;
      };
      checkDate = function(opDate) {
        if (!isFinite(date)) return true;
        if (direction === DIRECTION_FORWARD) {
          return opDate <= date;
        } else {
          return opDate >= date;
        }
      };
      oneOpModeTest = function() {
        var opDate;
        if (checkFirstTime()) return true;
        opDate = _this._getOpDate(lastOp);
        _this._applyToModelAndView(direction, opDate, nextStepErr);
        return false;
      };
      toDateModeTest = function() {
        var continueIteration, opDate;
        if (checkFirstTime()) return true;
        opDate = _this._getOpDate(lastOp);
        continueIteration = checkDate(opDate);
        if (continueIteration) {
          _this._applyToModelAndView(direction, opDate, nextStepErr);
        }
        return continueIteration;
      };
      fastModeTest = function() {
        var continueIteration, delta, opDate;
        if (checkFirstTime()) return true;
        opDate = _this._getOpDate(lastOp);
        continueIteration = checkDate(opDate);
        if (lastDate) {
          delta = Math.abs(opDate - lastDate);
          continueIteration = delta < FAST_MODE_THRESHOLD;
        }
        lastDate = opDate;
        if (continueIteration) {
          _this._applyToModelAndView(direction, opDate, nextStepErr);
        }
        return continueIteration;
      };
      discoverFunc = direction === DIRECTION_FORWARD ? this.discoverForward : this.discoverBack;
      task = function(callback) {
        return discoverFunc(index, function(err, _nextStepErr, op, newIndex) {
          if (err) return callback(err);
          index = newIndex;
          lastOp = op;
          nextStepErr = _nextStepErr;
          return callback();
        });
      };
      if (mode === MODE_ONE_OP) {
        return async.whilst(oneOpModeTest, task, function() {});
      } else if (mode === MODE_TO_DATE) {
        return async.whilst(toDateModeTest, task, function() {});
      } else if (mode === MODE_FAST) {
        return async.whilst(fastModeTest, task, function() {});
      }
    };

    PlaybackBlipViewModel.prototype._applyToModelAndView = function(direction, date, nextStepErr) {
      var rootBlipView, view;
      view = this.getView();
      rootBlipView = this._waveViewModel.getRootBlipView();
      if (direction === DIRECTION_FORWARD) {
        this._model.forward();
        if (rootBlipView != null) rootBlipView.switchBackButtonsState(false);
        if (nextStepErr === NO_MORE_OPERATIONS) {
          if (view != null) view.switchForwardButtonsState(true);
        }
      } else {
        this._model.back();
        if (rootBlipView != null) rootBlipView.switchForwardButtonsState(false);
        if (nextStepErr === NO_MORE_OPERATIONS) {
          if (view != null) view.switchBackButtonsState(true);
        }
      }
      return rootBlipView != null ? rootBlipView.setCalendarDate(date) : void 0;
    };

    PlaybackBlipViewModel.prototype._getOpDate = function(op) {
      return new Date(op.meta.ts * 1000);
    };

    PlaybackBlipViewModel.prototype.discoverForward = function(index, callback) {
      return callback.apply(null, this._model.getNextOp(index));
    };

    PlaybackBlipViewModel.prototype.discoverBack = function(index, callback) {
      var err, newIndex, nextStepErr, op, _ref2,
        _this = this;
      _ref2 = this._model.getPrevOp(index), err = _ref2[0], nextStepErr = _ref2[1], op = _ref2[2], newIndex = _ref2[3];
      if (!err) return callback(null, nextStepErr, op, newIndex);
      if (err === NO_MORE_OPERATIONS) {
        return callback(err);
      } else if (err === SHOULD_LOAD_NEXT_PART) {
        return this._loadNextPart(this._model.getOpsCount(), function(err) {
          if (err) return callback(err);
          return _this.discoverBack(index, callback);
        });
      }
    };

    PlaybackBlipViewModel.prototype._loadNextPart = function(offset, callback) {
      var view,
        _this = this;
      view = this._waveViewModel.getRootBlipView();
      if (view != null) view.showOperationLoadingSpinner();
      return this._blipProcessor.getPlaybackOps(this._model.getServerId(), offset, function(err, ops) {
        if (view != null) view.hideOperationLoadingSpinner();
        if (err) return callback(err);
        _this._model.appendOps(ops);
        return callback();
      });
    };

    PlaybackBlipViewModel.prototype.getOriginalBlip = function() {
      return this._waveViewModel.getOriginalBlip(this.getServerId());
    };

    return PlaybackBlipViewModel;

  })(BlipViewModel);

  module.exports = {
    PlaybackBlipViewModel: PlaybackBlipViewModel
  };

}).call(this);

});

require.define("/lib/client/client/playback/blip_view.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipView, DOM, PlaybackBlipView, PlaybackInteractor,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  BlipView = require('../blip/view').BlipView;

  PlaybackInteractor = require('./interactor').PlaybackInteractor;

  DOM = require('../utils/dom');

  PlaybackBlipView = (function(_super) {

    __extends(PlaybackBlipView, _super);

    function PlaybackBlipView() {
      PlaybackBlipView.__super__.constructor.apply(this, arguments);
    }

    PlaybackBlipView.prototype._addRootBlipClasses = function() {
      return DOM.addClass(this._blipContainer, 'root-blip');
    };

    PlaybackBlipView.prototype._initBlipEventsInteractor = function() {
      return this._interactor = new PlaybackInteractor(this._blipViewModel, this);
    };

    PlaybackBlipView.prototype._isFolded = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.isRoot()) return false;
      return PlaybackBlipView.__super__._isFolded.apply(this, args);
    };

    PlaybackBlipView.prototype.attachPlaybackRootMenu = function(menu) {
      if (!this.isRoot()) return;
      this._interactor.attachMenu(menu, this._menuContainer, {});
      return DOM.addClass(this._menuContainer, 'active');
    };

    PlaybackBlipView.prototype.setReadState = function() {};

    PlaybackBlipView.prototype.markActive = function() {
      if (this.isRoot()) return;
      return PlaybackBlipView.__super__.markActive.call(this);
    };

    PlaybackBlipView.prototype.unmarkActive = function() {
      if (this.isRoot()) return;
      return PlaybackBlipView.__super__.unmarkActive.call(this);
    };

    PlaybackBlipView.prototype.setCalendarDate = function(date) {
      var _ref;
      return (_ref = this._interactor) != null ? _ref.setCalendarDate(date) : void 0;
    };

    PlaybackBlipView.prototype.setCalendarDateIfGreater = function(date) {
      var _ref;
      return (_ref = this._interactor) != null ? _ref.setCalendarDateIfGreater(date) : void 0;
    };

    PlaybackBlipView.prototype.showOperationLoadingSpinner = function() {
      var _ref;
      return (_ref = this._interactor) != null ? _ref.showOperationLoadingSpinner() : void 0;
    };

    PlaybackBlipView.prototype.hideOperationLoadingSpinner = function() {
      var _ref;
      return (_ref = this._interactor) != null ? _ref.hideOperationLoadingSpinner() : void 0;
    };

    PlaybackBlipView.prototype.switchForwardButtonsState = function(isDisable) {
      var _ref;
      return (_ref = this._interactor) != null ? _ref.switchForwardButtonsState(isDisable) : void 0;
    };

    PlaybackBlipView.prototype.switchBackButtonsState = function(isDisable) {
      var _ref;
      return (_ref = this._interactor) != null ? _ref.switchBackButtonsState(isDisable) : void 0;
    };

    return PlaybackBlipView;

  })(BlipView);

  module.exports = {
    PlaybackBlipView: PlaybackBlipView
  };

}).call(this);

});

require.define("/lib/client/client/playback/interactor.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var CalendarPopup, DateTimePicker, EventProcessor, Interactable, PlaybackInteractor, PopupContent, ck, formatAsClientDate, formatAsClientTime, fromClientToDatetime, popup, renderCalendarPopup, _ref, _ref2,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  Interactable = require('../utils/interactable').Interactable;

  EventProcessor = require('./events').EventProcessor;

  _ref = require('../popup'), PopupContent = _ref.PopupContent, popup = _ref.popup;

  DateTimePicker = require('../utils/date_time_picker').DateTimePicker;

  _ref2 = require('../../share/utils/date_converter'), formatAsClientDate = _ref2.formatAsClientDate, formatAsClientTime = _ref2.formatAsClientTime, fromClientToDatetime = _ref2.fromClientToDatetime;

  ck = window.CoffeeKup;

  PlaybackInteractor = (function() {

    function PlaybackInteractor(_blipViewModel, _blipView) {
      this._blipViewModel = _blipViewModel;
      this._blipView = _blipView;
      this._onCalendarChange = __bind(this._onCalendarChange, this);
      this._handleEvent = __bind(this._handleEvent, this);
      this._interactables = [];
    }

    PlaybackInteractor.prototype._handleEvent = function(event) {
      if (!(EventProcessor[event.type] != null)) {
        if (typeof console.trace === "function") console.trace();
        return console.warn("Event '" + event.type + "' is not supported");
      }
      try {
        return EventProcessor[event.type](this, event.args);
      } catch (e) {
        return console.error('Failed to handle event', e);
      }
    };

    PlaybackInteractor.prototype._attach = function(interactable) {
      if (this._interactables.indexOf(interactable) >= 0) return;
      interactable.on(Interactable.EVENT, this._handleEvent);
      return this._interactables.push(interactable);
    };

    PlaybackInteractor.prototype._detach = function(interactable) {
      var index;
      if ((index = this._interactables.indexOf(interactable)) < 0) return;
      this._interactables[index].removeListener(Interactable.EVENT, this._handleEvent);
      return this._interactables.splice(index, 1);
    };

    PlaybackInteractor.prototype._attachMenu = function(blipMenu, placeHolder, params) {
      if (this._blipMenu) return;
      placeHolder.appendChild(blipMenu.getContainer());
      blipMenu.reset(params);
      this._attach(blipMenu);
      this._blipMenu = blipMenu;
      if (!this._blipViewModel.getOriginalBlip()) {
        return this._blipMenu.disableReplaceButton();
      }
    };

    PlaybackInteractor.prototype._detachMenu = function() {
      var menuElement, _ref3;
      if (!this._blipMenu) return;
      menuElement = this._blipMenu.getContainer();
      if ((_ref3 = menuElement.parentNode) != null) _ref3.removeChild(menuElement);
      this._detach(this._blipMenu);
      return delete this._blipMenu;
    };

    PlaybackInteractor.prototype.setCanEdit = function() {};

    PlaybackInteractor.prototype.setEditableMode = function() {};

    PlaybackInteractor.prototype.setFoldable = function() {};

    PlaybackInteractor.prototype.updateEditingModifiers = function() {};

    PlaybackInteractor.prototype.enableIdDependantButtons = function() {};

    PlaybackInteractor.prototype.setSendable = function() {};

    PlaybackInteractor.prototype.setLastSent = function() {};

    PlaybackInteractor.prototype.updateFoldedByDefault = function() {};

    PlaybackInteractor.prototype.getBlip = function() {
      return this._blipView;
    };

    PlaybackInteractor.prototype.attachMenu = function(blipMenu, placeHolder, params) {
      return this._attachMenu(blipMenu, placeHolder, params);
    };

    PlaybackInteractor.prototype.detachMenu = function() {
      return this._detachMenu();
    };

    PlaybackInteractor.prototype.attach = function(interactable) {
      return this._attach(interactable);
    };

    PlaybackInteractor.prototype.detach = function(interactable) {
      return this._detach(interactable);
    };

    PlaybackInteractor.prototype.destroy = function() {
      var interactable, _i, _len, _ref3;
      this._detachMenu();
      delete this._blipViewModel;
      delete this._blipView;
      delete this._blipMenu;
      _ref3 = this._interactables;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        interactable = _ref3[_i];
        interactable.removeListener(Interactable.EVENT, this._handleEvent);
      }
      return delete this._interactables;
    };

    PlaybackInteractor.prototype.copy = function() {
      this._blipView.renderRecursively();
      return this._blipView.getParent().getEditor().copyElementToBuffer(this._blipView.getContainer());
    };

    PlaybackInteractor.prototype.forward = function() {
      return this._blipViewModel.getWave().forward();
    };

    PlaybackInteractor.prototype.back = function() {
      return this._blipViewModel.getWave().back();
    };

    PlaybackInteractor.prototype.fastForward = function() {
      return this._blipViewModel.getWave().fastForward();
    };

    PlaybackInteractor.prototype.fastBack = function() {
      return this._blipViewModel.getWave().fastBack();
    };

    PlaybackInteractor.prototype._onCalendarChange = function(date) {
      return this._blipViewModel.getWave().playToDate(date);
    };

    PlaybackInteractor.prototype.calendar = function(target) {
      var calendarPopup;
      if (popup.getContainer()) return;
      calendarPopup = new CalendarPopup(this._currentCalendarDate || new Date(), this._onCalendarChange);
      popup.render(calendarPopup, target);
      return popup.show();
    };

    PlaybackInteractor.prototype.replace = function() {
      var opToInsert, originalBlip, originalBlipView;
      originalBlip = this._blipViewModel.getOriginalBlip();
      if (!originalBlip) return;
      originalBlipView = originalBlip.getView();
      this._blipView.renderRecursively();
      opToInsert = this._blipView.getParent().getEditor().getCopyElementOp(this._blipView.getContainer());
      return originalBlipView.getParent().getEditor().pasteBlipOpAfter(originalBlip.getContainer(), opToInsert);
    };

    PlaybackInteractor.prototype.showOperationLoadingSpinner = function() {
      if (!this._blipMenu) return;
      return this._blipMenu.showOperationLoadingSpinner();
    };

    PlaybackInteractor.prototype.hideOperationLoadingSpinner = function() {
      if (!this._blipMenu) return;
      return this._blipMenu.hideOperationLoadingSpinner();
    };

    PlaybackInteractor.prototype.setCalendarDate = function(date) {
      if (!date) return;
      this._currentCalendarDate = date;
      if (!this._blipMenu) return;
      return this._blipMenu.setCalendarDate(date);
    };

    PlaybackInteractor.prototype.setCalendarDateIfGreater = function(date) {
      if (!this._currentCalendarDate) return this.setCalendarDate(date);
      if (this._currentCalendarDate > date) return;
      return this.setCalendarDate(date);
    };

    PlaybackInteractor.prototype.switchForwardButtonsState = function(isDisable) {
      if (!this._blipMenu) return;
      return this._blipMenu.switchForwardButtonsState(isDisable);
    };

    PlaybackInteractor.prototype.switchBackButtonsState = function(isDisable) {
      if (!this._blipMenu) return;
      return this._blipMenu.switchBackButtonsState(isDisable);
    };

    return PlaybackInteractor;

  })();

  renderCalendarPopup = ck.compile(function() {
    return div('.playback-calendar-popup', function() {
      var dateParams, timeParams;
      dateParams = {
        type: 'text',
        tabindex: '1',
        value: this.date
      };
      timeParams = {
        type: 'text',
        tabindex: '2',
        value: this.time
      };
      div('', function() {
        div('.date-icon.js-date-icon', '');
        return input('.js-date-input', dateParams);
      });
      return div('', function() {
        div('.time-icon.js-time-icon', '');
        return input('.js-time-input', timeParams);
      });
    });
  });

  CalendarPopup = (function(_super) {

    __extends(CalendarPopup, _super);

    function CalendarPopup(_currentDate, _onChange) {
      this._currentDate = _currentDate;
      this._onChange = _onChange;
      this._dateTimePicker = new DateTimePicker();
      this._render();
    }

    CalendarPopup.prototype._render = function() {
      var $container, date, dateInput, time, timeInput,
        _this = this;
      this._container = document.createElement('span');
      date = formatAsClientDate(this._currentDate);
      time = formatAsClientTime(this._currentDate);
      $(this._container).append(renderCalendarPopup({
        date: date,
        time: time
      }));
      $container = $(this._container);
      dateInput = $container.find('.js-date-input')[0];
      timeInput = $container.find('.js-time-input')[0];
      this._dateTimePicker.init(dateInput, timeInput);
      $container.find('.js-date-icon').click(function() {
        return $(dateInput).focus();
      });
      $container.find('.js-time-icon').click(function() {
        return $(timeInput).focus();
      });
      return this._dateTimePicker.on('change', function(date, time) {
        return _this._onChange(fromClientToDatetime(date, time));
      });
    };

    CalendarPopup.prototype.destroy = function() {
      var _ref3;
      if ((_ref3 = this._dateTimePicker) != null) _ref3.destroy();
      delete this._dateTimePicker;
      $(this._container).remove();
      return delete this._container;
    };

    CalendarPopup.prototype.getContainer = function() {
      if (!this._container) this._render();
      return this._container;
    };

    CalendarPopup.prototype.shouldCloseWhenClicked = function(element) {
      return true;
    };

    return CalendarPopup;

  })(PopupContent);

  module.exports = {
    PlaybackInteractor: PlaybackInteractor
  };

}).call(this);

});

require.define("/lib/client/client/playback/events.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BrowserEvents, EventProcessor, PlaybackEventTypes;

  BrowserEvents = require('../../utils/browser_events');

  PlaybackEventTypes = {
    CALENDAR: '_calendar',
    FAST_BACK: '_fast_back',
    BACK: '_back',
    FORWARD: '_forward',
    FAST_FORWARD: '_fast_forward',
    COPY: '_copy',
    REPLACE: '_replace'
  };

  EventProcessor = (function() {

    function EventProcessor() {}

    EventProcessor.prototype._calendar = function(interactor, args) {
      var _ref;
      return interactor.calendar((_ref = args.event) != null ? _ref.target : void 0);
    };

    EventProcessor.prototype._fast_back = function(interactor) {
      return interactor.fastBack();
    };

    EventProcessor.prototype._back = function(interactor) {
      return interactor.back();
    };

    EventProcessor.prototype._forward = function(interactor) {
      return interactor.forward();
    };

    EventProcessor.prototype._fast_forward = function(interactor) {
      return interactor.fastForward();
    };

    EventProcessor.prototype._copy = function(interactor) {
      return interactor.copy();
    };

    EventProcessor.prototype._replace = function(interactor) {
      return interactor.replace();
    };

    return EventProcessor;

  })();

  module.exports = {
    PlaybackEventTypes: PlaybackEventTypes,
    EventProcessor: new EventProcessor()
  };

}).call(this);

});

require.define("/lib/client/client/playback/blip_model.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipModel, NO_MORE_OPERATIONS, PlaybackBlipModel, SHOULD_LOAD_NEXT_PART, ftextShareType, jsonShareType, _ref,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BlipModel = require('../blip/model').BlipModel;

  ftextShareType = sharejs.types.ftext;

  jsonShareType = sharejs.types.json;

  _ref = require('./constants'), NO_MORE_OPERATIONS = _ref.NO_MORE_OPERATIONS, SHOULD_LOAD_NEXT_PART = _ref.SHOULD_LOAD_NEXT_PART;

  PlaybackBlipModel = (function(_super) {

    __extends(PlaybackBlipModel, _super);

    function PlaybackBlipModel() {
      PlaybackBlipModel.__super__.constructor.apply(this, arguments);
    }

    PlaybackBlipModel.prototype._init = function(doc, waveId, isRead, title) {
      PlaybackBlipModel.__super__._init.call(this, doc, waveId, isRead, title);
      this._no_more_operations = false;
      this._ops = [];
      return this._playbackPointer = -1;
    };

    PlaybackBlipModel.prototype.getOpsCount = function() {
      return this._ops.length;
    };

    PlaybackBlipModel.prototype.getLastOpDate = function() {
      if (this._ops.length === 0) return;
      return new Date(this._ops[this._ops.length - 1].meta.ts * 1000);
    };

    PlaybackBlipModel.prototype.getCurrentDate = function() {
      var op;
      if (this._ops.length === 0) return;
      if (this._playbackPointer < 0) {
        op = this._ops[0];
      } else if (this._playbackPointer === this._ops.length - 1) {
        op = this._ops[this._ops.length - 1];
      } else {
        op = this._ops[this._playbackPointer];
      }
      return new Date(op.meta.ts * 1000);
    };

    PlaybackBlipModel.prototype.appendOps = function(ops) {
      if (!ops || ops.length === 0) {
        this._no_more_operations = true;
        return;
      }
      this._ops = ops.concat(this._ops);
      return this._playbackPointer += ops.length;
    };

    PlaybackBlipModel.prototype.back = function() {
      var invertedOp, op, properType;
      if (this._playbackPointer < 0) return;
      op = this._ops[this._playbackPointer];
      if (op.op.length === 0) {
        invertedOp = [];
      } else {
        properType = ftextShareType.isFormattedTextOperation(op.op[0]) ? ftextShareType : jsonShareType;
        invertedOp = properType.invert(op.op);
      }
      this._doc._onOpReceived(this._convertOp(invertedOp));
      return this._playbackPointer--;
    };

    PlaybackBlipModel.prototype.forward = function() {
      var op;
      if (this._playbackPointer === this._ops.length - 1) return;
      this._playbackPointer++;
      op = this._ops[this._playbackPointer];
      return this._doc._onOpReceived(this._convertOp(op.op));
    };

    PlaybackBlipModel.prototype.getPrevOp = function(index) {
      var err, nextStepErr, nextStepIndex, nextStepOp, op, _ref2, _ref3;
      _ref2 = this._getPrevOp(index), err = _ref2[0], op = _ref2[1], index = _ref2[2];
      _ref3 = this._getPrevOp(index), nextStepErr = _ref3[0], nextStepOp = _ref3[1], nextStepIndex = _ref3[2];
      return [err, nextStepErr, op, index];
    };

    PlaybackBlipModel.prototype._getPrevOp = function(index) {
      if (!(index != null)) index = this._playbackPointer;
      if (index < 0) {
        if (this._no_more_operations || this._ops.length === 0 || this._ops[0].v === 0) {
          return [NO_MORE_OPERATIONS, null];
        } else {
          return [SHOULD_LOAD_NEXT_PART, null];
        }
      }
      return [null, this._ops[index], index - 1];
    };

    PlaybackBlipModel.prototype.getNextOp = function(index) {
      var err, nextStepErr, nextStepIndex, nextStepOp, op, _ref2, _ref3;
      _ref2 = this._getNextOp(index), err = _ref2[0], op = _ref2[1], index = _ref2[2];
      _ref3 = this._getNextOp(index), nextStepErr = _ref3[0], nextStepOp = _ref3[1], nextStepIndex = _ref3[2];
      return [err, nextStepErr, op, index];
    };

    PlaybackBlipModel.prototype._getNextOp = function(index) {
      if (!(index != null)) index = this._playbackPointer + 1;
      if (index >= this._ops.length) return [NO_MORE_OPERATIONS, null];
      return [null, this._ops[index], index + 1];
    };

    PlaybackBlipModel.prototype._convertOp = function(op) {
      return {
        v: this._doc.version,
        meta: {},
        doc: this.id,
        op: op
      };
    };

    return PlaybackBlipModel;

  })(BlipModel);

  module.exports = {
    PlaybackBlipModel: PlaybackBlipModel
  };

}).call(this);

});

require.define("/lib/client/client/playback/constants.js",function(require,module,exports,__dirname,__filename,process,global){(function() {

  module.exports = {
    NO_MORE_OPERATIONS: 1,
    SHOULD_LOAD_NEXT_PART: 2
  };

}).call(this);

});

require.define("/lib/client/client/playback/wave_view_model.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var DIRECTION_BACK, DIRECTION_FORWARD, PlaybackBlipMenu, PlaybackWaveView, PlaybackWaveViewModel, WaveViewModel, async, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  WaveViewModel = require('../wave/index').WaveViewModel;

  PlaybackBlipMenu = require('./blip_menu').PlaybackBlipMenu;

  PlaybackWaveView = require('./wave_view').PlaybackWaveView;

  async = require('async');

  _ = require('underscore');

  DIRECTION_FORWARD = 1;

  DIRECTION_BACK = 2;

  PlaybackWaveViewModel = (function(_super) {

    __extends(PlaybackWaveViewModel, _super);

    function PlaybackWaveViewModel() {
      var args, _i, _originalWaveViewModel, _rootBlipId;
      args = 3 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 2) : (_i = 0, []), _originalWaveViewModel = arguments[_i++], _rootBlipId = arguments[_i++];
      this._originalWaveViewModel = _originalWaveViewModel;
      this._rootBlipId = _rootBlipId;
      this._initRootBlipCalendar = __bind(this._initRootBlipCalendar, this);
      PlaybackWaveViewModel.__super__.constructor.apply(this, args);
      this._blipMenu = new PlaybackBlipMenu();
    }

    PlaybackWaveViewModel.prototype.__initView = function(processor, participants, container) {
      return this.__view = new PlaybackWaveView(this, processor, participants, container, this._originalWaveViewModel.getView(), this._rootBlipId);
    };

    PlaybackWaveViewModel.prototype._subscribe = function() {};

    PlaybackWaveViewModel.prototype._subscribeBlip = function(blip) {};

    PlaybackWaveViewModel.prototype.getOriginalBlip = function(id) {
      return this._originalWaveViewModel.getBlipByServerId(id);
    };

    PlaybackWaveViewModel.prototype.setBlipAsLoaded = function(blip) {
      var view;
      PlaybackWaveViewModel.__super__.setBlipAsLoaded.call(this, blip);
      view = blip.getView();
      if (view.isRoot()) {
        view.attachPlaybackRootMenu(new PlaybackBlipMenu({
          isRoot: true
        }));
        view.setCursor();
        view.setCursorToStart();
        this.getView().runCheckRange();
        this._rootBlipView = view;
        this._originalWaveViewModel.getView().unlinkActiveBlip();
      }
      return this._initRootBlipCalendar();
    };

    PlaybackWaveViewModel.prototype._initRootBlipCalendar = function() {
      var blip, id, _ref, _results;
      if (!this._rootBlipView) return;
      _ref = this._loadedBlips;
      _results = [];
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        blip = _ref[id];
        _results.push(this._rootBlipView.setCalendarDateIfGreater(blip.getModel().getLastOpDate()));
      }
      return _results;
    };

    PlaybackWaveViewModel.prototype.getRootBlipView = function() {
      return this._rootBlipView;
    };

    PlaybackWaveViewModel.prototype.forward = function() {
      return this._oneOp(DIRECTION_FORWARD);
    };

    PlaybackWaveViewModel.prototype.back = function() {
      return this._oneOp(DIRECTION_BACK);
    };

    PlaybackWaveViewModel.prototype._oneOp = function(direction) {
      var _this = this;
      return this._discover(direction, function(err, ops) {
        var id, ts, _ref;
        _ref = ops[0], ts = _ref[0], id = _ref[1];
        if (direction === DIRECTION_FORWARD) {
          return _this._loadedBlips[id].executeOneForwardOp();
        } else {
          return _this._loadedBlips[id].executeOneBackOp();
        }
      });
    };

    PlaybackWaveViewModel.prototype.fastForward = function() {
      return this._fast(DIRECTION_FORWARD);
    };

    PlaybackWaveViewModel.prototype.fastBack = function() {
      return this._fast(DIRECTION_BACK);
    };

    PlaybackWaveViewModel.prototype._fast = function(direction) {
      var _this = this;
      return this._discover(direction, function(err, ops) {
        var date, id, ts, _ref, _ref2;
        _ref = ops[1], ts = _ref[0], id = _ref[1];
        date = new Date(ts * 1000);
        _ref2 = ops[0], ts = _ref2[0], id = _ref2[1];
        if (direction === DIRECTION_FORWARD) {
          return _this._loadedBlips[id].executeFastForward(date);
        } else {
          return _this._loadedBlips[id].executeFastBack(date);
        }
      });
    };

    PlaybackWaveViewModel.prototype.playToDate = function(date) {
      var blip, id, _ref, _results;
      _ref = this._loadedBlips;
      _results = [];
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        blip = _ref[id];
        _results.push(blip.playToDate(date));
      }
      return _results;
    };

    PlaybackWaveViewModel.prototype._discover = function(direction, callback) {
      var infinityValue, iterator;
      infinityValue = direction === DIRECTION_FORWARD ? Infinity : -Infinity;
      iterator = function(blip, callback) {
        var discoverFunc;
        discoverFunc = direction === DIRECTION_FORWARD ? blip.discoverForward : blip.discoverBack;
        return discoverFunc(null, function(err, nextStepErr, op) {
          var ts;
          ts = err ? infinityValue : op.meta.ts;
          return callback(null, [ts, blip.getServerId()]);
        });
      };
      return async.map(_.values(this._loadedBlips), iterator, function(err, ops) {
        var sortFunc;
        if (direction === DIRECTION_FORWARD) {
          sortFunc = function(x, y) {
            return x[0] - y[0];
          };
        } else {
          sortFunc = function(x, y) {
            return y[0] - x[0];
          };
        }
        return callback(null, ops.sort(sortFunc));
      });
    };

    return PlaybackWaveViewModel;

  })(WaveViewModel);

  exports.PlaybackWaveViewModel = PlaybackWaveViewModel;

}).call(this);

});

require.define("/lib/client/client/wave/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BLIP_READ_STATE, BlipMenu, LocalStorage, STATE_LOADED, WaveView, WaveViewModel, WaveViewModelBase, _ref, _ref2,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  _ref = require('./index_base'), WaveViewModelBase = _ref.WaveViewModelBase, STATE_LOADED = _ref.STATE_LOADED;

  WaveView = require('./view').WaveView;

  _ref2 = require('../utils/localStorage'), LocalStorage = _ref2.LocalStorage, BLIP_READ_STATE = _ref2.BLIP_READ_STATE;

  BlipMenu = require('../blip/menu').BlipMenu;

  WaveViewModel = (function(_super) {

    __extends(WaveViewModel, _super);

    function WaveViewModel() {
      this._processRemoteBlipStateChange = __bind(this._processRemoteBlipStateChange, this);
      WaveViewModel.__super__.constructor.apply(this, arguments);
    }

    WaveViewModel.prototype.__initView = function(processor, participants, container) {
      return this.__view = new WaveView(this, processor, participants, container);
    };

    WaveViewModel.prototype.__initBlipProcessor = function() {
      return this.__blipProcessor = require('../blip/processor').instance;
    };

    WaveViewModel.prototype.__initLocalStorage = function() {
      return LocalStorage.on(BLIP_READ_STATE, this._processRemoteBlipStateChange);
    };

    WaveViewModel.prototype.__deinitLocalStorage = function() {
      return LocalStorage.removeListener(BLIP_READ_STATE, this._processRemoteBlipStateChange);
    };

    WaveViewModel.prototype._processRemoteBlipStateChange = function(params) {
      /*
              Отмечает прочитанным блип, который был прочитан из другой вкладки
      */
      var blip, blipId, isRead, waveId;
      if (!params) return;
      waveId = params.waveId, blipId = params.blipId, isRead = params.isRead;
      if (this._model.serverId !== waveId) return;
      if (!(blipId != null)) return;
      blip = this._getChildBlipByServerId(blipId);
      if (!blip) return;
      if (isRead) {
        return blip.getView().markAsRead();
      } else {
        return blip.getView().markAsUnread();
      }
    };

    WaveViewModel.prototype.__initLoadedWave = function() {
      return this.__updateTotalBlipsCount();
    };

    WaveViewModel.prototype.__updateTotalBlipsCount = function() {
      var eventParams;
      if (this._state !== STATE_LOADED) return;
      eventParams = {
        waveId: this._model.serverId,
        unreadBlipsCount: this.getUnreadBlipsCount(),
        totalBlipsCount: this.getTotalUsableBlipsCount()
      };
      return LocalStorage.updateBlipReadState(eventParams);
    };

    WaveViewModel.prototype.__activateNextUnreadBlip = function() {
      var lastActive, newActive;
      lastActive = this.__model.getActiveBlip();
      WaveViewModel.__super__.__activateNextUnreadBlip.call(this);
      if ((newActive = this.__model.getActiveBlip()) !== lastActive) {
        return newActive.focus();
      }
    };

    WaveViewModel.prototype.getBlipMenu = function() {
      var _ref3;
      return (_ref3 = this._blipMenu) != null ? _ref3 : this._blipMenu = new BlipMenu();
    };

    WaveViewModel.prototype.destroy = function() {
      WaveViewModel.__super__.destroy.call(this);
      if (this._blipMenu) {
        this._blipMenu.destroy();
        return delete this._blipMenu;
      }
    };

    return WaveViewModel;

  })(WaveViewModelBase);

  exports.WaveViewModel = WaveViewModel;

}).call(this);

});

require.define("/lib/client/client/wave/view.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ADD_BUTTONS, AccountMenu, AddParticipantForm, BlipThread, BrowserEvents, BrowserSupport, COMMENT_PERMISSION, DEFAULT_ROLES, DOM, EDIT_PERMISSION, History, LineLevelParams, LocalStorage, MindMap, Participants, ROLES, ROLE_COMMENTATOR, ROLE_EDITOR, ROLE_NO_ROLE, ROLE_OWNER, ROLE_READER, RangeMenu, RoleSelectPopup, SCROLL_INTO_VIEW_OFFSET, SavingMessageView, SettingsMenu, TextLevelParams, WAVE_SHARED_STATE_LINK_PUBLIC, WAVE_SHARED_STATE_PRIVATE, WAVE_SHARED_STATE_PUBLIC, WaveView, WaveViewBase, isEmail, popup, randomString, renderSelectAccountTypeBanner, renderWave, role, strip, trackParticipantAddition, _i, _len, _ref, _ref2, _ref3, _ref4, _ref5, _ref6,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  WaveViewBase = require('./view_base');

  Participants = require('./participants').Participants;

  trackParticipantAddition = require('./participants/utils').trackParticipantAddition;

  _ref = require('./participants/constants'), ROLES = _ref.ROLES, ROLE_OWNER = _ref.ROLE_OWNER, ROLE_EDITOR = _ref.ROLE_EDITOR, ROLE_COMMENTATOR = _ref.ROLE_COMMENTATOR, ROLE_READER = _ref.ROLE_READER, ROLE_NO_ROLE = _ref.ROLE_NO_ROLE;

  _ref2 = require('./template'), renderWave = _ref2.renderWave, renderSelectAccountTypeBanner = _ref2.renderSelectAccountTypeBanner;

  DOM = require('../utils/dom');

  popup = require('../popup').popup;

  randomString = require('../utils/random_string').randomString;

  _ref3 = require('../editor/model'), TextLevelParams = _ref3.TextLevelParams, LineLevelParams = _ref3.LineLevelParams;

  BrowserSupport = require('../utils/browser_support');

  SettingsMenu = require('./settings_menu').SettingsMenu;

  AccountMenu = require('./account_menu').AccountMenu;

  _ref4 = require('../utils/string'), isEmail = _ref4.isEmail, strip = _ref4.strip;

  _ref5 = require('./model'), WAVE_SHARED_STATE_PUBLIC = _ref5.WAVE_SHARED_STATE_PUBLIC, WAVE_SHARED_STATE_LINK_PUBLIC = _ref5.WAVE_SHARED_STATE_LINK_PUBLIC, WAVE_SHARED_STATE_PRIVATE = _ref5.WAVE_SHARED_STATE_PRIVATE;

  BlipThread = require('../blip/blip_thread').BlipThread;

  AddParticipantForm = require('./participants/add_form').AddParticipantForm;

  _ref6 = require('../blip/model'), EDIT_PERMISSION = _ref6.EDIT_PERMISSION, COMMENT_PERMISSION = _ref6.COMMENT_PERMISSION;

  RoleSelectPopup = require('./role_select_popup').RoleSelectPopup;

  LocalStorage = require('../utils/localStorage').LocalStorage;

  MindMap = require('../mindmap').MindMap;

  RangeMenu = require('../blip/menu/range_menu');

  History = require('../utils/history_navigation');

  BrowserEvents = require('../utils/browser_events');

  SCROLL_INTO_VIEW_OFFSET = -90;

  ADD_BUTTONS = [];

  for (_i = 0, _len = ROLES.length; _i < _len; _i++) {
    role = ROLES[_i];
    if (role.id !== ROLE_OWNER) {
      ADD_BUTTONS.push({
        id: role.id,
        name: role.name.toLowerCase()
      });
    }
  }

  DEFAULT_ROLES = [[ROLE_EDITOR, 'edit'], [ROLE_COMMENTATOR, 'comment'], [ROLE_READER, 'read']];

  WaveView = (function(_super) {

    __extends(WaveView, _super);

    function WaveView(_waveViewModel, _waveProcessor, participants, _container) {
      this._waveViewModel = _waveViewModel;
      this._waveProcessor = _waveProcessor;
      this._container = _container;
      this._handleBufferUpdate = __bind(this._handleBufferUpdate, this);
      this._doScrollOnDrag = __bind(this._doScrollOnDrag, this);
      this._handleScrollDragLeaveEvent = __bind(this._handleScrollDragLeaveEvent, this);
      this._handleScrollDragEnterEvent = __bind(this._handleScrollDragEnterEvent, this);
      this._handleContainerDropEvent = __bind(this._handleContainerDropEvent, this);
      this._handleContainerDragLeaveEvent = __bind(this._handleContainerDragLeaveEvent, this);
      this._handleContainerDragEnterEvent = __bind(this._handleContainerDragEnterEvent, this);
      this.setLongMindmapView = __bind(this.setLongMindmapView, this);
      this.setShortMindmapView = __bind(this.setShortMindmapView, this);
      this.setMindmapView = __bind(this.setMindmapView, this);
      this.setTextView = __bind(this.setTextView, this);
      this._showNextTip = __bind(this._showNextTip, this);
      this._hideTip = __bind(this._hideTip, this);
      this.processAddParticipantResponse = __bind(this.processAddParticipantResponse, this);
      this._processClickEvent = __bind(this._processClickEvent, this);
      this._processBlipKeyUpEvent = __bind(this._processBlipKeyUpEvent, this);
      this._processKeyDownEvent = __bind(this._processKeyDownEvent, this);
      this._preProcessKeyDownEvent = __bind(this._preProcessKeyDownEvent, this);
      this._goToUnread = __bind(this._goToUnread, this);
      this._selectAll = __bind(this._selectAll, this);
      this._unfoldChildBlips = __bind(this._unfoldChildBlips, this);
      this._foldChildBlips = __bind(this._foldChildBlips, this);
      this._insertGadget = __bind(this._insertGadget, this);
      this._showGadgetPopup = __bind(this._showGadgetPopup, this);
      this._insertTask = __bind(this._insertTask, this);
      this._insertTag = __bind(this._insertTag, this);
      this._insertMention = __bind(this._insertMention, this);
      this._insertBlipButtonClick = __bind(this._insertBlipButtonClick, this);
      this._processAddParticipantResponse = __bind(this._processAddParticipantResponse, this);
      this._processAddParticipantClick = __bind(this._processAddParticipantClick, this);
      this._isExistParticipant = __bind(this._isExistParticipant, this);
      this._setOnScrollMenuPosition = __bind(this._setOnScrollMenuPosition, this);
      this._resizerRepositionMenu = __bind(this._resizerRepositionMenu, this);
      this.markActiveBlip = __bind(this.markActiveBlip, this);
      this._windowCheckCusor = __bind(this._windowCheckCusor, this);
      this.runCheckRange = __bind(this.runCheckRange, this);
      this._checkRange = __bind(this._checkRange, this);
      this._onRootBlipGot = __bind(this._onRootBlipGot, this);
      this._setBlipReadMode = __bind(this._setBlipReadMode, this);
      this._processFFEnterKeypress = __bind(this._processFFEnterKeypress, this);
      this._changeBlipEditMode = __bind(this._changeBlipEditMode, this);
      this._setParticipantsWidth = __bind(this._setParticipantsWidth, this);
      this._handleGDriveViewShareButton = __bind(this._handleGDriveViewShareButton, this);
      this._shareButtonHandler = __bind(this._shareButtonHandler, this);
      this._processAddParticipantBlockClick = __bind(this._processAddParticipantBlockClick, this);
      this._processAddButtonChange = __bind(this._processAddButtonChange, this);
      this._contactButtonHandler = __bind(this._contactButtonHandler, this);
      this._contactSelectHandler = __bind(this._contactSelectHandler, this);
      /*
              @param waveViewModel: WaveViewModel
              @param _waveProcessor: WaveProcessor
              @param participants: array, часть ShareJS-документа, отвечающего за участников
              @param container: HTMLNode, нода, в которой отображаться сообщению
      */
      WaveView.__super__.constructor.call(this);
      this.container = this._container;
      this._init(this._waveViewModel, participants);
    }

    WaveView.prototype._init = function(waveViewModel, participants) {
      /*
              @param waveViewModel: WaveViewModel
              @param participants: array, часть ShareJS-документа, отвечающего за участников
      */
      var _ref7,
        _this = this;
      this._inEditMode = false;
      this._isAnonymous = !(((_ref7 = window.userInfo) != null ? _ref7.id : void 0) != null);
      this._model = waveViewModel.getModel();
      this._editable = BrowserSupport.isSupported() && !this._isAnonymous;
      this._createDOM(renderWave);
      this._initWaveHeader(waveViewModel, participants);
      this._initEditingMenu();
      this._updateParticipantsManagement();
      this._initRootBlip(waveViewModel);
      this._updateReplyButtonState();
      this._initTips();
      this._initDragScroll();
      waveViewModel.on('waveLoaded', function() {
        $(_this._waveBlips).on('scroll', _this._setOnScrollMenuPosition);
        $(window).on('scroll', _this._setOnScrollMenuPosition);
        return $(window).on('resize resizeTopicByResizer', _this._resizerRepositionMenu);
      });
      this._initBuffer();
      if (!BrowserSupport.isSupported() && !this._isAnonymous) {
        return this._$wavePanel.addClass('visible');
      }
    };

    WaveView.prototype._contactSelectHandler = function(item) {
      if ((item != null) && item) this._$participantIdInput.val(item.email);
      return this._processAddParticipantClick();
    };

    WaveView.prototype._contactButtonHandler = function(e) {
      var source,
        _this = this;
      source = $(e.currentTarget).attr('source');
      _gaq.push(['_trackEvent', 'Contacts synchronization', 'Synchronize contacts click', "add users " + source]);
      return this._waveProcessor.initContactsUpdate(source, e.screenX - 630, e.screenY, function() {
        if (_this._closed) return;
        _this.activateContacts(source);
        return _gaq.push(['_trackEvent', 'Contacts synchronization', 'Successfull synchronization', "add users " + source]);
      });
    };

    WaveView.prototype.activateContacts = function(source) {
      var _ref7;
      return (_ref7 = this._addParticipantForm) != null ? _ref7.refreshContacts(source) : void 0;
    };

    WaveView.prototype._getRole = function() {
      var r, _j, _len2;
      role = this._waveViewModel.getRole();
      for (_j = 0, _len2 = ROLES.length; _j < _len2; _j++) {
        r = ROLES[_j];
        if (r.id === role) return r;
      }
    };

    WaveView.prototype._initWaveHeader = function(waveViewModel, participants) {
      /*
              Инициализирует заголовок волны
      */
      var $c;
      this._reservedHeaderSpace = 0;
      $c = $(this.container);
      this._waveHeader = $c.find('.js-wave-header')[0];
      this._$wavePanel = $c.find('.js-wave-panel');
      this._initParticipantAddition();
      this._initParticipants(waveViewModel, participants);
      if (this._isAnonymous) {
        $c.find('.js-enter-rizzoma-btn').click(function(e) {
          window.AuthDialog.initAndShow(true, History.getLoginRedirectUrl());
          e.stopPropagation();
          return e.preventDefault();
        });
      }
      this._initWaveShareMenu();
      this._curView = 'text';
      role = this._getRole();
      if (role) {
        $(this._waveHeader).find('.js-account-section-role').text(role.name);
      }
      this._initSavingMessage();
      this._initSettingsMenu();
      this._initAccountMenu();
      return this._initSelectAccountTypeBanner();
    };

    WaveView.prototype._initSelectAccountTypeBanner = function() {
      var _this = this;
      if (!window.showAccountSelectionBanner) return;
      $(this.container).prepend(renderSelectAccountTypeBanner());
      $(this.container).find(".js-open-account-select").on("click", function() {
        _gaq.push(['_trackEvent', 'Monetization', 'Upgrade account link click']);
        $('.js-account-wizard-banner').remove();
        delete window.showAccountSelectionWizard;
        delete window.showAccountSelectionBanner;
        return _this._waveProcessor.openAccountWizard();
      });
      return $(this.container).find('.js-account-wizard-banner').on("click", function() {
        return $('.js-account-wizard-banner').remove();
      });
    };

    WaveView.prototype._initParticipantAddition = function() {
      if (this._isAnonymous) return;
      this._$addParticipantsBlock = $(this._waveHeader).find('.js-add-form');
      return this._addParticipantsBlockButton = DOM.findAndBind($(this._waveHeader), '.js-add-block-button', 'click', this._processAddParticipantBlockClick);
    };

    WaveView.prototype._processAddButtonChange = function() {
      return this._addButtonRole = parseInt(this._$addButtonSelect.val());
    };

    WaveView.prototype._createAddParticipantForm = function() {
      var maxResults,
        _this = this;
      maxResults = History.isEmbedded() ? 5 : 7;
      this._addParticipantForm = new AddParticipantForm(this._$addParticipantsBlock, maxResults, ADD_BUTTONS, this._waveProcessor, this._contactSelectHandler, this._contactButtonHandler);
      this._$participantIdInput = this._$addParticipantsBlock.find('.js-input-email');
      return setTimeout(function() {
        _this._$addButtonSelect = _this._$addParticipantsBlock.find('.js-add-select');
        _this._$addButtonSelect.selectBox().change(_this._processAddButtonChange);
        _this._$addButtonSelect.on('close', function() {
          window.setTimeout(function() {
            return $(_this._participantIdInput).focus();
          });
          return 0;
        });
        _this._$addButton = _this._$addParticipantsBlock.find('.js-add-button');
        return _this._updateParticipantAddition();
      }, 0);
    };

    WaveView.prototype._processAddParticipantBlockClick = function(event) {
      var _ref7;
      if ((_ref7 = this._addParticipantForm) != null ? _ref7.isVisible() : void 0) {
        return this._addParticipantForm.hide();
      } else {
        if (!(this._addParticipantForm != null)) this._createAddParticipantForm();
        this._addParticipantForm.show();
        return this._$participantIdInput.focus();
      }
    };

    WaveView.prototype._initSocialShareButtons = function() {
      var loadWnd, socialSection, twUrl, tweetLength, twhashtag,
        _this = this;
      socialSection = $(this._waveHeader).find('.js-social-section');
      this._facebookButton = socialSection.find('.js-social-facebook');
      this._twitterButton = socialSection.find('.js-social-twitter');
      this._googleButton = socialSection.find('.js-social-google');
      this._socialOverlay = socialSection.find('.js-social-overlay');
      loadWnd = function(title, url, e) {
        var wnd;
        wnd = window.open("/share_topic_wait/", title, "width=640,height=440,left=" + (e.screenX - 630) + ",top=" + e.screenY + ",scrollbars=no");
        if (_this._waveProcessor.rootRouterIsConnected()) {
          return _this._waveProcessor.markWaveAsSocialSharing(_this._model.serverId, function() {
            if (wnd) return wnd.document.location.href = url;
          });
        } else {
          return wnd.document.location.href = url;
        }
      };
      this._facebookButton.on('click', function(e) {
        _gaq.push(['_trackEvent', 'Topic sharing', 'Share topic on Facebook']);
        mixpanel.track('Topic sharing', {
          'channel': 'Facebook'
        });
        loadWnd('Facebook', "http://www.facebook.com/sharer/sharer.php?u=" + (encodeURIComponent(_this.getSocialSharingUrl())), e);
        return false;
      });
      this._googleButton.on('click', function(e) {
        _gaq.push(['_trackEvent', 'Topic sharing', 'Share topic on Google+']);
        mixpanel.track('Topic sharing', {
          'channel': 'Google+'
        });
        loadWnd('Google', "https://plus.google.com/share?url=" + (encodeURIComponent(_this.getSocialSharingUrl())), e);
        return false;
      });
      twUrl = this.getSocialSharingUrl();
      twhashtag = '#rizzoma';
      tweetLength = 140 - twUrl.length - twhashtag.length;
      return this._twitterButton.on('click', function(e) {
        var snippet, t, _j, _len2, _ref7;
        _gaq.push(['_trackEvent', 'Topic sharing', 'Share topic on Twitter']);
        mixpanel.track('Topic sharing', {
          'channel': 'Twitter'
        });
        snippet = '';
        _ref7 = _this.rootBlip.getModel().getSnapshotContent();
        for (_j = 0, _len2 = _ref7.length; _j < _len2; _j++) {
          t = _ref7[_j];
          if (snippet.length >= tweetLength) break;
          if (t.params.__TYPE !== 'TEXT') {
            snippet += " ";
          } else {
            snippet += t.t;
          }
        }
        if (snippet.length >= tweetLength) {
          snippet = snippet.substr(0, tweetLength - 3);
          snippet += "..." + twhashtag;
        } else {
          snippet += " " + twhashtag;
        }
        window.open("https://twitter.com/intent/tweet?source=tw&text=" + (encodeURIComponent(snippet)) + "&url=" + (encodeURIComponent(twUrl)), 'Twitter', "width=640,height=290,left=" + (e.screenX - 630) + ",top=" + e.screenY + ",scrollbars=no");
        return false;
      });
    };

    WaveView.prototype._shareButtonHandler = function(e) {
      var waveUrl,
        _this = this;
      waveUrl = this._sharePopup.find('.js-wave-url');
      if (this._sharePopup.is(':visible')) return this._sharePopup.hide();
      this._sharePopup.show();
      _gaq.push(['_trackEvent', 'Topic sharing', 'Topic sharing manage']);
      waveUrl.select();
      waveUrl.on('mousedown', function() {
        return waveUrl.select();
      });
      window.setTimeout(function() {
        return $(document).on('click.shareWaveBlock', function(e) {
          if ($(e.target).closest('.js-share-window, .js-role-selector-popup').length === 0) {
            _this._sharePopup.hide();
            $(document).off('click.shareWaveBlock');
          }
          return true;
        });
      }, 0);
      return this._checkRange();
    };

    WaveView.prototype._handleGDriveViewShareButton = function(e) {
      var menu,
        _this = this;
      menu = this._shareContainer.find('.js-gdrive-share-menu');
      if (menu.is(':visible')) return menu.hide();
      menu.show();
      window.setTimeout(function() {
        return $(document).on('click.gDriveShareMenu', function(e) {
          if ($(e.target).closest('.js-gdrive-share-menu').length === 0) {
            menu.hide();
            $(document).off('click.gDriveShareMenu');
          }
          return true;
        });
      }, 0);
      return this._checkRange();
    };

    WaveView.prototype._initWaveShareMenu = function() {
      /*
              Инициализирует меню расшаривания волны
      */
      var $c, getRole, menu, roleId, roleName, setPopup, setRole, _j, _len2, _ref7,
        _this = this;
      if (this._isAnonymous) return;
      this._shareContainer = $(this._waveHeader).find('.js-share-container');
      this._shareButton = this._shareContainer.find('.js-show-share-button');
      this._sharePopup = this._shareContainer.find('.js-share-window');
      if (History.isGDrive()) {
        menu = this._shareContainer.find('.js-gdrive-share-menu');
        menu.on('click', 'a.js-btn', function(e) {
          e.preventDefault();
          menu.hide();
          return $(document).off('click.gDriveShareMenu');
        });
        this._shareButton.on('click', this._handleGDriveViewShareButton);
        this._shareContainer.find('.js-share-window-button').on('click', this._shareButtonHandler);
      } else {
        this._shareButton.on('click', this._shareButtonHandler);
      }
      if (!BrowserSupport.isSupported() || !window.loggedIn) {
        /*
                    Не авторизованные пользователи или пользователи
                    не под Chrome не могут расшарить волну
        */
        this._shareButton.attr('disabled', 'disabled');
      }
      $c = $(this.container);
      this._byLinkRoleId = ROLE_EDITOR;
      this._publicRoleId = ROLE_COMMENTATOR;
      this._isPrivateButton = DOM.findAndBind($c, '.js-is-private-button', 'change', function() {
        if (_this._isPrivateButton.checked) {
          return _this.setSharedState(WAVE_SHARED_STATE_PRIVATE);
        }
      });
      this._isByLinkButton = DOM.findAndBind($c, '.js-by-link-button', 'change', function() {
        if (_this._isByLinkButton.checked) {
          return _this.setSharedState(WAVE_SHARED_STATE_LINK_PUBLIC, _this._byLinkRoleId);
        }
      });
      this._isPublicButton = DOM.findAndBind($c, '.js-is-public-button', 'change', function() {
        if (_this._isPublicButton.checked) {
          return _this.setSharedState(WAVE_SHARED_STATE_PUBLIC, _this._publicRoleId);
        }
      });
      this._sharedRoleSelect = $(this._sharePopup).find('.js-shared-role-select')[0];
      setPopup = function(node, getRole, setRole) {
        return $(node).click(function(event) {
          if (!_this._canChangeTopicShare) return;
          popup.hide();
          popup.render(new RoleSelectPopup(DEFAULT_ROLES, getRole, setRole), event.target);
          popup.show();
          return false;
        });
      };
      getRole = function() {
        return _this._byLinkRoleId;
      };
      setRole = function(roleId) {
        _this._byLinkRoleId = roleId;
        popup.hide();
        return _this.setSharedState(WAVE_SHARED_STATE_LINK_PUBLIC, _this._byLinkRoleId);
      };
      setPopup(this._sharedRoleSelect, getRole, setRole);
      getRole = function() {
        return _this._publicRoleId;
      };
      setRole = function(roleId) {
        _this._publicRoleId = roleId;
        popup.hide();
        return _this.setSharedState(WAVE_SHARED_STATE_PUBLIC, _this._publicRoleId);
      };
      this._publicRoleSelect = $(this._sharePopup).find('.js-public-role-select')[0];
      for (_j = 0, _len2 = DEFAULT_ROLES.length; _j < _len2; _j++) {
        _ref7 = DEFAULT_ROLES[_j], roleId = _ref7[0], roleName = _ref7[1];
        if (roleId === this._publicRoleId) {
          $(this._publicRoleSelect).text(roleName);
        }
      }
      setPopup(this._publicRoleSelect, getRole, setRole);
      this._initSocialShareButtons();
      return this.updatePublicState();
    };

    WaveView.prototype._disableSocialButtons = function() {
      this._socialOverlay.addClass('social-overlay');
      this._facebookButton.attr('disabled', 'disabled');
      this._twitterButton.attr('disabled', 'disabled');
      return this._googleButton.attr('disabled', 'disabled');
    };

    WaveView.prototype._enableSocialButtons = function() {
      this._socialOverlay.removeClass('social-overlay');
      this._facebookButton.removeAttr('disabled');
      this._twitterButton.removeAttr('disabled');
      return this._googleButton.removeAttr('disabled');
    };

    WaveView.prototype._setShareContainerClass = function(className) {
      $(this._shareContainer).removeClass('private');
      $(this._shareContainer).removeClass('public');
      $(this._shareContainer).removeClass('shared');
      return $(this._shareContainer).addClass(className);
    };

    WaveView.prototype._setDefaultRoleId = function(element, roleId) {
      var id, name, _j, _len2, _ref7, _results;
      _results = [];
      for (_j = 0, _len2 = DEFAULT_ROLES.length; _j < _len2; _j++) {
        _ref7 = DEFAULT_ROLES[_j], id = _ref7[0], name = _ref7[1];
        if (roleId !== id) continue;
        _results.push($(element).text(name));
      }
      return _results;
    };

    WaveView.prototype.__scrollToBlipContainer = function(blipContainer) {
      return DOM.scrollTargetIntoViewWithAnimation(blipContainer, this._waveBlips, true, SCROLL_INTO_VIEW_OFFSET);
    };

    WaveView.prototype.updatePublicState = function(sharedState, defaultRoleId) {
      var _ref7;
      if (sharedState == null) sharedState = this._model.getSharedState();
      if (defaultRoleId == null) defaultRoleId = this._model.getDefaultRole();
      /*
              Устанавливает состояние переключателя публичности волны
              @param isPublic: boolean
              @param defaultRoleId: int
      */
      if (!window.loggedIn) return;
      if (sharedState === WAVE_SHARED_STATE_LINK_PUBLIC) {
        this._isByLinkButton.checked = true;
        this._setDefaultRoleId(this._sharedRoleSelect, defaultRoleId);
        this._byLinkRoleId = defaultRoleId;
        this._setShareContainerClass('shared');
        this._enableSocialButtons();
        this._shareButton.attr('title', "Topic is shared by link, click to change");
        this._participants.showCreateTopicForSelectedButton();
      } else if (sharedState === WAVE_SHARED_STATE_PRIVATE) {
        this._isPrivateButton.checked = true;
        this._setShareContainerClass('private');
        this._disableSocialButtons();
        this._shareButton.attr('title', "Topic is private, click to change");
        this._participants.showCreateTopicForSelectedButton();
      } else {
        this._isPublicButton.checked = true;
        this._setDefaultRoleId(this._publicRoleSelect, defaultRoleId);
        this._publicRoleId = defaultRoleId;
        this._setShareContainerClass('public');
        this._enableSocialButtons();
        this._shareButton.attr('title', "Topic is public, click to change");
        this._participants.hideCreateTopicForSelectedButton();
      }
      this._shareContainerWidth = $(this._shareContainer).width() + parseInt($(this._shareContainer).css('margin-left')) + parseInt($(this._shareContainer).css('margin-right'));
      if ((_ref7 = this._waveViewModel.getRole()) === ROLE_OWNER || _ref7 === ROLE_EDITOR) {
        return;
      }
      return this._updateParticipantsManagement();
    };

    WaveView.prototype.setSharedState = function(sharedState, defaultRole) {
      var _this = this;
      if (defaultRole == null) defaultRole = 1;
      /*
              Устанавливает публичность волны
              Обновляет кнопку в интерфейсе и отправляет команду серверу при необходимости
              @param isPublic: boolean
              @param defaultRole: int
      */
      this.updatePublicState(sharedState, defaultRole);
      return this._waveProcessor.setWaveShareState(this._model.serverId, sharedState, defaultRole, function(err) {
        if (_this._isPublicButton.checked) {
          _gaq.push(['_trackEvent', 'Topic sharing', 'Set topic public']);
        } else if (_this._isPrivateButton.checked) {
          _gaq.push(['_trackEvent', 'Topic sharing', 'Set topic private']);
        } else {
          _gaq.push(['_trackEvent', 'Topic sharing', 'Set topic shared']);
        }
        if (!err) return;
        _this._waveViewModel.showWarning(err.message);
        return _this.updatePublicState();
      });
    };

    WaveView.prototype._initParticipants = function(waveViewModel, participants) {
      /*
              Инициализирует панель с участниками волны
              @param participants: array, часть ShareJS-документа, отвечающего за участников
      */
      var child, headerChildren, _j, _len2;
      this._participants = new Participants(waveViewModel, this._waveProcessor, this._model.serverId, participants, true, this._model.getGDriveShareUrl());
      $(this.container).find('.js-wave-participants').append(this._participants.getContainer());
      this._excludeParticipantsWidth = 0;
      headerChildren = $(this._waveHeader).children();
      for (_j = 0, _len2 = headerChildren.length; _j < _len2; _j++) {
        child = headerChildren[_j];
        if ($(child).hasClass('js-wave-participants') || $(child).hasClass('clearer') || !$(child).is(':visible')) {
          continue;
        }
        this._excludeParticipantsWidth += $(child).outerWidth(true);
      }
      this._setParticipantsWidth();
      return $(window).on('resize resizeTopicByResizer', this._setParticipantsWidth);
    };

    WaveView.prototype.getParticipantIds = function() {
      return this._participants.all();
    };

    WaveView.prototype._setParticipantsWidth = function() {
      var headerInnerWidth, participantsWidth;
      if (this._isAnonymous) {
        participantsWidth = $(this.container).find('.js-wave-participants').outerWidth();
      } else {
        headerInnerWidth = $(this._waveHeader).width() - parseInt($(this._waveHeader).css('padding-left')) - parseInt($(this._waveHeader).css('padding-right'));
        participantsWidth = headerInnerWidth - this._excludeParticipantsWidth - parseInt($($(this._waveHeader).find('.js-participant-container')[0]).css('margin-left')) - parseInt($($(this._waveHeader).find('.js-participant-container')[0]).css('margin-right'));
        participantsWidth -= this._reservedHeaderSpace;
      }
      return this._participants.setParticipantsWidth(participantsWidth);
    };

    WaveView.prototype._initEditingMenu = function() {
      /*
              Инициализирует меню редактирования волны
      */      if (!this._editable) return;
      this._initEditingMenuKeyHandlers();
      this._disableEditingButtons();
      this._disableActiveBlipControls();
      return this._initActiveBlipControls();
    };

    WaveView.prototype._initActiveBlipControls = function() {
      /*
              Инициализирует кнопки вставки реплая или меншена в активный блиб
      */
      var $insertTaskBtn, accountProcessor, activateButtons, businessButtons, businessChangeCallback, checkPermission,
        _this = this;
      checkPermission = function(callback) {
        return function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (_this._activeBlipControlsEnabled === false) return false;
          return callback.apply(null, args);
        };
      };
      activateButtons = function(buttons) {
        var className, controlInfo, handler, _j, _len2, _results;
        _results = [];
        for (_j = 0, _len2 = buttons.length; _j < _len2; _j++) {
          controlInfo = buttons[_j];
          className = controlInfo.className, handler = controlInfo.handler;
          controlInfo.$button = _this._$activeBlipControls.find(className);
          _results.push(controlInfo.$button.mousedown(handler));
        }
        return _results;
      };
      this._activeBlipControlButtons = [
        {
          className: '.js-insert-reply',
          handler: checkPermission(this._eventHandler(this._insertBlipButtonClick))
        }, {
          className: '.js-insert-mention',
          handler: checkPermission(this._eventHandler(this._insertMention))
        }, {
          className: '.js-insert-tag',
          handler: checkPermission(this._eventHandler(this._insertTag))
        }, {
          className: '.js-insert-gadget',
          handler: checkPermission(this._eventHandler(this._showGadgetPopup))
        }
      ];
      activateButtons(this._activeBlipControlButtons);
      accountProcessor = require('../account_setup_wizard/processor').instance;
      businessButtons = [
        {
          className: '.js-insert-task',
          handler: checkPermission(this._eventHandler(this._insertTask))
        }
      ];
      if (accountProcessor.isBusinessUser()) {
        activateButtons(businessButtons);
        return this._activeBlipControlButtons.push(businessButtons[0]);
      } else {
        $insertTaskBtn = this._$activeBlipControls.find('.js-insert-task').hide();
        businessChangeCallback = function(isBusiness) {
          if (!isBusiness) return;
          if (!_this._activeBlipControlButtons) return;
          $insertTaskBtn.show();
          accountProcessor.removeListener('is-business-change', businessChangeCallback);
          activateButtons(businessButtons);
          return _this._activeBlipControlButtons.push(businessButtons[0]);
        };
        return accountProcessor.on('is-business-change', businessChangeCallback);
      }
    };

    WaveView.prototype._deinitActiveBlipControls = function() {
      var $button, handler, _j, _len2, _ref7, _ref8;
      _ref7 = this._activeBlipControlButtons;
      for (_j = 0, _len2 = _ref7.length; _j < _len2; _j++) {
        _ref8 = _ref7[_j], $button = _ref8.$button, handler = _ref8.handler;
        if ($button != null) $button.off('mousedown', handler);
      }
      return delete this._activeBlipControlButtons;
    };

    WaveView.prototype._initEditingMenuKeyHandlers = function() {
      /*
              Инициализирует обработчики нажатий на клавиши в топике
      */
      var _this = this;
      this._ctrlHandlers = {
        65: this._selectAll,
        69: this._changeBlipEditMode
      };
      this._globalCtrlHandlers = {
        32: this._goToUnread
      };
      this._ctrlShiftHandlers = {
        38: this._foldChildBlips,
        40: this._unfoldChildBlips
      };
      this._shiftHandlers = {
        13: this._setBlipReadMode
      };
      this._ctrlRepeats = {};
      this.blipNode.addEventListener('keydown', this._preProcessKeyDownEvent, true);
      if (BrowserSupport.isMozilla()) {
        this.blipNode.addEventListener('keypress', this._processFFEnterKeypress, true);
      }
      this._globalKeyHandler = function(e) {
        if (!(e.ctrlKey || e.metaKey)) return;
        return _this._processKeyDownEvent(_this._globalCtrlHandlers, e);
      };
      window.addEventListener('keydown', this._globalKeyHandler, true);
      this.blipNode.addEventListener('keyup', this._processBlipKeyUpEvent, true);
      if (BrowserSupport.isSupported()) {
        return this.blipNode.addEventListener('click', this._processClickEvent, false);
      }
    };

    WaveView.prototype._changeBlipEditMode = function() {
      var blip;
      blip = this._getBlipAndRange()[0];
      if (!blip) return;
      return blip.setEditable(!this._inEditMode);
    };

    WaveView.prototype._processFFEnterKeypress = function(e) {
      if (e.keyCode !== 13 || !e.shiftKey) return;
      return e.stopPropagation();
    };

    WaveView.prototype._setBlipReadMode = function(e) {
      var blip;
      blip = this._getBlipAndRange()[0];
      if (!blip) return;
      return blip.setEditable(false);
    };

    WaveView.prototype._initRootBlip = function(waveViewModel) {
      /*
              Инициализирует корневой блип
      */
      var processor,
        _this = this;
      processor = require('../blip/processor').instance;
      processor.openBlip(waveViewModel, this._model.getContainerBlipId(), this.blipNode, null, this._onRootBlipGot);
      return this.on('range-change', function(range, blip) {
        if (blip) return _this.markActiveBlip(blip);
      });
    };

    WaveView.prototype._onRootBlipGot = function(err, rootBlip) {
      this.rootBlip = rootBlip;
      if (err) return this._waveProcessor.showPageError(err);
      return this._initRangeChangeEvent();
    };

    WaveView.prototype._disableEditingButtons = function() {
      return this._editingButtonsEnabled = false;
    };

    WaveView.prototype._enableEditingButtons = function() {
      return this._editingButtonsEnabled = true;
    };

    WaveView.prototype._disableActiveBlipControls = function() {
      if (!this._editable) return;
      if (this._activeBlipControlsEnabled === false) return;
      this._activeBlipControlsEnabled = false;
      this._hideGadgetPopup();
      return this._$activeBlipControls.addClass('unvisible');
    };

    WaveView.prototype.enableActiveBlipControls = function() {
      var _this = this;
      return window.setTimeout(function() {
        if (_this._activeBlipControlsEnabled === true) return;
        _this._activeBlipControlsEnabled = true;
        return _this._$activeBlipControls.removeClass('unvisible');
      }, 0);
    };

    WaveView.prototype.cursorIsInText = function() {
      return this._editingButtonsEnabled;
    };

    WaveView.prototype._checkChangedRange = function(range, blipView) {
      var _ref7;
      if (range) {
        DOM.addClass(this.container, 'has-cursor');
      } else {
        DOM.removeClass(this.container, 'has-cursor');
      }
      if (range && ((_ref7 = blipView.getPermission()) === EDIT_PERMISSION || _ref7 === COMMENT_PERMISSION)) {
        if (this._inEditMode) {
          this.enableActiveBlipControls();
        } else {
          this._disableActiveBlipControls();
        }
        if (blipView.getPermission() === EDIT_PERMISSION) {
          this._enableEditingButtons();
        } else {
          this._disableEditingButtons();
        }
      } else {
        this._disableEditingButtons();
        this._disableActiveBlipControls();
      }
      if (blipView === this._lastBlip) {
        if (range === this._lastRange) return;
        if (range && this._lastRange && range.compareBoundaryPoints(Range.START_TO_START, this._lastRange) === 0 && range.compareBoundaryPoints(Range.END_TO_END, this._lastRange) === 0) {
          return;
        }
      }
      this._lastRange = range;
      if (this._lastRange) this._lastRange = this._lastRange.cloneRange();
      this._lastBlip = blipView;
      return this.emit('range-change', this._lastRange, blipView);
    };

    WaveView.prototype._checkRange = function() {
      /*
              Проверяет положение курсора и генерирует событие изменения положения
              курсора при необходимости
      */
      var params;
      params = this._getBlipAndRange();
      if (params) {
        return this._checkChangedRange(params[1], params[0]);
      } else {
        return this._checkChangedRange(null, null);
      }
    };

    WaveView.prototype.runCheckRange = function() {
      var _this = this;
      return window.setTimeout(function() {
        return _this._checkRange();
      }, 0);
    };

    WaveView.prototype._windowCheckCusor = function(e) {
      var _this = this;
      return window.setTimeout(function() {
        var blip, params;
        if (!_this.rootBlip) return;
        params = _this._getBlipAndRange();
        if (params) {
          return _this._checkChangedRange(params[1], params[0]);
        } else {
          blip = _this.rootBlip.getView().getBlipContainingElement(e.target);
          return _this._checkChangedRange(null, blip);
        }
      }, 0);
    };

    WaveView.prototype._initRangeChangeEvent = function() {
      /*
              Инициализирует событие "изменение курсора"
      */      this._lastRange = null;
      this._lastBlip = null;
      window.addEventListener('keydown', this.runCheckRange, false);
      window.addEventListener('mousedown', this._windowCheckCusor, false);
      return window.addEventListener('mouseup', this._windowCheckCusor, false);
    };

    WaveView.prototype._eventHandler = function(func) {
      /*
              Возвращает функцию, которая остановит событие и вызовет переданную
              @param func: function
              @return: function
                  function(event)
      */      return function(event) {
        event.preventDefault();
        event.stopPropagation();
        return func(event);
      };
    };

    WaveView.prototype._createDOM = function(renderWave) {
      /*
              Создает DOM для отображения документа
      */
      var c, waveParams;
      c = $(this.container);
      BrowserEvents.addPropagationBlocker(this.container, BrowserEvents.DOM_NODE_INSERTED);
      c.empty();
      waveParams = {
        url: this.getUrl(),
        editable: this._editable,
        isAnonymous: this._isAnonymous,
        gDriveShareUrl: this._model.getGDriveShareUrl(),
        isGDriveView: History.isGDrive()
      };
      c.append(renderWave(waveParams));
      this._waveContent = $(this.container).find('.js-wave-content')[0];
      this._waveBlips = $(this.container).find('.js-wave-blips')[0];
      this._$activeBlipControls = $('.js-right-tools-panel .js-active-blip-controls');
      return this.blipNode = $(this.container).find('.js-container-blip')[0];
    };

    WaveView.prototype._initSettingsMenu = function() {
      var $settingsContainer, menu,
        _this = this;
      menu = new SettingsMenu();
      $settingsContainer = $(this.container).find('.js-settings-container');
      $settingsContainer.on(BrowserEvents.C_READ_ALL_EVENT, function() {
        return _this.emit(_this.constructor.Events.READ_ALL);
      });
      return menu.render($settingsContainer[0], {
        topicId: this._waveViewModel.getServerId(),
        exportUrl: this.getExportUrl(),
        embeddedUrl: this._getEmbeddedUrl()
      });
    };

    WaveView.prototype._initAccountMenu = function() {
      var menu;
      menu = new AccountMenu();
      return menu.render($('.js-account-container')[0], {
        role: this._getRole()
      });
    };

    WaveView.prototype.markActiveBlip = function(blip) {
      /*
              @param blip: BlipView
      */      if (this._activeBlip === blip) return blip.updateCursor();
      this.clearActiveBlip();
      this._activeBlip = blip;
      this._activeBlip.setCursor();
      this._activeBlip.markActive();
      this._activeBlip.setReadState(true);
      this._model.setActiveBlip(blip.getViewModel());
      return this._setOnScrollMenuPosition();
    };

    WaveView.prototype.unlinkActiveBlip = function() {
      return delete this._activeBlip;
    };

    WaveView.prototype.clearActiveBlip = function() {
      if (!this._activeBlip) return;
      this._activeBlip.clearCursor();
      return this._activeBlip.unmarkActive();
    };

    WaveView.prototype._resizerRepositionMenu = function() {
      var _ref7;
      RangeMenu.get().hide();
      return (_ref7 = this._activeBlip) != null ? _ref7.updateMenuLeftPosition() : void 0;
    };

    WaveView.prototype._setOnScrollMenuPosition = function(e) {
      var _ref7;
      if (e == null) e = false;
      RangeMenu.get().hide();
      return (_ref7 = this._activeBlip) != null ? _ref7.updateMenuPosition(e) : void 0;
    };

    WaveView.prototype._isExistParticipant = function(email) {
      var p, participants, _j, _len2;
      participants = this._waveViewModel.getUsers(this._participants.all());
      for (_j = 0, _len2 = participants.length; _j < _len2; _j++) {
        p = participants[_j];
        if (p.getEmail() === email) return true;
      }
      return false;
    };

    WaveView.prototype._processAddParticipantClick = function() {
      /*
              Обрабатывает нажатие на кнопку добавления участника
      */
      var email;
      email = strip(this._$participantIdInput.val());
      if (!email) return;
      if (!isEmail(email)) {
        return this._waveViewModel.showWarning("Enter valid e-mail");
      }
      if (this._isExistParticipant(email)) {
        this._waveViewModel.showWarning("Participant already added to topic");
        this._$participantIdInput.select();
        return;
      }
      this._waveProcessor.addParticipant(this._model.serverId, email, this._addButtonRole, this._processAddParticipantResponse);
      return this._$participantIdInput.val('').focus();
    };

    WaveView.prototype._processAddParticipantResponse = function(err, user) {
      /*
              Обрабатывает ответ сервера на добавление пользователя
              @param err: object|null
      */
      var _ref7;
      if (err) return this._waveViewModel.showWarning(err.message);
      $(this.container).parent('.js-inner-wave-container').find('.js-wave-notifications .js-wave-warning').remove();
      trackParticipantAddition('By email field', user);
      this._waveViewModel.updateUserInfo(user);
      this._waveProcessor.addOrUpdateContact(user);
      return (_ref7 = this._addParticipantForm) != null ? _ref7.restartAutocompleter() : void 0;
    };

    WaveView.prototype._expandCrossedBlipRange = function(range, blipViewStart, blipViewEnd, directionForward) {
      var commonView, el, end, endThread, endView, endViewContainer, start, startThread, startView, startViewContainer, _ref7;
      if (blipViewEnd) {
        start = [];
        end = [];
        startView = blipViewStart;
        while (startView) {
          start.push(startView);
          startView = startView.getParent();
        }
        endView = blipViewEnd;
        while (endView) {
          end.push(endView);
          endView = endView.getParent();
        }
        while ((startView = start.pop()) === (endView = end.pop())) {
          commonView = startView;
        }
        if (startView) {
          startThread = BlipThread.getBlipThread(startView.getContainer());
          startViewContainer = startThread.getContainer();
          range.setStartBefore(startViewContainer);
          if (this._lastRange) {
            if (range.compareBoundaryPoints(Range.START_TO_START, this._lastRange) > -1) {
              range.setStartAfter(startViewContainer);
            }
          }
        }
        if (endView) {
          endThread = BlipThread.getBlipThread(endView.getContainer());
          endViewContainer = endThread.getContainer();
          range.setEndAfter(endViewContainer);
          if (this._lastRange) {
            if (range.compareBoundaryPoints(Range.END_TO_END, this._lastRange) < 1) {
              range.setEndBefore(endViewContainer);
            }
          }
        }
      } else {
        el = (_ref7 = blipViewStart.getEditor()) != null ? _ref7.getContainer() : void 0;
        commonView = blipViewStart;
        if (el) range.setEnd(el, el.childNodes.length);
      }
      DOM.setRange(range, directionForward);
      if (commonView != null) commonView.getEditor().focus();
      return [commonView, range];
    };

    WaveView.prototype._getBlipAndRange = function() {
      /*
              Возвращает текущее выделение и блип, в котором оно сделано
              @return: [BlipView, DOM range]|null
      */
      var blipViewEnd, blipViewStart, cursor, directionForward, editor, range, selection;
      if (!this.rootBlip) return null;
      selection = window.getSelection();
      if (!selection || !selection.rangeCount) return;
      range = selection.getRangeAt(0);
      if (!range) return null;
      cursor = [range.startContainer, range.startOffset];
      blipViewStart = this.rootBlip.getView().getBlipContainingCursor(cursor);
      directionForward = selection.anchorNode === range.startContainer && selection.anchorOffset === range.startOffset ? true : false;
      if (!blipViewStart) return null;
      cursor = [range.endContainer, range.endOffset];
      blipViewEnd = range.collapsed ? blipViewStart : this.rootBlip.getView().getBlipContainingCursor(cursor);
      if (blipViewStart !== blipViewEnd) {
        return this._expandCrossedBlipRange(range, blipViewStart, blipViewEnd, directionForward);
      } else if (blipViewStart !== this._lastBlip) {
        editor = blipViewStart.getEditor();
        editor.focus();
      }
      return [blipViewStart, range];
    };

    WaveView.prototype._createBlip = function(forceCreate) {
      var blip, blipViewModel, opParams;
      if (forceCreate == null) forceCreate = false;
      /*
              @param: forceCreate boolean
              @return: BlipViewModel | undefined
      */
      opParams = this._getBlipAndRange();
      if (!opParams) return;
      blip = opParams[0];
      if (!this._inEditMode || forceCreate) {
        blipViewModel = blip.initInsertInlineBlip();
        if (!blipViewModel) return;
        return blipViewModel;
      }
    };

    WaveView.prototype._insertBlipButtonClick = function() {
      var blipViewModel;
      blipViewModel = this._createBlip(true);
      if (!blipViewModel) return;
      return _gaq.push(['_trackEvent', 'Blip usage', 'Insert reply', 'Re in editing menu']);
    };

    WaveView.prototype._insertMention = function() {
      var blipView, blipViewModel;
      blipViewModel = this._createBlip();
      blipView = !blipViewModel ? this._activeBlip : blipViewModel.getView();
      if (!blipView) return;
      return setTimeout(function() {
        var recipientInput;
        recipientInput = blipView.getEditor().insertRecipient();
        return recipientInput != null ? recipientInput.insertionEventLabel = 'Menu button' : void 0;
      }, 0);
    };

    WaveView.prototype._insertTag = function() {
      var blipView, blipViewModel;
      blipViewModel = this._createBlip();
      blipView = !blipViewModel ? this._activeBlip : blipViewModel.getView();
      if (!blipView) return;
      return setTimeout(function() {
        var tagInput;
        tagInput = blipView.getEditor().insertTag();
        return tagInput != null ? tagInput.insertionEventLabel = 'Menu button' : void 0;
      }, 0);
    };

    WaveView.prototype._insertTask = function() {
      var blipView, blipViewModel;
      blipViewModel = this._createBlip();
      blipView = !blipViewModel ? this._activeBlip : blipViewModel.getView();
      if (!blipView) return;
      return setTimeout(function() {
        var taskInput;
        taskInput = blipView.getEditor().insertTaskRecipient();
        return taskInput != null ? taskInput.insertionEventLabel = 'Menu button' : void 0;
      }, 0);
    };

    WaveView.prototype._showGadgetPopup = function(event) {
      var gadgetPopup;
      if (event.ctrlKey && event.shiftKey) {
        return this._insertGadget();
      } else {
        gadgetPopup = this.getInsertGadgetPopup();
        if (gadgetPopup.isVisible()) {
          return this._hideGadgetPopup();
        } else {
          gadgetPopup.show(this.getActiveBlip());
          return gadgetPopup.shownAt = Date.now();
        }
      }
    };

    WaveView.prototype._hideGadgetPopup = function() {
      var gadgetPopup, shouldHide, timeDiff;
      gadgetPopup = this.getInsertGadgetPopup();
      if (!(gadgetPopup != null)) return;
      shouldHide = true;
      if (gadgetPopup.shownAt != null) {
        timeDiff = Date.now() - gadgetPopup.shownAt;
        shouldHide = timeDiff > 100;
      }
      if (shouldHide) return gadgetPopup.hide();
    };

    WaveView.prototype.getInsertGadgetPopup = function() {
      var control, _j, _len2, _ref7;
      if (!this._insertGadgetPopup && this._activeBlipControlButtons) {
        _ref7 = this._activeBlipControlButtons;
        for (_j = 0, _len2 = _ref7.length; _j < _len2; _j++) {
          control = _ref7[_j];
          if (control.className === '.js-insert-gadget') {
            this._insertGadgetPopup = control.$button[0].insertGadgetPopup;
          }
        }
      }
      return this._insertGadgetPopup;
    };

    WaveView.prototype._insertGadget = function() {
      var blip, opParams, range;
      opParams = this._getBlipAndRange();
      if (!opParams) return;
      blip = opParams[0], range = opParams[1];
      return blip.initInsertGadget();
    };

    WaveView.prototype._foldChildBlips = function() {
      /*
              Сворачивает все блипы, вложенные в текщуий
      */
      var blip, r, _base;
      if ((_base = this._ctrlRepeats).foldChildBlips == null) {
        _base.foldChildBlips = 0;
      }
      if (this._ctrlRepeats.foldChildBlips) {
        blip = this.rootBlip.getView();
        blip.foldAllChildBlips();
        blip.setCursorToStart();
        this._checkRange();
      } else {
        r = this._getBlipAndRange();
        if (!r) return;
        blip = r[0];
        blip.foldAllChildBlips();
      }
      if (blip === this.rootBlip.getView()) {
        _gaq.push(['_trackEvent', 'Blip usage', 'Hide replies', 'Root shortcut']);
      } else {
        _gaq.push(['_trackEvent', 'Blip usage', 'Hide replies', 'Reply shortcut']);
      }
      return this._ctrlRepeats.foldChildBlips++;
    };

    WaveView.prototype._unfoldChildBlips = function() {
      /*
              Разворачивает все блипы, вложенные в текщуий
      */
      var blip, r;
      this._ctrlRepeats.foldChildBlips = 0;
      r = this._getBlipAndRange();
      if (!r) return;
      blip = r[0];
      if (blip === this.rootBlip.getView()) {
        _gaq.push(['_trackEvent', 'Blip usage', 'Show replies', 'Root shortcut']);
      } else {
        _gaq.push(['_trackEvent', 'Blip usage', 'Show replies', 'Reply shortcut']);
      }
      return blip.unfoldAllChildBlips();
    };

    WaveView.prototype._selectAll = function() {
      /*
              Выделяет все содержимое блипа, при двукратном нажатии - все содержимое корневого тредового блипа
      */
      var b, bContainer, bView, blip, blips, node, r, range, _, _base;
      if ((_base = this._ctrlRepeats).selectAll == null) _base.selectAll = 0;
      if (this._ctrlRepeats.selectAll) {
        blips = this.rootBlip.getView().getChildBlips();
        blip = null;
        r = DOM.getRange();
        if (!r) return;
        node = r.startContainer;
        for (_ in blips) {
          if (!__hasProp.call(blips, _)) continue;
          b = blips[_];
          bView = b.getView();
          bContainer = bView.getContainer();
          if (DOM.contains(bContainer, node) || bContainer === node) {
            blip = bView;
            break;
          }
        }
        if (!blip) return;
      } else {
        r = this._getBlipAndRange();
        if (!r) return;
        blip = r[0];
      }
      this._ctrlRepeats.selectAll++;
      range = blip.selectAll();
      return this._checkChangedRange(range, blip);
    };

    WaveView.prototype._goToUnread = function() {
      /*
              Переводит фокус на первый непрочитаный блип,
              расположенный после блипа под фокусом
      */      if (this._curView !== 'text') return;
      return this.emit('goToNextUnread');
    };

    WaveView.prototype.getActiveBlip = function() {
      return this._activeBlip.getViewModel();
    };

    WaveView.prototype.getRootBlip = function() {
      return this.rootBlip;
    };

    WaveView.prototype.updateRangePos = function() {
      return this._setOrUpdateRangeMenuPos(true);
    };

    WaveView.prototype._setOrUpdateRangeMenuPos = function(update) {
      var menu;
      menu = RangeMenu.get();
      if (!this._lastBlip || !this._lastRange) return menu.hide();
      if (!BrowserSupport.isSupported()) return menu.hide();
      if (update) {
        return this._lastBlip.updateRangeMenuPosByRange(this._lastRange, this.container);
      } else {
        return this._lastBlip.setRangeMenuPosByRange(this._lastRange, this.container);
      }
    };

    WaveView.prototype._preProcessKeyDownEvent = function(e) {
      var handlers;
      if (e.ctrlKey || e.metaKey) {
        handlers = this._ctrlHandlers;
        if (e.shiftKey) handlers = this._ctrlShiftHandlers;
      } else if (e.shiftKey) {
        handlers = this._shiftHandlers;
      }
      return this._processKeyDownEvent(handlers, e);
    };

    WaveView.prototype._processKeyDownEvent = function(handlers, e) {
      /*
              Обрабатывает нажатия клавиш внутри блипов
              @param e: DOM event
      */      if (((!(e.ctrlKey || e.metaKey)) && (!e.shiftKey)) || e.altKey) return;
      if (!(e.keyCode in handlers)) return;
      handlers[e.keyCode]();
      e.preventDefault();
      return e.stopPropagation();
    };

    WaveView.prototype._processBlipKeyUpEvent = function(e) {
      /*
              Обрабатывает отпускание клавиш внутри блипов
              @param e: DOM event
      */      if (e.which !== 17 || e.keyCode !== 17) return;
      return this._ctrlRepeats = {};
    };

    WaveView.prototype._removeAutocompleter = function() {
      var _ref7, _ref8;
      if ((_ref7 = this._autoCompleter) != null) _ref7.deactivate();
      if ((_ref8 = this._autoCompleter) != null) _ref8.dom.$results.remove();
      return delete this._autoCompleter;
    };

    WaveView.prototype._processClickEvent = function() {
      return this._setOrUpdateRangeMenuPos(false);
    };

    WaveView.prototype.destroy = function() {
      var $wnd, _ref7, _ref8, _ref9;
      WaveView.__super__.destroy.call(this);
      delete this._ctrlHandlers;
      delete this._ctrlShiftHandlers;
      delete this._shiftHandlers;
      delete this._globalCtrlHandlers;
      window.removeEventListener('keydown', this._globalKeyHandler, true);
      delete this._globalKeyHandler;
      LocalStorage.removeListener('buffer', this._handleBufferUpdate);
      this._closed = true;
      if ((_ref7 = this._$addButtonSelect) != null) _ref7.selectBox('destroy');
      if ((_ref8 = this._addParticipantForm) != null) _ref8.destroy();
      delete this._insertGadgetPopup;
      if ((_ref9 = this._participants) != null) _ref9.destroy();
      delete this._participants;
      this._destroySavingMessage();
      require('../editor/file/upload_form').removeInstance();
      this.removeListeners('range-change');
      this.removeAllListeners();
      $(this._waveBlips).off('scroll');
      $(window).off('scroll', this._setOnScrollMenuPosition);
      this.blipNode.removeEventListener('keydown', this._preProcessKeyDownEvent, true);
      if (BrowserSupport.isMozilla()) {
        this.blipNode.removeEventListener('keypress', this._processFFEnterKeypress, true);
      }
      this.blipNode.removeEventListener('keyup', this._processBlipKeyUpEvent, true);
      this.blipNode.removeEventListener('click', this._processClickEvent, false);
      delete this.blipNode;
      window.removeEventListener('keydown', this.runCheckRange, false);
      window.removeEventListener('mousedown', this._windowCheckCusor, false);
      window.removeEventListener('mouseup', this._windowCheckCusor, false);
      $wnd = $(window);
      $wnd.off('resize resizeTopicByResizer', this._setParticipantsWidth);
      $wnd.off('resize resizeTopicByResizer', this._resizerRepositionMenu);
      this._destroyMindmap();
      this._removeAutocompleter();
      $(this.container).empty().unbind();
      this._disableActiveBlipControls();
      this._deinitActiveBlipControls();
      delete this.rootBlip;
      if (this._activeBlip) delete this._activeBlip;
      if (this._editingBlip) delete this._editingBlip;
      if (this._lastBlip) delete this._lastBlip;
      if (this._lastEditableBlip) delete this._lastEditableBlip;
      this._destroyDragScroll();
      this.container = void 0;
      delete this._model;
      delete this._waveViewModel;
      return jQuery.fragments = {};
    };

    WaveView.prototype.applyParticipantOp = function(op) {
      var isMyOp, _ref7, _ref8;
      this._participants.applyOp(op);
      if (!window.loggedIn) return;
      isMyOp = ((_ref7 = op.ld) != null ? _ref7.id : void 0) === window.userInfo.id || ((_ref8 = op.li) != null ? _ref8.id : void 0) === window.userInfo.id;
      if (!isMyOp) return;
      return this.updateInterfaceAccordingToRole();
    };

    WaveView.prototype.updateInterfaceAccordingToRole = function() {
      this._waveViewModel.updateParticipants();
      this._updateParticipantsManagement();
      this.rootBlip.getView().recursivelyUpdatePermission();
      return this._updateReplyButtonState();
    };

    WaveView.prototype._updateReplyButtonState = function() {
      /*
              Ставится или снимается класс, прячущий кнопки реплаев
      */
      var _ref7;
      if ((_ref7 = this._waveViewModel.getRole()) === ROLE_OWNER || _ref7 === ROLE_EDITOR || _ref7 === ROLE_COMMENTATOR) {
        $(this.container).removeClass('read-only');
        return this._canReply = true;
      } else {
        $(this.container).addClass('read-only');
        return this._canReply = false;
      }
    };

    WaveView.prototype._updateParticipantsManagement = function() {
      /*
              Приводит окна управления пользователей в состояние, соответствующее текущим правам
      */      this._updateParticipantAddition();
      return this._updateWaveSharing();
    };

    WaveView.prototype._updateParticipantAddition = function() {
      var defaultRole, myRole, _ref10, _ref11, _ref12, _ref7, _ref8, _ref9;
      myRole = this._waveViewModel.getRole();
      if (myRole === ROLE_NO_ROLE) {
        if ((_ref7 = this._$addButton) != null) _ref7.attr('disabled', 'disabled');
      } else {
        if ((_ref8 = this._$addButton) != null) _ref8.removeAttr('disabled');
        if (this._model.getSharedState() === WAVE_SHARED_STATE_PRIVATE) {
          defaultRole = myRole;
          if (defaultRole === ROLE_OWNER) defaultRole = ROLE_EDITOR;
          this._addButtonRole = defaultRole;
          if ((_ref9 = this._$addButtonSelect) != null) {
            _ref9.selectBox('value', defaultRole);
          }
        } else {
          this._addButtonRole = this._model.getDefaultRole();
          if ((_ref10 = this._$addButtonSelect) != null) {
            _ref10.selectBox('value', this._model.getDefaultRole());
          }
        }
      }
      if ((myRole === ROLE_OWNER || myRole === ROLE_EDITOR)) {
        return (_ref11 = this._$addButtonSelect) != null ? _ref11.selectBox('enable') : void 0;
      } else {
        return (_ref12 = this._$addButtonSelect) != null ? _ref12.selectBox('disable') : void 0;
      }
    };

    WaveView.prototype._updateWaveSharing = function() {
      var _ref7;
      if (((_ref7 = this._waveViewModel.getRole()) === ROLE_OWNER || _ref7 === ROLE_EDITOR)) {
        $([this._isPrivateButton, this._isByLinkButton, this._isPublicButton]).removeAttr('disabled');
        $([this._publicRoleSelect, this._sharedRoleSelect]).removeClass('disabled');
        return this._canChangeTopicShare = true;
      } else {
        if (this._isPrivateButton || this._isByLinkButton || this._isPublicButton) {
          $([this._isPrivateButton, this._isByLinkButton, this._isPublicButton]).attr('disabled', 'disabled');
        }
        if (this._publicRoleSelect || this._sharedRoleSelect) {
          $([this._publicRoleSelect, this._sharedRoleSelect]).addClass('disabled');
        }
        return this._canChangeTopicShare = false;
      }
    };

    WaveView.prototype.isExistParticipant = function(email) {
      return this._isExistParticipant(email);
    };

    WaveView.prototype.processAddParticipantResponse = function(err, user) {
      return this._processAddParticipantResponse(err, user);
    };

    WaveView.prototype.getUrl = function() {
      /*
              Возвращает ссылку, соответствующую волне
              @return: string
      */      return "" + document.location.protocol + "//" + (window.HOST + History.getWavePrefix()) + this._model.serverId + "/";
    };

    WaveView.prototype.getExportUrl = function() {
      return "/api/export/1/" + this._model.serverId + "/html/";
    };

    WaveView.prototype._getEmbeddedUrl = function() {
      return "" + document.location.protocol + "//" + (window.HOST + History.getEmbeddedPrefix()) + this._model.serverId + "/";
    };

    WaveView.prototype.getSocialSharingUrl = function() {
      /*
              Возвращает ссылку для шаринга волны в соцсетях
              @return: string
      */      return document.location.protocol + '//' + window.HOST + window.socialSharingConf.url + this._model.serverId + this._model.socialSharingUrl.substr(0, window.socialSharingConf.signLength) + ("/" + (randomString(2)));
    };

    WaveView.prototype._initTips = function() {
      this._$topicTipsContainer = $(this.container).find('.js-topic-tip');
      this._$topicTipsContainer.find('.js-hide-topic-tip').click(this._hideTip);
      return this._$topicTipsContainer.find('.js-next-tip').click(this._showNextTip);
    };

    WaveView.prototype._tipIsHidden = function() {
      var lastHiddenDate;
      if (!LocalStorage.loginCountIsMoreThanTwo()) return true;
      lastHiddenDate = LocalStorage.getLastHiddenTipDate() - 0;
      return this._lastTipDate <= lastHiddenDate;
    };

    WaveView.prototype.showTip = function(text, _lastTipDate, force) {
      var $textContainer;
      this._lastTipDate = _lastTipDate;
      if (force == null) force = false;
      if (!force && this._tipIsHidden()) return;
      if (force) LocalStorage.removeLastHiddenTipDate();
      $textContainer = this._$topicTipsContainer.find('.js-topic-tip-text');
      $textContainer.html(text).find('a').attr('target', '_blank');
      $textContainer.attr('title', $textContainer.text());
      return $(this.container).addClass('tip-shown');
    };

    WaveView.prototype._hideTip = function() {
      _gaq.push(['_trackEvent', 'Tips', 'Close tip']);
      LocalStorage.setLastHiddenTipDate(this._lastTipDate);
      return $(this.container).removeClass('tip-shown');
    };

    WaveView.prototype._showNextTip = function() {
      _gaq.push(['_trackEvent', 'Tips', 'Show next tip']);
      return this._waveProcessor.showNextTip();
    };

    WaveView.prototype.setTextView = function() {
      if (this._curView === 'text') return;
      this._curView = 'text';
      $(this._waveContent).removeClass('mindmap-view');
      return this.emit('wave-view-change');
    };

    WaveView.prototype.setMindmapView = function() {
      if (this._curView === 'mindmap') return;
      this._curView = 'mindmap';
      $(this._waveContent).addClass('mindmap-view');
      _gaq.push(['_trackEvent', 'Topic content', 'Switch to mindmap']);
      if (!(this._mindmap != null)) {
        this._initMindmap();
      } else {
        this._mindmap.update();
      }
      return this.emit('wave-view-change');
    };

    WaveView.prototype.setShortMindmapView = function() {
      var _ref7;
      return (_ref7 = this._mindmap) != null ? _ref7.setShortMode() : void 0;
    };

    WaveView.prototype.setLongMindmapView = function() {
      var _ref7;
      return (_ref7 = this._mindmap) != null ? _ref7.setLongMode() : void 0;
    };

    WaveView.prototype.getCurView = function() {
      return this._curView;
    };

    WaveView.prototype.getScrollableElement = function() {
      return this._waveBlips;
    };

    WaveView.prototype._initMindmap = function() {
      var mindMapContainer;
      this._mindmap = new MindMap(this._waveViewModel);
      mindMapContainer = $(this.container).find('.js-topic-mindmap-container')[0];
      return this._mindmap.render(mindMapContainer);
    };

    WaveView.prototype._destroyMindmap = function() {
      var _ref7;
      if ((_ref7 = this._mindmap) != null) _ref7.destroy();
      return delete this._mindmap;
    };

    WaveView.prototype._initDragScroll = function() {
      var el, _j, _len2, _ref7;
      this._resetDragScrollVars();
      this.container.addEventListener('dragenter', this._handleContainerDragEnterEvent, false);
      this.container.addEventListener('dragleave', this._handleContainerDragLeaveEvent, false);
      this.container.addEventListener('drop', this._handleContainerDropEvent, false);
      _ref7 = this.container.getElementsByClassName('js-scroll');
      for (_j = 0, _len2 = _ref7.length; _j < _len2; _j++) {
        el = _ref7[_j];
        el.addEventListener('dragenter', this._handleScrollDragEnterEvent, false);
        el.addEventListener('dragleave', this._handleScrollDragLeaveEvent, false);
      }
      this._scrollUpEl = this.container.getElementsByClassName('js-scroll-up')[0];
      return this._scrollDownEl = this.container.getElementsByClassName('js-scroll-down')[0];
    };

    WaveView.prototype._destroyDragScroll = function() {
      var el, _j, _len2, _ref7;
      this._resetDragScrollVars();
      this.container.removeEventListener('dragenter', this._handleContainerDragEnterEvent, false);
      this.container.removeEventListener('dragleave', this._handleContainerDragLeaveEvent, false);
      this.container.removeEventListener('drop', this._handleContainerDropEvent, false);
      _ref7 = this.container.getElementsByClassName('js-scroll');
      for (_j = 0, _len2 = _ref7.length; _j < _len2; _j++) {
        el = _ref7[_j];
        el.removeEventListener('dragenter', this._handleScrollDragEnterEvent, false);
        el.removeEventListener('dragleave', this._handleScrollDragLeaveEvent, false);
      }
      this._handleContainerDragEnterEvent = void 0;
      this._handleContainerDragLeaveEvent = void 0;
      this._handleContainerDropEvent = void 0;
      this._handleScrollDragEnterEvent = void 0;
      this._handleScrollDragLeaveEvent = void 0;
      this._doScrollOnDrag = void 0;
      this._scrollUpEl = void 0;
      return this._scrollDownEl = void 0;
    };

    WaveView.prototype._handleContainerDragEnterEvent = function() {
      this._dragCount++;
      return this._updateDragState();
    };

    WaveView.prototype._handleContainerDragLeaveEvent = function() {
      this._dragCount--;
      return this._updateDragState();
    };

    WaveView.prototype._handleContainerDropEvent = function() {
      this._resetDragScrollVars();
      return this._updateDragState();
    };

    WaveView.prototype._handleScrollDragEnterEvent = function(e) {
      this._lastDraggedOverClass = e.target.className;
      this._dragScrollAmount = parseInt(e.target.getAttribute('offset')) || 0;
      if (this._dragScrollAmount) return this._setDragScrollInterval();
    };

    WaveView.prototype._handleScrollDragLeaveEvent = function(e) {
      if (e.target.className === this._lastDraggedOverClass) {
        this._lastDraggedOverClass = '';
        return this._clearDragScrollInterval();
      }
    };

    WaveView.prototype._resetDragScrollVars = function() {
      this._clearDragScrollInterval();
      this._dragScrollAmount = 0;
      this._dragCount = 0;
      return this._lastDraggedOverClass = '';
    };

    WaveView.prototype._setDragScrollInterval = function() {
      this._clearDragScrollInterval();
      return this._dragScrollIntervalId = setInterval(this._doScrollOnDrag, 100);
    };

    WaveView.prototype._doScrollOnDrag = function() {
      var height, scrollHeight, scrollTop;
      scrollTop = this._waveBlips.scrollTop;
      scrollHeight = this._waveBlips.scrollHeight;
      height = this._waveBlips.offsetHeight;
      if (scrollTop + this._dragScrollAmount <= 0) {
        this._waveBlips.scrollTop = 0;
        this._clearDragScrollInterval();
        return this._updateDragState();
      }
      if (scrollTop + height + this._dragScrollAmount >= scrollHeight) {
        this._waveBlips.scrollTop = scrollHeight - height;
        this._clearDragScrollInterval();
        return this._updateDragState();
      }
      return this._waveBlips.scrollTop += this._dragScrollAmount;
    };

    WaveView.prototype._clearDragScrollInterval = function() {
      if (!this._dragScrollIntervalId) return;
      return this._dragScrollIntervalId = clearInterval(this._dragScrollIntervalId);
    };

    WaveView.prototype._updateTopScrollArea = function(show) {
      if (show) {
        return this._scrollUpEl.style.display = 'block';
      } else {
        return this._scrollUpEl.style.display = 'none';
      }
    };

    WaveView.prototype._updateBottomScrollArea = function(show) {
      if (show) {
        return this._scrollDownEl.style.display = 'block';
      } else {
        return this._scrollDownEl.style.display = 'none';
      }
    };

    WaveView.prototype._showScrollableAreas = function() {
      var height, scrollHeight, scrollTop;
      height = this._waveBlips.offsetHeight;
      scrollHeight = this._waveBlips.scrollHeight;
      if (height === scrollHeight) return this._hideScrollableAreas();
      scrollTop = this._waveBlips.scrollTop;
      if (!scrollTop) {
        this._updateTopScrollArea(false);
      } else {
        this._updateTopScrollArea(true);
      }
      if (scrollTop + height >= scrollHeight) {
        return this._updateBottomScrollArea(false);
      } else {
        return this._updateBottomScrollArea(true);
      }
    };

    WaveView.prototype._hideScrollableAreas = function() {
      this._updateTopScrollArea(false);
      return this._updateBottomScrollArea(false);
    };

    WaveView.prototype._updateDragState = function() {
      if (this._dragCount) {
        return this._showScrollableAreas();
      } else {
        return this._hideScrollableAreas();
      }
    };

    WaveView.prototype._initSavingMessage = function() {
      this._savingMessage = new SavingMessageView();
      return this._savingMessage.init(this._waveViewModel.getId(), this._waveHeader);
    };

    WaveView.prototype._destroySavingMessage = function() {
      var _ref7;
      if ((_ref7 = this._savingMessage) != null) _ref7.destroy();
      return delete this._savingMessage;
    };

    WaveView.prototype._setEditMode = function(_inEditMode) {
      var cl;
      this._inEditMode = _inEditMode;
      cl = 'wave-edit-mode';
      if (this._inEditMode) {
        DOM.addClass(this._container, cl);
      } else {
        DOM.removeClass(this._container, cl);
      }
      return this._checkChangedRange(this._lastRange, this._lastBlip);
    };

    WaveView.prototype.hasCursor = function() {
      return DOM.hasClass(this.container, 'has-cursor');
    };

    WaveView.prototype.setEditModeEnabled = function(enabled) {
      return this._setEditMode(enabled);
    };

    WaveView.prototype.isEditMode = function() {
      return this._inEditMode;
    };

    WaveView.prototype.getContainer = function() {
      return this.container;
    };

    WaveView.prototype.foldAll = function() {
      if (this._curView === 'text') {
        return this.rootBlip.getView().foldAllChildBlips();
      } else {
        return this._mindmap.fold();
      }
    };

    WaveView.prototype.unfoldAll = function() {
      if (this._curView === 'text') {
        return this.rootBlip.getView().unfoldAllChildBlips();
      } else {
        return this._mindmap.unfold();
      }
    };

    WaveView.prototype._initBuffer = function() {
      LocalStorage.on('buffer', this._handleBufferUpdate);
      return this._updateBufferPresenceMark(LocalStorage.hasBuffer());
    };

    WaveView.prototype._updateBufferPresenceMark = function(hasBuffer) {
      if (hasBuffer) {
        return $(this.container).addClass('has-buffer');
      } else {
        return $(this.container).removeClass('has-buffer');
      }
    };

    WaveView.prototype._handleBufferUpdate = function(param) {
      return this._updateBufferPresenceMark(param.newValue != null);
    };

    WaveView.prototype.setReservedHeaderSpace = function(_reservedHeaderSpace) {
      this._reservedHeaderSpace = _reservedHeaderSpace;
      return this._setParticipantsWidth();
    };

    return WaveView;

  })(WaveViewBase);

  SavingMessageView = (function() {

    SavingMessageView.prototype.SAVE_TIME = 0.5;

    SavingMessageView.prototype.FADE_TIME = 120;

    function SavingMessageView() {
      this._onFinishSend = __bind(this._onFinishSend, this);
      this._onStartSend = __bind(this._onStartSend, this);      this._saveTimeout = null;
      this._fadeTimeout = null;
    }

    SavingMessageView.prototype._getMessages = function() {
      var container;
      container = $(this._container);
      return [container.find('.js-saving-message-saving'), container.find('.js-saving-message-saved')];
    };

    SavingMessageView.prototype._onStartSend = function(groupId) {
      var saved, saving, _ref7;
      if (groupId !== this._waveId) return;
      _ref7 = this._getMessages(), saving = _ref7[0], saved = _ref7[1];
      saved.removeClass('visible');
      return saving.addClass('visible');
    };

    SavingMessageView.prototype._onFinishSend = function(groupId) {
      var _this = this;
      if (this._saveTimeout) clearTimeout(this._saveTimeout);
      return this._saveTimeout = setTimeout(function() {
        var saved, saving, _ref7;
        if (groupId !== _this._waveId) return;
        _ref7 = _this._getMessages(), saving = _ref7[0], saved = _ref7[1];
        saving.removeClass('visible');
        saved.addClass('visible');
        if (_this._fadeTimeout) clearTimeout(_this._fadeTimeout);
        return _this._fadeTimeout = setTimeout(function() {
          return saved.removeClass('visible');
        }, _this.FADE_TIME * 1000);
      }, this.SAVE_TIME * 1000);
    };

    SavingMessageView.prototype.init = function(_waveId, _container) {
      var processor;
      this._waveId = _waveId;
      this._container = _container;
      processor = require('../ot/processor').instance;
      processor.on('start-send', this._onStartSend);
      return processor.on('finish-send', this._onFinishSend);
    };

    SavingMessageView.prototype.destroy = function() {
      var processor;
      processor = require('../ot/processor').instance;
      processor.removeListener('start-send', this._onStartSend);
      processor.removeListener('finish-send', this._onFinishSend);
      clearTimeout(this._saveTimeout);
      return clearTimeout(this._fadeTimeout);
    };

    return SavingMessageView;

  })();

  module.exports = {
    WaveView: WaveView
  };

}).call(this);

});

require.define("/lib/client/client/wave/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ck, likesForAnonymousPublic, renderContentMobile, selectAccountTypeBannerTmpl, waveContentTmplMobile, waveHeaderTmplMobile, waveTmpl;

  ck = window.CoffeeKup;

  waveTmpl = function() {
    /*
        Шаблон волны
    */
    var contentClasses, getShareSettingsPopup;
    getShareSettingsPopup = function() {
      return div('js-gdrive-share-menu popup-menu-container gdrive-menu-container hidden', function() {
        return div('internal-container', function() {
          return div('settings-menu', function() {
            if (this.gDriveShareUrl) {
              a({
                href: h(this.gDriveShareUrl),
                target: '_blank'
              }, 'Share via Google Drive');
            }
            a('js-add-block-button js-btn', {
              href: '#'
            }, 'Share via Rizzoma');
            return a('js-share-window-button js-btn', {
              href: '#'
            }, 'Make Public/Shared by link');
          });
        });
      });
    };
    div('.js-scroll-up .js-scroll .drag-scroll-up', function() {
      div('.js-scroll-u-1000 .scroll-20', {
        offset: '-1000'
      });
      div('.js-scroll-u-500 .scroll-20', {
        offset: '-500'
      });
      div('.js-scroll-u-250 .scroll-20', {
        offset: '-250'
      });
      return div('.js-scroll-u-50 .scroll-20', {
        offset: '-50'
      });
    });
    div('.js-wave-header.wave-header', function() {
      if (!this.empty) {
        if (this.isAnonymous) {
          div('.anonymous-login-container', function() {
            text('Feel free to add info, ask question or comment');
            return a('.js-enter-rizzoma-btn.btn.sign-in-btn', {
              href: "/topic/",
              title: "Sign in"
            }, function() {
              return text('Enter Rizzoma');
            });
          });
        } else {
          if (!this.isGDriveView) {
            div('.js-add-participant-block.add-participant-block', function() {
              button('.js-add-block-button.add-block-button', 'Invite');
              return div('.js-add-form.add-form', '');
            });
          }
        }
        if (this.isAnonymous) {
          div('.anonymous-wave-info', function() {
            span('.participants-caption', 'Participants:');
            return div('.js-wave-participants.wave-participants', '');
          });
          return;
        }
        div('.js-wave-participants.wave-participants', '');
        div('.js-share-container.share-section.wave-header-section', function() {
          button("js-show-share-button wave-share-button " + (this.gDriveShareUrl ? 'gdrive' : ''), function() {
            div('.lock', '');
            div('gdrive-icon16', '');
            return text('Share');
          });
          if (this.isGDriveView) {
            getShareSettingsPopup();
            div('.js-add-participant-block.add-participant-block', function() {
              return div('.js-add-form.add-form', '');
            });
          }
          return div('.js-share-window.wave-share-popup hidden', function() {
            return div('.internal-container', function() {
              div('.wave-url-sharing', function() {
                div('.wave-url-container', function() {
                  return input('.js-wave-url.wave-url', {
                    type: "text",
                    value: "" + this.url,
                    readonly: 'readonly'
                  });
                });
                return div('.js-social-section.social-section', function() {
                  div('.js-social-overlay.social-overlay', {
                    title: "To share topic on social networks make it Shared by link or Public"
                  });
                  button('.js-social-facebook.social-facebook', {
                    title: "Share topic on Facebook"
                  });
                  button('.js-social-google.social-google', {
                    title: "Share topic on Google+"
                  });
                  return button('.js-social-twitter.social-twitter', {
                    title: "Share topic on Twitter"
                  });
                });
              });
              div('.wave-share-window-delimiter', '');
              div('.make-public-section', function() {
                label('.sharing-section', function() {
                  input('.js-is-private-button', {
                    type: 'radio',
                    name: 'privacy'
                  });
                  return div('.description', function() {
                    div('.description-icon', function() {
                      return img('', {
                        src: '/s/img/sharing_lock.png'
                      });
                    });
                    return div('.description-text', function() {
                      span('Private.');
                      return span('.section-details', " Only listed participants can access. Sign-in required.");
                    });
                  });
                });
                label('.sharing-section.by-link', function() {
                  input('.js-by-link-button', {
                    type: 'radio',
                    name: 'privacy'
                  });
                  return div('.description', function() {
                    div('.description-icon', function() {
                      return img('', {
                        src: '/s/img/sharing_link.png'
                      });
                    });
                    return div('.description-text', function() {
                      span('Anyone with the link.');
                      return span('.section-details', function() {
                        text(" Anyone who has the link can ");
                        a('.new-participant-role-select.js-shared-role-select', 'edit');
                        return text(".");
                      });
                    });
                  });
                });
                return label('.sharing-section.public', function() {
                  input('.js-is-public-button', {
                    type: 'radio',
                    name: 'privacy'
                  });
                  return div('.description', function() {
                    div('.description-icon', function() {
                      return img('', {
                        src: '/s/img/sharing_unlock.png'
                      });
                    });
                    return div('.description-text', function() {
                      span('Public on the web.');
                      return span('.section-details', function() {
                        text(" Anyone can find and ");
                        a('.new-participant-role-select.js-public-role-select', 'edit');
                        return text(".");
                      });
                    });
                  });
                });
              });
              if (!this.gDriveShareUrl) return;
              hr('');
              return div({
                style: 'color: #000; font-size: 13px; line-height: normal;'
              }, function() {
                span('This topic was shared via Google Drive ');
                return a('button', {
                  target: '_blank',
                  href: h(this.gDriveShareUrl)
                }, 'Settings');
              });
            });
          });
        });
        div('.js-saving-message.saving-message.wave-header-section', function() {
          div('.js-saving-message-saving', 'Saving topic...');
          return div('.js-saving-message-saved', 'Topic saved');
        });
      }
      div('.js-settings-container.wave-header-section.settings-section', '');
      return div('.clearer', '');
    });
    div('.js-topic-tip.topic-tip', function() {
      span('.js-topic-tip-text.topic-tip-text', '');
      return div('.tip-management', function() {
        button('.js-next-tip.next-tip', 'Next tip ');
        return button('.js-hide-topic-tip.hide-topic-tip', 'Close');
      });
    });
    div('.js-wave-panel.wave-panel', '');
    contentClasses = '.js-wave-content.wave-content';
    if (this.isAnonymous) contentClasses += '.no-editing';
    div(contentClasses, function() {
      if (!this.empty) {
        div('.js-wave-blips.wave-blips', function() {
          div('.js-container-blip container-blip', '');
          if (!this.isAnonymous) {
            return div('topic-url', function() {
              return a('js-topic-url', {
                href: this.url
              }, 'Open as topic');
            });
          }
        });
        return div('.js-topic-mindmap-container.topic-mindmap-container', '');
      }
    });
    return div('.js-scroll-down .js-scroll .drag-scroll-down', function() {
      div('.js-scroll-d-50 scroll-20', {
        offset: '50'
      });
      div('.js-scroll-d-250 scroll-20', {
        offset: '250'
      });
      div('.js-scroll-d-500 scroll-10', {
        offset: '500'
      });
      return div('.js-scroll-d-1000 scroll-10', {
        offset: '1000'
      });
    });
  };

  waveHeaderTmplMobile = function() {
    return section('header js-wave-header', function() {
      return div('wrapper', function() {
        if (this.isAnonymous) {
          div('.anonymous-login-container', function() {
            return a('.js-enter-rizzoma-btn.btn.sign-in-btn', {
              href: "/topic/?mode=mobile",
              title: "Sign in"
            }, function() {
              return text('Sign in');
            });
          });
        }
        button("js-back-button.header-button.back-button", function() {
          return div('icon', '');
        });
        button("js-toggle-edit-mode active-blip-control.header-button.edit-button", {
          disabled: 'disabled'
        }, function() {
          return span('Edit');
        });
        button("js-insert-reply.active-blip-control.header-button.reply-button", {
          disabled: 'disabled'
        }, function() {
          return div('icon', '');
        });
        button("js-insert-mention.active-blip-control.header-button.mention-button", {
          disabled: 'disabled'
        }, function() {
          return div('icon', '');
        });
        button("js-hide-replies-button.active-blip-control.header-button.collapse-button", {
          disabled: 'disabled'
        }, function() {
          return div('icon', '');
        });
        button("js-show-replies-button.active-blip-control.header-button.expand-button", {
          disabled: 'disabled'
        }, function() {
          return div('icon', '');
        });
        return button('js-next-unread-button header-button next-unread-button', {
          disabled: 'disabled'
        }, function() {
          span({
            style: "display: inline-block;"
          }, 'Next');
          return div('icon', '');
        });
      });
    });
  };

  waveContentTmplMobile = function() {
    /*
        Шаблон волны
    */    return div('.js-wave-content.wave-content', function() {
      if (!this.empty) {
        return div('.wave-blips', function() {
          div('.js-container-blip container-blip', function() {});
          return div('.js-root-blip-menu.root-blip-menu', function() {
            return div('.menu-content', function() {
              div('.root-button-delimiter', '');
              button('.js-root-reply-button.root-reply-button', {
                disabled: 'disabled'
              }, function() {
                img('', {
                  src: '/s/img/ico_reply.png'
                });
                return text('Reply');
              });
              div('.root-button-delimiter', '');
              return div('.clearer', '');
            });
          });
        });
      }
    });
  };

  likesForAnonymousPublic = function() {
    div('.public-like', function() {
      return text('<fb:like href="http://facebook.com/rizzomacom" send="false" layout="button_count" width="95" show_faces="false" font="verdana" style="top: -3px;"></fb:like>');
    });
    div('.public-like', function() {
      a('.twitter-share-button', {
        href: "https://twitter.com/share"
      });
      return text('  <script>\
                    !function(d,s,id){\
                        var js,fjs=d.getElementsByTagName(s)[0];\
                        if(!d.getElementById(id)){js=d.createElement(s);\
                            js.id=id;\
                            js.src="//platform.twitter.com/widgets.js";\
                            fjs.parentNode.insertBefore(js,fjs);\
                        }}(document,"script","twitter-wjs");\
                </script>');
    });
    div('.public-like', function() {
      return text('  <script type="text/javascript">\
                    function googleLikeCallback(e) {\
                        if (e.state == "on") _gaq.push(["_trackEvent", "Social", "+1", "public anonymous"]);\
                    }\
                </script>\
                <g:plusone size="medium" callback="googleLikeCallback"></g:plusone>\
                <script type="text/javascript">\
                    (function() {\
                        var po = document.createElement("script"); po.type = "text/javascript"; po.async = true;\
                        po.src = "https://apis.google.com/js/plusone.js";\
                        var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(po, s);\
                    })();\
                </script>');
    });
    return div('.clearer', '');
  };

  selectAccountTypeBannerTmpl = function() {
    return div('.js-account-wizard-banner.account-wizard-banner', function() {
      div('.js-close-account-wizard-banner.close-account-wizard-banner', function() {
        text('Close');
        return img({
          src: '/s/img/close-account-select-banner.png'
        });
      });
      img({
        src: "/s/img/logo/for-select-acc-banner.png"
      });
      return div('.content-block', function() {
        span("js-open-account-select open-account-select", "Click here");
        return span(" to upgrade your account");
      });
    });
  };

  exports.renderWave = ck.compile(waveTmpl);

  exports.renderWaveHeaderMobile = ck.compile(waveHeaderTmplMobile);

  renderContentMobile = ck.compile(waveContentTmplMobile);

  exports.renderWaveMobile = function(params) {
    if (params == null) params = {};
    return exports.renderWaveHeaderMobile(params) + renderContentMobile(params);
  };

  exports.renderLikesForAnonymousPublic = ck.compile(likesForAnonymousPublic);

  exports.renderSelectAccountTypeBanner = ck.compile(selectAccountTypeBannerTmpl);

}).call(this);

});

require.define("/lib/client/client/utils/random_string.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var randomString;

  randomString = exports.randomString = function(length, special) {
    var iteration, randString, randomNumber;
    if (length == null) length = 0;
    if (special == null) special = false;
    /*
        Генерирует строку из случайных символов
        @param length: int длина генерируемой строки
        @param special: bool включать ли в строку спецсимволы
    */
    iteration = 0;
    randString = "";
    while (iteration < length) {
      randomNumber = (Math.floor(Math.random() * 100) % 94) + 33;
      if (!special) {
        if ((randomNumber >= 33) && (randomNumber <= 47)) continue;
        if ((randomNumber >= 58) && (randomNumber <= 64)) continue;
        if ((randomNumber >= 91) && (randomNumber <= 96)) continue;
        if ((randomNumber >= 123) && (randomNumber <= 126)) continue;
      }
      iteration++;
      randString += String.fromCharCode(randomNumber);
    }
    return randString;
  };

}).call(this);

});

require.define("/lib/client/client/wave/settings_menu.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BrowserEvents, EmbeddedCodeGenerator, PopupContent, Request, SettingsMenu, SettingsPopup, buttonTmpl, ck, popup, popupTmpl, renderButton, renderPopup, _ref,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  Request = require('../../share/communication').Request;

  _ref = require('../popup'), popup = _ref.popup, PopupContent = _ref.PopupContent;

  EmbeddedCodeGenerator = require('./embedded_code_generator_window');

  BrowserEvents = require('../../utils/browser_events');

  ck = window.CoffeeKup;

  buttonTmpl = function() {
    return button('.js-show-settings-button.wave-header-button.show-settings-button', {
      title: 'Show settings'
    });
  };

  popupTmpl = function() {
    return div('.settings-menu', function() {
      var _ref2;
      a('.js-read-all', {
        href: '#',
        title: "Mark this topic as read"
      }, 'Mark topic as read');
      a('.js-follow-topic', {
        href: '#',
        title: "Follow topic"
      }, 'Follow');
      a('.js-unfollow-topic', {
        href: '#',
        title: "Unfollow topic"
      }, 'Unfollow');
      if (!((_ref2 = window.userInfo) != null ? _ref2.inIframe : void 0)) {
        a('.js-start-hangout', {
          href: "https://talkgadget.google.com/hangouts?gid=" + (h(window.socialSharingConf.hangoutAppId)) + "&gd=" + (h(this.topicId)),
          target: '_blank',
          title: "Start Google+ Hangout with Rizzoma topic embedded"
        }, 'Start G+ Hangout');
      }
      a('.js-print-topic', {
        href: '#',
        title: 'Print topic contents'
      }, 'Print');
      if (this.exportUrl) {
        a('.js-single-export', {
          href: this.exportUrl,
          target: '_blank',
          title: 'Export opened topic as HTML'
        }, 'Export single topic');
      }
      a('.js-multi-export', {
        href: '#',
        title: 'Export multiple topics as ZIP-archive'
      }, 'Export multiple topics');
      if (this.embeddedUrl) {
        return a('.js-embedded', {
          href: '#',
          title: 'Get embedded code'
        }, 'Get embedded code');
      }
    });
  };

  renderButton = ck.compile(buttonTmpl);

  renderPopup = ck.compile(popupTmpl);

  SettingsPopup = (function(_super) {

    __extends(SettingsPopup, _super);

    function SettingsPopup(button, params) {
      var container;
      container = $(renderPopup(params));
      this._container = container[0];
      this._initReadAllButton(container, button);
      this._initFollowAndUnfollowButtons(container, params.topicId);
      this._initPrintButton(container);
      this._initHangoutButton(container);
      this._initSingleExportButton(container);
      this._initMultiExportPopup(container, button);
      this._initGetEmbeddedButton(container, params.embeddedUrl);
    }

    SettingsPopup.prototype._initReadAllButton = function($container, button) {
      var _this = this;
      return $container.find('.js-read-all').click(function() {
        var event;
        _gaq.push(['_trackEvent', 'Topic content', 'Mark topic as read']);
        event = BrowserEvents.createCustomEvent(BrowserEvents.C_READ_ALL_EVENT, true, true);
        button.dispatchEvent(event);
        return popup.hide();
      });
    };

    SettingsPopup.prototype._initFollowAndUnfollowButtons = function(container, topicId) {
      var button, processor;
      processor = require('../search_panel/topic/processor').instance;
      button = container.find('.js-follow-topic');
      button.click(function() {
        _gaq.push(['_trackEvent', 'Topic content', 'Follow topic', 'Make followed by settings menu']);
        processor.followTopic(topicId, function() {
          return popup.hide();
        });
        return false;
      });
      button = container.find('.js-unfollow-topic');
      return button.click(function() {
        _gaq.push(['_trackEvent', 'Topic content', 'Follow topic', 'Make unfollowed by settings menu']);
        processor.unfollowTopic(topicId, function() {
          return popup.hide();
        });
        return false;
      });
    };

    SettingsPopup.prototype._initPrintButton = function(container) {
      var button;
      button = container.find('.js-print-topic');
      return button.click(function() {
        _gaq.push(['_trackEvent', 'Topic content', 'Print topic']);
        return window.print();
      });
    };

    SettingsPopup.prototype._initHangoutButton = function(container) {
      var button;
      button = container.find('.js-start-hangout');
      return button.click(function() {
        return _gaq.push(['_trackEvent', 'Hangout', 'Hangout click']);
      });
    };

    SettingsPopup.prototype._initSingleExportButton = function(container) {
      var button;
      button = container.find('.js-single-export');
      return button.click(function() {
        return _gaq.push(['_trackEvent', 'Topic content', 'Export single topic']);
      });
    };

    SettingsPopup.prototype._initMultiExportPopup = function(container, button) {
      var showExportPopup;
      showExportPopup = require('../export').showExportPopup;
      return container.find('.js-multi-export').click(function(e) {
        var request, router;
        e.preventDefault();
        _gaq.push(['_trackEvent', 'Topic content', 'Export multiple topics']);
        request = new Request(null, function(error, topics) {
          if (topics) return showExportPopup(topics, button);
        });
        router = require('../app').router;
        return router.handle('navigation.loadTopicList', request);
      });
    };

    SettingsPopup.prototype._initGetEmbeddedButton = function(container, url) {
      return container.find('.js-embedded').click(function() {
        _gaq.push(['_trackEvent', 'Topic content', 'Get embedded code']);
        EmbeddedCodeGenerator.get().open(url);
        return popup.hide();
      });
    };

    SettingsPopup.prototype.destroy = function() {};

    SettingsPopup.prototype.getContainer = function() {
      return this._container;
    };

    return SettingsPopup;

  })(PopupContent);

  SettingsMenu = (function() {

    function SettingsMenu() {}

    SettingsMenu.prototype._initButton = function(container, params) {
      var button;
      button = container.find('.js-show-settings-button');
      return button.bind('click', function() {
        _gaq.push(['_trackEvent', 'Settings', 'Settings click']);
        popup.hide();
        popup.render(new SettingsPopup(button[0], params), button[0]);
        return popup.show();
      });
    };

    SettingsMenu.prototype.render = function(container, params) {
      var content;
      if (params.isEmptyView) return;
      content = renderButton();
      container = $(container);
      container.empty().append(content);
      return this._initButton(container, params);
    };

    return SettingsMenu;

  })();

  module.exports = {
    SettingsMenu: SettingsMenu
  };

}).call(this);

});

require.define("/lib/client/client/wave/embedded_code_generator_window.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var CenteredWindow, DomUtils, EmbeddedCodeGenerator, MIN_VALUE, getValidValueFromInput, instance, renderTmpl, tmpl, validateInputValue,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  CenteredWindow = require('../widget/window/centered_window').CenteredWindow;

  DomUtils = require('../utils/dom');

  tmpl = function() {
    div('title', 'To embed Rizzoma topic use this HTML code');
    div(function() {
      return textarea('js-output', '');
    });
    return div(function() {
      div('input-block', function() {
        label({
          "for": 'embeddedGeneratorWidth'
        }, 'Width: ');
        return input('js-width text-input width-input', {
          id: 'embeddedGeneratorWidth',
          type: 'number',
          value: this.minValue,
          min: this.minValue
        });
      });
      return div('input-block', function() {
        label({
          "for": 'embeddedGeneratorHeight'
        }, 'Height: ');
        return input('js-height text-input height-input', {
          id: 'embeddedGeneratorHeight',
          type: 'number',
          value: this.minValue,
          min: this.minValue
        });
      });
    });
  };

  renderTmpl = window.CoffeeKup.compile(tmpl);

  MIN_VALUE = 550;

  getValidValueFromInput = function(input) {
    var val;
    val = parseInt(input.value) || MIN_VALUE;
    if (val < MIN_VALUE) val = MIN_VALUE;
    return val;
  };

  validateInputValue = function() {
    var val;
    val = getValidValueFromInput(this);
    if (this.value !== (val + '')) return this.value = val;
  };

  EmbeddedCodeGenerator = (function(_super) {

    __extends(EmbeddedCodeGenerator, _super);

    function EmbeddedCodeGenerator() {
      this._updateOutput = __bind(this._updateOutput, this);
      var params;
      params = {
        closeButton: true,
        closeOnOutsideAction: true,
        closeOnEsc: true
      };
      EmbeddedCodeGenerator.__super__.constructor.call(this, params);
    }

    EmbeddedCodeGenerator.prototype.__createDom = function(params) {
      var body;
      EmbeddedCodeGenerator.__super__.__createDom.call(this, params);
      body = this.getBodyEl();
      params = {
        minValue: MIN_VALUE
      };
      body.appendChild(DomUtils.parseFromString(renderTmpl(params)));
      DomUtils.addClass(body, 'embedded-code-generator');
      this._widthInput = body.getElementsByClassName('js-width')[0];
      this._heightInput = body.getElementsByClassName('js-height')[0];
      this._output = body.getElementsByClassName('js-output')[0];
      this._widthInput.addEventListener('change', validateInputValue, false);
      this._heightInput.addEventListener('change', validateInputValue, false);
      this._widthInput.addEventListener('input', this._updateOutput, false);
      this._heightInput.addEventListener('input', this._updateOutput, false);
      return this._output.addEventListener('click', function() {
        return this.select();
      }, false);
    };

    EmbeddedCodeGenerator.prototype._updateOutput = function() {
      var height, width;
      width = getValidValueFromInput(this._widthInput);
      height = getValidValueFromInput(this._heightInput);
      return this._output.value = "<iframe width=\"" + width + "\" height=\"" + height + "\" src=\"" + this._url + "\" frameborder=\"0\" allowfullscreen></iframe>";
    };

    EmbeddedCodeGenerator.prototype.open = function(_url) {
      this._url = _url;
      if (!this._url) return console.warn('URL was not provided');
      EmbeddedCodeGenerator.__super__.open.call(this);
      this._updateOutput();
      return this._output.select();
    };

    return EmbeddedCodeGenerator;

  })(CenteredWindow);

  instance = null;

  module.exports.get = function() {
    return instance != null ? instance : instance = new EmbeddedCodeGenerator();
  };

}).call(this);

});

require.define("/lib/client/client/export/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ExportPopup, PopupContent, Request, popup, processor, renderArchiveList, renderCommonForm, _ref,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  _ref = require('./template'), renderCommonForm = _ref.renderCommonForm, renderArchiveList = _ref.renderArchiveList;

  popup = require('../popup').popup;

  PopupContent = require('../popup').PopupContent;

  Request = require('../../share/communication').Request;

  processor = require('./processor').instance;

  ExportPopup = (function(_super) {

    __extends(ExportPopup, _super);

    ExportPopup.prototype.ARCHIVE_LIST_UPDATE_INTERVAL = 10;

    function ExportPopup(topics) {
      var _this = this;
      this._archives = [];
      this._container = $(renderCommonForm({
        topics: topics
      }))[0];
      this._addClickHandler();
      this._loadArchiveList();
      this._interval = setInterval(function() {
        return _this._loadArchiveList();
      }, this.ARCHIVE_LIST_UPDATE_INTERVAL * 1000);
    }

    ExportPopup.prototype._onSelectAllClick = function(container, element) {
      return container.find(':checkbox').attr('checked', element.is(':checked'));
    };

    ExportPopup.prototype._getWaveIdsToExport = function(container) {
      var ids, items;
      ids = [];
      items = container.find('.ep-topic :checkbox:checked').parents('.ep-topic');
      $.each(items, function(_, item) {
        return ids.push($(item).data('id'));
      });
      return ids;
    };

    ExportPopup.prototype._onStartExportClick = function(container) {
      var waveIds,
        _this = this;
      waveIds = this._getWaveIdsToExport(container);
      if (!waveIds.length) return;
      return processor.exportTopics(waveIds, function(error) {
        if (error) return;
        return _this._renderArchiveList(true, _this._archives);
      });
    };

    ExportPopup.prototype._addClickHandler = function() {
      var container,
        _this = this;
      container = $(this._container);
      return container.click(function(event) {
        var element;
        element = $(event.target);
        if (element.hasClass('ep-select-all')) {
          _this._onSelectAllClick(container, element);
        }
        if (element.hasClass('ep-start')) {
          return _this._onStartExportClick(container);
        }
      });
    };

    ExportPopup.prototype._renderArchiveList = function(hasTask, archives) {
      var container, list;
      if (!this._container) return;
      container = $(this._container).find('.ep-archives-container');
      container.find('.ep-archives').remove();
      archives = hasTask ? archives.slice(0, 2) : archives.slice(0, 3);
      this._archives = archives;
      if (!hasTask && !archives.length) {
        return container.hide();
      } else {
        container.show();
      }
      list = renderArchiveList({
        hasTask: hasTask,
        archives: archives
      });
      return container.append(list);
    };

    ExportPopup.prototype._loadArchiveList = function() {
      var _this = this;
      return processor.findArchives(function(error, data) {
        if (error) return;
        return _this._renderArchiveList(data.hasTask, data.archives);
      });
    };

    ExportPopup.prototype.destroy = function() {
      var container;
      container = $(this._container);
      container.unbind();
      container.remove();
      this._container = null;
      return clearInterval(this._interval);
    };

    ExportPopup.prototype.getContainer = function() {
      return this._container;
    };

    return ExportPopup;

  })(PopupContent);

  exports.showExportPopup = function(topics, node) {
    popup.hide();
    popup.render(new ExportPopup(topics), node);
    return popup.show();
  };

}).call(this);

});

require.define("/lib/client/client/export/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var archiveListTmpl, ck, commonFormTmpl;

  ck = window.CoffeeKup;

  commonFormTmpl = function() {
    return div('.js-export-popup.export-popup', function() {
      div('.ep-title', 'Export topics');
      div('.ep-select-all-container', function() {
        input('.ep-select-all', {
          type: 'checkbox'
        });
        return 'select all';
      });
      ul('.ep-topics', function() {
        var topic, _i, _len, _ref, _results;
        _ref = this.topics;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          topic = _ref[_i];
          _results.push(li('.ep-topic', {
            'data-id': topic.waveId
          }, function() {
            input({
              type: 'checkbox'
            });
            return topic.title || span('.ep-topic-no-title', '(no title)');
          }));
        }
        return _results;
      });
      div('', 'Tip: use the search to narrow down this list.');
      div('.ep-start-container', function() {
        return button('.ep-start.button', 'Export selected topics');
      });
      return div('.ep-archives-container', function() {
        return span('', 'Recently exported topics:');
      });
    });
  };

  archiveListTmpl = function() {
    return ul('.ep-archives', function() {
      var archive, _i, _len, _ref, _results;
      if (this.hasTask) li('.ep-archive', 'Preparing archive...');
      _ref = this.archives;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        archive = _ref[_i];
        _results.push(li('.ep-archive', function() {
          return a('.ep-archive-link', {
            href: "//" + window.HOST + "/export/" + archive.url,
            target: '_blank'
          }, "" + archive.topics + " " + (archive.topics === 1 ? 'topic' : 'topics') + " on " + archive.created);
        }));
      }
      return _results;
    });
  };

  exports.renderCommonForm = ck.compile(commonFormTmpl);

  exports.renderArchiveList = ck.compile(archiveListTmpl);

}).call(this);

});

require.define("/lib/client/client/wave/account_menu.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var AccountMenu, AccountMergePopup, AccountPopup, BrowserSupport, KeyCodes, PopupContent, Request, buttonTmpl, ck, getOtherUrl, orgRenderPopup, popup, popupTmpl, renderButton, renderPopup, _ref,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  AccountMergePopup = require('../account_merge').AccountMergePopup;

  KeyCodes = require('../utils/key_codes').KeyCodes;

  Request = require('../../share/communication').Request;

  _ref = require('../popup'), popup = _ref.popup, PopupContent = _ref.PopupContent;

  BrowserSupport = require('../utils/browser_support');

  getOtherUrl = require('../utils/url').getOtherUrl;

  ck = window.CoffeeKup;

  buttonTmpl = function() {
    var attrs, _ref2;
    attrs = {};
    if (((_ref2 = window.userInfo) != null ? _ref2.name : void 0) != null) {
      attrs.title = h(window.userInfo.name);
    }
    return button('.js-account-button.account-button', attrs, function() {
      if (!(window.userInfo != null)) return;
      div('.avatar', {
        style: "background-image: url(" + (h(window.userInfo.avatar)) + ")"
      });
      return div('.account-show-popup', '');
    });
  };

  popupTmpl = function() {
    var getProfile, getProfileFieldValues, isValueAlreadyExist, profile;
    isValueAlreadyExist = function(where, value) {
      var exist, _;
      for (_ in where) {
        exist = where[_];
        if (value === exist) return true;
      }
      return false;
    };
    getProfileFieldValues = function(name) {
      var auth, authId, result, value, _ref2;
      result = null;
      _ref2 = window.userInfo.profile;
      for (authId in _ref2) {
        auth = _ref2[authId];
        value = auth[name];
        if (!value || value === window.userInfo[name]) continue;
        if (result && isValueAlreadyExist(result, value)) continue;
        if (result == null) result = {};
        result[authId] = value;
      }
      return result;
    };
    getProfile = function() {
      if (!window.userInfo.profile) return {};
      return {
        names: getProfileFieldValues('name'),
        emails: getProfileFieldValues('email'),
        avatars: getProfileFieldValues('avatar')
      };
    };
    profile = getProfile();
    return div('.js-account-window.account-popup', function() {
      div('.avatar-container', function() {
        div('.avatar', {
          style: "background-image: url(" + (h(this.avatar || window.userInfo.avatar)) + ")"
        }, function() {
          if (profile.avatars) {
            return button('.js-show-avatar-variants.show-variants', {
              title: 'Choose an avatar to use'
            }, '');
          }
        });
        if (profile.avatars) {
          return ul('.js-avatar-variants.variants', function() {
            var avatar, key, _ref2, _results;
            _ref2 = profile.avatars;
            _results = [];
            for (key in _ref2) {
              avatar = _ref2[key];
              _results.push(li('.js-variant.avatar-variant', {
                style: "background-image: url(" + (h(avatar)) + ")",
                'data-key': h(key)
              }, ''));
            }
            return _results;
          });
        }
      });
      div('.avatar-delimiter', '');
      return div('.info', function() {
        div('.name', function() {
          span(h(window.userInfo.name));
          if (profile.names) {
            button('.js-show-name-variants.show-variants', {
              title: 'Choose a name to use'
            }, '');
            return ul('.js-name-variants.variants.name-variants', function() {
              var key, name, _ref2, _results;
              _ref2 = profile.names;
              _results = [];
              for (key in _ref2) {
                name = _ref2[key];
                _results.push(li('.js-variant.name-variant', {
                  'data-key': h(key)
                }, h(name)));
              }
              return _results;
            });
          }
        });
        div('.email', function() {
          span(h(window.userInfo.email));
          if (profile.emails) {
            button('.js-show-email-variants.show-variants', {
              title: 'Choose an email to use'
            }, '');
            return ul('.js-email-variants.variants.email-variants', function() {
              var email, key, _ref2, _results;
              _ref2 = profile.emails;
              _results = [];
              for (key in _ref2) {
                email = _ref2[key];
                _results.push(li('.js-variant.email-variant', {
                  'data-key': h(key)
                }, h(email)));
              }
              return _results;
            });
          }
        });
        div('.skype-id-container', function() {
          input('.js-skype-id-input.skype-id-input', {
            placeholder: 'Fill in your skypeID',
            value: h(window.userInfo.skypeId || ''),
            title: 'Your skypeID'
          });
          return a('.js-skype-status-help.skype-status-help.hidden', {
            href: 'https://support.skype.com/en/faq/FA605/how-do-i-set-up-the-skype-button-to-show-my-status-on-the-web-in-skype-for-windows-desktop',
            target: '_blank'
          }, 'How to make my skype status visible');
        });
        div('.signed-via-container', function() {
          var authSource;
          authSource = window.userInfo.authSource;
          span(".signed-via." + authSource, '');
          if (authSource === 'password') {
            return span('.signed-via-text', "Signed in with password");
          } else {
            return span('.signed-via-text', "Signed in via " + (authSource.charAt(0).toUpperCase() + authSource.slice(1)));
          }
        });
        div(function() {
          var plan;
          plan = this.isBusiness ? 'Business' : 'Free';
          text("Your current plan is " + plan + ". ");
          return a({
            href: '/settings/account-menu/',
            target: '_blank'
          }, 'Upgrade');
        });
        if (this.role) {
          div("You are " + (this.role.name.toLowerCase()) + " of this topic");
        }
        return div('.buttons-panel', function() {
          button('.button.js-merge-with-account', {
            title: 'Merge with another account'
          }, 'Merge');
          a('.button', {
            href: '/settings/',
            target: '_blank'
          }, 'Settings');
          if (window.loggedIn) {
            return a('.button.js-logout', {
              href: '/logout/',
              title: 'Log out from Rizzoma'
            }, 'Sign out');
          }
        });
      });
    });
  };

  renderButton = ck.compile(buttonTmpl);

  renderPopup = ck.compile(popupTmpl);

  if (BrowserSupport.isMozilla()) {
    orgRenderPopup = renderPopup;
    renderPopup = function(params) {
      if (params == null) params = {};
      params.avatar = getOtherUrl(window.userInfo.avatar);
      return orgRenderPopup(params);
    };
  }

  AccountPopup = (function(_super) {

    __extends(AccountPopup, _super);

    function AccountPopup(params, _reinit) {
      var container, _base;
      this._reinit = _reinit;
      params || (params = {});
      params.isBusiness = require('../account_setup_wizard/processor').instance.isBusinessUser();
      container = $(renderPopup(params));
      if (typeof (_base = container.find('.js-skype-id-input')).placeholder === "function") {
        _base.placeholder();
      }
      this._container = container[0];
      this._initContainer(container);
      this._initShowNameVariantsButton(container);
      this._initShowEmailVariantsButton(container);
      this._initShowAvatarVariantsButton(container);
      this._initSkypeIdInput(container);
      this._initMergeButton(container);
    }

    AccountPopup.prototype._initContainer = function(container) {
      return container.click(function(event) {
        var element;
        element = $(event.target);
        if (!element.hasClass('js-show-name-variants')) {
          container.find('.js-name-variants').removeClass('visible');
        }
        if (!element.hasClass('js-show-email-variants')) {
          container.find('.js-email-variants').removeClass('visible');
        }
        if (!element.hasClass('js-show-avatar-variants')) {
          return container.find('.js-avatar-variants').removeClass('visible');
        }
      });
    };

    AccountPopup.prototype._getAuthId = function(field) {
      var info, key, _ref2;
      _ref2 = window.userInfo.profile;
      for (key in _ref2) {
        info = _ref2[key];
        if (info[field] === window.userInfo[field]) return key;
        if (field === 'avatar' && window.userInfo.avatar === '/s/img/user/unknown.png' && !info.avatar) {
          return key;
        }
      }
      return null;
    };

    AccountPopup.prototype._changeProfileField = function(name, authId) {
      var field, key, keys, request, router, _i, _len, _ref2,
        _this = this;
      keys = {};
      _ref2 = ['name', 'email', 'avatar'];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        field = _ref2[_i];
        key = this._getAuthId(field);
        if (!key) return;
        keys[field] = key;
      }
      keys[name] = authId;
      request = new Request(keys, function(error, user) {
        if (error) return;
        $.extend(window.userInfo, {
          name: user.name,
          email: user.email,
          avatar: user.avatar
        });
        return _this._reinit();
      });
      router = require('../app').router;
      return router.handle('network.user.changeProfile', request);
    };

    AccountPopup.prototype._initShowNameVariantsButton = function(container) {
      var button, variants,
        _this = this;
      button = container.find(".js-show-name-variants");
      if (!button.length) return;
      variants = container.find(".js-name-variants");
      button.click(function() {
        return variants.toggleClass('visible');
      });
      return variants.on('click', '.js-variant', function(event) {
        var key;
        key = $(event.target).data('key');
        return _this._changeProfileField('name', key);
      });
    };

    AccountPopup.prototype._initShowEmailVariantsButton = function(container) {
      var button, variants,
        _this = this;
      button = container.find(".js-show-email-variants");
      if (!button.length) return;
      variants = container.find(".js-email-variants");
      button.click(function() {
        return variants.toggleClass('visible');
      });
      return variants.on('click', '.js-variant', function(event) {
        var key;
        key = $(event.target).data('key');
        return _this._changeProfileField('email', key);
      });
    };

    AccountPopup.prototype._initShowAvatarVariantsButton = function(container) {
      var button, variants,
        _this = this;
      button = container.find(".js-show-avatar-variants");
      if (!button.length) return;
      variants = container.find(".js-avatar-variants");
      button.click(function() {
        return variants.toggleClass('visible');
      });
      return variants.on('click', '.js-variant', function(event) {
        var key;
        key = $(event.target).data('key');
        return _this._changeProfileField('avatar', key);
      });
    };

    AccountPopup.prototype._initSkypeIdInput = function(container) {
      var changeSkypeId, input;
      input = container.find('.js-skype-id-input');
      changeSkypeId = function(e) {
        var request, router, skypeId, userInfo;
        input.blur();
        skypeId = e.target.value;
        if (skypeId === window.userInfo.skypeId) return;
        request = new Request({
          skypeId: skypeId
        }, function(err) {
          if (err) return console.warn("Could not set skype id", err);
        });
        router = require('../app').router;
        router.handle('network.user.setUserSkypeId', request);
        userInfo = {
          id: window.userInfo.id,
          email: window.userInfo.email,
          name: window.userInfo.name,
          avatar: window.userInfo.avatar,
          skypeId: skypeId
        };
        require('../user/processor').instance.addOrUpdateUsersInfo([userInfo]);
        return window.userInfo.skypeId = skypeId;
      };
      input.change(changeSkypeId);
      input.keypress(function(e) {
        if (e.keyCode !== KeyCodes.KEY_ENTER) return;
        return changeSkypeId(e);
      });
      return input.focus(function() {
        return container.find('.js-skype-status-help').removeClass('hidden');
      });
    };

    AccountPopup.prototype._initMergeButton = function(container) {
      return container.find('.js-merge-with-account').click(function() {
        popup.hide();
        return (new AccountMergePopup()).show();
      });
    };

    AccountPopup.prototype.destroy = function() {};

    AccountPopup.prototype.getContainer = function() {
      return this._container;
    };

    return AccountPopup;

  })(PopupContent);

  AccountMenu = (function() {

    function AccountMenu() {}

    AccountMenu.prototype._initButton = function(container, params) {
      var button, callback;
      button = container.find('.js-account-button');
      callback = function() {
        if (!(window.userInfo != null)) return;
        popup.hide();
        popup.render(new AccountPopup(params, callback), button[0]);
        popup.addExtendedClass('account-menu-popup');
        return popup.show();
      };
      return button.click(callback);
    };

    AccountMenu.prototype.render = function(container, params) {
      var content;
      content = renderButton();
      container = $(container);
      container.empty().append(content);
      return this._initButton(container, params);
    };

    return AccountMenu;

  })();

  module.exports = {
    AccountMenu: AccountMenu
  };

}).call(this);

});

require.define("/lib/client/client/account_merge/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var AccountMergePopup, KeyCodes, ck, contactsUpdateWindowParams, emailSentTmpl, isEmail, mergeConfirmTmpl, mergeErrorTmpl, mergePopupTmpl, renderEmailSent, renderMergeConfirm, renderMergeError, renderMergePopup, renderSuccessfullyMerged, successfullyMergedTmpl,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  ck = window.CoffeeKup;

  KeyCodes = require('../utils/key_codes').KeyCodes;

  isEmail = require('../../share/utils/string').isEmail;

  contactsUpdateWindowParams = require('../wave/processor').contactsUpdateWindowParams;

  mergePopupTmpl = function() {
    return div(function() {
      div('.js-notification-overlay.notification-overlay', '');
      return div('.notification-block', function() {
        return div('.js-account-merge-form-container.account-merge-form-container', function() {
          div('.js-merge-close.merge-close', {
            title: 'Close'
          }, '');
          div('.merge-title', 'Merge your accounts');
          return div('.js-merge-content.merge-content', function() {
            div(function() {
              text("You're signed in as ");
              span('.bold', "" + (h(this.currentName ? this.currentName + ' (' + this.currentEmail + ')' : this.currentEmail)));
              return text(".");
            });
            if (this.email != null) {
              div(function() {
                text("Attention! You could be missing some topics because you were invited by another email ");
                span('.bold', "" + (h(this.email)));
                return text(". Please sign in using " + (h(this.email)) + " or join it to your current account.");
              });
            } else {
              div(function() {
                return text("You can join some other account to use them for authorization in Rizzoma.com or to be invited");
              });
              div('.merge-button-block', function() {
                button('.js-google-account.button', 'Join Google account');
                return button('.js-facebook-account.button', 'Join Facebook account');
              });
            }
            return div('.js-secondary-email-container', function() {
              div('Add another email to your account');
              div('.secondary-email-block', function() {
                input('.js-secondary-email-input.secondary-email-input', {
                  type: 'text',
                  placeholder: 'Email address',
                  value: h(this.email || '')
                });
                return button('.js-send-secondary-email.send-secondary-email.button', 'Join');
              });
              return div('.js-email-error.merge-error.hidden', 'Invalid email');
            });
          });
        });
      });
    });
  };

  renderMergePopup = ck.compile(mergePopupTmpl);

  emailSentTmpl = function() {
    return div('.merge-message', "Merging request accepted. An email with next step has been sent to " + (h(this.email)) + ". Please follow it.");
  };

  renderEmailSent = ck.compile(emailSentTmpl);

  mergeErrorTmpl = function() {
    return div('.merge-error', function() {
      var _ref;
      text("Merging request rejected.");
      if ((_ref = this.error) != null ? _ref.message : void 0) {
        return text(" " + this.error.message + ".");
      }
    });
  };

  renderMergeError = ck.compile(mergeErrorTmpl);

  successfullyMergedTmpl = function() {
    return div('.merge-message', function() {
      text("Successfully merged. ");
      a({
        href: "/topic/"
      }, "Reload page");
      return text(".");
    });
  };

  renderSuccessfullyMerged = ck.compile(successfullyMergedTmpl);

  mergeConfirmTmpl = function() {
    var avatar;
    avatar = '/s/img/user/unknown.png';
    div('.avatar-block', {
      style: "background-image: url(" + (this.currentAvatar || avatar) + ");"
    }, function() {
      text("You're signed in as ");
      span('.bold', "" + (h(this.currentName ? this.currentName + ' (' + this.currentEmail + ')' : this.currentEmail)));
      return text(".");
    });
    div('.avatar-block', {
      style: "background-image: url(" + (this.newAvatar || avatar) + ");"
    }, function() {
      text("Please confirm joining " + (h(this.newSource ? this.newSource.charAt(0).toUpperCase() + this.newSource.slice(1) : '')) + " profile ");
      span('.bold', "" + (h(this.newName ? this.newName + ' (' + this.newEmail + ')' : this.newEmail)));
      return text(" with your current account.");
    });
    return div('.js-confirm-button-block.confirm-button-block', function() {
      button('.js-ok-button.button', 'Ok');
      return button('.js-cancel-button.button', 'Cancel');
    });
  };

  renderMergeConfirm = ck.compile(mergeConfirmTmpl);

  AccountMergePopup = (function() {

    function AccountMergePopup(_email) {
      this._email = _email;
      this._close = __bind(this._close, this);
      this._windowKeyHandler = __bind(this._windowKeyHandler, this);
    }

    AccountMergePopup.prototype.show = function() {
      var _base;
      _gaq.push(['_trackEvent', 'Account merging', 'Show account merging', this._email ? 'from email' : 'from profile']);
      this._$container = $(renderMergePopup({
        email: this._email,
        currentName: window.userInfo.name,
        currentEmail: window.userInfo.email
      }));
      if (typeof (_base = $('.js-secondary-email-input')).placeholder === "function") {
        _base.placeholder();
      }
      $(document.body).append(this._$container);
      this._initClose();
      this._initEmailInput();
      return this._initMergeButtons();
    };

    AccountMergePopup.prototype._initClose = function() {
      this._$container.find('.js-notification-overlay, .js-merge-close').click(this._close);
      return $(window).keydown(this._windowKeyHandler);
    };

    AccountMergePopup.prototype._windowKeyHandler = function(e) {
      if (e.which === KeyCodes.KEY_ESCAPE) return this._close(e);
    };

    AccountMergePopup.prototype._initEmailInput = function() {
      var _this = this;
      this._$input = this._$container.find('.js-secondary-email-input');
      this._$input.keypress(function(e) {
        if (e.which !== KeyCodes.KEY_ENTER) return;
        return _this._sendEmail(_this._$input.val());
      });
      this._$container.find('.js-send-secondary-email').click(function() {
        return _this._sendEmail(_this._$input.val());
      });
      return this._$input.focus();
    };

    AccountMergePopup.prototype._initMergeButtons = function() {
      var _this = this;
      this._$container.find('.js-google-account').click(function() {
        return _this._openMergeByOauthWindow('google');
      });
      this._$container.find('.js-facebook-account').click(function() {
        return _this._openMergeByOauthWindow('facebook');
      });
      return window.mergeByOauth = function(profile, code) {
        var $block, params;
        profile = JSON.parse(profile);
        $block = _this._$container.find('.js-merge-content').empty();
        params = {
          newAvatar: profile.avatar,
          newSource: profile.source,
          newName: profile.name,
          newEmail: profile.email,
          currentAvatar: window.userInfo.avatar,
          currentName: window.userInfo.name,
          currentEmail: window.userInfo.email
        };
        $block.append(renderMergeConfirm(params));
        $block.find('.js-ok-button').click(function() {
          return require('../user/processor').instance.mergeByOauth(code, function(err) {
            _this._hideConfirmButtonBlock();
            if (err) {
              console.error("Could not merge (OAuth)", err);
              return _this._addMergeError(err);
            } else {
              return _this._addSuccessfullyMerged();
            }
          });
        });
        $block.find('.js-cancel-button').click(_this._close);
        return _this._$container.find('.js-account-merge-form-container').width(400);
      };
    };

    AccountMergePopup.prototype._openMergeByOauthWindow = function(source) {
      var params;
      _gaq.push(['_trackEvent', 'Account merging', 'Do merging', "" + source + " button"]);
      params = contactsUpdateWindowParams[source];
      return window.open("/accounts_merge/" + source + "/", 'Loading', "width=" + params.width + ",height=" + params.height);
    };

    AccountMergePopup.prototype._sendEmail = function(email) {
      var $emailError, domain,
        _this = this;
      domain = email.match(/@(.+)/);
      if (domain) {
        domain = domain[1];
      } else {
        domain = 'invalid';
      }
      $emailError = this._$container.find('.js-email-error');
      if (!isEmail(email)) return $emailError.removeClass('hidden');
      $emailError.addClass('hidden');
      if (domain === 'gmail.com' || domain === 'googlemail.com') {
        return this._openMergeByOauthWindow('google');
      }
      if (domain === 'facebook.com') {
        return this._openMergeByOauthWindow('facebook');
      }
      this._hideEmail();
      _gaq.push(['_trackEvent', 'Account merging', 'Do merging', domain]);
      return require('../user/processor').instance.prepareMerge(email, function(err, res) {
        if (err) {
          console.error("Could not merge (email)", err);
          return _this._addMergeError(err);
        } else {
          return _this._addEmailSent(email);
        }
      });
    };

    AccountMergePopup.prototype._addEmailSent = function(email) {
      return this._addMessage(renderEmailSent({
        email: email
      }));
    };

    AccountMergePopup.prototype._addMergeError = function(error) {
      return this._addMessage(renderMergeError({
        error: error
      }));
    };

    AccountMergePopup.prototype._addSuccessfullyMerged = function() {
      return this._addMessage(renderSuccessfullyMerged());
    };

    AccountMergePopup.prototype._addMessage = function(html) {
      return this._$container.find('.js-merge-content').append(html);
    };

    AccountMergePopup.prototype._hideEmail = function() {
      return this._$container.find('.js-secondary-email-container').addClass('hidden');
    };

    AccountMergePopup.prototype._hideConfirmButtonBlock = function() {
      return this._$container.find('.js-confirm-button-block').addClass('hidden');
    };

    AccountMergePopup.prototype._close = function(e) {
      e.stopPropagation();
      e.preventDefault();
      $(window).off('keydown', this._windowKeyHandler);
      this._$container.remove();
      return delete window.mergeByOauth;
    };

    return AccountMergePopup;

  })();

  module.exports = {
    AccountMergePopup: AccountMergePopup
  };

}).call(this);

});

require.define("/lib/client/client/wave/participants/add_form.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var AddParticipantForm, Autocompleter, DomUtils, KeyCodes, ck, cmpContacts, compareContactsByNameAndEmail, contactsConstants, contactsRefreshedMessageTmpl, contactsSyncButtomTmpl, formTmpl, getContactSources, renderContactsSyncButton, renderForm, renderRefreshedMessage, renderUser, userTmpl, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  DomUtils = require('../../utils/dom');

  _ref = require('../../user/utils'), compareContactsByNameAndEmail = _ref.compareContactsByNameAndEmail, getContactSources = _ref.getContactSources;

  KeyCodes = require('../../utils/key_codes').KeyCodes;

  contactsConstants = require('../../../share/contacts/constants');

  ck = window.CoffeeKup;

  formTmpl = function() {
    return div('.internal-container', function() {
      div('.input-email-title', function() {
        text('Add new');
        return select('.js-add-select.add-button-select', function() {
          var id, name, _i, _len, _ref2, _ref3, _results;
          _ref2 = this.addButtons;
          _results = [];
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            _ref3 = _ref2[_i], id = _ref3.id, name = _ref3.name;
            _results.push(option({
              value: id
            }, name));
          }
          return _results;
        });
      });
      div('.input-email-container', function() {
        input('.js-input-email.input-email', {
          type: "text",
          value: "enter email"
        });
        return button('.js-add-button.button', 'Add');
      });
      div('.js-autocomplete-results.autocomplete-results', '');
      return div('.js-contacts-sync-button-container.contacts-sync-button-container', '');
    });
  };

  renderForm = ck.compile(formTmpl);

  contactsSyncButtomTmpl = function() {
    var caption, imgSrc;
    if (this.hasContacts) {
      imgSrc = '/s/img/refresh-contacts-ico.png';
    } else if (this.source === 'google') {
      imgSrc = '/s/img/add-google-contacts-ico.png';
    } else if (this.source === 'facebook') {
      imgSrc = '/s/img/add-facebook-contacts-ico.png';
    }
    if (this.hasContacts) {
      if (this.source === 'google') {
        caption = 'Refresh my Google contacts';
      } else if (this.source === 'facebook') {
        caption = 'Refresh my Facebook contacts';
      }
    } else {
      if (this.source === 'google') {
        caption = 'Show my Google contacts';
      } else if (this.source === 'facebook') {
        caption = 'Show my Facebook contacts';
      }
    }
    return button('.js-sync-contacts-button.contact-sync-button.button', {
      source: this.sourceConstant
    }, function() {
      img({
        src: imgSrc
      });
      return span(caption);
    });
  };

  renderContactsSyncButton = ck.compile(contactsSyncButtomTmpl);

  contactsRefreshedMessageTmpl = function() {
    return div('.contacts-refreshed', function() {
      img({
        src: '/s/img/contacts-refreshed.png'
      });
      if (this.source === 'google') {
        return text('Google contacts refreshed ');
      } else if (this.source === 'facebook') {
        return text('Facebook contacts refreshed ');
      }
    });
  };

  renderRefreshedMessage = ck.compile(contactsRefreshedMessageTmpl);

  userTmpl = function() {
    return div(".js-autocomplete-item.autocomplete-item", function() {
      div('.avatar', {
        style: "background-image: url(" + (h(this.item.avatar)) + ")"
      }, h(this.item.initials));
      return span({
        title: "" + (h(this.item.name)) + " " + (h(this.item.email))
      }, function() {
        span('.name', h(this.item.name));
        return span('.email', h(this.item.email));
      });
    });
  };

  renderUser = ck.compile(userTmpl);

  cmpContacts = function(a, b) {
    return compareContactsByNameAndEmail(a.data, b.data);
  };

  Autocompleter = (function() {

    function Autocompleter(_getContacts, _$resultsContainer, _renderItem, _$queryInput, _maxItemsToShow, _selectHandler) {
      this._getContacts = _getContacts;
      this._$resultsContainer = _$resultsContainer;
      this._renderItem = _renderItem;
      this._$queryInput = _$queryInput;
      this._maxItemsToShow = _maxItemsToShow;
      this._selectHandler = _selectHandler;
      this._filterParticipantsHandler = __bind(this._filterParticipantsHandler, this);
      this._init = __bind(this._init, this);
      this._getContacts(this._init);
    }

    Autocompleter.prototype._init = function(_data) {
      var _this = this;
      this._data = _data;
      this._data.sort(cmpContacts);
      this._renderData();
      this._$queryInput.on('keyup focus', this._filterParticipantsHandler);
      this._$resultsContainer.on('mouseover', '.js-autocomplete-item', function(event) {
        _this._$resultsContainer.find('.js-autocomplete-item').removeClass('acSelect');
        return $(event.currentTarget).addClass('acSelect');
      });
      return this._$resultsContainer.on('click', '.js-autocomplete-item', function(event) {
        var item;
        event.stopPropagation();
        item = $(event.currentTarget).data('item');
        return _this._selectHandler(item);
      });
    };

    Autocompleter.prototype._renderData = function() {
      var i, item, result, _i, _len, _ref2;
      this._$resultsContainer.empty();
      result = '';
      i = 0;
      _ref2 = this._data;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        item = _ref2[_i];
        if (i >= this._maxItemsToShow) break;
        if (!item.hide) {
          this._$resultsContainer.append($(this._renderItem({
            item: item.data
          })).data({
            item: item.data
          })[0]);
          i += 1;
        }
      }
      return $(this._$resultsContainer.find('.js-autocomplete-item')[0]).addClass('acSelect');
    };

    Autocompleter.prototype._filterParticipantsHandler = function(event) {
      var $activeElem, currentString;
      switch (event.keyCode) {
        case KeyCodes.KEY_END:
        case KeyCodes.KEY_HOME:
        case KeyCodes.KEY_SHIFT:
        case KeyCodes.KEY_CTRL:
        case KeyCodes.KEY_ALT:
        case KeyCodes.KEY_LEFT:
        case KeyCodes.KEY_RIGHT:
        case KeyCodes.KEY_TAB:
          break;
        case KeyCodes.KEY_UP:
          return this._focusPrev();
        case KeyCodes.KEY_DOWN:
          return this._focusNext();
        case KeyCodes.KEY_ENTER:
          $activeElem = this._$resultsContainer.find('.acSelect');
          if ($activeElem.length === 1) {
            this._selectHandler($activeElem.data('item'));
            break;
          }
          return this._selectHandler();
        default:
          currentString = $(event.currentTarget).val().toLowerCase();
          this.__filterParticipants(currentString);
          return this._renderData();
      }
    };

    Autocompleter.prototype._focusNext = function() {
      var $nextAfterSelectedItem, $selectedItem;
      $selectedItem = this._$resultsContainer.find('.js-autocomplete-item.acSelect');
      $nextAfterSelectedItem = $selectedItem.next('.js-autocomplete-item');
      if ($nextAfterSelectedItem.length > 0) {
        $selectedItem.removeClass('acSelect');
        return $nextAfterSelectedItem.addClass('acSelect');
      }
    };

    Autocompleter.prototype._focusPrev = function() {
      var $prevBeforeSelectedItem, $selectedItem;
      $selectedItem = this._$resultsContainer.find('.js-autocomplete-item.acSelect');
      $prevBeforeSelectedItem = $selectedItem.prev('.js-autocomplete-item');
      if ($prevBeforeSelectedItem.length > 0) {
        $selectedItem.removeClass('acSelect');
        return $prevBeforeSelectedItem.addClass('acSelect');
      }
    };

    Autocompleter.prototype.__filterParticipants = function(filterString) {
      var item, _i, _len, _ref2, _results;
      _ref2 = this._data;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        item = _ref2[_i];
        if (item.searchString.search(filterString) === -1) {
          _results.push(item.hide = true);
        } else {
          _results.push(item.hide = false);
        }
      }
      return _results;
    };

    Autocompleter.prototype.getData = function() {
      return this._data;
    };

    Autocompleter.prototype.getActiveItem = function() {
      var $activeElem;
      $activeElem = this._$resultsContainer.find('.acSelect');
      if ($activeElem.length === 1) return $activeElem.data('item');
    };

    Autocompleter.prototype.reset = function() {
      var _this = this;
      return this._getContacts(function(_data) {
        _this._data = _data;
        _this._data.sort(cmpContacts);
        _this._$queryInput.val('');
        _this.__filterParticipants('');
        return _this._renderData();
      });
    };

    Autocompleter.prototype.restart = function() {
      var _this = this;
      return this._getContacts(function(_data) {
        _this._data = _data;
        _this._data.sort(cmpContacts);
        return _this._renderData();
      });
    };

    Autocompleter.prototype.destroy = function() {
      delete this._data;
      return this._$resultsContainer.empty();
    };

    return Autocompleter;

  })();

  AddParticipantForm = (function() {

    function AddParticipantForm(_$container, _maxItemsToShow, _addButtons, _waveProcessor, _contactSelectHandler, _contactButtonHandler) {
      this._$container = _$container;
      this._maxItemsToShow = _maxItemsToShow;
      this._addButtons = _addButtons;
      this._waveProcessor = _waveProcessor;
      this._contactSelectHandler = _contactSelectHandler;
      this._contactButtonHandler = _contactButtonHandler;
      this._renderForm = __bind(this._renderForm, this);
      this._getContacts = __bind(this._getContacts, this);
      this._getContacts(this._renderForm);
    }

    AddParticipantForm.prototype._getContacts = function(callback, fromServer) {
      var _this = this;
      if (fromServer == null) fromServer = false;
      return this._waveProcessor.getUserContacts(function(err, users) {
        var user, userContacts;
        if (err || !users) return console.warn('Failed to load contacts', err);
        userContacts = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = users.length; _i < _len; _i++) {
            user = users[_i];
            _results.push({
              searchString: user.getSearchString(),
              data: user.getDataForAutocomplete()
            });
          }
          return _results;
        })();
        return callback(userContacts);
      }, fromServer);
    };

    AddParticipantForm.prototype._renderForm = function(userContacts) {
      var $resultsContainer, res,
        _this = this;
      res = renderForm({
        addButtons: this._addButtons
      });
      res = DomUtils.parseFromString(res);
      this._$container[0].appendChild(res);
      this._$syncContactsButtonContainer = this._$container.find('.js-contacts-sync-button-container');
      this._renderSyncBlock(userContacts);
      this._$syncContactsButtonContainer.on('click', '.js-sync-contacts-button', this._contactButtonHandler);
      this._$addButton = this._$container.find('.js-add-button');
      this._$queryInput = this._$container.find('.js-input-email');
      this._$queryInput.attr('textColor', this._$queryInput.css('color'));
      this._$queryInput.bind('focus', function() {
        _this._$queryInput.val(_this._$queryInput.val() === 'enter email' ? '' : _this._$queryInput.val());
        return _this._$queryInput.css('color', '#000');
      });
      this._$queryInput.bind('blur', function() {
        if (_this._$queryInput.val() !== '') return;
        _this._$queryInput.val('enter email');
        return _this._$queryInput.css('color', _this._$queryInput.attr('textColor'));
      });
      $resultsContainer = this._$container.find('.js-autocomplete-results');
      this._autocompleter = new Autocompleter(this._getContacts, $resultsContainer, renderUser, this._$queryInput, this._maxItemsToShow, this._contactSelectHandler);
      return this._initEvents();
    };

    AddParticipantForm.prototype._initEvents = function() {
      var _this = this;
      return this._$addButton.on('click', function() {
        return _this._contactSelectHandler(_this._autocompleter.getActiveItem());
      });
    };

    AddParticipantForm.prototype._renderSyncBlock = function(userContacts, justRefreshedSource) {
      var contactSources;
      contactSources = getContactSources(userContacts);
      return this._$syncContactsButtonContainer.empty().append(this._renderGoogleContactsSyncButton(contactSources, justRefreshedSource)).append(this._renderFacebookContactsSyncButton(contactSources, justRefreshedSource));
    };

    AddParticipantForm.prototype._renderGoogleContactsSyncButton = function(contactSources, justRefreshedSource) {
      var params;
      params = {
        source: 'google',
        hasContacts: contactSources.google,
        sourceConstant: contactsConstants.SOURCE_NAME_GOOGLE
      };
      if (justRefreshedSource === contactsConstants.SOURCE_NAME_GOOGLE) {
        return renderRefreshedMessage(params);
      } else {
        return renderContactsSyncButton(params);
      }
    };

    AddParticipantForm.prototype._renderFacebookContactsSyncButton = function(contactSources, justRefreshedSource) {
      var params;
      params = {
        source: 'facebook',
        hasContacts: contactSources.facebook,
        sourceConstant: contactsConstants.SOURCE_NAME_FACEBOOK
      };
      if (justRefreshedSource === contactsConstants.SOURCE_NAME_FACEBOOK) {
        return renderRefreshedMessage(params);
      } else {
        return renderContactsSyncButton(params);
      }
    };

    AddParticipantForm.prototype.show = function() {
      var _this = this;
      this._autocompleter.reset();
      this._$container.show();
      this._renderSyncBlock(this._autocompleter.getData());
      return window.setTimeout(function() {
        $(document).on('keydown.closeAddParticipantBlock', function(e) {
          if (e.keyCode !== 27) return;
          return _this.hide();
        });
        return $(document).on('click.addParticipantBlock', function(e) {
          if ($(e.target).closest('.js-add-form, .js-add-select-selectBox-dropdown-menu').length !== 0) {
            return;
          }
          return _this.hide();
        });
      }, 0);
    };

    AddParticipantForm.prototype.hide = function() {
      this._$container.hide();
      $(document).off('keydown.closeAddParticipantBlock');
      return $(document).off('click.addParticipantBlock');
    };

    AddParticipantForm.prototype.isVisible = function() {
      return this._$container.is(':visible');
    };

    AddParticipantForm.prototype.refreshContacts = function(justRefreshedSource) {
      this._renderSyncBlock(this._autocompleter.getData(), justRefreshedSource);
      return this._autocompleter.restart();
    };

    AddParticipantForm.prototype.restartAutocompleter = function() {
      return this._autocompleter.restart();
    };

    AddParticipantForm.prototype.destroy = function() {
      this.hide();
      this._autocompleter.destroy();
      delete this._autocompleter;
      return this._$container.empty();
    };

    return AddParticipantForm;

  })();

  module.exports = {
    AddParticipantForm: AddParticipantForm,
    renderContactsSyncButton: renderContactsSyncButton
  };

}).call(this);

});

require.define("/lib/client/client/wave/role_select_popup.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var PopupContent, RoleSelectPopup, ck, renderRoleSelect,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  PopupContent = require('../popup/').PopupContent;

  ck = window.CoffeeKup;

  renderRoleSelect = ck.compile(function() {
    var groupName, roleId, roleName, _i, _len, _ref, _ref2, _results;
    groupName = Math.random();
    _ref = this.roles;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref2 = _ref[_i], roleId = _ref2[0], roleName = _ref2[1];
      _results.push(div('.role', function() {
        var inputId, params;
        inputId = Math.random();
        params = {
          name: groupName,
          type: 'radio',
          id: inputId
        };
        if (this.curState === roleId) params.checked = 'checked';
        input(".js-role-" + roleId, params);
        return label({
          "for": inputId
        }, roleName);
      }));
    }
    return _results;
  });

  RoleSelectPopup = (function(_super) {

    __extends(RoleSelectPopup, _super);

    function RoleSelectPopup(roles, getState, stateChangeCallback) {
      var $c, roleId, _fn, _i, _len;
      this._container = document.createElement('span');
      $c = $(this._container);
      $c.append(renderRoleSelect({
        curState: getState(),
        roles: roles
      }));
      _fn = function(roleId) {
        var roleNode;
        roleNode = $c.find(".js-role-" + roleId)[0];
        return $(roleNode).on('change click', function() {
          if (roleNode.checked) return stateChangeCallback(roleId);
        });
      };
      for (_i = 0, _len = roles.length; _i < _len; _i++) {
        roleId = roles[_i][0];
        _fn(roleId);
      }
    }

    RoleSelectPopup.prototype.getContainer = function() {
      return this._container;
    };

    RoleSelectPopup.prototype.getInternalContainerClass = function() {
      return 'role-selector-popup js-role-selector-popup';
    };

    RoleSelectPopup.prototype.destroy = function() {};

    return RoleSelectPopup;

  })(PopupContent);

  module.exports = {
    RoleSelectPopup: RoleSelectPopup
  };

}).call(this);

});

require.define("/lib/client/client/mindmap/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var DRAG_THRESHOLD_PIXELS, GHOST_MAX_HEIGHT, GHOST_MAX_WIDTH, GHOST_X_OFFSET, GHOST_Y_OFFSET, LONG_MAX_NODE_TEXT_LENGTH, LONG_MAX_THREAD_WIDTH, MAX_CHILD_BLIP_DROP_ZONE, MAX_SCROLL_DELTA, MAX_SPEED_SCROLL_ZONE, MAX_TEXT_DROP_ZONE, MAX_THREAD_BLIP_DROP_ZONE, MindMap, MindMapNode, MindMapNodeBlock, MindMapThread, ROLE_EDITOR, ROLE_OWNER, SCROLL_ZONE, SHORT_MAX_NODE_TEXT_LENGTH, SHORT_MAX_THREAD_WIDTH, TEXT_NODE_HEIGHT, addClass, convertBlipOpsToSnapshot, convertTextOpsToBlipOps, convertTextOpsToSnapshot, getElement, removeClass, _ref, _ref2, _ref3, _ref4, _ref5,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  MindMapNode = require('./node').MindMapNode;

  MindMapNodeBlock = require('./nodeblock/real').MindMapNodeBlock;

  MindMapThread = require('./thread/real').MindMapThread;

  _ref = require('./utils'), getElement = _ref.getElement, addClass = _ref.addClass, removeClass = _ref.removeClass, convertTextOpsToSnapshot = _ref.convertTextOpsToSnapshot, convertBlipOpsToSnapshot = _ref.convertBlipOpsToSnapshot, convertTextOpsToBlipOps = _ref.convertTextOpsToBlipOps;

  _ref2 = require('../wave/participants/constants'), ROLE_OWNER = _ref2.ROLE_OWNER, ROLE_EDITOR = _ref2.ROLE_EDITOR;

  _ref3 = require('./const'), TEXT_NODE_HEIGHT = _ref3.TEXT_NODE_HEIGHT, GHOST_X_OFFSET = _ref3.GHOST_X_OFFSET, GHOST_Y_OFFSET = _ref3.GHOST_Y_OFFSET, GHOST_MAX_WIDTH = _ref3.GHOST_MAX_WIDTH, GHOST_MAX_HEIGHT = _ref3.GHOST_MAX_HEIGHT;

  _ref4 = require('./const'), SHORT_MAX_NODE_TEXT_LENGTH = _ref4.SHORT_MAX_NODE_TEXT_LENGTH, LONG_MAX_NODE_TEXT_LENGTH = _ref4.LONG_MAX_NODE_TEXT_LENGTH;

  _ref5 = require('./const'), SHORT_MAX_THREAD_WIDTH = _ref5.SHORT_MAX_THREAD_WIDTH, LONG_MAX_THREAD_WIDTH = _ref5.LONG_MAX_THREAD_WIDTH;

  MAX_SCROLL_DELTA = 50;

  MAX_SPEED_SCROLL_ZONE = 30;

  SCROLL_ZONE = 70;

  MAX_TEXT_DROP_ZONE = TEXT_NODE_HEIGHT;

  MAX_CHILD_BLIP_DROP_ZONE = 25;

  MAX_THREAD_BLIP_DROP_ZONE = 40;

  DRAG_THRESHOLD_PIXELS = 7;

  MindMap = (function() {

    function MindMap(_waveViewModel) {
      this._waveViewModel = _waveViewModel;
      this.updateSize = __bind(this.updateSize, this);
      this._updateScrollability = __bind(this._updateScrollability, this);
      this._autoscroll = __bind(this._autoscroll, this);
      this._processContainerMouseMove = __bind(this._processContainerMouseMove, this);
      this._processContainerMouseUp = __bind(this._processContainerMouseUp, this);
      this._processContainerMouseDown = __bind(this._processContainerMouseDown, this);
      this._isFirstRender = true;
    }

    MindMap.prototype.render = function(_container) {
      this._container = _container;
      this._svgWidth = this._svgHeight = 0;
      this._createRootBlock();
      this._createSVGNode();
      this._rootBlock.updatePosition();
      this._isFirstRender = false;
      this._initDrag();
      return window.addEventListener('resize', this._updateScrollability);
    };

    MindMap.prototype._createRootBlock = function() {
      var containerBlip, _ref6;
      containerBlip = this._waveViewModel.getView().rootBlip;
      if ((_ref6 = this._rootBlock) != null) _ref6.destroy();
      this._rootBlock = new MindMapNodeBlock(this, null, containerBlip);
      return this._rootBlock.on('size-updated', this.updateSize);
    };

    MindMap.prototype._createSVGNode = function() {
      this._svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      this._svg.setAttribute('class', 'mindmap');
      this._svg.appendChild(this._rootBlock.getContainer());
      this._svgContainer = $("<div class=\"svg-container\"></div>")[0];
      this._svgContainer.appendChild(this._svg);
      this._container.appendChild(this._svgContainer);
      this._defs = getElement('defs');
      this._svg.appendChild(this._defs);
      this._createGradientDefs();
      return this._createGhostClipPath();
    };

    MindMap.prototype._createGradientDefs = function() {
      this._defs.appendChild(this._getGradientDef('blipSizeBoxOddGradient'));
      this._defs.appendChild(this._getGradientDef('blipSizeBoxEvenGradient'));
      return this._defs.appendChild(this._getGradientDef('virtualBlipSizeBoxGradient'));
    };

    MindMap.prototype._getGradientDef = function(id) {
      var gradient, stop1, stop2;
      stop1 = getElement('stop', {
        offset: '0%',
        "class": 'start-color'
      });
      stop2 = getElement('stop', {
        offset: '100%',
        "class": 'end-color'
      });
      gradient = getElement('linearGradient', {
        id: id,
        x1: '0%',
        y1: '0%',
        x2: '0%',
        y2: '100%'
      });
      gradient.appendChild(stop1);
      gradient.appendChild(stop2);
      return gradient;
    };

    MindMap.prototype._initDrag = function() {
      var _ref6;
      this._canDrag = (_ref6 = this._waveViewModel.getRole()) === ROLE_OWNER || _ref6 === ROLE_EDITOR;
      return $(this._container).mousedown(this._processContainerMouseDown);
    };

    MindMap.prototype._initDragEvents = function() {
      $(this._container).mouseup(this._processContainerMouseUp);
      return $(this._container).mousemove(this._processContainerMouseMove);
    };

    MindMap.prototype._deinitDragEvents = function() {
      $(this._container).off('mouseup', this._processContainerMouseUp);
      return $(this._container).off('mousemove', this._processContainerMouseMove);
    };

    MindMap.prototype._deinitDrag = function() {
      $(this._container).off('mousedown', this._processContainerMouseDown);
      return this._deinitDragEvents();
    };

    MindMap.prototype._getCoordinates = function(e, offsetElement) {
      var coords;
      coords = $(offsetElement).offset();
      return {
        x: e.pageX - coords.left,
        y: e.pageY - coords.top
      };
    };

    MindMap.prototype._getSvgCoordinates = function(e) {
      return this._getCoordinates(e, this._svg);
    };

    MindMap.prototype._getContainerCoordinates = function(e) {
      return this._getCoordinates(e, this._container);
    };

    MindMap.prototype._dropTargetsAreEqual = function(a, b) {
      if (!(a != null) && !(b != null)) return true;
      if (!(a != null) || !(b != null)) return false;
      return a[0] === b[0] && a[1] === b[1];
    };

    MindMap.prototype._getTextTopDropTarget = function(node) {
      var block, virtualIndex;
      if (node.isVirtual()) return this._dropTarget;
      block = node.getParent();
      virtualIndex = block.getChildNodeRealIndex(node) + 1;
      return [block, virtualIndex];
    };

    MindMap.prototype._getBlipTopDropTarget = function(node) {
      var block, thread, virtualIndex;
      if (node.isVirtual()) return this._dropTarget;
      block = node.getParent();
      thread = block.getParent();
      virtualIndex = thread.getChildNodeRealIndex(block) + 1;
      return [thread, virtualIndex];
    };

    MindMap.prototype._getTextBottomDropTarget = function(node) {
      var block, virtualIndex;
      if (node.isVirtual()) return this._dropTarget;
      block = node.getParent();
      virtualIndex = block.getChildNodeRealIndex(node);
      if (block.getParent().getParent().isRoot() && virtualIndex < 2) return null;
      return [block, virtualIndex];
    };

    MindMap.prototype._getBlipBottomDropTarget = function(node) {
      var block, thread, virtualIndex;
      if (node.isVirtual()) return this._dropTarget;
      block = node.getParent();
      thread = block.getParent();
      virtualIndex = thread.getChildNodeRealIndex(block);
      if (thread.getParent().isRoot() && virtualIndex === 0) return null;
      return [thread, virtualIndex];
    };

    MindMap.prototype._getBlipLeftDropTarget = function(node) {
      if (node.isVirtual()) return this._dropTarget;
      return [node, 0];
    };

    MindMap.prototype._getTopDropTarget = function(node, dist, textDropZone, blipDropZone) {
      if (!(textDropZone != null) || dist < textDropZone) {
        return this._getTextTopDropTarget(node);
      } else if (!(blipDropZone != null) || dist < blipDropZone) {
        return this._getBlipTopDropTarget(node);
      } else {
        return null;
      }
    };

    MindMap.prototype._getBottomDropTarget = function(node, dist, textDropZone, blipDropZone) {
      if (!(textDropZone != null) || dist < textDropZone) {
        return this._getTextBottomDropTarget(node);
      } else if (!(blipDropZone != null) || dist < blipDropZone) {
        return this._getBlipBottomDropTarget(node);
      } else {
        return null;
      }
    };

    MindMap.prototype._getVerticalDropTargetForParagraph = function(x, y) {
      var blipDropZone, bottom, bottomBlock, dist, res, textDropZone, top, topBlock;
      top = this._rootBlock.getNodeToTheTopOfCoords(x, y);
      bottom = this._rootBlock.getNodeToTheBottomOfCoords(x, y);
      if ((top != null) && (bottom != null)) {
        topBlock = top[0].getParent();
        bottomBlock = bottom[0].getParent();
        blipDropZone = null;
        if (topBlock !== bottomBlock) {
          dist = top[1] + bottom[1];
          if (topBlock.getParent() !== bottomBlock.getParent()) {
            textDropZone = Math.min(MAX_TEXT_DROP_ZONE, dist / 4);
            blipDropZone = MAX_THREAD_BLIP_DROP_ZONE;
          } else {
            textDropZone = Math.min(MAX_TEXT_DROP_ZONE, dist / 3);
          }
        }
        if (top[1] < bottom[1]) {
          res = this._getTopDropTarget(top[0], top[1], textDropZone, blipDropZone);
        } else {
          res = this._getBottomDropTarget(bottom[0], bottom[1], textDropZone, blipDropZone);
        }
      } else if (top != null) {
        res = this._getTopDropTarget(top[0], top[1], MAX_TEXT_DROP_ZONE, MAX_THREAD_BLIP_DROP_ZONE);
      } else if (bottom != null) {
        res = this._getBottomDropTarget(bottom[0], bottom[1], MAX_TEXT_DROP_ZONE, MAX_THREAD_BLIP_DROP_ZONE);
      } else {
        res = null;
      }
      return res;
    };

    MindMap.prototype._getVerticalDropTargetForBlip = function(x, y) {
      var bottom, bottomBlock, res, top, topBlock;
      top = this._rootBlock.getNodeToTheTopOfCoords(x, y);
      bottom = this._rootBlock.getNodeToTheBottomOfCoords(x, y);
      if ((top != null) && (bottom != null)) {
        topBlock = top[0].getParent();
        bottomBlock = bottom[0].getParent();
        if (topBlock === bottomBlock) {
          res = null;
        } else {
          if (topBlock.getParent() === bottomBlock.getParent()) {
            if (top[1] < bottom[1]) {
              res = this._getBlipTopDropTarget(top[0]);
            } else {
              res = this._getBlipBottomDropTarget(bottom[0]);
            }
          } else {
            if (top[1] < bottom[1]) {
              res = this._getTopDropTarget(top[0], top[1], 0, MAX_THREAD_BLIP_DROP_ZONE);
            } else {
              res = this._getBottomDropTarget(bottom[0], bottom[1], 0, MAX_THREAD_BLIP_DROP_ZONE);
            }
          }
        }
      } else if (top != null) {
        res = this._getTopDropTarget(top[0], top[1], 0, MAX_THREAD_BLIP_DROP_ZONE);
      } else if (bottom != null) {
        res = this._getBottomDropTarget(bottom[0], bottom[1], 0, MAX_THREAD_BLIP_DROP_ZONE);
      } else {
        res = null;
      }
      return res;
    };

    MindMap.prototype._nodeHasAncestor = function(node, ancestor) {
      while (node != null) {
        if (node === ancestor) return true;
        node = node.getParent();
      }
      return false;
    };

    MindMap.prototype._canUseDropTarget = function(dropTarget) {
      var movedIndex, movedParent, _ref6;
      if (!(dropTarget != null)) return true;
      if (this._nodeHasAncestor(dropTarget[0], this._movedNode)) return false;
      if (dropTarget[0] instanceof MindMapNodeBlock && (this._movedNode instanceof MindMapThread || this._movedNode instanceof MindMapNodeBlock)) {
        return false;
      }
      movedParent = this._movedNode.getParent();
      if (dropTarget[0] !== movedParent) return true;
      movedIndex = movedParent.getChildNodeRealIndex(this._movedNode);
      return (_ref6 = dropTarget[1]) !== movedIndex && _ref6 !== (movedIndex + 1);
    };

    MindMap.prototype._updateDropTarget = function() {
      var left, newDropTarget, x, y, _ref6;
      if (!(this._movedNode != null)) return;
      _ref6 = this._getSvgCoordinates(this._lastMoveEvent), x = _ref6.x, y = _ref6.y;
      left = this._rootBlock.getNodeToTheLeftOfCoords(x, y);
      if ((left != null) && !left[0].hasDescription() && left[1] < MAX_CHILD_BLIP_DROP_ZONE) {
        newDropTarget = this._getBlipLeftDropTarget(left[0]);
      } else {
        if (this._movedNode instanceof MindMapNode) {
          newDropTarget = this._getVerticalDropTargetForParagraph(x, y);
        } else {
          newDropTarget = this._getVerticalDropTargetForBlip(x, y);
        }
      }
      if (!this._canUseDropTarget(newDropTarget)) newDropTarget = null;
      if (this._dropTargetsAreEqual(this._dropTarget, newDropTarget)) return;
      this._removeDropTarget();
      return this._setDropTarget(newDropTarget);
    };

    MindMap.prototype._setDropTarget = function(target) {
      if (!(target != null)) return;
      if (target[0] instanceof MindMapThread) {
        target[0].insertVirtualBlipsAt(target[1], this._movedBlipsSnapshot);
      } else if (target[0] instanceof MindMapNodeBlock) {
        target[0].insertVirtualParagraphAt(target[1], this._movedTextSnapshot);
      } else {
        target[0].insertVirtualDescription(this._movedBlipsSnapshot);
      }
      this._dropTarget = target;
      if (this._ghost != null) return addClass(this._ghost, 'hidden');
    };

    MindMap.prototype._removeDropTarget = function() {
      if (!(this._dropTarget != null)) return;
      this._dropTarget[0].removeAllVirtualNodes();
      delete this._dropTarget;
      if (this._ghost != null) return removeClass(this._ghost, 'hidden');
    };

    MindMap.prototype._getDragNode = function(node) {
      while ((node != null) && !(node.dragNode != null)) {
        node = node.parentNode;
      }
      return node != null ? node.dragNode : void 0;
    };

    MindMap.prototype._processContainerMouseDown = function(e) {
      var node, x, y, _ref6;
      if (e.button !== 0) return;
      if (this._canDrag) node = this._getDragNode(e.target);
      if (node) {
        this._movedOps = node.getCopyOps();
        if (node instanceof MindMapNode) {
          this._ghostNode = node.getTextNodeContainer();
          this._movedTextSnapshot = convertTextOpsToSnapshot(this._movedOps);
          this._movedBlipsSnapshot = [this._movedTextSnapshot];
        } else if (node instanceof MindMapNodeBlock) {
          this._ghostNode = node.getTextContainer();
          this._movedTextSnapshot = null;
          this._movedBlipsSnapshot = convertBlipOpsToSnapshot(this._movedOps);
        } else if (node instanceof MindMapThread) {
          this._ghostNode = node.getBlockContainer();
          this._movedTextSnapshot = null;
          this._movedBlipsSnapshot = convertBlipOpsToSnapshot(this._movedOps);
        }
        this._lastMoveEvent = e;
        this._startX = e.screenX;
        this._startY = e.screenY;
        this._movedNode = node;
        this._createGhost();
      } else if (this._scrollable) {
        _ref6 = this._getContainerCoordinates(e), x = _ref6.x, y = _ref6.y;
        if ((x < $(this._container).innerWidth() - 20) && (y < $(this._container).innerHeight() - 20)) {
          this._startX = e.screenX;
          this._startY = e.screenY;
          this._startScrollLeft = this._svgContainer.scrollLeft;
          this._startScrollTop = this._svgContainer.scrollTop;
          addClass(this._svgContainer, 'moving');
        }
      }
      this._initDragEvents();
      return e.preventDefault();
    };

    MindMap.prototype._performDrop = function(dropNode, dropIndex, movedNode, movedOps) {
      var ops;
      if (dropNode instanceof MindMapNodeBlock) {
        dropNode.insertSnapshotParagraphOpsAt(dropIndex, movedOps);
      } else {
        if (movedNode instanceof MindMapNode) {
          ops = convertTextOpsToBlipOps(movedOps);
        } else {
          ops = movedOps;
        }
        if (dropNode instanceof MindMapThread) {
          dropNode.insertBlipOpsAt(dropIndex, ops);
        } else {
          dropNode.insertBlipOpsAsDescription(ops);
        }
      }
      return movedNode.removeFromSnapshot();
    };

    MindMap.prototype._processContainerMouseUp = function() {
      var dropIndex, dropNode, _ref6;
      if (this._dropTarget != null) {
        _ref6 = this._dropTarget, dropNode = _ref6[0], dropIndex = _ref6[1];
      }
      this._removeDropTarget();
      if (dropNode != null) {
        this._performDrop(dropNode, dropIndex, this._movedNode, this._movedOps);
      }
      this._movedNode = null;
      this._movedOps = null;
      this._startX = null;
      removeClass(this._svgContainer, 'moving');
      this._dragStarted = false;
      this._deinitDragEvents();
      this._removeGhost();
      return this._removeAutoscrollTimer();
    };

    MindMap.prototype._processContainerMouseMove = function(e) {
      var dist;
      if (this._ghost) {
        if (e.target.mindMapNode != null) e.target.mindMapNode.showDescription();
        this._lastMoveEvent = e;
        if (!this._dragStarted) {
          dist = Math.abs(e.screenX - this._startX) + Math.abs(e.screenY - this._startY);
          this._dragStarted = dist > DRAG_THRESHOLD_PIXELS;
        }
        if (this._dragStarted) {
          this._updateGhostPosition();
          this._updateDropTarget();
          if (this._dropTarget != null) this._updateDropTarget();
          this._rootBlock.updatePosition();
          return this._updateAutoScroll();
        }
      } else if (this._startX != null) {
        this._svgContainer.scrollLeft = this._startScrollLeft - e.screenX + this._startX;
        return this._svgContainer.scrollTop = this._startScrollTop - e.screenY + this._startY;
      }
    };

    MindMap.prototype._getScrollDelta = function(coord, max) {
      var changeSign, delta, ratio, res;
      if (coord > SCROLL_ZONE) {
        coord = max - coord;
        changeSign = 1;
      } else {
        changeSign = -1;
      }
      if (coord <= MAX_SPEED_SCROLL_ZONE) {
        res = MAX_SCROLL_DELTA;
      } else if (coord >= SCROLL_ZONE) {
        res = 0;
      } else {
        delta = SCROLL_ZONE - MAX_SPEED_SCROLL_ZONE;
        ratio = (SCROLL_ZONE - coord) / delta;
        res = Math.floor(MAX_SCROLL_DELTA * ratio * ratio);
      }
      return changeSign * res;
    };

    MindMap.prototype._updateAutoScroll = function() {
      var x, y, _ref6;
      _ref6 = this._getContainerCoordinates(this._lastMoveEvent), x = _ref6.x, y = _ref6.y;
      this._dx = this._getScrollDelta(x, $(this._container).innerWidth());
      this._dy = this._getScrollDelta(y, $(this._container).innerHeight());
      if (this._dx || this._dy) {
        return this._setAutoscrollTimer();
      } else {
        return this._removeAutoscrollTimer();
      }
    };

    MindMap.prototype._setAutoscrollTimer = function() {
      if (this._autoscrollTimer != null) return;
      return this._autoscrollTimer = window.setInterval(this._autoscroll, 50);
    };

    MindMap.prototype._removeAutoscrollTimer = function() {
      if (!(this._autoscrollTimer != null)) return;
      window.clearInterval(this._autoscrollTimer);
      return this._autoscrollTimer = null;
    };

    MindMap.prototype._autoscroll = function() {
      this._svgContainer.scrollLeft = window.parseInt(this._svgContainer.scrollLeft) + this._dx;
      this._svgContainer.scrollTop = window.parseInt(this._svgContainer.scrollTop) + this._dy;
      this._updateDropTarget();
      if (this._dropTarget != null) this._updateDropTarget();
      return this._rootBlock.updatePosition();
    };

    MindMap.prototype._updateScrollability = function() {
      this._scrollable = this._svgWidth > this._svgContainer.offsetWidth || this._svgHeight > this._svgContainer.offsetHeight;
      if (this._scrollable) {
        return addClass(this._svgContainer, 'scrollable');
      } else {
        return removeClass(this._svgContainer, 'scrollable');
      }
    };

    MindMap.prototype.updateSize = function() {
      this._svgWidth = Math.floor(this._rootBlock.getTotalWidth() + 20);
      this._svgHeight = Math.floor(this._rootBlock.getTotalHeight() + 50);
      this._svg.style.width = this._svgWidth + 'px';
      this._svg.style.height = this._svgHeight + 'px';
      return this._updateScrollability();
    };

    MindMap.prototype.fold = function() {
      var _ref6;
      return (_ref6 = this._rootBlock) != null ? _ref6.foldAllRecursively() : void 0;
    };

    MindMap.prototype.unfold = function() {
      var _ref6;
      return (_ref6 = this._rootBlock) != null ? _ref6.unfoldAllRecursively() : void 0;
    };

    MindMap.prototype.update = function() {
      if (!(this._rootBlock != null)) return;
      this._rootBlock.invalidateIncludingChildren();
      return this._rootBlock.updatePosition();
    };

    MindMap.prototype._createGhostClipPath = function() {
      var clip, clipPath;
      clip = getElement('rect', {
        width: GHOST_MAX_WIDTH,
        height: GHOST_MAX_HEIGHT
      });
      clipPath = getElement('clipPath', {
        id: 'ghostClipPath'
      });
      clipPath.appendChild(clip);
      return this._defs.appendChild(clipPath);
    };

    MindMap.prototype._createGhost = function() {
      var _ref6;
      this._ghostNode.setAttribute('id', 'dragNode');
      if ((_ref6 = this._ghost) != null) _ref6.parentNode.removeChild(this._ghost);
      this._ghost = getElement('use', {
        'clip-path': 'url(#ghostClipPath)',
        "class": 'ghost'
      });
      this._ghost.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', "#dragNode");
      this._svg.appendChild(this._ghost);
      return this._updateGhostPosition();
    };

    MindMap.prototype._updateGhostPosition = function() {
      var x, y, _ref6;
      _ref6 = this._getSvgCoordinates(this._lastMoveEvent), x = _ref6.x, y = _ref6.y;
      this._ghost.setAttribute('x', x + GHOST_X_OFFSET);
      this._ghost.setAttribute('y', y + GHOST_Y_OFFSET);
      return this._ghost.parentNode.appendChild(this._ghost);
    };

    MindMap.prototype._removeGhost = function() {
      var _ref6;
      if ((_ref6 = this._ghostNode) != null) _ref6.removeAttribute('id');
      if (!(this._ghost != null)) return;
      this._ghost.parentNode.removeChild(this._ghost);
      return this._ghost = null;
    };

    MindMap.prototype.isFirstRender = function() {
      return this._isFirstRender;
    };

    MindMap.prototype.getMaxNodeTextLength = function() {
      if (this._isLongMode) {
        return LONG_MAX_NODE_TEXT_LENGTH;
      } else {
        return SHORT_MAX_NODE_TEXT_LENGTH;
      }
    };

    MindMap.prototype.getMaxThreadWidth = function() {
      if (this._isLongMode) {
        return LONG_MAX_THREAD_WIDTH;
      } else {
        return SHORT_MAX_THREAD_WIDTH;
      }
    };

    MindMap.prototype.setLongMode = function() {
      if (this._isLongMode) return;
      this._isLongMode = true;
      return this.update();
    };

    MindMap.prototype.setShortMode = function() {
      if (!this._isLongMode) return;
      this._isLongMode = false;
      return this.update();
    };

    MindMap.prototype.isDragging = function() {
      return this._startX != null;
    };

    MindMap.prototype.destroy = function() {
      var _ref6;
      this._removeGhost();
      this._removeDropTarget();
      if ((_ref6 = this._rootBlock) != null) _ref6.destroy();
      this._deinitDrag();
      this._removeAutoscrollTimer();
      delete this._rootBlock;
      delete this._svgContainer;
      return delete this._container;
    };

    return MindMap;

  })();

  module.exports = {
    MindMap: MindMap
  };

}).call(this);

});

require.define("/lib/client/client/mindmap/node.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var DESCRIPTION_LEFT_OFFSET, DROP_CHILD_THREAD_ZONE, FOLD_BUTTON_HEIGHT, FOLD_BUTTON_LEFT_PADDING, FOLD_BUTTON_TOP_OFFSET, FOLD_BUTTON_WIDTH, MindMapNode, MindMapNodeBlock, MindMapThread, PARAGRAPH_LINE_HEIGHT, PARAGRAPH_LINE_LEFT_OFFSET, TEXT_NODE_HEIGHT, TEXT_NODE_PADDING_LEFT, TEXT_Y_OFFSET, TextNode, VirtualMindMapThread, addClass, copy, getElement, removeClass, _ref, _ref2,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  MindMapNodeBlock = require('./nodeblock/real').MindMapNodeBlock;

  _ref = require('./utils'), getElement = _ref.getElement, copy = _ref.copy, addClass = _ref.addClass, removeClass = _ref.removeClass;

  TextNode = require('./text_node').TextNode;

  MindMapThread = require('./thread/real').MindMapThread;

  VirtualMindMapThread = require('./thread/virtual').VirtualMindMapThread;

  _ref2 = require('./const'), TEXT_NODE_HEIGHT = _ref2.TEXT_NODE_HEIGHT, TEXT_Y_OFFSET = _ref2.TEXT_Y_OFFSET, TEXT_NODE_PADDING_LEFT = _ref2.TEXT_NODE_PADDING_LEFT, DESCRIPTION_LEFT_OFFSET = _ref2.DESCRIPTION_LEFT_OFFSET, PARAGRAPH_LINE_LEFT_OFFSET = _ref2.PARAGRAPH_LINE_LEFT_OFFSET, PARAGRAPH_LINE_HEIGHT = _ref2.PARAGRAPH_LINE_HEIGHT, FOLD_BUTTON_WIDTH = _ref2.FOLD_BUTTON_WIDTH, FOLD_BUTTON_HEIGHT = _ref2.FOLD_BUTTON_HEIGHT, FOLD_BUTTON_TOP_OFFSET = _ref2.FOLD_BUTTON_TOP_OFFSET, FOLD_BUTTON_LEFT_PADDING = _ref2.FOLD_BUTTON_LEFT_PADDING, DROP_CHILD_THREAD_ZONE = _ref2.DROP_CHILD_THREAD_ZONE;

  MindMapNode = (function() {

    function MindMapNode(_mindmap, _id, textBlocks, _parent, descriptionBlips) {
      this._mindmap = _mindmap;
      this._id = _id;
      this._parent = _parent;
      this.unmarkSelected = __bind(this.unmarkSelected, this);
      this.markSelected = __bind(this.markSelected, this);
      this._switchToTextView = __bind(this._switchToTextView, this);
      this._processFoldButtonClick = __bind(this._processFoldButtonClick, this);
      this._createDOMNodes(textBlocks);
      this._description = new MindMapThread(this._mindmap, this, descriptionBlips);
      this._needsPositionUpdate = true;
    }

    MindMapNode.prototype.getId = function() {
      return this._id;
    };

    MindMapNode.prototype._createDOMNodes = function(textBlocks) {
      /*
              Создает ноды, необходимые для отображения параграфа
      */
      var containerClass;
      containerClass = 'node-container';
      if (this.isVirtual() && !this.isRoot()) containerClass += ' virtual';
      this._container = getElement('g', {
        'class': containerClass
      });
      return this._createTextContainer(textBlocks);
    };

    MindMapNode.prototype.getContainer = function() {
      return this._container;
    };

    MindMapNode.prototype._createFoldButton = function() {
      if (this._foldButtonGroup != null) return;
      this._foldButtonGroup = getElement('g');
      this._foldButton = getElement('image', {
        'width': FOLD_BUTTON_WIDTH,
        'height': FOLD_BUTTON_HEIGHT,
        'class': 'fold-button'
      });
      this._foldButton.addEventListener('click', this._processFoldButtonClick);
      this._foldButton.mindMapNode = this;
      this._foldButtonGroup.appendChild(this._foldButton);
      return this._container.appendChild(this._foldButtonGroup);
    };

    MindMapNode.prototype._destroyFoldButton = function() {
      if (!(this._foldButtonGroup != null)) return;
      this._foldButton.removeEventListener('click', this._processFoldButtonClick);
      this._foldButtonGroup.parentNode.removeChild(this._foldButtonGroup);
      delete this._foldButton.mindMapNode;
      return delete this._foldButtonGroup;
    };

    MindMapNode.prototype._updateFoldButton = function() {
      /*
              Обновляет видимость, позицию и картинку на кнопке сворачивания треда
      */
      var name;
      if (this.isRoot() || !this._description.getBlocks().length > 0) {
        addClass(this._foldButtonGroup, 'hidden');
        return;
      }
      removeClass(this._foldButtonGroup, 'hidden');
      name = [];
      name.push(this._descriptionIsHidden() ? 'plus' : 'minus');
      name.push(this._description.isRead() ? 'read' : 'unread');
      this._foldButton.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', "/s/img/mindmap/" + (name.join('_')) + ".png");
      return this._foldButtonGroup.setAttribute('transform', "translate(" + (this._getFoldButtonX()) + ", " + FOLD_BUTTON_TOP_OFFSET + ")");
    };

    MindMapNode.prototype._getFoldButtonX = function() {
      return this._parent.getThreadTextWidth() + FOLD_BUTTON_LEFT_PADDING;
    };

    MindMapNode.prototype.getFoldButtonRight = function() {
      return this._getFoldButtonX() + FOLD_BUTTON_WIDTH;
    };

    MindMapNode.prototype.getFoldButtonMidY = function() {
      return FOLD_BUTTON_HEIGHT / 2;
    };

    MindMapNode.prototype._processFoldButtonClick = function() {
      if (this._descriptionIsHidden()) {
        this._description.show();
      } else {
        this._description.hide();
      }
      this.recursivelyInvalidateAllCalculatedFields();
      return this.updatePositionFromRoot();
    };

    MindMapNode.prototype._descriptionIsHidden = function() {
      if (this.isVirtual() && !this.isRoot()) return true;
      return this._description.isHidden();
    };

    MindMapNode.prototype.showDescription = function() {
      if (!this._descriptionIsHidden()) return;
      this._description.show();
      this.recursivelyInvalidateAllCalculatedFields();
      return this.updatePositionFromRoot();
    };

    MindMapNode.prototype._createTextContainer = function(textBlocks) {
      var containerClass;
      containerClass = this.isRoot() ? 'root-node' : 'paragraph-label';
      this._textContainer = getElement('g', {
        "class": containerClass
      });
      this._container.appendChild(this._textContainer);
      if (!this.isRoot()) this._createSizeBox();
      this._createTextNode(textBlocks);
      if (!this.isRoot()) this._textContainer.dragNode = this;
      if (!this.isVirtual()) {
        this._textContainer.addEventListener('dblclick', this._switchToTextView);
      }
      if (!this.isVirtual()) {
        this._textContainer.addEventListener('mouseover', this.markSelected);
      }
      if (!this.isVirtual()) {
        this._textContainer.addEventListener('mouseout', this.unmarkSelected);
      }
      this._createFoldButton();
      return this._createParagraphLine();
    };

    MindMapNode.prototype._createTextNode = function(textBlocks) {
      var textNodeContainer;
      this._textNode = new TextNode(this._mindmap, textBlocks);
      textNodeContainer = this._textNode.getContainer();
      textNodeContainer.setAttribute('transform', "translate(" + TEXT_NODE_PADDING_LEFT + ", " + TEXT_Y_OFFSET + ")");
      return this._textContainer.appendChild(textNodeContainer);
    };

    MindMapNode.prototype._createSizeBox = function() {
      this._sizeBox = getElement('rect', {
        "class": 'paragraph-size-box',
        height: TEXT_NODE_HEIGHT
      });
      return this._textContainer.appendChild(this._sizeBox);
    };

    MindMapNode.prototype._updateSizeBoxPosition = function() {
      var _ref3;
      return (_ref3 = this._sizeBox) != null ? _ref3.setAttribute('width', this._parent.getThreadTextWidth()) : void 0;
    };

    MindMapNode.prototype.getTextNodeContainer = function() {
      return this._textNode.getContainer();
    };

    MindMapNode.prototype._createParagraphLine = function() {
      var paraLine;
      if (this.isRoot()) return;
      paraLine = getElement('path', {
        "class": 'paragraph-line',
        d: "M " + PARAGRAPH_LINE_LEFT_OFFSET + " " + ((TEXT_NODE_HEIGHT - PARAGRAPH_LINE_HEIGHT) / 2) + " l 0 " + PARAGRAPH_LINE_HEIGHT
      });
      return this._textContainer.appendChild(paraLine);
    };

    MindMapNode.prototype.getTextBlocks = function() {
      return this._textNode.getTextBlocks();
    };

    MindMapNode.prototype._switchToTextView = function() {
      return this._parent.switchToTextView(this._id);
    };

    MindMapNode.prototype._destroyTextContainer = function() {
      var _ref3;
      this._destroyFoldButton();
      this._textContainer.removeEventListener('dblclick', this._switchToTextView);
      this._textContainer.removeEventListener('mouseover', this.markSelected);
      this._textContainer.removeEventListener('mouseout', this.unmarkSelected);
      return (_ref3 = this._container) != null ? _ref3.removeChild(this._textContainer) : void 0;
    };

    MindMapNode.prototype.updatePosition = function() {
      /*
              Обновляет позиции и размеры всех элементов
      */      if (!this._needsPositionUpdate) return;
      this._updateFoldButton();
      this._updateDescription();
      this._updateSizeBoxPosition();
      this._textNode.updatePosition();
      return this._needsPositionUpdate = false;
    };

    MindMapNode.prototype.updatePositionFromRoot = function() {
      /*
              Обновляет позиции и размеры всех элементов, начиная от корня
      */      return this._parent.updatePositionFromRoot();
    };

    MindMapNode.prototype._updateDescription = function() {
      if (this._descriptionIsHidden() || !this._description.getBlocks().length) {
        addClass(this._description.getContainer(), 'hidden');
        return;
      }
      removeClass(this._description.getContainer(), 'hidden');
      return this._description.updatePosition();
    };

    MindMapNode.prototype.getDescriptionHeight = function() {
      if (this._descriptionIsHidden()) return 0;
      return this._description.getTotalHeight();
    };

    MindMapNode.prototype.getDescriptionWidth = function() {
      var res;
      res = 0;
      if (!this._descriptionIsHidden()) res = this._description.getTotalWidth();
      if (this._virtualDescription) {
        res = Math.max(res, this._virtualDescription.getTotalWidth());
      }
      return res;
    };

    MindMapNode.prototype.setTextBlocks = function(textBlocks) {
      this._textNode.setTextBlocks(textBlocks);
      return this.invalidateAllCalculatedFields();
    };

    MindMapNode.prototype.isRoot = function() {
      return this._parent.isRoot();
    };

    MindMapNode.prototype.foldAllRecursively = function() {
      this._description.foldAllRecursively();
      return this._needsPositionUpdate = true;
    };

    MindMapNode.prototype.unfoldAllRecursively = function() {
      this._description.unfoldAllRecursively();
      return this._needsPositionUpdate = true;
    };

    MindMapNode.prototype.getTextWidth = function() {
      return this._textNode.getTextWidth();
    };

    MindMapNode.prototype.isOfMaxWidth = function() {
      return this._textNode.widthIsMax();
    };

    MindMapNode.prototype.getDescription = function() {
      return this._description;
    };

    MindMapNode.prototype._getBlockIndexAtYCoord = function(y) {
      var block, curTop, index, _len, _ref3;
      _ref3 = this._description;
      for (index = 0, _len = _ref3.length; index < _len; index++) {
        block = _ref3[index];
        curTop = this._getDescriptionBlockTop(index) - TEXT_NODE_HEIGHT;
        if (y < curTop) return Math.max(0, index - 1);
      }
      return this._description.length - 1;
    };

    MindMapNode.prototype.getNodeAtDescriptionZoneToTheBottomOfCoords = function(x, y) {
      if (this._descriptionIsHidden()) return null;
      return this._description.getNodeToTheBottomOfCoords(x, y);
    };

    MindMapNode.prototype.getNodeAtDescriptionZoneToTheTopOfCoords = function(x, y) {
      if (this._descriptionIsHidden()) return null;
      return this._description.getNodeToTheTopOfCoords(x, y);
    };

    MindMapNode.prototype.getNodeAtDescriptionZoneToTheLeftOfCoords = function(x, y) {
      if (this._descriptionIsHidden()) return null;
      return this._description.getNodeToTheLeftOfCoords(x, y);
    };

    MindMapNode.prototype.isVirtual = function() {
      return !(this._id != null);
    };

    MindMapNode.prototype.getCopyOps = function() {
      return this._parent.getSnapshotParagraphInsertOps(this._id);
    };

    MindMapNode.prototype.removeFromSnapshot = function() {
      return this._parent.removeSnapshotParagraphBlocks(this._id);
    };

    MindMapNode.prototype.recursivelyInvalidateAllCalculatedFields = function() {
      this.invalidateAllCalculatedFields();
      return this._parent.recursivelyInvalidateAllCalculatedFields();
    };

    MindMapNode.prototype.invalidateAllCalculatedFields = function() {
      /*
              Сбрасывает все вычисляемые значения. Вызывается родительским блоком после обновления текста и описания.
      */      this._needsPositionUpdate = true;
      return this._textNode.invalidateAllCalculatedFields();
    };

    MindMapNode.prototype.invalidateIncludingChildren = function() {
      this.invalidateAllCalculatedFields();
      return this._description.invalidateIncludingChildren();
    };

    MindMapNode.prototype.forceUpdateNeed = function() {
      return this._needsPositionUpdate = true;
    };

    MindMapNode.prototype.getParent = function() {
      return this._parent;
    };

    MindMapNode.prototype.hasDescription = function() {
      var block, _i, _len, _ref3;
      _ref3 = this._description.getBlocks();
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        block = _ref3[_i];
        if (block instanceof MindMapNodeBlock) return true;
      }
      return false;
    };

    MindMapNode.prototype.setNumberedListValue = function(value, level) {
      return this._textNode.setNumberedListValue(value, level);
    };

    MindMapNode.prototype.insertVirtualDescription = function(blips) {
      var index;
      this._virtualDescription = new VirtualMindMapThread(this._mindmap, this, blips);
      index = this._parent.getNodeIndex(this);
      this._parent.insertVirtualDescriptionForParagraph(index);
      return this._virtualDescription.updatePosition();
    };

    MindMapNode.prototype.getVirtualDescription = function() {
      return this._virtualDescription;
    };

    MindMapNode.prototype.removeAllVirtualNodes = function() {
      var _ref3;
      if ((_ref3 = this._virtualDescription) != null) _ref3.destroy();
      return delete this._virtualDescription;
    };

    MindMapNode.prototype.insertBlipOpsAsDescription = function(ops) {
      return this._parent.insertBlipOpsAsDescription(this._id, ops);
    };

    MindMapNode.prototype.markSelected = function() {
      if (this._mindmap.isDragging()) return;
      this._selected = true;
      addClass(this._textContainer, 'selected');
      this._needsPositionUpdate = true;
      return this._parent.markSelectedParagraph(this._id);
    };

    MindMapNode.prototype.unmarkSelected = function() {
      if (!this._selected) return;
      removeClass(this._textContainer, 'selected');
      this._selected = false;
      this._needsPositionUpdate = true;
      return this._parent.unmarkSelectedParagraph(this._id);
    };

    MindMapNode.prototype.destroy = function() {
      var _ref3;
      this.unmarkSelected();
      this._destroyTextContainer();
      this._description.destroy();
      delete this._description;
      this.removeAllVirtualNodes();
      delete this._parent;
      return (_ref3 = this._container.parentNode) != null ? _ref3.removeChild(this._container) : void 0;
    };

    return MindMapNode;

  })();

  module.exports = {
    MindMapNode: MindMapNode
  };

}).call(this);

});

require.define("/lib/client/client/mindmap/nodeblock/real.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BLIP_BACKGROUND_OFFSET, BLIP_BACKGROUND_REMOVE_TIMEOUT, BLIP_DRAG_ZONE_HEIGHT, BLIP_DRAG_ZONE_WIDTH, History, LineLevelParams, MicroEvent, MindMapNodeBlock, MindMapNodeBlockBase, ModelField, ModelType, ParamsField, TEXT_NODE_HEIGHT, addClass, copy, copyNodeTextContent, getBlockType, getElement, getMindMapNode, removeClass, _ref, _ref2, _ref3,
    __slice = Array.prototype.slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  MindMapNodeBlockBase = require('./base').MindMapNodeBlockBase;

  _ref = require('../../editor/model'), ModelField = _ref.ModelField, ParamsField = _ref.ParamsField, ModelType = _ref.ModelType, LineLevelParams = _ref.LineLevelParams;

  MicroEvent = require('../../utils/microevent');

  History = require('../../utils/history_navigation');

  _ref2 = require('../utils'), getElement = _ref2.getElement, copy = _ref2.copy, copyNodeTextContent = _ref2.copyNodeTextContent, getBlockType = _ref2.getBlockType, removeClass = _ref2.removeClass, addClass = _ref2.addClass;

  _ref3 = require('../const'), TEXT_NODE_HEIGHT = _ref3.TEXT_NODE_HEIGHT, BLIP_DRAG_ZONE_WIDTH = _ref3.BLIP_DRAG_ZONE_WIDTH, BLIP_DRAG_ZONE_HEIGHT = _ref3.BLIP_DRAG_ZONE_HEIGHT, BLIP_BACKGROUND_OFFSET = _ref3.BLIP_BACKGROUND_OFFSET, BLIP_BACKGROUND_REMOVE_TIMEOUT = _ref3.BLIP_BACKGROUND_REMOVE_TIMEOUT;

  getMindMapNode = function() {
    var MindMapNode, args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    MindMapNode = require('../node').MindMapNode;
    getMindMapNode = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return typeof result === "object" ? result : child;
      })(MindMapNode, args, function() {});
    };
    return getMindMapNode.apply(null, args);
  };

  MindMapNodeBlock = (function(_super) {

    __extends(MindMapNodeBlock, _super);

    function MindMapNodeBlock(_mindmap, _parent, _blipViewModel, _containsHeader) {
      this._mindmap = _mindmap;
      this._parent = _parent;
      this._blipViewModel = _blipViewModel;
      this._containsHeader = _containsHeader;
      this._removeBackgroundBox = __bind(this._removeBackgroundBox, this);
      this._updateText = __bind(this._updateText, this);
      this._blipLoadCallbacks = {};
      this._waveViewModel = this._blipViewModel.getWaveViewModel();
      MindMapNodeBlock.__super__.constructor.call(this, this._mindmap, this._parent);
      this._blipViewModel.on('remote-ops', this._updateText);
      this._blipViewModel.on('undo-redo-ops', this._updateText);
      this._blipViewModel.getView().on('ops', this._updateText);
      if (!this._mindmap.isFirstRender()) this.animateBackground();
    }

    MindMapNodeBlock.prototype._createDOMNodes = function() {
      MindMapNodeBlock.__super__._createDOMNodes.call(this);
      if (!this.isRoot()) return this._createDragZone();
    };

    MindMapNodeBlock.prototype._createDragZone = function() {
      this._dragZone = getElement('image', {
        'width': BLIP_DRAG_ZONE_WIDTH,
        'height': BLIP_DRAG_ZONE_HEIGHT,
        'x': -BLIP_DRAG_ZONE_WIDTH,
        'class': 'blip-drag-zone'
      });
      this._dragZone.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '/s/img/mindmap/blip_drag_zone.png');
      this._dragZone.dragNode = this;
      return this._textContainer.appendChild(this._dragZone);
    };

    MindMapNodeBlock.prototype._updateDragZone = function() {
      if (!(this._dragZone != null)) return;
      return this._dragZone.setAttribute('y', this.getParagraphTextTop(0));
    };

    MindMapNodeBlock.prototype._createBlipSizeBox = function() {
      if (this.isRoot()) return;
      return MindMapNodeBlock.__super__._createBlipSizeBox.call(this);
    };

    MindMapNodeBlock.prototype.updatePosition = function() {
      var parent,
        _this = this;
      if (this._waveViewModel.getView().getCurView() !== 'mindmap') return;
      if (!this._needsPositionUpdate) return;
      if (this.isRoot()) {
        parent = this._container.parentNode;
        parent.removeChild(this._container);
      }
      MindMapNodeBlock.__super__.updatePosition.call(this);
      this._updateDragZone();
      this._updateBackgroundBoxPosition();
      if (this._blipViewModel.getView().isRead()) {
        removeClass(this._textContainer, 'unread');
      } else {
        addClass(this._textContainer, 'unread');
      }
      if (parent) {
        parent.appendChild(this._container);
        return window.setTimeout(function() {
          return _this.emit('size-updated');
        }, 0);
      }
    };

    MindMapNodeBlock.prototype.updatePositionFromRoot = function() {
      if (this.isRoot()) return this.updatePosition();
      return MindMapNodeBlock.__super__.updatePositionFromRoot.call(this);
    };

    MindMapNodeBlock.prototype.getChildNodeRealIndex = function(node) {
      var index, paragraph, virtualsBefore, _len, _ref4;
      virtualsBefore = 0;
      _ref4 = this._paragraphs;
      for (index = 0, _len = _ref4.length; index < _len; index++) {
        paragraph = _ref4[index];
        if (!paragraph.node) continue;
        if (paragraph.node === node) return index - virtualsBefore;
        if (!(paragraph.id != null)) virtualsBefore++;
      }
    };

    MindMapNodeBlock.prototype._getContent = function() {
      return this._blipViewModel.getModel().getSnapshotContent();
    };

    MindMapNodeBlock.prototype._getBlips = function(blipIds) {
      var blipId, descriptionBlip, res, _i, _len;
      res = [];
      for (_i = 0, _len = blipIds.length; _i < _len; _i++) {
        blipId = blipIds[_i];
        descriptionBlip = this._blipViewModel.getView().getChildBlipByServerId(blipId);
        if (descriptionBlip != null) {
          delete this._blipLoadCallbacks[blipId];
          res.push(descriptionBlip);
        } else {
          if (!this._blipLoadCallbacks[blipId]) {
            this._blipLoadCallbacks[blipId] = true;
            this._waveViewModel.onBlipLoaded(blipId, this._updateText);
          }
        }
      }
      return res;
    };

    MindMapNodeBlock.prototype._getTextBlocksFromText = function(text) {
      return [
        {
          t: ' ',
          params: {
            __TYPE: 'LINE'
          }
        }, {
          t: text,
          params: {
            __TYPE: 'TEXT'
          }
        }
      ];
    };

    MindMapNodeBlock.prototype._getParagraphNode = function(id, paragraphBlocks, blipIds) {
      var blips, descriptionBlips;
      descriptionBlips = [];
      blips = this._getBlips(blipIds);
      if (this.isRoot()) {
        paragraphBlocks = this._getTextBlocksFromText(blips[0].getModel().getTitle());
      }
      return getMindMapNode(this._mindmap, id, paragraphBlocks, this, blips);
    };

    MindMapNodeBlock.prototype._updateParagraphNode = function(node, paragraphBlocks, blipIds) {
      if (this.isRoot()) {
        paragraphBlocks = this._getTextBlocksFromText(blips[0].getModel().getTitle());
      }
      node.setTextBlocks(paragraphBlocks);
      return node.getDescription().updateBlips(this._getBlips(blipIds));
    };

    MindMapNodeBlock.prototype._updateText = function() {
      /*
              Реагирует на изменение текста блипа
      */
      var oldNodes;
      if (this._destroyed) return;
      oldNodes = this._getNodesByParagraphId();
      this._updateContent(oldNodes);
      this.recursivelyInvalidateAllCalculatedFields();
      return this.updatePositionFromRoot();
    };

    MindMapNodeBlock.prototype.switchToTextView = function(paragraphId) {
      var pos, waveView;
      pos = this._getParagraphPosition(paragraphId, false)[0];
      if (!(pos != null)) return;
      waveView = this._waveViewModel.getView();
      waveView.setTextView();
      this._blipViewModel.getView().getEditor().setCursorAtParagraph(pos + 1);
      return waveView.scrollIntoView();
    };

    MindMapNodeBlock.prototype.getBlipId = function() {
      return this._blipViewModel.getModel().serverId;
    };

    MindMapNodeBlock.prototype.foldAllRecursively = function() {
      MindMapNodeBlock.__super__.foldAllRecursively.call(this);
      if (this.isRoot()) return this.updatePosition();
    };

    MindMapNodeBlock.prototype.unfoldAllRecursively = function() {
      MindMapNodeBlock.__super__.unfoldAllRecursively.call(this);
      if (this.isRoot()) return this.updatePosition();
    };

    MindMapNodeBlock.prototype._getParagraphPosition = function(paragraphId, includeParagraph) {
      var block, index, paragraph, pos, _i, _len, _len2, _ref4, _ref5;
      if (includeParagraph == null) includeParagraph = false;
      pos = 0;
      _ref4 = this._paragraphs;
      for (index = 0, _len = _ref4.length; index < _len; index++) {
        paragraph = _ref4[index];
        if (paragraph.id === paragraphId) {
          if (!includeParagraph) return [pos, index];
        }
        _ref5 = paragraph.blocks;
        for (_i = 0, _len2 = _ref5.length; _i < _len2; _i++) {
          block = _ref5[_i];
          pos += block[ModelField.TEXT].length;
        }
        if (paragraph.id === paragraphId) return [pos, index];
      }
      return [null, null];
    };

    MindMapNodeBlock.prototype._applyOps = function(ops) {
      var blipView, _ref4;
      blipView = this._blipViewModel.getView();
      blipView.submitOps(ops);
      return (_ref4 = blipView.getEditor()) != null ? _ref4.applyOps(ops, false) : void 0;
    };

    MindMapNodeBlock.prototype._getBlockParamsChangeOps = function(p, len, fromParams, toParams) {
      /*
              Возвращает операции, необходимые для замены одних параметров другими
              @param pos: int
              @param len: int
              @param fromParams: {key: value}, исходные параметры
              @param toParams: {key: value}, конечные параметры
      */
      var name, paramsd, paramsi, res, value;
      res = [];
      for (name in toParams) {
        value = toParams[name];
        if (!LineLevelParams.isValid(name)) continue;
        if (value === fromParams[name]) continue;
        if (fromParams[name] != null) {
          paramsd = {};
          paramsd[name] = fromParams[name];
          res.push({
            p: p,
            len: len,
            paramsd: paramsd
          });
        }
        if (toParams[name] != null) {
          paramsi = {};
          paramsi[name] = value;
          res.push({
            p: p,
            len: len,
            paramsi: paramsi
          });
        }
      }
      for (name in fromParams) {
        value = fromParams[name];
        if (!LineLevelParams.isValid(name)) continue;
        if (name in toParams) continue;
        paramsd = {};
        paramsd[name] = value;
        res.push({
          p: p,
          len: len,
          paramsd: paramsd
        });
      }
      return res;
    };

    MindMapNodeBlock.prototype._getParagraphRemoveOps = function(index, pos) {
      /*
              Возвращает операции для удаления параграфа текста. Если удаляется первый параграф, то оставялет первый
              LINE-блок, вместо него удаляет LINE-блок следующего параграфа
              @param index: int, индекс удаляемого параграфа
              @param pos: int, количество символов до удаляемого параграфа
      */
      var block, firstBlockChangeOps, nextLineBlock, ops, removedBlocks, _i, _len;
      if (index === 0 && this._paragraphs.length === 1) {
        throw new Error("Cannot remove single first paragraph");
      }
      ops = [];
      if (index === 0) {
        removedBlocks = this._paragraphs[index].blocks.slice(1);
        pos += 1;
      } else {
        removedBlocks = this._paragraphs[index].blocks;
      }
      for (_i = 0, _len = removedBlocks.length; _i < _len; _i++) {
        block = removedBlocks[_i];
        ops.push({
          td: block[ModelField.TEXT],
          p: pos,
          params: copy(block.params)
        });
      }
      if (index === 0) {
        nextLineBlock = this._paragraphs[index + 1].blocks[0];
        ops.push({
          td: nextLineBlock[ModelField.TEXT],
          p: 1,
          params: copy(nextLineBlock.params)
        });
        firstBlockChangeOps = this._getBlockParamsChangeOps(0, 1, this._paragraphs[0].blocks[0].params, nextLineBlock.params);
        ops = ops.concat(firstBlockChangeOps);
      }
      return ops;
    };

    MindMapNodeBlock.prototype.removeSnapshotParagraphBlocks = function(paragraphId) {
      var index, pos, _ref4;
      _ref4 = this._getParagraphPosition(paragraphId), pos = _ref4[0], index = _ref4[1];
      if (!(index != null)) {
        console.warn("Mindmap tried to delete paragraph " + paragraphId + " from blip " + (this.getBlipId()) + ", but it is not present");
        return;
      }
      if (this._paragraphs.length === 1) {
        return this._parent.removeChildBlipFromSnapshot(this.getBlipId());
      } else {
        return this._applyOps(this._getParagraphRemoveOps(index, pos));
      }
    };

    MindMapNodeBlock.prototype._getBlipBlock = function(blipId) {
      /*
              Возвращает позицию и блок с указанным блипом
              @param blipId: string
              @return: [pos, blipBlock]
      */
      var block, index, paragraph, pos, _i, _len, _len2, _ref4, _ref5;
      pos = 0;
      _ref4 = this._paragraphs;
      for (index = 0, _len = _ref4.length; index < _len; index++) {
        paragraph = _ref4[index];
        _ref5 = paragraph.blocks;
        for (_i = 0, _len2 = _ref5.length; _i < _len2; _i++) {
          block = _ref5[_i];
          if (this._isBlipBlock(block) && block[ModelField.PARAMS][ParamsField.ID] === blipId) {
            return [pos, block];
          }
          pos += block[ModelField.TEXT].length;
        }
      }
      return [null, null];
    };

    MindMapNodeBlock.prototype.removeSnapshotBlip = function(blipId) {
      var blipBlock, op, pos, _ref4;
      _ref4 = this._getBlipBlock(blipId), pos = _ref4[0], blipBlock = _ref4[1];
      if (!(pos != null)) {
        console.warn("Mindmap tried to delete child blip " + blipId + " from blip " + (this.getBlipId()) + ", but it is not present");
        return;
      }
      op = {
        p: pos,
        td: blipBlock.t,
        params: copy(blipBlock.params)
      };
      return this._applyOps([op]);
    };

    MindMapNodeBlock.prototype._getParagraphThreadRemoveOps = function(index, pos) {
      /*
              Возвращает операции для удаления треда указанного параграфа.
              @param index: int, индекс удаляемого параграфа
              @param pos: int, количество символов до удаляемого параграфа
      */
      var block, lastBlockGroupOps, lastBlockGroupPos, lastPos, type, _i, _len, _ref4;
      lastBlockGroupOps = [];
      lastPos = lastBlockGroupPos = pos;
      _ref4 = this._paragraphs[index].blocks;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        block = _ref4[_i];
        type = getBlockType(block);
        lastPos += block[ModelField.TEXT].length;
        if (type === ModelType.BLIP) {
          lastBlockGroupOps.push({
            td: block[ModelField.TEXT],
            p: lastBlockGroupPos,
            params: copy(block.params)
          });
        } else {
          lastBlockGroupOps = [];
          lastBlockGroupPos = lastPos;
        }
      }
      return lastBlockGroupOps;
    };

    MindMapNodeBlock.prototype.removeSnapshotParagraphThread = function(paragraphId) {
      var index, pos, _ref4;
      _ref4 = this._getParagraphPosition(paragraphId), pos = _ref4[0], index = _ref4[1];
      if (!(index != null)) {
        console.warn("Mindmap tried to delete thread from paragraph " + paragraphId + " from blip " + (this.getBlipId()) + ", but paragraph is not present");
        return;
      }
      return this._applyOps(this._getParagraphThreadRemoveOps(index, pos));
    };

    MindMapNodeBlock.prototype._getBlockInsertionOp = function(block, node) {
      var blipId, params, type;
      type = getBlockType(block);
      params = copy(block[ModelField.PARAMS]);
      if (type !== ModelType.BLIP) {
        return {
          ti: block.t,
          params: params
        };
      }
      blipId = block[ModelField.PARAMS][ParamsField.ID];
      return this._blipViewModel.getView().getBlipCopyOpByServerId(blipId);
    };

    MindMapNodeBlock.prototype._getParagraphInsertionOps = function(paragraph) {
      var block, op, res, _i, _len, _ref4;
      res = [];
      _ref4 = paragraph.blocks;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        block = _ref4[_i];
        op = this._getBlockInsertionOp(block, paragraph.node);
        if (op) res.push(op);
      }
      return res;
    };

    MindMapNodeBlock.prototype._getContentInsertionOps = function() {
      var paragraph, res, _i, _len, _ref4;
      res = [];
      _ref4 = this._paragraphs;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        paragraph = _ref4[_i];
        res = res.concat(this._getParagraphInsertionOps(paragraph));
      }
      return res;
    };

    MindMapNodeBlock.prototype.getCopyOp = function() {
      var blipParams, model, ops, params;
      ops = this._getContentInsertionOps();
      model = this._blipViewModel.getModel();
      blipParams = {
        isFoldedByDefault: model.isFoldedByDefault(),
        contributors: model.getContributors(),
        sourceBlipId: model.getServerId()
      };
      params = {};
      params[ParamsField.TYPE] = ModelType.BLIP;
      return {
        ti: ' ',
        params: params,
        ops: ops,
        blipParams: blipParams
      };
    };

    MindMapNodeBlock.prototype.getCopyOps = function() {
      return [this.getCopyOp()];
    };

    MindMapNodeBlock.prototype.getTextBlocks = function() {
      return this._getContent();
    };

    MindMapNodeBlock.prototype.removeFromSnapshot = function() {
      return this._blipViewModel.getView().remove();
    };

    MindMapNodeBlock.prototype.insertSnapshotParagraphOpsAt = function(index, ops) {
      var blipView, paragraphId, pos;
      if (index > 0) {
        paragraphId = this._paragraphs[index - 1].id;
        pos = this._getParagraphPosition(paragraphId, true)[0];
      } else {
        pos = 0;
      }
      blipView = this._blipViewModel.getView();
      blipView.renderRecursivelyToRoot();
      return blipView.getEditor().pasteOpsAtPosition(pos, ops);
    };

    MindMapNodeBlock.prototype.insertBlipOpsAsDescription = function(paragraphId, ops) {
      var blipView, pos;
      pos = this._getParagraphPosition(paragraphId, true)[0];
      if (!(pos != null)) return;
      blipView = this._blipViewModel.getView();
      blipView.renderRecursivelyToRoot();
      return blipView.getEditor().pasteOpsAtPosition(pos, ops);
    };

    MindMapNodeBlock.prototype._insertSnapshotBlipOpInBlipAfter = function(block, op) {
      var blipContainer, blipView;
      blipContainer = block.getBlipViewModel().getView().getContainer();
      blipView = this._blipViewModel.getView();
      blipView.renderRecursivelyToRoot();
      return blipView.getEditor().pasteBlipOpAfter(blipContainer, op);
    };

    MindMapNodeBlock.prototype.insertSnapshotBlipOpsInBlipAfter = function(block, ops) {
      var i, _results;
      i = ops.length - 1;
      _results = [];
      while (i >= 0) {
        this._insertSnapshotBlipOpInBlipAfter(block, ops[i]);
        _results.push(i--);
      }
      return _results;
    };

    MindMapNodeBlock.prototype._insertSnapshotBlipOpInBlipBefore = function(block, op) {
      var blipContainer, blipView;
      blipContainer = block.getBlipViewModel().getView().getContainer();
      blipView = this._blipViewModel.getView();
      blipView.renderRecursivelyToRoot();
      return blipView.getEditor().pasteBlipOpBefore(blipContainer, op);
    };

    MindMapNodeBlock.prototype.insertSnapshotBlipOpsInBlipBefore = function(block, ops) {
      var op, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = ops.length; _i < _len; _i++) {
        op = ops[_i];
        _results.push(this._insertSnapshotBlipOpInBlipBefore(block, op));
      }
      return _results;
    };

    MindMapNodeBlock.prototype.getSnapshotParagraphInsertOps = function(paragraphId) {
      /*
              Возвращает операции вставки параграфа и всех его тредов в формате text/rizzoma (см. текстовый редактор)
              @param paragraphId: string
      */
      var index, pos, _ref4;
      _ref4 = this._getParagraphPosition(paragraphId, false), pos = _ref4[0], index = _ref4[1];
      if (!(index != null)) return null;
      return this._getParagraphInsertionOps(this._paragraphs[index]);
    };

    MindMapNodeBlock.prototype.getBlipViewModel = function() {
      return this._blipViewModel;
    };

    MindMapNodeBlock.prototype.insertVirtualParagraphAt = function(index, textBlocks) {
      var virtualPara;
      virtualPara = {
        blocks: textBlocks,
        node: getMindMapNode(this._mindmap, null, textBlocks, this, [])
      };
      this._paragraphs.splice(index, 0, virtualPara);
      this._container.appendChild(virtualPara.node.getContainer());
      return this.recursivelyInvalidateAllCalculatedFields();
    };

    MindMapNodeBlock.prototype.removeAllVirtualNodes = function() {
      var newParagraphs, paragraph, _i, _len, _ref4;
      newParagraphs = [];
      _ref4 = this._paragraphs;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        paragraph = _ref4[_i];
        if (paragraph.id != null) {
          newParagraphs.push(paragraph);
        } else {
          paragraph.node.destroy();
        }
      }
      this._paragraphs = newParagraphs;
      this.recursivelyInvalidateAllCalculatedFields();
      return this.updatePositionFromRoot();
    };

    MindMapNodeBlock.prototype._canUseParagraphNode = function(node) {
      return (node != null) && !node.isVirtual();
    };

    MindMapNodeBlock.prototype.insertVirtualDescriptionForParagraph = function(index) {
      var container;
      container = this._paragraphs[index].node.getVirtualDescription().getContainer();
      container.setAttribute('transform', "translate(0," + (this.getParagraphDescriptionTop(index)) + ")");
      return this._descriptionContainer.appendChild(container);
    };

    MindMapNodeBlock.prototype._shouldUseParagraph = function(index) {
      if (index) return true;
      return !this._containsHeader;
    };

    MindMapNodeBlock.prototype.animateBackground = function() {
      this._removeBackgroundBox();
      this._createBackgroundBox();
      this._updateBackgroundBoxPosition();
      return this._backgroundBoxRemoveHandler = setTimeout(this._removeBackgroundBox, BLIP_BACKGROUND_REMOVE_TIMEOUT);
    };

    MindMapNodeBlock.prototype._createBackgroundBox = function() {
      this._backgroundBox = getElement('rect', {
        'class': 'blip-background-box'
      });
      return this._textContainer.insertBefore(this._backgroundBox, this._blipSizeBox);
    };

    MindMapNodeBlock.prototype._updateBackgroundBoxPosition = function() {
      var bottom, top;
      if (!(this._backgroundBox != null)) return;
      top = this.getParagraphTextTop(0) - BLIP_BACKGROUND_OFFSET;
      bottom = this.getParagraphTextBottom(this._paragraphs.length - 1) + BLIP_BACKGROUND_OFFSET;
      this._backgroundBox.setAttribute('x', -BLIP_BACKGROUND_OFFSET);
      this._backgroundBox.setAttribute('y', top);
      this._backgroundBox.setAttribute('width', this.getThreadTextWidth() + 2 * BLIP_BACKGROUND_OFFSET);
      return this._backgroundBox.setAttribute('height', bottom - top);
    };

    MindMapNodeBlock.prototype._removeBackgroundBox = function() {
      var _ref4, _ref5;
      if ((_ref4 = this._backgroundBox) != null) {
        if ((_ref5 = _ref4.parentNode) != null) {
          _ref5.removeChild(this._backgroundBox);
        }
      }
      delete this._backgroundBox;
      return clearTimeout(this._backgroundBoxRemoveHandler);
    };

    MindMapNodeBlock.prototype._getParagraphIndex = function(paragraphId) {
      var index, paragraph, _len, _ref4;
      _ref4 = this._paragraphs;
      for (index = 0, _len = _ref4.length; index < _len; index++) {
        paragraph = _ref4[index];
        if (paragraph.id === paragraphId) return index;
      }
    };

    MindMapNodeBlock.prototype.markSelectedParagraph = function(paragraphId) {
      this._selectedParagraphIndex = this._getParagraphIndex(paragraphId);
      this._needsPositionUpdate = true;
      if (this.isRoot()) {
        return this.updatePosition();
      } else {
        return this._parent.markSelectedBlock(this);
      }
    };

    MindMapNodeBlock.prototype.getSelectedParagraphIndex = function() {
      return this._selectedParagraphIndex;
    };

    MindMapNodeBlock.prototype.unmarkSelectedParagraph = function() {
      this._selectedParagraphIndex = null;
      this._needsPositionUpdate = true;
      if (this.isRoot()) {
        return this.updatePosition();
      } else {
        return this._parent.unmarkSelectedBlock();
      }
    };

    MindMapNodeBlock.prototype.destroy = function() {
      this.removeListeners('size-updated');
      this._blipViewModel.removeListener('remote-ops', this._updateText);
      this._blipViewModel.getView().removeListener('ops', this._updateText);
      this._removeBackgroundBox();
      MindMapNodeBlock.__super__.destroy.call(this);
      return delete this._waveViewModel;
    };

    return MindMapNodeBlock;

  })(MindMapNodeBlockBase);

  MicroEvent.mixin(MindMapNodeBlock);

  module.exports = {
    MindMapNodeBlock: MindMapNodeBlock
  };

}).call(this);

});

require.define("/lib/client/client/mindmap/nodeblock/base.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BLIP_SPACE, DESCRIPTION_LEFT_OFFSET, FOLD_BUTTON_LEFT_PADDING, FOLD_BUTTON_WIDTH, HEADER_OFFSET_X, HEADER_OFFSET_Y, LineLevelParams, MINIMAL_THREAD_WIDTH, MindMapNodeBlockBase, ModelField, ModelType, ParamsField, ROOT_BLOCK_OFFSET_X, ROOT_BLOCK_OFFSET_Y, TEXT_NODE_HEIGHT, TEXT_NODE_PADDING_LEFT, getBlockType, getElement, _ref, _ref2, _ref3;

  _ref = require('../../editor/model'), ModelField = _ref.ModelField, ParamsField = _ref.ParamsField, ModelType = _ref.ModelType, LineLevelParams = _ref.LineLevelParams;

  _ref2 = require('../utils'), getElement = _ref2.getElement, getBlockType = _ref2.getBlockType;

  _ref3 = require('../const'), TEXT_NODE_HEIGHT = _ref3.TEXT_NODE_HEIGHT, TEXT_NODE_PADDING_LEFT = _ref3.TEXT_NODE_PADDING_LEFT, BLIP_SPACE = _ref3.BLIP_SPACE, DESCRIPTION_LEFT_OFFSET = _ref3.DESCRIPTION_LEFT_OFFSET, MINIMAL_THREAD_WIDTH = _ref3.MINIMAL_THREAD_WIDTH, ROOT_BLOCK_OFFSET_X = _ref3.ROOT_BLOCK_OFFSET_X, ROOT_BLOCK_OFFSET_Y = _ref3.ROOT_BLOCK_OFFSET_Y, FOLD_BUTTON_WIDTH = _ref3.FOLD_BUTTON_WIDTH, FOLD_BUTTON_LEFT_PADDING = _ref3.FOLD_BUTTON_LEFT_PADDING, HEADER_OFFSET_X = _ref3.HEADER_OFFSET_X, HEADER_OFFSET_Y = _ref3.HEADER_OFFSET_Y;

  MindMapNodeBlockBase = (function() {

    function MindMapNodeBlockBase(_mindmap, _parent) {
      this._mindmap = _mindmap;
      this._parent = _parent;
      this._isRoot = !(this._parent != null);
      this._createDOMNodes();
      this._updateContent({});
      this._needsPositionUpdate = true;
    }

    MindMapNodeBlockBase.prototype.getParent = function() {
      return this._parent;
    };

    MindMapNodeBlockBase.prototype._createDOMNodes = function() {
      /*
              Создает ноды, необходимые для отображения блипа
      */      this._container = getElement('g', {
        "class": 'blip-container'
      });
      this._textContainer = getElement('g', {
        "class": 'blip-text-container'
      });
      this._container.appendChild(this._textContainer);
      this._createBlipSizeBox();
      this._descriptionContainer = getElement('g');
      if (!(this._parent != null)) {
        return this._container.appendChild(this._descriptionContainer);
      }
    };

    MindMapNodeBlockBase.prototype.getContainer = function() {
      return this._container;
    };

    MindMapNodeBlockBase.prototype.getTextContainer = function() {
      return this._textContainer;
    };

    MindMapNodeBlockBase.prototype.getDescriptionContainer = function() {
      return this._descriptionContainer;
    };

    MindMapNodeBlockBase.prototype._createBlipSizeBox = function() {
      /*
              Создает подложку, обозначающую границы блипа
      */      this._blipSizeBox = getElement('rect', {
        'class': 'blip-size-box'
      });
      return this._textContainer.appendChild(this._blipSizeBox);
    };

    MindMapNodeBlockBase.prototype._updateBlipSizeBoxPosition = function() {
      var bottom, top;
      if (!(this._blipSizeBox != null)) return;
      top = this.getParagraphTextTop(0);
      bottom = this.getParagraphTextBottom(this._paragraphs.length - 1);
      this._blipSizeBox.setAttribute('y', top);
      this._blipSizeBox.setAttribute('width', this.getThreadTextWidth());
      return this._blipSizeBox.setAttribute('height', bottom - top);
    };

    MindMapNodeBlockBase.prototype.getNodeIndex = function(node) {
      var index, paragraph, _len, _ref4;
      _ref4 = this._paragraphs;
      for (index = 0, _len = _ref4.length; index < _len; index++) {
        paragraph = _ref4[index];
        if (paragraph.node === node) return index;
      }
      return null;
    };

    MindMapNodeBlockBase.prototype.getParagraphTextTop = function(index) {
      var res;
      if (!(this._paragraphs[index].textTop != null)) {
        if (index === 0) {
          if (this.isRoot()) {
            this._paragraphs[index].textTop = HEADER_OFFSET_Y;
          } else {
            this._paragraphs[index].textTop = 0;
          }
        } else {
          res = this.getParagraphTextBottom(index - 1);
          this._paragraphs[index].textTop = res;
        }
      }
      return this._paragraphs[index].textTop;
    };

    MindMapNodeBlockBase.prototype.getParagraphTextBottom = function(index) {
      var res;
      if (!(this._paragraphs[index].textBottom != null)) {
        res = this.getParagraphTextTop(index);
        if (this._paragraphs[index].node != null) res += TEXT_NODE_HEIGHT;
        this._paragraphs[index].textBottom = res;
      }
      return this._paragraphs[index].textBottom;
    };

    MindMapNodeBlockBase.prototype.getParagraphTextMid = function(index) {
      var bot, top;
      top = this.getParagraphTextTop(index);
      bot = Math.max(top, this.getParagraphTextBottom(index));
      return (top + bot) / 2;
    };

    MindMapNodeBlockBase.prototype._getShiftedParagraphDescriptionTop = function(index) {
      var res, _ref4;
      if (this.isRoot()) return ROOT_BLOCK_OFFSET_Y;
      if (index === 0) return 0;
      if (!(this._paragraphs[index].descriptionTop != null)) {
        res = this.getParagraphDescriptionBottom(index - 1);
        if ((_ref4 = this._paragraphs[index].node) != null ? _ref4.getDescriptionHeight() : void 0) {
          res += BLIP_SPACE;
        }
        this._paragraphs[index].descriptionTop = res;
      }
      return this._paragraphs[index].descriptionTop;
    };

    MindMapNodeBlockBase.prototype.getParagraphDescriptionTop = function(index) {
      return Math.max(this._getShiftedParagraphDescriptionTop(index), 0);
    };

    MindMapNodeBlockBase.prototype.getParagraphDescriptionBottom = function(index) {
      var res, _ref4;
      if (!(this._paragraphs[index].descriptionBottom != null)) {
        res = this._getShiftedParagraphDescriptionTop(index);
        if ((_ref4 = this._paragraphs[index].node) != null ? _ref4.getDescriptionHeight() : void 0) {
          res += this._paragraphs[index].node.getDescriptionHeight();
        } else if (index === 0) {
          res -= BLIP_SPACE;
        }
        this._paragraphs[index].descriptionBottom = res;
      }
      return this._paragraphs[index].descriptionBottom;
    };

    MindMapNodeBlockBase.prototype.getBlockDescriptionTop = function() {
      var index;
      if (!(this._parent != null)) return 0;
      index = this._parent.getBlockIndex(this);
      return this._parent.getBlockDescriptionTop(index);
    };

    MindMapNodeBlockBase.prototype.getBlockTop = function() {
      var index;
      if (!(this._parent != null)) return 0;
      index = this._parent.getBlockIndex(this);
      return this._parent.getBlockTop(index);
    };

    MindMapNodeBlockBase.prototype._getTextLeft = function() {
      if (this.isRoot()) {
        return HEADER_OFFSET_X;
      } else {
        return 0;
      }
    };

    MindMapNodeBlockBase.prototype.getDescriptionTop = function() {
      if (this.isRoot()) {
        return ROOT_BLOCK_OFFSET_Y;
      } else {
        return 0;
      }
    };

    MindMapNodeBlockBase.prototype.getDescriptionLeft = function() {
      if (this.isRoot()) {
        return ROOT_BLOCK_OFFSET_X;
      } else {
        return this.getThreadTextWidth() + DESCRIPTION_LEFT_OFFSET;
      }
    };

    MindMapNodeBlockBase.prototype.updatePosition = function() {
      var index, paragraph, textLeft, textTop, _len, _ref4;
      if (!this._needsPositionUpdate) return;
      textLeft = this._getTextLeft();
      _ref4 = this._paragraphs;
      for (index = 0, _len = _ref4.length; index < _len; index++) {
        paragraph = _ref4[index];
        if (!paragraph.node) continue;
        paragraph.node.updatePosition();
        textTop = this.getParagraphTextTop(index);
        paragraph.node.getContainer().setAttribute('transform', "translate(" + textLeft + "," + textTop + ")");
        paragraph.node.getDescription().getContainer().setAttribute('transform', "translate(0," + (this.getParagraphDescriptionTop(index)) + ")");
      }
      this._descriptionContainer.setAttribute('transform', "translate(" + (this.getDescriptionLeft()) + "," + (this.getDescriptionTop()) + ")");
      this._updateBlipSizeBoxPosition();
      return this._needsPositionUpdate = false;
    };

    MindMapNodeBlockBase.prototype.updatePositionFromRoot = function() {
      return this._parent.updatePositionFromRoot();
    };

    MindMapNodeBlockBase.prototype.getChildNodePos = function(node) {
      var count, foundNode, index, paragraph, pos, _len, _ref4;
      count = 0;
      pos = 0;
      foundNode = false;
      _ref4 = this._paragraphs;
      for (index = 0, _len = _ref4.length; index < _len; index++) {
        paragraph = _ref4[index];
        if (!paragraph.node) continue;
        count++;
        if (paragraph.node === node) foundNode = true;
        if (!foundNode) pos++;
      }
      return [pos, count];
    };

    MindMapNodeBlockBase.prototype.hasSingleChildNode = function() {
      var nodeCount, paragraph, _i, _len, _ref4;
      nodeCount = 0;
      _ref4 = this._paragraphs;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        paragraph = _ref4[_i];
        if (!paragraph.node) continue;
        nodeCount++;
        if (nodeCount > 1) return false;
      }
      return true;
    };

    MindMapNodeBlockBase.prototype._parseParagraphs = function() {
      /*
              Разбирает содержимое блипа на параграфы
              @return: [{blocks: [block], id}]
      */
      var block, content, curParagraph, paragraphs, _i, _len;
      content = this._getContent();
      paragraphs = [];
      curParagraph = null;
      for (_i = 0, _len = content.length; _i < _len; _i++) {
        block = content[_i];
        if (getBlockType(block) === ModelType.LINE) {
          if (curParagraph) paragraphs.push(curParagraph);
          curParagraph = {
            blocks: []
          };
          curParagraph.id = block[ModelField.PARAMS][ParamsField.RANDOM];
        }
        curParagraph.blocks.push(block);
      }
      paragraphs.push(curParagraph);
      return paragraphs;
    };

    MindMapNodeBlockBase.prototype._getNodesByParagraphId = function() {
      var paragraph, res, _i, _len, _ref4;
      res = {};
      _ref4 = this._paragraphs;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        paragraph = _ref4[_i];
        if (paragraph.node != null) {
          if (paragraph.node.isVirtual()) {
            paragraph.node.destroy();
          } else {
            res[paragraph.id] = paragraph.node;
          }
        }
      }
      return res;
    };

    MindMapNodeBlockBase.prototype.forceChildrenUpdateNeed = function() {
      /*
              Заставляет обновиться блип и все дочерние параграфы. Используется при изменении ширины треда.
      */
      var paragraph, _i, _len, _ref4, _ref5, _results;
      this._needsPositionUpdate = true;
      _ref4 = this._paragraphs;
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        paragraph = _ref4[_i];
        if (!(paragraph.node != null)) continue;
        paragraph.node.forceUpdateNeed();
        _results.push((_ref5 = paragraph.node) != null ? _ref5.getDescription().forceUpdateNeed() : void 0);
      }
      return _results;
    };

    MindMapNodeBlockBase.prototype._invalidateHeightCalculatedFields = function() {
      var paragraph, _i, _len, _ref4, _ref5, _results;
      this._needsPositionUpdate = true;
      _ref4 = this._paragraphs;
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        paragraph = _ref4[_i];
        paragraph.textTop = null;
        paragraph.textBottom = null;
        paragraph.descriptionTop = null;
        paragraph.descriptionBottom = null;
        _results.push((_ref5 = paragraph.node) != null ? _ref5.getDescription().forceUpdateNeed() : void 0);
      }
      return _results;
    };

    MindMapNodeBlockBase.prototype._invalidateAllCalculatedFields = function() {
      this._invalidateHeightCalculatedFields();
      return this._invalidateTextWidth();
    };

    MindMapNodeBlockBase.prototype.recursivelyInvalidateAllCalculatedFields = function() {
      /*
              Сбрасывает закешированные вычисленные значения
      */
      var _ref4;
      this._invalidateAllCalculatedFields();
      return (_ref4 = this._parent) != null ? _ref4.recursivelyInvalidateAllCalculatedFields() : void 0;
    };

    MindMapNodeBlockBase.prototype.invalidateIncludingChildren = function() {
      var paragraph, _i, _len, _ref4, _results;
      this._invalidateAllCalculatedFields();
      _ref4 = this._paragraphs;
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        paragraph = _ref4[_i];
        if (paragraph.node != null) {
          _results.push(paragraph.node.invalidateIncludingChildren());
        }
      }
      return _results;
    };

    MindMapNodeBlockBase.prototype._getBlipThreadId = function(blipBlock) {
      return blipBlock[ModelField.PARAMS][ParamsField.THREAD_ID] || blipBlock[ModelField.PARAMS][ParamsField.ID];
    };

    MindMapNodeBlockBase.prototype._isBlipBlock = function(block) {
      return getBlockType(block) === ModelType.BLIP;
    };

    MindMapNodeBlockBase.prototype._getParagraphDescriptionBlipIds = function(paragraph) {
      /*
              Thread, находящийся в самом конце параграфа
              @param paragraph: [block]
              @return: [threadId] | null
      */
      var curBlock, curBlockIndex, lastBlock, res, threadId;
      curBlockIndex = paragraph.blocks.length - 1;
      while (curBlockIndex >= 0) {
        lastBlock = paragraph.blocks[curBlockIndex];
        if (this._isBlipBlock(lastBlock)) break;
        if (!this._isEmptyTextBlock(lastBlock)) break;
        curBlockIndex--;
      }
      if (curBlockIndex < 0 || !this._isBlipBlock(lastBlock)) return [];
      threadId = this._getBlipThreadId(lastBlock);
      res = [];
      while (curBlockIndex >= 0) {
        curBlock = paragraph.blocks[curBlockIndex];
        if (this._getBlipThreadId(curBlock) !== threadId) break;
        res.push(curBlock[ModelField.PARAMS][ParamsField.ID]);
        curBlockIndex--;
      }
      res.reverse();
      return res;
    };

    MindMapNodeBlockBase.prototype._updateParagraphContent = function(paragraph, oldNodes, numberedListCounter) {
      var deleteStart, descriptionThreadBlipIds, newValue, node, numberLevel;
      descriptionThreadBlipIds = this._getParagraphDescriptionBlipIds(paragraph);
      if (paragraph.id in oldNodes) {
        node = oldNodes[paragraph.id];
        this._updateParagraphNode(node, paragraph.blocks, descriptionThreadBlipIds);
        delete oldNodes[paragraph.id];
      } else {
        node = this._getParagraphNode(paragraph.id, paragraph.blocks, descriptionThreadBlipIds);
        this._textContainer.appendChild(node.getContainer());
        this._descriptionContainer.insertBefore(node.getDescription().getContainer(), this._descriptionContainer.firstChild);
      }
      if (!node.isVirtual()) {
        numberLevel = paragraph.blocks[0][ModelField.PARAMS][LineLevelParams.NUMBERED];
        deleteStart = numberLevel != null ? numberLevel + 1 : 0;
        numberedListCounter.splice(deleteStart, numberedListCounter.length);
        if (numberLevel != null) {
          if (numberedListCounter[numberLevel] != null) {
            newValue = numberedListCounter[numberLevel] + 1;
          } else {
            newValue = 1;
          }
          numberedListCounter[numberLevel] = newValue;
          node.setNumberedListValue(newValue, numberLevel);
        }
      }
      return paragraph.node = node;
    };

    MindMapNodeBlockBase.prototype._isEmptyTextBlock = function(block) {
      return getBlockType(block) === ModelType.TEXT && block[ModelField.TEXT].match(/^\s*$/);
    };

    MindMapNodeBlockBase.prototype._paragraphIsEmpty = function(paragraph) {
      var block, index, _len, _ref4;
      _ref4 = paragraph.blocks;
      for (index = 0, _len = _ref4.length; index < _len; index++) {
        block = _ref4[index];
        if (index === 0) {
          if (block[ModelField.PARAMS][LineLevelParams.BULLETED] != null) {
            return false;
          }
          if (block[ModelField.PARAMS][LineLevelParams.NUMBERED] != null) {
            return false;
          }
          continue;
        }
        if (index === 0) continue;
        if (getBlockType(block) !== ModelType.TEXT) return false;
        if (!this._isEmptyTextBlock(block)) return false;
      }
      return true;
    };

    MindMapNodeBlockBase.prototype._shouldUseParagraph = function(index) {
      return true;
    };

    MindMapNodeBlockBase.prototype._updateContent = function(oldNodes) {
      /*
              Парсит и обновляет параграфы блипа
              @param oldNodes: {paragraphId: paragraph}, старые ноды, используются при обновлении
              @param reder: boolean, нужно ли рендерить создаваемые ноды
      */
      var hasNodes, index, node, nodeId, numberedListCounter, paragraph, _len, _ref4, _results;
      this._paragraphs = this._parseParagraphs();
      hasNodes = false;
      numberedListCounter = [];
      _ref4 = this._paragraphs;
      for (index = 0, _len = _ref4.length; index < _len; index++) {
        paragraph = _ref4[index];
        if (!this._shouldUseParagraph(index)) continue;
        if (this._paragraphIsEmpty(paragraph)) {
          numberedListCounter = [];
          continue;
        }
        hasNodes = true;
        this._updateParagraphContent(paragraph, oldNodes, numberedListCounter);
      }
      if (!hasNodes) {
        this._updateParagraphContent(this._paragraphs[0], oldNodes, numberedListCounter);
      }
      _results = [];
      for (nodeId in oldNodes) {
        node = oldNodes[nodeId];
        _results.push(node.destroy());
      }
      return _results;
    };

    MindMapNodeBlockBase.prototype.foldAllRecursively = function() {
      var paragraph, _i, _len, _ref4, _results;
      this._invalidateHeightCalculatedFields();
      _ref4 = this._paragraphs;
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        paragraph = _ref4[_i];
        if (paragraph.node != null) {
          _results.push(paragraph.node.foldAllRecursively());
        }
      }
      return _results;
    };

    MindMapNodeBlockBase.prototype.unfoldAllRecursively = function() {
      var paragraph, _i, _len, _ref4, _results;
      this._invalidateHeightCalculatedFields();
      _ref4 = this._paragraphs;
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        paragraph = _ref4[_i];
        if (paragraph.node != null) {
          _results.push(paragraph.node.unfoldAllRecursively());
        }
      }
      return _results;
    };

    MindMapNodeBlockBase.prototype._invalidateTextWidth = function() {
      var paragraph, _i, _len, _ref4, _results;
      this._textWidth = null;
      _ref4 = this._paragraphs;
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        paragraph = _ref4[_i];
        if (paragraph.node != null) {
          _results.push(paragraph.node.forceUpdateNeed());
        }
      }
      return _results;
    };

    MindMapNodeBlockBase.prototype.hasMaxWidth = function() {
      /*
              Возвращает true, если хотя бы один из параграфов имеет максимальную ширину
      */
      var paragraph, _i, _len, _ref4;
      _ref4 = this._paragraphs;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        paragraph = _ref4[_i];
        if (paragraph.node != null) if (paragraph.node.isOfMaxWidth()) return true;
      }
    };

    MindMapNodeBlockBase.prototype.getTextWidth = function() {
      /*
              Возвращает ширину текста, выделяемую для всех нод этого блока
              @return: float
      */
      var paragraph, _i, _len, _ref4;
      if (!(this._textWidth != null)) {
        this._textWidth = MINIMAL_THREAD_WIDTH;
        _ref4 = this._paragraphs;
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          paragraph = _ref4[_i];
          if (paragraph.node != null) {
            this._textWidth = Math.max(this._textWidth, paragraph.node.getTextWidth());
          }
        }
        this._textWidth += 2 * TEXT_NODE_PADDING_LEFT;
      }
      return this._textWidth;
    };

    MindMapNodeBlockBase.prototype.getThreadTextWidth = function() {
      if (!(this._parent != null)) return this.getTextWidth();
      return this._parent.getTextWidth();
    };

    MindMapNodeBlockBase.prototype._getParagraphIndexWithDescrtiptionAtYCoord = function(y) {
      var index, lastIndex, paragraph, _len, _ref4;
      if (y < this.getParagraphDescriptionTop(0)) return 0;
      lastIndex = null;
      _ref4 = this._paragraphs;
      for (index = 0, _len = _ref4.length; index < _len; index++) {
        paragraph = _ref4[index];
        if (!(paragraph.node != null)) continue;
        if ((this.getParagraphDescriptionTop(index) <= y && y <= this.getParagraphDescriptionBottom(index))) {
          return index;
        }
        lastIndex = index;
      }
      return lastIndex;
    };

    MindMapNodeBlockBase.prototype._canUseParagraphNode = function(node) {
      return node != null;
    };

    MindMapNodeBlockBase.prototype._getNodeAtTextZoneToTheTopOfCoords = function(y) {
      var index, nodeIndex, paragraph, _len, _ref4;
      if (this.isRoot()) return null;
      if (y < this.getParagraphTextMid(0)) return null;
      nodeIndex = null;
      _ref4 = this._paragraphs;
      for (index = 0, _len = _ref4.length; index < _len; index++) {
        paragraph = _ref4[index];
        if (!(this._canUseParagraphNode(paragraph.node))) continue;
        if (y < this.getParagraphTextMid(index)) break;
        nodeIndex = index;
      }
      if (!(nodeIndex != null)) return null;
      return [this._paragraphs[nodeIndex].node, y - this.getParagraphTextMid(nodeIndex)];
    };

    MindMapNodeBlockBase.prototype._getNodeAtTextZoneToTheBottomOfCoords = function(y) {
      var index, nodeIndex, paragraph, _len, _ref4;
      if (this.isRoot()) return null;
      nodeIndex = null;
      _ref4 = this._paragraphs;
      for (index = 0, _len = _ref4.length; index < _len; index++) {
        paragraph = _ref4[index];
        if (!(this._canUseParagraphNode(paragraph.node))) continue;
        nodeIndex = index;
        if (y < this.getParagraphTextMid(index)) break;
      }
      if (y > this.getParagraphTextMid(nodeIndex)) return null;
      return [this._paragraphs[nodeIndex].node, this.getParagraphTextMid(nodeIndex) - y];
    };

    MindMapNodeBlockBase.prototype._getNodeAtTextZoneToTheLeftOfCoords = function(x, y) {
      var index, paragraph, _len, _ref4;
      if (this.isRoot()) return null;
      _ref4 = this._paragraphs;
      for (index = 0, _len = _ref4.length; index < _len; index++) {
        paragraph = _ref4[index];
        if (this._canUseParagraphNode(paragraph.node)) {
          if ((this.getParagraphTextTop(index) < y && y < this.getParagraphTextBottom(index))) {
            return [paragraph.node, x - this.getThreadTextWidth()];
          }
        }
      }
      return null;
    };

    MindMapNodeBlockBase.prototype._getParagraphDescriptionCoordinates = function(index, x, y) {
      var newX, newY;
      newX = x - this.getDescriptionLeft();
      newY = y - this.getParagraphDescriptionTop(index) - this.getDescriptionTop();
      return [newX, newY];
    };

    MindMapNodeBlockBase.prototype.getNodeAtDescriptionZoneToTheTopOfCoords = function(x, y) {
      var curIndex, curRes, newX, newY, node, _ref4;
      curIndex = this._getParagraphIndexWithDescrtiptionAtYCoord(y);
      if (!(curIndex != null)) return null;
      while (curIndex >= 0) {
        node = this._paragraphs[curIndex].node;
        if ((node != null) && (this.isRoot() || !node.isVirtual())) {
          _ref4 = this._getParagraphDescriptionCoordinates(curIndex, x, y), newX = _ref4[0], newY = _ref4[1];
          curRes = node.getNodeAtDescriptionZoneToTheTopOfCoords(newX, newY);
          if (curRes != null) return curRes;
        }
        curIndex--;
      }
      return null;
    };

    MindMapNodeBlockBase.prototype.getNodeAtDescriptionZoneToTheBottomOfCoords = function(x, y) {
      var curIndex, curRes, newX, newY, node, _ref4;
      curIndex = this._getParagraphIndexWithDescrtiptionAtYCoord(y);
      if (!(curIndex != null)) return null;
      while (curIndex < this._paragraphs.length) {
        node = this._paragraphs[curIndex].node;
        if ((node != null) && (this.isRoot() || !node.isVirtual())) {
          _ref4 = this._getParagraphDescriptionCoordinates(curIndex, x, y), newX = _ref4[0], newY = _ref4[1];
          curRes = node.getNodeAtDescriptionZoneToTheBottomOfCoords(newX, newY);
          if (curRes != null) return curRes;
        }
        curIndex++;
      }
      return null;
    };

    MindMapNodeBlockBase.prototype.getNodeAtDescriptionZoneToTheLeftOfCoords = function(x, y) {
      var curIndex, curRes, newX, newY, node, _ref4;
      curIndex = this._getParagraphIndexWithDescrtiptionAtYCoord(y);
      if (!(curIndex != null)) return null;
      node = this._paragraphs[curIndex].node;
      if ((node != null) && (this.isRoot() || !node.isVirtual())) {
        _ref4 = this._getParagraphDescriptionCoordinates(curIndex, x, y), newX = _ref4[0], newY = _ref4[1];
        curRes = node.getNodeAtDescriptionZoneToTheLeftOfCoords(newX, newY);
        return curRes;
      }
      return null;
    };

    MindMapNodeBlockBase.prototype.getNodeToTheTopOfCoords = function(x, y) {
      if (x > this.getDescriptionLeft()) {
        return this.getNodeAtDescriptionZoneToTheTopOfCoords(x, y);
      } else if (x < this._getTextLeft()) {
        return null;
      } else if (x < this.getThreadTextWidth()) {
        return this._getNodeAtTextZoneToTheTopOfCoords(y);
      } else {
        return null;
      }
    };

    MindMapNodeBlockBase.prototype.getNodeToTheBottomOfCoords = function(x, y) {
      if (x > this.getDescriptionLeft()) {
        return this.getNodeAtDescriptionZoneToTheBottomOfCoords(x, y);
      } else if (x < this._getTextLeft()) {
        return null;
      } else if (x < this.getThreadTextWidth()) {
        return this._getNodeAtTextZoneToTheBottomOfCoords(y);
      } else {
        return null;
      }
    };

    MindMapNodeBlockBase.prototype.getNodeToTheLeftOfCoords = function(x, y) {
      var curIndex, node;
      if (x > this.getDescriptionLeft()) {
        return this.getNodeAtDescriptionZoneToTheLeftOfCoords(x, y);
      } else if (x < this._getTextLeft()) {
        return null;
      } else if (x < this.getThreadTextWidth()) {
        return null;
      } else {
        return this._getNodeAtTextZoneToTheLeftOfCoords(x, y);
      }
      curIndex = this._getParagraphIndexAtYCoord(y);
      node = this._paragraphs[curIndex].node;
      if (!(node != null)) return null;
      return node.getNodeToTheLeftOfCoords(x, y - this.getParagraphTextTop(curIndex));
    };

    MindMapNodeBlockBase.prototype.getTotalWidth = function() {
      /*
              Возвращает полную ширину этого блока вместе со всеми потомками
              @return: float
      */
      var descriptionRight, descriptionWidth, hasDescription, paragraph, threadRight, _i, _len, _ref4;
      descriptionWidth = 0;
      hasDescription = false;
      _ref4 = this._paragraphs;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        paragraph = _ref4[_i];
        if (!(paragraph.node != null)) continue;
        if (paragraph.node.hasDescription()) hasDescription = true;
        descriptionWidth = Math.max(descriptionWidth, paragraph.node.getDescriptionWidth());
      }
      descriptionRight = 0;
      if (descriptionWidth) {
        descriptionRight = descriptionWidth + this.getDescriptionLeft();
      }
      threadRight = this._getTextLeft() + this.getThreadTextWidth();
      if (hasDescription) {
        threadRight += FOLD_BUTTON_WIDTH + FOLD_BUTTON_LEFT_PADDING;
      }
      return Math.max(threadRight, descriptionRight);
    };

    MindMapNodeBlockBase.prototype.getTotalHeight = function() {
      /*
              Возвращает высоту этого блока вместе со всеми потомками
              @return: float
      */      if (this.isRoot()) {
        return this.getDescriptionHeight() + this.getParagraphDescriptionTop(0);
      }
      return Math.max(this.getDescriptionHeight(), this.getSelfHeight());
    };

    MindMapNodeBlockBase.prototype.getSelfHeight = function() {
      var paraCount, paragraph, _i, _len, _ref4;
      paraCount = 0;
      _ref4 = this._paragraphs;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        paragraph = _ref4[_i];
        if (paragraph.node != null) paraCount++;
      }
      return paraCount * TEXT_NODE_HEIGHT;
    };

    MindMapNodeBlockBase.prototype.getDescriptionHeight = function() {
      var index;
      index = this._paragraphs.length - 1;
      return Math.max(0, this.getParagraphDescriptionBottom(index));
    };

    MindMapNodeBlockBase.prototype.isRoot = function() {
      return this._isRoot;
    };

    MindMapNodeBlockBase.prototype.destroy = function() {
      var p, _i, _len, _ref4, _ref5, _ref6;
      _ref4 = this._paragraphs;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        p = _ref4[_i];
        if ((_ref5 = p.node) != null) _ref5.destroy();
      }
      this._container.parentNode.removeChild(this._container);
      delete this._container;
      if ((_ref6 = this._descriptionContainer.parentNode) != null) {
        _ref6.removeChild(this._descriptionContainer);
      }
      delete this._descriptionContainer;
      this._paragraphs = [];
      delete this._parent;
      return this._destroyed = true;
    };

    return MindMapNodeBlockBase;

  })();

  module.exports = {
    MindMapNodeBlockBase: MindMapNodeBlockBase
  };

}).call(this);

});

require.define("/lib/client/client/mindmap/utils.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ModelField, ModelType, ParamsField, convertBlipOpToSnapshot, convertTextOpToSnapshot, convertTextOpsToSnapshot, copy, getElement, getNodeClass, hasClass, _ref;

  _ref = require('../editor/model'), ModelField = _ref.ModelField, ParamsField = _ref.ParamsField, ModelType = _ref.ModelType;

  getElement = exports.getElement = function(name, properties) {
    var key, res, value;
    res = document.createElementNS('http://www.w3.org/2000/svg', name);
    if (properties != null) {
      for (key in properties) {
        value = properties[key];
        res.setAttribute(key, value);
      }
    }
    return res;
  };

  copy = exports.copy = function(object) {
    return JSON.parse(JSON.stringify(object));
  };

  exports.copyNodeTextContent = function(element) {
    /*
        Копирует содержимое HTML-ноды, пропуская треды
    */
    var child, res, _i, _len, _ref2;
    res = element.cloneNode(false);
    if (res.nodeName === 'INPUT') res.disabled = 'disabled';
    _ref2 = element.childNodes;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      child = _ref2[_i];
      if ($(child).hasClass('blip-thread')) continue;
      res.appendChild(copyNodeTextContent(child));
    }
    return res;
  };

  exports.getBlockType = function(block) {
    return block[ModelField.PARAMS][ParamsField.TYPE];
  };

  getNodeClass = function(node) {
    return node.getAttribute('class') || '';
  };

  hasClass = exports.hasClass = function(node, value) {
    return (" " + (getNodeClass(node)) + " ").indexOf(" " + value + " ") > -1;
  };

  exports.addClass = function(node, value) {
    if (hasClass(node, value)) return;
    return node.setAttribute('class', ("" + (getNodeClass(node)) + " " + value).trim());
  };

  exports.removeClass = function(node, value) {
    var className;
    className = (" " + (getNodeClass(node)) + " ").replace(" " + value + " ", ' ').trim();
    return node.setAttribute('class', className);
  };

  exports.removeClasses = function(node, values) {
    var className, removeClassNames;
    removeClassNames = values.join('|');
    className = (" " + (getNodeClass(node)) + " ").replace(new RegExp(" (?:" + removeClassNames + ") "), ' ').trim();
    return node.setAttribute('class', className);
  };

  convertTextOpToSnapshot = function(op) {
    var res;
    if (!('ti' in op)) {
      throw "Cannot convert text operation " + (JSON.stringify(op)) + " to snapshot";
    }
    res = {};
    res[ModelField.TEXT] = op.ti;
    res[ModelField.PARAMS] = copy(op[ModelField.PARAMS]);
    return res;
  };

  convertTextOpsToSnapshot = exports.convertTextOpsToSnapshot = function(ops) {
    var op, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = ops.length; _i < _len; _i++) {
      op = ops[_i];
      _results.push(convertTextOpToSnapshot(op));
    }
    return _results;
  };

  convertBlipOpToSnapshot = function(op) {
    if (!('ops' in op)) {
      throw "Cannot convert blip operation " + (JSON.stringify(op)) + " to snapshot";
    }
    return convertTextOpsToSnapshot(op.ops);
  };

  exports.convertBlipOpsToSnapshot = function(ops) {
    var op, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = ops.length; _i < _len; _i++) {
      op = ops[_i];
      _results.push(convertBlipOpToSnapshot(op));
    }
    return _results;
  };

  exports.convertTextOpsToBlipOps = function(ops) {
    var params;
    params = {};
    params[ParamsField.TYPE] = ModelType.BLIP;
    return [
      {
        ti: ' ',
        params: params,
        ops: ops,
        blipParams: {}
      }
    ];
  };

}).call(this);

});

require.define("/lib/client/client/mindmap/const.js",function(require,module,exports,__dirname,__filename,process,global){
/*
Константы для отрисовки mindmap
*/

(function() {
  var BLIP_SPACE, DESCRIPTION_BLOCK_LINE_TOP_OFFSET, DESCRIPTION_HEIGHT_LINE_LEFT_OFFSET, DESCRIPTION_HEIGHT_LINE_WIDTH, FOLD_BUTTON_HEIGHT, ROOT_BLIP_SPACE, TEXT_NODE_HEIGHT, THREAD_DRAG_ZONE_HEIGHT;

  module.exports.TEXT_NODE_HEIGHT = TEXT_NODE_HEIGHT = 21;

  module.exports.TEXT_Y_OFFSET = 15;

  module.exports.TEXT_NODE_PADDING_LEFT = 10;

  module.exports.HEADER_OFFSET_X = 20;

  module.exports.HEADER_OFFSET_Y = 5;

  module.exports.ROOT_BLOCK_OFFSET_X = 30;

  module.exports.ROOT_BLOCK_OFFSET_Y = 30;

  module.exports.FOLD_BUTTON_WIDTH = 19;

  module.exports.FOLD_BUTTON_HEIGHT = FOLD_BUTTON_HEIGHT = 19;

  module.exports.FOLD_BUTTON_TOP_OFFSET = (TEXT_NODE_HEIGHT - FOLD_BUTTON_HEIGHT) / 2;

  module.exports.FOLD_BUTTON_LEFT_PADDING = 3;

  module.exports.SHORT_MAX_NODE_TEXT_LENGTH = 25;

  module.exports.LONG_MAX_NODE_TEXT_LENGTH = 75;

  module.exports.PIXELS_PER_SYMBOL = 7;

  module.exports.SHORT_MAX_THREAD_WIDTH = 240;

  module.exports.LONG_MAX_THREAD_WIDTH = 550;

  module.exports.ICO_WIDTH = 18;

  module.exports.ICO_HEIGHT = 14;

  module.exports.ICO_SIDE_PADDING = 1;

  module.exports.MINIMAL_THREAD_WIDTH = 30;

  module.exports.BLIP_SPACE = BLIP_SPACE = 6;

  module.exports.DESCRIPTION_LEFT_OFFSET = 100;

  module.exports.DESCRIPTION_ARROW_HEIGHT = 10;

  module.exports.PARAGRAPH_LINE_LEFT_OFFSET = 4;

  module.exports.PARAGRAPH_LINE_HEIGHT = TEXT_NODE_HEIGHT - 4;

  module.exports.THREAD_DRAG_ZONE_HEIGHT = THREAD_DRAG_ZONE_HEIGHT = 21;

  module.exports.HIDDEN_THREAD_DRAG_ZONE_HEIGHT = THREAD_DRAG_ZONE_HEIGHT / 2 - BLIP_SPACE / 2;

  module.exports.ROOT_BLIP_SPACE = ROOT_BLIP_SPACE = THREAD_DRAG_ZONE_HEIGHT + 1;

  module.exports.DESCRIPTION_BLOCK_LINE_TOP_OFFSET = DESCRIPTION_BLOCK_LINE_TOP_OFFSET = -10;

  module.exports.DESCRIPTION_HEIGHT_LINE_TOP_OFFSET = DESCRIPTION_BLOCK_LINE_TOP_OFFSET + ROOT_BLIP_SPACE / 2;

  module.exports.DESCRIPTION_HEIGHT_LINE_LEFT_OFFSET = DESCRIPTION_HEIGHT_LINE_LEFT_OFFSET = -20;

  module.exports.DESCRIPTION_HEIGHT_LINE_WIDTH = DESCRIPTION_HEIGHT_LINE_WIDTH = 4;

  module.exports.DESCRIPTION_BLOCK_LINE_LEFT_OFFSET = DESCRIPTION_HEIGHT_LINE_LEFT_OFFSET + DESCRIPTION_HEIGHT_LINE_WIDTH / 2;

  module.exports.BLIP_DRAG_ZONE_WIDTH = 13;

  module.exports.BLIP_DRAG_ZONE_HEIGHT = 21;

  module.exports.THREAD_DRAG_ZONE_WIDTH = 23;

  module.exports.DROP_CHILD_THREAD_ZONE = 20;

  module.exports.GHOST_X_OFFSET = 5;

  module.exports.GHOST_Y_OFFSET = 5;

  module.exports.GHOST_MAX_WIDTH = 1000;

  module.exports.GHOST_MAX_HEIGHT = 350;

  module.exports.VIRTUAL_THREAD_LEFT_OFFSET = 10;

  module.exports.VIRTUAL_THREAD_TOP_OFFSET = -7;

  module.exports.BLIP_BACKGROUND_REMOVE_TIMEOUT = 5000;

  module.exports.BLIP_BACKGROUND_OFFSET = 4;

}).call(this);

});

require.define("/lib/client/client/mindmap/text_node.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BULLETED_LIST_LEVEL_COUNT, BULLETED_LIST_LEVEL_PADDING, BULLETED_LIST_START_PADDING, ICO_HEIGHT, ICO_SIDE_PADDING, ICO_WIDTH, LineLevelParams, ModelField, ModelType, PIXELS_PER_SYMBOL, TEXT_Y_OFFSET, TextNode, empty, getBlockType, getElement, _ref, _ref2, _ref3, _ref4;

  _ref = require('./utils'), getElement = _ref.getElement, getBlockType = _ref.getBlockType;

  empty = require('../utils/dom').empty;

  _ref2 = require('./const'), ICO_WIDTH = _ref2.ICO_WIDTH, ICO_HEIGHT = _ref2.ICO_HEIGHT, ICO_SIDE_PADDING = _ref2.ICO_SIDE_PADDING, PIXELS_PER_SYMBOL = _ref2.PIXELS_PER_SYMBOL, TEXT_Y_OFFSET = _ref2.TEXT_Y_OFFSET;

  _ref3 = require('../editor/model'), ModelField = _ref3.ModelField, ModelType = _ref3.ModelType, LineLevelParams = _ref3.LineLevelParams;

  _ref4 = require('../editor/renderer'), BULLETED_LIST_LEVEL_COUNT = _ref4.BULLETED_LIST_LEVEL_COUNT, BULLETED_LIST_LEVEL_PADDING = _ref4.BULLETED_LIST_LEVEL_PADDING, BULLETED_LIST_START_PADDING = _ref4.BULLETED_LIST_START_PADDING;

  TextNode = (function() {
    /*
        Класс для отображения параграфа в mindmap
    */
    function TextNode(_mindmap, _textBlocks) {
      this._mindmap = _mindmap;
      this._textBlocks = _textBlocks;
      this._container = getElement('g');
      this._updateViewBlocks();
    }

    TextNode.prototype.getContainer = function() {
      return this._container;
    };

    TextNode.prototype._getBlockNodesCache = function() {
      var block, res, _base, _base2, _i, _len, _name, _name2, _ref5;
      res = {
        'text': {},
        'image': {}
      };
      if (!(this._viewBlocks != null)) return res;
      _ref5 = this._viewBlocks;
      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
        block = _ref5[_i];
        if (!(block.node != null)) continue;
        if (block.text != null) {
          if ((_base = res.text)[_name = block.text] == null) _base[_name] = [];
          res.text[block.text].push(block.node);
        }
        if (block.path != null) {
          if ((_base2 = res.image)[_name2 = block.path] == null) {
            _base2[_name2] = [];
          }
          res.image[block.path].push(block.node);
        }
      }
      return res;
    };

    TextNode.prototype._updateViewBlocks = function() {
      var block, blockNodesCache, cache, _i, _len, _ref5, _ref6, _results;
      blockNodesCache = this._getBlockNodesCache();
      empty(this._container);
      this._width = null;
      _ref5 = this._getViewBlocks(), this._viewBlocks = _ref5[0], this._widthIsMax = _ref5[1];
      _ref6 = this._viewBlocks;
      _results = [];
      for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
        block = _ref6[_i];
        if (block.text != null) {
          cache = blockNodesCache.text[block.text];
          if (cache != null ? cache.length : void 0) {
            block.node = cache.pop();
          } else {
            block.node = this._createTextViewBlock(block.text);
          }
        } else {
          cache = blockNodesCache.image[block.path];
          if (cache != null ? cache.length : void 0) {
            block.node = cache.pop();
          } else {
            block.node = this._createIcoViewBlock(block.path);
          }
        }
        _results.push(this._container.appendChild(block.node));
      }
      return _results;
    };

    TextNode.prototype._getTextNodeWidth = function(node) {
      var container, width;
      container = $("<span>" + node.childNodes[0].data + "</span>");
      $('body').append(container);
      width = container[0].offsetWidth;
      container.remove();
      return width;
    };

    TextNode.prototype._getViewBlockWidth = function(index) {
      var block, res;
      block = this._viewBlocks[index];
      if (block.path != null) return ICO_WIDTH + 2 * ICO_SIDE_PADDING;
      res = this._getTextNodeWidth(block.node);
      if (block.offset != null) res += block.offset;
      if (block.rightOffset != null) res += block.rightOffset;
      return res;
    };

    TextNode.prototype._createTextViewBlock = function(text) {
      var params, res;
      params = {
        'pointer-event': 'none'
      };
      res = getElement('text', params);
      res.appendChild(document.createTextNode(text));
      return res;
    };

    TextNode.prototype._createIcoViewBlock = function(path) {
      var res;
      res = getElement('image', {
        'width': ICO_WIDTH,
        'height': ICO_HEIGHT,
        'y': -ICO_HEIGHT
      });
      res.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', path);
      return res;
    };

    TextNode.prototype._getViewBlockRightPosition = function(index) {
      var block;
      if (index < 0) return 0;
      block = this._viewBlocks[index];
      if (!(block.rightPosition != null)) {
        block.rightPosition = this._getViewBlockRightPosition(index - 1) + this._getViewBlockWidth(index);
      }
      return block.rightPosition;
    };

    TextNode.prototype.updatePosition = function() {
      var block, index, left, _len, _ref5, _results;
      _ref5 = this._viewBlocks;
      _results = [];
      for (index = 0, _len = _ref5.length; index < _len; index++) {
        block = _ref5[index];
        left = this._getViewBlockRightPosition(index - 1);
        if (block.path != null) left += ICO_SIDE_PADDING;
        if (block.offset != null) left += block.offset;
        _results.push(block.node.setAttribute('x', left));
      }
      return _results;
    };

    TextNode.prototype.setTextBlocks = function(_textBlocks) {
      this._textBlocks = _textBlocks;
      this.invalidateAllCalculatedFields();
      return this._updateViewBlocks();
    };

    TextNode.prototype.getTextBlocks = function() {
      return this._textBlocks;
    };

    TextNode.prototype.getTextWidth = function() {
      return this._getViewBlockRightPosition(this._viewBlocks.length - 1);
    };

    TextNode.prototype.widthIsMax = function() {
      return this._widthIsMax;
    };

    TextNode.prototype._getText = function(blocks) {
      var block, index, maxLength, res, _len;
      res = '';
      maxLength = this._mindmap.getMaxNodeTextLength();
      for (index = 0, _len = blocks.length; index < _len; index++) {
        block = blocks[index];
        if (index === 0) continue;
        res += block[ModelField.TEXT];
        if (res.length > maxLength) {
          res = res.slice(0, (maxLength - 1)) + '…';
          break;
        }
      }
      return res;
    };

    TextNode.prototype._addSymbolsToViewBlocks = function(viewBlocks, symbols) {
      var textViewBlock;
      if (!viewBlocks.length || !(viewBlocks[viewBlocks.length - 1].text != null) || (viewBlocks[viewBlocks.length - 1].rightOffset != null)) {
        textViewBlock = {
          text: ''
        };
        viewBlocks.push(textViewBlock);
      } else {
        textViewBlock = viewBlocks[viewBlocks.length - 1];
      }
      return textViewBlock.text += symbols;
    };

    TextNode.prototype._getViewBlocks = function() {
      var addSymbols, block, bulletLevel, haveMore, index, maxLength, offset, res, shiftLevel, symbolsLeft, text, totalSymbols, type, _len, _ref5;
      res = [];
      totalSymbols = 0;
      haveMore = false;
      maxLength = this._mindmap.getMaxNodeTextLength();
      _ref5 = this._textBlocks;
      for (index = 0, _len = _ref5.length; index < _len; index++) {
        block = _ref5[index];
        if (totalSymbols > maxLength - 1) {
          haveMore = true;
          break;
        }
        if (index === 0) {
          bulletLevel = block[ModelField.PARAMS][LineLevelParams.BULLETED];
          if (bulletLevel != null) {
            shiftLevel = bulletLevel;
            addSymbols = "•◦▪"[bulletLevel % BULLETED_LIST_LEVEL_COUNT] + ' ';
          } else if (this._numberedValue != null) {
            shiftLevel = this._numberedLevel;
            addSymbols = this._numberedValue + '. ';
          }
          if (!(shiftLevel != null)) continue;
          offset = BULLETED_LIST_START_PADDING + (shiftLevel - 1) * BULLETED_LIST_LEVEL_PADDING;
          res.push({
            text: addSymbols,
            offset: offset
          });
          totalSymbols += 1 + offset / PIXELS_PER_SYMBOL;
        }
        type = getBlockType(block);
        if (type === ModelType.TEXT) {
          symbolsLeft = Math.floor(maxLength - totalSymbols);
          if (symbolsLeft < block[ModelField.TEXT].length) haveMore = true;
          text = block[ModelField.TEXT].slice(0, symbolsLeft);
          this._addSymbolsToViewBlocks(res, text);
          totalSymbols += text.length;
        } else if (type === ModelType.ATTACHMENT || type === ModelType.FILE) {
          res.push({
            path: '/s/img/image_ico.png'
          });
          totalSymbols += (ICO_WIDTH + 2 * ICO_SIDE_PADDING) / PIXELS_PER_SYMBOL;
        }
      }
      if (haveMore) this._addSymbolsToViewBlocks(res, '…');
      return [res, haveMore];
    };

    TextNode.prototype.setNumberedListValue = function(_numberedValue, _numberedLevel) {
      this._numberedValue = _numberedValue;
      this._numberedLevel = _numberedLevel;
      return this._updateViewBlocks();
    };

    TextNode.prototype.invalidateAllCalculatedFields = function() {
      var block, _i, _len, _ref5;
      this._width = this._numberedLevel = this._numberedValue = null;
      _ref5 = this._viewBlocks;
      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
        block = _ref5[_i];
        block.rightPosition = null;
      }
      return this._updateViewBlocks();
    };

    return TextNode;

  })();

  module.exports = {
    TextNode: TextNode
  };

}).call(this);

});

require.define("/lib/client/client/mindmap/thread/real.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipThread, DESCRIPTION_BLOCK_LINE_LEFT_OFFSET, DESCRIPTION_BLOCK_LINE_TOP_OFFSET, DESCRIPTION_HEIGHT_LINE_LEFT_OFFSET, DESCRIPTION_HEIGHT_LINE_TOP_OFFSET, DESCRIPTION_HEIGHT_LINE_WIDTH, DROP_CHILD_THREAD_ZONE, HIDDEN_THREAD_DRAG_ZONE_HEIGHT, MindMapNodeBlock, MindMapThread, MindMapThreadBase, ROOT_BLIP_SPACE, THREAD_DRAG_ZONE_HEIGHT, THREAD_DRAG_ZONE_WIDTH, VirtualMindMapNodeBlock, addClass, getElement, removeClass, removeClasses, _ref, _ref2,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  MindMapNodeBlock = require('../nodeblock/real').MindMapNodeBlock;

  VirtualMindMapNodeBlock = require('../nodeblock/virtual').VirtualMindMapNodeBlock;

  BlipThread = require('../../blip/blip_thread').BlipThread;

  _ref = require('../utils'), getElement = _ref.getElement, addClass = _ref.addClass, removeClass = _ref.removeClass, removeClasses = _ref.removeClasses;

  MindMapThreadBase = require('./base').MindMapThreadBase;

  _ref2 = require('../const'), THREAD_DRAG_ZONE_WIDTH = _ref2.THREAD_DRAG_ZONE_WIDTH, THREAD_DRAG_ZONE_HEIGHT = _ref2.THREAD_DRAG_ZONE_HEIGHT, HIDDEN_THREAD_DRAG_ZONE_HEIGHT = _ref2.HIDDEN_THREAD_DRAG_ZONE_HEIGHT, ROOT_BLIP_SPACE = _ref2.ROOT_BLIP_SPACE, DESCRIPTION_BLOCK_LINE_LEFT_OFFSET = _ref2.DESCRIPTION_BLOCK_LINE_LEFT_OFFSET, DESCRIPTION_BLOCK_LINE_TOP_OFFSET = _ref2.DESCRIPTION_BLOCK_LINE_TOP_OFFSET, DESCRIPTION_HEIGHT_LINE_TOP_OFFSET = _ref2.DESCRIPTION_HEIGHT_LINE_TOP_OFFSET, DESCRIPTION_HEIGHT_LINE_LEFT_OFFSET = _ref2.DESCRIPTION_HEIGHT_LINE_LEFT_OFFSET, DESCRIPTION_HEIGHT_LINE_WIDTH = _ref2.DESCRIPTION_HEIGHT_LINE_WIDTH, DROP_CHILD_THREAD_ZONE = _ref2.DROP_CHILD_THREAD_ZONE;

  MindMapThread = (function(_super) {

    __extends(MindMapThread, _super);

    function MindMapThread(_mindmap, _parent, blips) {
      this._mindmap = _mindmap;
      this._parent = _parent;
      MindMapThread.__super__.constructor.call(this, this._mindmap, this._parent);
      this._possibleArrowClasses.push('selected');
      this._createDescriptionContainer();
      if (!this.isRoot()) {
        this._createDragZone();
        this._createArrow();
      }
      this.updateBlips(blips);
    }

    MindMapThread.prototype._createThreadContainer = function(className) {
      if (this.isRoot()) className += ' root-thread';
      return MindMapThread.__super__._createThreadContainer.call(this, className);
    };

    MindMapThread.prototype._createDescriptionContainer = function() {
      this._descriptionContainer = getElement('g');
      return this._container.insertBefore(this._descriptionContainer, this._threadContainer);
    };

    MindMapThread.prototype._createArrow = function() {
      MindMapThread.__super__._createArrow.call(this);
      return this._threadContainer.insertBefore(this._descriptionArrow, this._dragZone);
    };

    MindMapThread.prototype._createDragZone = function() {
      this._dragZone = getElement('image', {
        'width': THREAD_DRAG_ZONE_WIDTH,
        'height': THREAD_DRAG_ZONE_HEIGHT,
        'class': 'thread-drag-zone'
      });
      this._dragZone.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '/s/img/mindmap/thread_drag_zone.png');
      this._dragZone.dragNode = this;
      return this._threadContainer.insertBefore(this._dragZone, this._blockContainerParent);
    };

    MindMapThread.prototype._updateDragZone = function() {
      var left, top;
      if (!(this._dragZone != null)) return;
      if (!this._dragZoneIsShown()) {
        return addClass(this._dragZone, 'hidden');
      } else {
        removeClass(this._dragZone, 'hidden');
        left = this.getTextWidth() - THREAD_DRAG_ZONE_WIDTH;
        this._dragZone.setAttribute('x', left);
        top = this._blocks[0].getParagraphTextTop(0) + this.getBlockTop(0) - THREAD_DRAG_ZONE_HEIGHT;
        return this._dragZone.setAttribute('y', top);
      }
    };

    MindMapThread.prototype._dragZoneIsShown = function() {
      return this._blocks.length >= 2;
    };

    MindMapThread.prototype._getDragZoneHeight = function() {
      if (this._dragZoneIsShown()) {
        return THREAD_DRAG_ZONE_HEIGHT;
      } else {
        return HIDDEN_THREAD_DRAG_ZONE_HEIGHT;
      }
    };

    MindMapThread.prototype._getBlocksByBlipId = function() {
      var block, res, _i, _len, _ref3;
      res = {};
      _ref3 = this._blocks;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        block = _ref3[_i];
        if (block instanceof MindMapNodeBlock) {
          res[block.getBlipId()] = block;
        } else {
          this._removeBlock(block);
        }
      }
      return res;
    };

    MindMapThread.prototype._updateBlockLines = function() {
      var curLength, group, i, line, neededLength, _ref3, _results, _results2;
      if (this._blockLines == null) this._blockLines = [];
      neededLength = this._blocks.length;
      curLength = this._blockLines.length;
      if (curLength > neededLength) {
        _results = [];
        for (i = _ref3 = neededLength - 1; _ref3 <= curLength ? i < curLength : i > curLength; _ref3 <= curLength ? i++ : i--) {
          group = this._blockLines.pop();
          _results.push(group.parentNode.removeChild(group));
        }
        return _results;
      } else {
        _results2 = [];
        for (i = curLength; curLength <= neededLength ? i < neededLength : i > neededLength; curLength <= neededLength ? i++ : i--) {
          group = getElement('g');
          line = getElement('rect', {
            "class": 'block-line-top',
            x: 0,
            y: 0,
            height: 1
          });
          group.appendChild(line);
          line = getElement('rect', {
            "class": 'block-line-bottom',
            x: 0,
            y: 1,
            height: 1
          });
          group.appendChild(line);
          this._container.insertBefore(group, this._descriptionContainer);
          _results2.push(this._blockLines.push(group));
        }
        return _results2;
      }
    };

    MindMapThread.prototype._updateBlockLinePositions = function() {
      var group, index, line, top, width, _len, _ref3, _results;
      width = this.getTotalWidth() - DESCRIPTION_BLOCK_LINE_LEFT_OFFSET;
      _ref3 = this._blockLines;
      _results = [];
      for (index = 0, _len = _ref3.length; index < _len; index++) {
        group = _ref3[index];
        top = this.getBlockDescriptionTop(index);
        group.setAttribute('transform', "translate(" + DESCRIPTION_BLOCK_LINE_LEFT_OFFSET + ", " + (top + DESCRIPTION_BLOCK_LINE_TOP_OFFSET) + ")");
        _results.push((function() {
          var _i, _len2, _ref4, _results2;
          _ref4 = group.childNodes;
          _results2 = [];
          for (_i = 0, _len2 = _ref4.length; _i < _len2; _i++) {
            line = _ref4[_i];
            _results2.push(line.setAttribute('width', width));
          }
          return _results2;
        })());
      }
      return _results;
    };

    MindMapThread.prototype._updateBlockHeightLines = function() {
      var curLength, group, i, line, neededLength, _ref3, _results, _results2;
      if (this._blockHeightLines == null) this._blockHeightLines = [];
      neededLength = this._blocks.length;
      curLength = this._blockHeightLines.length;
      if (curLength > neededLength) {
        _results = [];
        for (i = _ref3 = neededLength - 1; _ref3 <= curLength ? i < curLength : i > curLength; _ref3 <= curLength ? i++ : i--) {
          group = this._blockLines.pop();
          _results.push(group.parentNode.removeChild(group));
        }
        return _results;
      } else {
        _results2 = [];
        for (i = curLength; curLength <= neededLength ? i < neededLength : i > neededLength; curLength <= neededLength ? i++ : i--) {
          line = getElement('rect', {
            "class": 'blip-height-line',
            x: DESCRIPTION_HEIGHT_LINE_LEFT_OFFSET,
            width: DESCRIPTION_HEIGHT_LINE_WIDTH
          });
          this._container.insertBefore(line, this._descriptionContainer);
          _results2.push(this._blockHeightLines.push(line));
        }
        return _results2;
      }
    };

    MindMapThread.prototype._updateBlockHeightLinePositions = function() {
      var height, index, line, top, _len, _ref3, _results;
      _ref3 = this._blockHeightLines;
      _results = [];
      for (index = 0, _len = _ref3.length; index < _len; index++) {
        line = _ref3[index];
        top = this.getBlockDescriptionTop(index) + DESCRIPTION_HEIGHT_LINE_TOP_OFFSET;
        height = this._blocks[index].getTotalHeight();
        line.setAttribute('y', top);
        _results.push(line.setAttribute('height', height));
      }
      return _results;
    };

    MindMapThread.prototype.updateBlips = function(blips) {
      /*
              Обновляет блипы треда
              @param blips: [BlipViewModel]
      */
      var blip, blipId, block, blockCache, blockDescriptionParent, index, newBlocks, _, _len;
      newBlocks = [];
      blockCache = this._getBlocksByBlipId();
      for (index = 0, _len = blips.length; index < _len; index++) {
        blip = blips[index];
        blipId = blip.getModel().serverId;
        if (blockCache[blipId] != null) {
          newBlocks.push(blockCache[blipId]);
          delete blockCache[blipId];
        } else {
          block = new MindMapNodeBlock(this._mindmap, this, blip, this.isRoot() && index === 0);
          newBlocks.push(block);
          this._blockContainer.appendChild(block.getContainer());
          blockDescriptionParent = getElement('g');
          blockDescriptionParent.appendChild(block.getDescriptionContainer());
          this._descriptionContainer.insertBefore(blockDescriptionParent, this._descriptionContainer.firstChild);
        }
      }
      for (_ in blockCache) {
        block = blockCache[_];
        this._removeBlock(block);
      }
      this._blocks = newBlocks;
      if (this.isRoot()) {
        this._updateBlockLines();
        this._updateBlockHeightLines();
      }
      return this.invalidateAllCalculatedFields();
    };

    MindMapThread.prototype._updateBlockPositions = function() {
      if (this.isRoot()) {
        this._updateBlockLinePositions();
        this._updateBlockHeightLinePositions();
      }
      return MindMapThread.__super__._updateBlockPositions.call(this);
    };

    MindMapThread.prototype._getBlockSpace = function() {
      if (this.isRoot()) {
        return ROOT_BLIP_SPACE;
      } else {
        return MindMapThread.__super__._getBlockSpace.call(this);
      }
    };

    MindMapThread.prototype.isRoot = function() {
      return this._parent.isRoot();
    };

    MindMapThread.prototype.getTotalWidth = function() {
      if (this.isHidden()) {
        return 0;
      } else {
        return MindMapThread.__super__.getTotalWidth.call(this);
      }
    };

    MindMapThread.prototype._getSelfTotalHeight = function() {
      var res;
      res = MindMapThread.__super__._getSelfTotalHeight.call(this);
      if (res) res += this._getDragZoneHeight();
      return res;
    };

    MindMapThread.prototype.getTotalHeight = function() {
      if (this.isHidden()) {
        return 0;
      } else {
        return MindMapThread.__super__.getTotalHeight.call(this);
      }
    };

    MindMapThread.prototype.isHidden = function() {
      var thread;
      thread = this._getTextThread();
      if (!thread) return false;
      return thread.isFolded();
    };

    MindMapThread.prototype.isRead = function() {
      var _ref3;
      return (_ref3 = this._getTextThread()) != null ? _ref3.isRead() : void 0;
    };

    MindMapThread.prototype._getTextThread = function() {
      /*
              Возвращает объект thread'а из текстового представления
      */
      var blipContainer, block, _i, _len, _ref3;
      if (!this._blocks.length) return null;
      _ref3 = this._blocks;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        block = _ref3[_i];
        if (!(block instanceof MindMapNodeBlock)) continue;
        blipContainer = block.getBlipViewModel().getView().getContainer();
        return BlipThread.getBlipThread(blipContainer);
      }
      return null;
    };

    MindMapThread.prototype.hide = function() {
      var thread;
      thread = this._getTextThread();
      if (!thread) return;
      return thread.fold();
    };

    MindMapThread.prototype.show = function() {
      var thread;
      thread = this._getTextThread();
      if (!thread) {
        this._parent.getParent().getBlipViewModel().getView().renderToRoot();
        thread = this._getTextThread();
      }
      return thread.unfold();
    };

    MindMapThread.prototype.foldAllRecursively = function() {
      var block, _i, _len, _ref3, _results;
      if (!this.isRoot() && !this.isHidden()) this.hide();
      this.invalidateAllCalculatedFields();
      _ref3 = this._blocks;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        block = _ref3[_i];
        _results.push(block.foldAllRecursively());
      }
      return _results;
    };

    MindMapThread.prototype.unfoldAllRecursively = function() {
      var block, _i, _len, _ref3, _results;
      if (!this.isRoot() && this.isHidden()) this.show();
      this.invalidateAllCalculatedFields();
      _ref3 = this._blocks;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        block = _ref3[_i];
        _results.push(block.unfoldAllRecursively());
      }
      return _results;
    };

    MindMapThread.prototype.updatePosition = function() {
      if (!this._needsPositionUpdate) return;
      MindMapThread.__super__.updatePosition.call(this);
      return this._updateDragZone();
    };

    MindMapThread.prototype.forceUpdateNeed = function() {
      return this._needsPositionUpdate = true;
    };

    MindMapThread.prototype.updatePositionFromRoot = function() {
      return this._parent.updatePositionFromRoot();
    };

    MindMapThread.prototype.removeAllVirtualNodes = function() {
      var block, newBlocks, _i, _len, _ref3;
      newBlocks = [];
      _ref3 = this._blocks;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        block = _ref3[_i];
        if (block instanceof MindMapNodeBlock) {
          newBlocks.push(block);
        } else {
          block.destroy();
        }
      }
      this._blocks = newBlocks;
      this.recursivelyInvalidateAllCalculatedFields();
      return this.updatePositionFromRoot();
    };

    MindMapThread.prototype._getRootThreadBlockDescriptionBottom = function(index) {
      var blockBottom;
      if (index < 0) return -this._getBlockSpace();
      blockBottom = this.getBlockTop(index) + this._blocks[index].getSelfHeight();
      return Math.max(this.getBlockDescriptionBottom(index), blockBottom);
    };

    MindMapThread.prototype.getBlockTop = function(index) {
      var block, prevBottom;
      block = this._blocks[index];
      if (!(block.top != null)) {
        if (this.isRoot()) {
          prevBottom = this._getRootThreadBlockDescriptionBottom(index - 1);
          block.top = prevBottom + this._getBlockSpace() + (block.getTotalHeight() - block.getSelfHeight()) / 2;
        } else {
          block.top = MindMapThread.__super__.getBlockTop.call(this, index);
          if (index === 0) block.top += this._getDragZoneHeight();
        }
      }
      return block.top;
    };

    MindMapThread.prototype._getShiftedBlockDescriptionTop = function(index) {
      var block;
      block = this._blocks[index];
      if (!(block.descriptionTop != null)) {
        if (this.isRoot()) {
          block.descriptionTop = this._getRootThreadBlockDescriptionBottom(index - 1) + this._getBlockSpace();
        } else {
          MindMapThread.__super__._getShiftedBlockDescriptionTop.call(this, index);
        }
      }
      return block.descriptionTop;
    };

    MindMapThread.prototype._getBlockIndexAtYCoord = function(y) {
      var index, _, _len, _ref3;
      if (y < this.getBlockTop(0)) return 0;
      _ref3 = this._blocks;
      for (index = 0, _len = _ref3.length; index < _len; index++) {
        _ = _ref3[index];
        if (y < this.getBlockTop(index)) return index - 1;
      }
      return this._blocks.length - 1;
    };

    MindMapThread.prototype._getBlockIndexWithDescriptionAtYCoord = function(y) {
      var index, _, _len, _ref3;
      if (y < this.getBlockDescriptionTop(0)) return 0;
      _ref3 = this._blocks;
      for (index = 0, _len = _ref3.length; index < _len; index++) {
        _ = _ref3[index];
        if (y < this.getBlockDescriptionTop(index)) return index - 1;
      }
      return this._blocks.length - 1;
    };

    MindMapThread.prototype.getNodeToTheTopOfCoords = function(x, y) {
      var block, curIndex, curRes;
      if (!this._blocks.length) return null;
      if (x > this.getTextWidth()) {
        curIndex = this._getBlockIndexWithDescriptionAtYCoord(y);
        while (curIndex >= 0) {
          block = this._blocks[curIndex];
          if (block instanceof MindMapNodeBlock) {
            curRes = block.getNodeAtDescriptionZoneToTheTopOfCoords(x, y - this.getBlockDescriptionTop(curIndex));
            if (curRes != null) return curRes;
          }
          curIndex--;
        }
      } else {
        curIndex = this._getBlockIndexAtYCoord(y);
        while (curIndex >= 0) {
          block = this._blocks[curIndex];
          if (block instanceof MindMapNodeBlock) {
            curRes = block.getNodeToTheTopOfCoords(x, y - this.getBlockTop(curIndex));
            if (curRes != null) return curRes;
          }
          curIndex--;
        }
      }
      return null;
    };

    MindMapThread.prototype.getNodeToTheBottomOfCoords = function(x, y) {
      var block, curIndex, curRes;
      if (!this._blocks.length) return null;
      if (x > this.getTextWidth()) {
        curIndex = this._getBlockIndexWithDescriptionAtYCoord(y);
        while (curIndex < this._blocks.length) {
          block = this._blocks[curIndex];
          if (block instanceof MindMapNodeBlock) {
            curRes = block.getNodeAtDescriptionZoneToTheBottomOfCoords(x, y - this.getBlockDescriptionTop(curIndex));
            if (curRes != null) return curRes;
          }
          curIndex++;
        }
      } else {
        curIndex = this._getBlockIndexAtYCoord(y);
        while (curIndex < this._blocks.length) {
          block = this._blocks[curIndex];
          if (block instanceof MindMapNodeBlock) {
            curRes = block.getNodeToTheBottomOfCoords(x, y - this.getBlockTop(curIndex));
            if (curRes != null) return curRes;
          }
          curIndex++;
        }
      }
      return null;
    };

    MindMapThread.prototype.getNodeToTheLeftOfCoords = function(x, y) {
      var block, curIndex;
      if (!this._blocks.length) return null;
      if (x > this.getTextWidth() + DROP_CHILD_THREAD_ZONE) {
        curIndex = this._getBlockIndexWithDescriptionAtYCoord(y);
        block = this._blocks[curIndex];
        if (block instanceof MindMapNodeBlock) {
          return block.getNodeAtDescriptionZoneToTheLeftOfCoords(x, y - this.getBlockDescriptionTop(curIndex));
        }
      } else {
        curIndex = this._getBlockIndexAtYCoord(y);
        block = this._blocks[curIndex];
        if (block instanceof MindMapNodeBlock) {
          return block.getNodeToTheLeftOfCoords(x, y - this.getBlockTop(curIndex));
        }
      }
      return null;
    };

    MindMapThread.prototype.getChildNodeRealIndex = function(target) {
      var block, res, _i, _len, _ref3;
      res = 0;
      _ref3 = this._blocks;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        block = _ref3[_i];
        if (block === target) break;
        if (!(block instanceof VirtualMindMapNodeBlock)) res++;
      }
      return res;
    };

    MindMapThread.prototype._insertVirtualBlipAt = function(index, content) {
      var blockDescriptionParent, virtualNodeBlock;
      virtualNodeBlock = new VirtualMindMapNodeBlock(this._mindmap, this, content);
      this._blocks.splice(index, 0, virtualNodeBlock);
      this._blockContainer.appendChild(virtualNodeBlock.getContainer());
      blockDescriptionParent = getElement('g');
      blockDescriptionParent.appendChild(virtualNodeBlock.getDescriptionContainer());
      this._descriptionContainer.appendChild(blockDescriptionParent);
      return this.recursivelyInvalidateAllCalculatedFields();
    };

    MindMapThread.prototype.insertVirtualBlipsAt = function(index, data) {
      var content, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        content = data[_i];
        this._insertVirtualBlipAt(index, content);
        _results.push(index++);
      }
      return _results;
    };

    MindMapThread.prototype.removeChildBlipFromSnapshot = function(blipId) {
      return this._parent.getParent().removeSnapshotBlip(blipId);
    };

    MindMapThread.prototype.insertBlipOpsAt = function(index, ops) {
      var blip, block, curIndex;
      blip = this._parent.getParent();
      curIndex = index - 1;
      while (curIndex >= 0) {
        block = this._blocks[curIndex];
        if (block instanceof MindMapNodeBlock) {
          return blip.insertSnapshotBlipOpsInBlipAfter(block, ops);
        }
        curIndex--;
      }
      curIndex = index;
      while (curIndex < this._blocks.length) {
        block = this._blocks[curIndex];
        if (block instanceof MindMapNodeBlock) {
          return blip.insertSnapshotBlipOpsInBlipBefore(block, ops);
        }
        curIndex++;
      }
    };

    MindMapThread.prototype.getBlipsData = function() {
      var block, _i, _len, _ref3, _results;
      _ref3 = this._blocks;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        block = _ref3[_i];
        _results.push(block.getTextBlocks());
      }
      return _results;
    };

    MindMapThread.prototype.getCopyOps = function() {
      var block, res, _i, _len, _ref3;
      res = [];
      _ref3 = this._blocks;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        block = _ref3[_i];
        res = res.concat(block.getCopyOps(block));
      }
      return res;
    };

    MindMapThread.prototype.removeFromSnapshot = function() {
      return this._parent.getParent().removeSnapshotParagraphThread(this._parent.getId());
    };

    MindMapThread.prototype.markSelectedBlock = function(block) {
      this._selectedBlockIndex = this.getBlockIndex(block);
      this._needsPositionUpdate = true;
      return this._parent.markSelected();
    };

    MindMapThread.prototype._getSelectedParagraphTop = function() {
      var block, res, selectedParaIndex;
      res = 0;
      block = this._blocks[this._selectedBlockIndex];
      selectedParaIndex = block.getSelectedParagraphIndex();
      res = block.getParagraphTextTop(selectedParaIndex);
      res += this.getBlockTop(this._selectedBlockIndex);
      return res;
    };

    MindMapThread.prototype._getArrowEndAndClassName = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (!(this._selectedBlockIndex != null)) {
        return MindMapThread.__super__._getArrowEndAndClassName.apply(this, args);
      }
      return [this._getSelectedParagraphTop() + 5, 'selected'];
    };

    MindMapThread.prototype.unmarkSelectedBlock = function() {
      this._selectedBlockIndex = null;
      this._needsPositionUpdate = true;
      return this._parent.unmarkSelected();
    };

    return MindMapThread;

  })(MindMapThreadBase);

  module.exports = {
    MindMapThread: MindMapThread
  };

}).call(this);

});

require.define("/lib/client/client/mindmap/nodeblock/virtual.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var MindMapNodeBlockBase, VirtualMindMapNodeBlock, addClass, getMindMapNode,
    __slice = Array.prototype.slice,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  MindMapNodeBlockBase = require('./base').MindMapNodeBlockBase;

  addClass = require('../utils').addClass;

  getMindMapNode = function() {
    var MindMapNode, args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    MindMapNode = require('../node').MindMapNode;
    getMindMapNode = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return typeof result === "object" ? result : child;
      })(MindMapNode, args, function() {});
    };
    return getMindMapNode.apply(null, args);
  };

  VirtualMindMapNodeBlock = (function(_super) {

    __extends(VirtualMindMapNodeBlock, _super);

    function VirtualMindMapNodeBlock(_mindmap, _parent, _content) {
      this._mindmap = _mindmap;
      this._parent = _parent;
      this._content = _content;
      VirtualMindMapNodeBlock.__super__.constructor.call(this, this._mindmap, this._parent);
    }

    VirtualMindMapNodeBlock.prototype._createDOMNodes = function() {
      VirtualMindMapNodeBlock.__super__._createDOMNodes.call(this);
      return addClass(this._container, 'virtual');
    };

    VirtualMindMapNodeBlock.prototype._getContent = function() {
      return this._content;
    };

    VirtualMindMapNodeBlock.prototype._getParagraphNode = function(id, paragraphBlocks) {
      return getMindMapNode(this._mindmap, null, paragraphBlocks, this, []);
    };

    VirtualMindMapNodeBlock.prototype._updateParagraphNode = function(node, paragraphBlocks) {
      return node.setTextBlocks(paragraphBlocks);
    };

    VirtualMindMapNodeBlock.prototype.isRoot = function() {
      return false;
    };

    return VirtualMindMapNodeBlock;

  })(MindMapNodeBlockBase);

  module.exports = {
    VirtualMindMapNodeBlock: VirtualMindMapNodeBlock
  };

}).call(this);

});

require.define("/lib/client/client/mindmap/thread/base.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BLIP_SPACE, DESCRIPTION_ARROW_HEIGHT, MindMapThreadBase, TEXT_NODE_HEIGHT, addClass, getElement, removeClasses, _ref, _ref2;

  _ref = require('../utils'), getElement = _ref.getElement, addClass = _ref.addClass, removeClasses = _ref.removeClasses;

  _ref2 = require('../const'), BLIP_SPACE = _ref2.BLIP_SPACE, TEXT_NODE_HEIGHT = _ref2.TEXT_NODE_HEIGHT, DESCRIPTION_ARROW_HEIGHT = _ref2.DESCRIPTION_ARROW_HEIGHT;

  MindMapThreadBase = (function() {

    function MindMapThreadBase(_mindmap, _parent) {
      this._mindmap = _mindmap;
      this._parent = _parent;
      this._blocks = [];
      this._container = getElement('g');
      this._createThreadContainer('thread-container');
      this._createBlockContainer();
      this._needsPositionUpdate = true;
      this._possibleArrowClasses = ['to-top', 'to-mid', 'to-bottom'];
    }

    MindMapThreadBase.prototype.getParent = function() {
      return this._parent;
    };

    MindMapThreadBase.prototype._createThreadContainer = function(className) {
      this._threadContainer = getElement('g', {
        "class": className
      });
      if (this._getSelfLeftOffset() || this._getSelfTopOffset()) {
        this._threadContainer.setAttribute('transform', "translate(" + (this._getSelfLeftOffset()) + "," + (this._getSelfTopOffset()) + ")");
      }
      return this._container.appendChild(this._threadContainer);
    };

    MindMapThreadBase.prototype._createBlockContainer = function() {
      this._blockContainerParent = getElement('g');
      this._blockContainer = getElement('g');
      this._blockContainerParent.appendChild(this._blockContainer);
      return this._threadContainer.appendChild(this._blockContainerParent);
    };

    MindMapThreadBase.prototype.getContainer = function() {
      return this._container;
    };

    MindMapThreadBase.prototype.getBlockContainer = function() {
      return this._blockContainer;
    };

    MindMapThreadBase.prototype._removeBlock = function(block) {
      var blockDescriptionParent, _ref3;
      blockDescriptionParent = block.getDescriptionContainer();
      if ((_ref3 = blockDescriptionParent.parentNode) != null) {
        _ref3.removeChild(blockDescriptionParent);
      }
      return block.destroy();
    };

    MindMapThreadBase.prototype._updateBlockPositions = function() {
      var block, index, _len, _ref3, _ref4, _results;
      _ref3 = this._blocks;
      _results = [];
      for (index = 0, _len = _ref3.length; index < _len; index++) {
        block = _ref3[index];
        if (index === 0) {
          this._blockContainerParent.setAttribute('transform', "translate(0, " + (this.getBlockTop(0)) + ")");
        }
        block.getContainer().setAttribute('transform', "translate(0," + (this.getBlockTop(index) - this.getBlockTop(0)) + ")");
        if ((_ref4 = block.getDescriptionContainer().parentNode) != null) {
          _ref4.setAttribute('transform', "translate(0," + (this.getBlockDescriptionTop(index)) + ")");
        }
        _results.push(block.updatePosition());
      }
      return _results;
    };

    MindMapThreadBase.prototype._getBlockSpace = function() {
      return BLIP_SPACE;
    };

    MindMapThreadBase.prototype.getBlockTop = function(index) {
      var block, space;
      block = this._blocks[index];
      if (!(block.top != null)) {
        if (index === 0) {
          block.top = (this.getTotalHeight() - this._getSelfTotalHeight()) / 2;
        } else {
          space = this._getBlockSpace();
          block.top = this.getBlockTop(index - 1) + this._blocks[index - 1].getSelfHeight() + space;
        }
      }
      return block.top;
    };

    MindMapThreadBase.prototype._getShiftedBlockDescriptionTop = function(index) {
      var res;
      if (index === 0) return 0;
      if (!(this._blocks[index].descriptionTop != null)) {
        res = this.getBlockDescriptionBottom(index - 1);
        if (this._blocks[index].getDescriptionHeight()) res += BLIP_SPACE;
        this._blocks[index].descriptionTop = res;
      }
      return this._blocks[index].descriptionTop;
    };

    MindMapThreadBase.prototype.getBlockDescriptionTop = function(index) {
      var res;
      res = Math.max(this._getShiftedBlockDescriptionTop(index), 0);
      return res;
    };

    MindMapThreadBase.prototype.getBlockDescriptionBottom = function(index) {
      var res;
      if (!(this._blocks[index].descriptionBottom != null)) {
        res = this._getShiftedBlockDescriptionTop(index);
        if (this._blocks[index].getDescriptionHeight()) {
          res += this._blocks[index].getDescriptionHeight();
        } else if (index === 0) {
          res -= BLIP_SPACE;
        }
        this._blocks[index].descriptionBottom = res;
      }
      return this._blocks[index].descriptionBottom;
    };

    MindMapThreadBase.prototype.invalidateAllCalculatedFields = function() {
      var block, _i, _len, _ref3, _results;
      this._needsPositionUpdate = true;
      this._selfTotalHeight = null;
      this._descriptionTotalHeight = null;
      this._textWidth = null;
      _ref3 = this._blocks;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        block = _ref3[_i];
        block.top = null;
        block.descriptionTop = null;
        block.descriptionBottom = null;
        _results.push(block.forceChildrenUpdateNeed());
      }
      return _results;
    };

    MindMapThreadBase.prototype.getTotalWidth = function() {
      var block, res, _i, _len, _ref3;
      if (!this._blocks.length) return 0;
      res = 0;
      _ref3 = this._blocks;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        block = _ref3[_i];
        res = Math.max(res, block.getTotalWidth());
      }
      return res + this._getSelfLeftOffset();
    };

    MindMapThreadBase.prototype.invalidateIncludingChildren = function() {
      var block, i, _len, _ref3, _results;
      this.invalidateAllCalculatedFields();
      _ref3 = this._blocks;
      _results = [];
      for (i = 0, _len = _ref3.length; i < _len; i++) {
        block = _ref3[i];
        _results.push(block.invalidateIncludingChildren());
      }
      return _results;
    };

    MindMapThreadBase.prototype.recursivelyInvalidateAllCalculatedFields = function() {
      this.invalidateAllCalculatedFields();
      return this._parent.recursivelyInvalidateAllCalculatedFields();
    };

    MindMapThreadBase.prototype.getBlocks = function() {
      return this._blocks;
    };

    MindMapThreadBase.prototype.updatePosition = function() {
      if (!this._needsPositionUpdate) return;
      this._updateBlockPositions();
      this._updateArrow();
      return this._needsPositionUpdate = false;
    };

    MindMapThreadBase.prototype._getSelfTotalHeight = function() {
      var block, height, space, _i, _len, _ref3;
      if (!this._selfTotalHeight) {
        space = this._getBlockSpace();
        height = 0;
        _ref3 = this._blocks;
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          block = _ref3[_i];
          height += block.getSelfHeight() + space;
        }
        this._selfTotalHeight = Math.max(0, height - space);
      }
      return this._selfTotalHeight;
    };

    MindMapThreadBase.prototype._getDescriptionTotalHeight = function() {
      var block, curHeight, height, _i, _len, _ref3;
      if (!this._descriptionTotalHeight) {
        height = 0;
        _ref3 = this._blocks;
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          block = _ref3[_i];
          curHeight = block.getDescriptionHeight();
          if (curHeight) height += curHeight + BLIP_SPACE;
        }
        this._descriptionTotalHeight = Math.max(0, height - BLIP_SPACE);
      }
      return this._descriptionTotalHeight;
    };

    MindMapThreadBase.prototype.getTotalHeight = function() {
      return Math.max(this._getSelfTotalHeight(), this._getDescriptionTotalHeight());
    };

    MindMapThreadBase.prototype._widthIsMax = function() {
      var block, _i, _len, _ref3;
      _ref3 = this._blocks;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        block = _ref3[_i];
        if (block.hasMaxWidth()) return true;
      }
      return false;
    };

    MindMapThreadBase.prototype.getTextWidth = function() {
      var block, res, _i, _len, _ref3;
      if (!(this._textWidth != null)) {
        if (this._widthIsMax()) {
          this._textWidth = this._mindmap.getMaxThreadWidth();
        } else {
          res = 0;
          _ref3 = this._blocks;
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            block = _ref3[_i];
            res = Math.max(res, block.getTextWidth());
          }
          this._textWidth = res;
        }
      }
      return this._textWidth;
    };

    MindMapThreadBase.prototype._createArrow = function() {
      var line;
      this._descriptionArrow = getElement('g', {
        "class": 'description-arrow'
      });
      this._descriptionArrow.appendChild(getElement('path'));
      line = getElement('path', {
        "class": 'description-arrow-line'
      });
      this._descriptionArrow.appendChild(line);
      return this._threadContainer.appendChild(this._descriptionArrow);
    };

    MindMapThreadBase.prototype._getSelfTopOffset = function() {
      return 0;
    };

    MindMapThreadBase.prototype._getSelfLeftOffset = function() {
      return 0;
    };

    MindMapThreadBase.prototype._getArrowEndAndClassName = function(yStart) {
      var centerFrom, centerTo, selfHeight, textTop, yEnd;
      yEnd = this._blocks[0].getParagraphTextTop(0) + this.getBlockTop(0);
      if (this._blocks.length > 1) return [yEnd, 'to-top'];
      textTop = this._blocks[0].getParagraphTextTop(0) + this.getBlockTop(0);
      selfHeight = this._blocks[0].getSelfHeight();
      centerFrom = textTop + selfHeight / 10;
      centerTo = textTop + selfHeight * 9 / 10;
      if (yStart < centerFrom) return [yEnd, 'to-top'];
      if (yStart < centerTo) {
        yEnd += (selfHeight - DESCRIPTION_ARROW_HEIGHT) / 2;
        return [yEnd, 'to-mid'];
      }
      yEnd += selfHeight - DESCRIPTION_ARROW_HEIGHT;
      return [yEnd, 'to-bottom'];
    };

    MindMapThreadBase.prototype._updateArrow = function() {
      var arrowClass, index, parentBlock, selfLeft, selfTop, width, xStart, yDiff, yEnd, yStart, _ref3;
      if (!this._descriptionArrow) return;
      parentBlock = this._parent.getParent();
      index = parentBlock.getNodeIndex(this._parent);
      xStart = this._parent.getFoldButtonRight();
      yStart = this._parent.getFoldButtonMidY();
      yStart += parentBlock.getParagraphTextTop(index) + parentBlock.getBlockTop();
      selfLeft = parentBlock.getDescriptionLeft() + this._getSelfLeftOffset();
      selfTop = parentBlock.getParagraphDescriptionTop(index) + this._getSelfTopOffset() + parentBlock.getBlockDescriptionTop();
      _ref3 = this._getArrowEndAndClassName(yStart - selfTop), yEnd = _ref3[0], arrowClass = _ref3[1];
      yEnd += selfTop;
      removeClasses(this._descriptionArrow, this._possibleArrowClasses);
      addClass(this._descriptionArrow, arrowClass);
      width = selfLeft - xStart;
      yDiff = yEnd - yStart;
      xStart -= selfLeft;
      yStart -= selfTop;
      this._descriptionArrow.childNodes[0].setAttribute('d', "M " + xStart + " " + yStart + " l " + width + " " + yDiff + " l 0 " + DESCRIPTION_ARROW_HEIGHT + " z");
      return this._descriptionArrow.childNodes[1].setAttribute('d', "M " + xStart + " " + yStart + " l " + width + " " + (yDiff + DESCRIPTION_ARROW_HEIGHT / 2));
    };

    MindMapThreadBase.prototype.getBlockIndex = function(searchedBlock) {
      var block, index, _len, _ref3;
      _ref3 = this._blocks;
      for (index = 0, _len = _ref3.length; index < _len; index++) {
        block = _ref3[index];
        if (block === searchedBlock) return index;
      }
      return null;
    };

    MindMapThreadBase.prototype.destroy = function() {
      var block, _i, _len, _ref3, _ref4;
      _ref3 = this._blocks;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        block = _ref3[_i];
        this._removeBlock(block);
      }
      if ((_ref4 = this._container.parentNode) != null) {
        _ref4.removeChild(this._container);
      }
      return delete this._container;
    };

    return MindMapThreadBase;

  })();

  module.exports = {
    MindMapThreadBase: MindMapThreadBase
  };

}).call(this);

});

require.define("/lib/client/client/mindmap/thread/virtual.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var MindMapThreadBase, VIRTUAL_THREAD_LEFT_OFFSET, VIRTUAL_THREAD_TOP_OFFSET, VirtualMindMapNodeBlock, VirtualMindMapThread, _ref,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  MindMapThreadBase = require('./base').MindMapThreadBase;

  VirtualMindMapNodeBlock = require('../nodeblock/virtual').VirtualMindMapNodeBlock;

  _ref = require('../const'), VIRTUAL_THREAD_LEFT_OFFSET = _ref.VIRTUAL_THREAD_LEFT_OFFSET, VIRTUAL_THREAD_TOP_OFFSET = _ref.VIRTUAL_THREAD_TOP_OFFSET;

  VirtualMindMapThread = (function(_super) {

    __extends(VirtualMindMapThread, _super);

    function VirtualMindMapThread(_mindmap, _parent, content) {
      this._mindmap = _mindmap;
      this._parent = _parent;
      VirtualMindMapThread.__super__.constructor.call(this, this._mindmap, this._parent);
      this._createArrow();
      this._setContent(content);
    }

    VirtualMindMapThread.prototype._createThreadContainer = function(className) {
      className += ' virtual';
      return VirtualMindMapThread.__super__._createThreadContainer.call(this, className);
    };

    VirtualMindMapThread.prototype._setContent = function(content) {
      /*
              Устанавливает содержимое виртуального треда
              @param content: [blip data]
      */
      var block, data, _i, _len, _results;
      this._blocks = [];
      _results = [];
      for (_i = 0, _len = content.length; _i < _len; _i++) {
        data = content[_i];
        block = new VirtualMindMapNodeBlock(this._mindmap, this, data);
        this._blocks.push(block);
        _results.push(this._blockContainer.appendChild(block.getContainer()));
      }
      return _results;
    };

    VirtualMindMapThread.prototype.isRoot = function() {
      return false;
    };

    VirtualMindMapThread.prototype._getSelfTopOffset = function() {
      return VIRTUAL_THREAD_TOP_OFFSET;
    };

    VirtualMindMapThread.prototype._getSelfLeftOffset = function() {
      return VIRTUAL_THREAD_LEFT_OFFSET;
    };

    return VirtualMindMapThread;

  })(MindMapThreadBase);

  module.exports = {
    VirtualMindMapThread: VirtualMindMapThread
  };

}).call(this);

});

require.define("/lib/client/client/playback/blip_menu.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ADDITIONAL_MENU_WIDTH, BUTTONS_ORDER, BUTTON_PARAMS, BrowserEvents, DomUtils, Interactable, OVERFLOW_MENU_ADDITIONAL_WIDTH, PlaybackBlipMenu, PlaybackEventTypes, TOTAL_WIDTH, formatAsShortenedDateTime, getEditBlockTotalWidth, getMenuDom, getTotalWidth, renderBlipMenu,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  renderBlipMenu = require('./template').renderBlipMenu;

  BrowserEvents = require('../utils/browser_events');

  DomUtils = require('../utils/dom');

  Interactable = require('../utils/interactable').Interactable;

  PlaybackEventTypes = require('./events').PlaybackEventTypes;

  formatAsShortenedDateTime = require('../../share/utils/datetime').formatAsShortenedDateTime;

  BUTTONS_ORDER = [];

  BUTTON_PARAMS = {
    CalendarButton: {
      selectionClass: 'js-calendar-button',
      event: PlaybackEventTypes.CALENDAR
    },
    FastBackButton: {
      selectionClass: 'js-fast-back-button',
      event: PlaybackEventTypes.FAST_BACK
    },
    BackButton: {
      selectionClass: 'js-back-button',
      event: PlaybackEventTypes.BACK
    },
    ForwardButton: {
      selectionClass: 'js-forward-button',
      event: PlaybackEventTypes.FORWARD
    },
    FastForwardButton: {
      selectionClass: 'js-fast-forward-button',
      event: PlaybackEventTypes.FAST_FORWARD
    },
    CopyButton: {
      selectionClass: 'js-copy-button',
      event: PlaybackEventTypes.COPY
    },
    ReplaceButton: {
      selectionClass: 'js-replace-button',
      event: PlaybackEventTypes.REPLACE
    }
  };

  OVERFLOW_MENU_ADDITIONAL_WIDTH = 60;

  ADDITIONAL_MENU_WIDTH = 15;

  TOTAL_WIDTH = null;

  getMenuDom = function(params) {
    var tmpEl;
    tmpEl = document.createElement('span');
    tmpEl.className = 'blip-menu';
    tmpEl.appendChild(DomUtils.parseFromString(renderBlipMenu(params)));
    return tmpEl;
  };

  getTotalWidth = function(params) {
    var b, buttons, editBlock, tmpEl, total, _i, _len;
    tmpEl = getMenuDom(params);
    document.body.appendChild(tmpEl);
    editBlock = tmpEl.getElementsByClassName('js-playback-menu')[0];
    buttons = editBlock.children;
    total = 0;
    for (_i = 0, _len = buttons.length; _i < _len; _i++) {
      b = buttons[_i];
      total += b.offsetWidth;
    }
    document.body.removeChild(tmpEl);
    return total + ADDITIONAL_MENU_WIDTH;
  };

  getEditBlockTotalWidth = function(params) {
    if (TOTAL_WIDTH) return TOTAL_WIDTH;
    if (!DomUtils.isCssReady()) return 1;
    return TOTAL_WIDTH = getTotalWidth(params);
  };

  PlaybackBlipMenu = (function(_super) {

    __extends(PlaybackBlipMenu, _super);

    function PlaybackBlipMenu(_params) {
      this._params = _params;
      this._handleClickWhileShowingColorPanel = __bind(this._handleClickWhileShowingColorPanel, this);
      this._resizeMenu = __bind(this._resizeMenu, this);
      this._handleButtonClick = __bind(this._handleButtonClick, this);
      PlaybackBlipMenu.__super__.constructor.call(this);
      this._hiddenEditButtons = [];
      this._container = getMenuDom(this._params);
      this._$container = $(this._container);
      this._$calendarButton = this._$container.find('.js-calendar-button');
      this._$fastBackButton = this._$container.find('.js-fast-back-button');
      this._$backButton = this._$container.find('.js-back-button');
      this._$forwardButton = this._$container.find('.js-forward-button');
      this._$fastForwardButton = this._$container.find('.js-fast-forward-button');
      this._$replaceButton = this._$container.find('.js-replace-button');
      this._initButtons();
      BrowserEvents.addBlocker(this._container, BrowserEvents.MOUSE_DOWN_EVENT);
      BrowserEvents.addBlocker(this._container, BrowserEvents.MOUSE_UP_EVENT);
      BrowserEvents.addBlocker(this._container, BrowserEvents.CLICK_EVENT);
    }

    PlaybackBlipMenu.prototype._initButtons = function() {
      return this._$container.on('click', "button", this._handleButtonClick);
    };

    PlaybackBlipMenu.prototype._getButtonBySelectionClass = function(button) {
      var key, props;
      if ((key = button.rzParamName) && (props = BUTTON_PARAMS[key])) return props;
      for (key in BUTTON_PARAMS) {
        props = BUTTON_PARAMS[key];
        if (DomUtils.hasClass(button, props.selectionClass)) {
          button.rzParamName = key;
          return props;
        }
      }
    };

    PlaybackBlipMenu.prototype._handleButtonClick = function(e) {
      var button;
      button = this._getButtonBySelectionClass(e.currentTarget);
      if (button.event) {
        return this.__dispatchEvent(button.event, {
          event: e
        });
      }
    };

    PlaybackBlipMenu.prototype._resizeMenu = function() {
      var blipWidth, menuWidth, _ref, _ref2;
      menuWidth = getEditBlockTotalWidth(this._params);
      blipWidth = ((_ref = this._container.parentNode) != null ? (_ref2 = _ref.parentNode) != null ? _ref2.offsetWidth : void 0 : void 0) || 0;
      if (menuWidth > blipWidth) {
        this._fitEditMenu(menuWidth - blipWidth);
      } else {
        this._fitEditMenu(0);
      }
      if (menuWidth + OVERFLOW_MENU_ADDITIONAL_WIDTH < blipWidth) {
        return DomUtils.removeClass(this._container, 'at-right');
      } else {
        return DomUtils.addClass(this._container, 'at-right');
      }
    };

    PlaybackBlipMenu.prototype._getButtonToHide = function(index) {
      if (index >= BUTTONS_ORDER.length) return null;
      return BUTTON_PARAMS[BUTTONS_ORDER[index]];
    };

    PlaybackBlipMenu.prototype._fitEditMenu = function(widthToHide) {
      var b, button, buttonsToHide, hiddenWidth, index, missedButtons, _i, _j, _len, _len2;
      hiddenWidth = 0;
      buttonsToHide = [];
      index = 0;
      while (hiddenWidth < widthToHide) {
        button = this._getButtonToHide(index);
        if (!button) break;
        buttonsToHide.push(button);
        hiddenWidth += 30;
        index += 1;
      }
      missedButtons = this._hiddenEditButtons.filter(function(b) {
        return buttonsToHide.indexOf(b) === -1;
      });
      for (_i = 0, _len = missedButtons.length; _i < _len; _i++) {
        b = missedButtons[_i];
        if (b.hiddenClass) DomUtils.removeClass(this._container, b.hiddenClass);
      }
      for (_j = 0, _len2 = buttonsToHide.length; _j < _len2; _j++) {
        b = buttonsToHide[_j];
        if (b.hiddenClass) DomUtils.addClass(this._container, b.hiddenClass);
      }
      return this._hiddenEditButtons = buttonsToHide;
    };

    PlaybackBlipMenu.prototype._setPressed = function(buttonKey, isPressed) {
      var $element;
      $element = this._$container.find('.' + BUTTON_PARAMS[buttonKey].selectionClass);
      if (!$element) return;
      if (isPressed) {
        return $element.addClass('pressed');
      } else {
        return $element.removeClass('pressed');
      }
    };

    PlaybackBlipMenu.prototype._handleClickWhileShowingColorPanel = function(event) {
      return this._hideColorPanel();
    };

    PlaybackBlipMenu.prototype.reset = function(params) {
      return this._isRoot = params.isRoot;
    };

    PlaybackBlipMenu.prototype.getContainer = function() {
      return this._container;
    };

    PlaybackBlipMenu.prototype.destroy = function() {
      delete this._$calendarButton;
      delete this._$replaceButton;
      delete this._$fastBackButton;
      delete this._$backButton;
      delete this._$forwardButton;
      delete this._$fastForwardButton;
      delete this._container;
      this._$container.remove();
      return delete this._$container;
    };

    PlaybackBlipMenu.prototype.showOperationLoadingSpinner = function() {
      var button, _i, _len, _ref;
      _ref = [this._$calendarButton, this._$fastBackButton, this._$backButton, this._$forwardButton, this._$fastForwardButton];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        button = _ref[_i];
        button.attr('disabled', true);
      }
      return this._$backButton.addClass('loading');
    };

    PlaybackBlipMenu.prototype.hideOperationLoadingSpinner = function() {
      var button, _i, _len, _ref;
      _ref = [this._$calendarButton, this._$fastBackButton, this._$backButton, this._$forwardButton, this._$fastForwardButton];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        button = _ref[_i];
        button.attr('disabled', false);
      }
      return this._$backButton.removeClass('loading');
    };

    PlaybackBlipMenu.prototype.setCalendarDate = function(date) {
      var formattedDate;
      formattedDate = formatAsShortenedDateTime(date);
      this._$calendarButton.attr('title', "Topic state at " + formattedDate);
      return this._$calendarButton.text(formattedDate);
    };

    PlaybackBlipMenu.prototype.switchForwardButtonsState = function(isDisable) {
      this._$forwardButton.attr('disabled', isDisable);
      return this._$fastForwardButton.attr('disabled', isDisable);
    };

    PlaybackBlipMenu.prototype.switchBackButtonsState = function(isDisable) {
      this._$backButton.attr('disabled', isDisable);
      return this._$fastBackButton.attr('disabled', isDisable);
    };

    PlaybackBlipMenu.prototype.disableReplaceButton = function() {
      return this._$replaceButton.attr('disabled', true);
    };

    return PlaybackBlipMenu;

  })(Interactable);

  module.exports = {
    PlaybackBlipMenu: PlaybackBlipMenu
  };

}).call(this);

});

require.define("/lib/client/client/playback/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var blipMenuTmpl, ck, waveTmpl;

  ck = window.CoffeeKup;

  waveTmpl = function() {
    var contentClasses;
    div('.js-scroll-up .js-scroll .drag-scroll-up', function() {
      div('.js-scroll-u-1000 .scroll-20', {
        offset: '-1000'
      });
      div('.js-scroll-u-500 .scroll-20', {
        offset: '-500'
      });
      div('.js-scroll-u-250 .scroll-20', {
        offset: '-250'
      });
      return div('.js-scroll-u-50 .scroll-20', {
        offset: '-50'
      });
    });
    div('.js-wave-panel.wave-panel', '');
    contentClasses = '.js-wave-content.wave-content';
    if (this.isAnonymous) contentClasses += '.no-editing';
    div(contentClasses, function() {
      if (!this.empty) {
        div('.js-wave-blips.wave-blips', function() {
          div('.js-container-blip container-blip', '');
          if (!this.isAnonymous) {
            return div('topic-url', function() {
              return a('js-topic-url', {
                href: this.url
              }, 'Open as topic');
            });
          }
        });
        return div('.js-topic-mindmap-container.topic-mindmap-container', '');
      }
    });
    return div('.js-scroll-down .js-scroll .drag-scroll-down', function() {
      div('.js-scroll-d-50 scroll-20', {
        offset: '50'
      });
      div('.js-scroll-d-250 scroll-20', {
        offset: '250'
      });
      div('.js-scroll-d-500 scroll-10', {
        offset: '500'
      });
      return div('.js-scroll-d-1000 scroll-10', {
        offset: '1000'
      });
    });
  };

  blipMenuTmpl = function() {
    return div("js-playback-menu playback-menu", function() {
      if (this.isRoot) {
        button('js-calendar-button calendar-button delimitered-right', function() {});
        button('js-fast-back-button fast-back-button icon-button delimitered-right', {
          title: 'Fast back'
        }, function() {
          return div('icon', '');
        });
        button('js-back-button back-button icon-button delimitered-right', {
          title: 'Back'
        }, function() {
          return div('icon', '');
        });
        button('js-forward-button forward-button icon-button delimitered-right', {
          title: 'Forward',
          disabled: true
        }, function() {
          return div('icon', '');
        });
        button('js-fast-forward-button fast-forward-button icon-button delimitered-right', {
          title: 'Fast forward',
          disabled: true
        }, function() {
          return div('icon', '');
        });
      }
      button('js-copy-button copy-button delimitered-right', {
        title: 'Copy content'
      }, function() {
        return 'Copy';
      });
      return button('js-replace-button replace-button', {
        title: 'Paste content to original topic'
      }, function() {
        return 'Paste as reply';
      });
    });
  };

  module.exports = {
    renderWave: ck.compile(waveTmpl),
    renderBlipMenu: ck.compile(blipMenuTmpl)
  };

}).call(this);

});

require.define("/lib/client/client/playback/wave_view.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var PlaybackWaveView, WaveView, renderWave,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  WaveView = require('../wave/view').WaveView;

  renderWave = require('./template').renderWave;

  PlaybackWaveView = (function(_super) {

    __extends(PlaybackWaveView, _super);

    function PlaybackWaveView() {
      var args, originalView, _blipWithPermanentMenu, _i;
      args = 3 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 2) : (_i = 0, []), originalView = arguments[_i++], _blipWithPermanentMenu = arguments[_i++];
      this._blipWithPermanentMenu = _blipWithPermanentMenu;
      originalView.clearActiveBlip();
      PlaybackWaveView.__super__.constructor.apply(this, args);
    }

    PlaybackWaveView.prototype._init = function(waveViewModel, participants) {
      /*
              @param waveViewModel: WaveViewModel
              @param participants: array, часть ShareJS-документа, отвечающего за участников
      */
      var _ref,
        _this = this;
      this._inEditMode = false;
      this._isAnonymous = !(((_ref = window.userInfo) != null ? _ref.id : void 0) != null);
      this._model = waveViewModel.getModel();
      this._editable = false;
      this._createDOM(renderWave);
      this._reservedHeaderSpace = 0;
      this._$wavePanel = $(this.container).find('.js-wave-panel');
      this._initRootBlip(waveViewModel);
      this._initDragScroll();
      waveViewModel.on('waveLoaded', function() {
        $(_this._waveBlips).on('scroll', _this._setOnScrollMenuPosition);
        $(window).on('scroll', _this._setOnScrollMenuPosition);
        return $(window).on('resize resizeTopicByResizer', _this._resizerRepositionMenu);
      });
      return this._initBuffer();
    };

    PlaybackWaveView.prototype._deinitActiveBlipControls = function() {};

    return PlaybackWaveView;

  })(WaveView);

  module.exports.PlaybackWaveView = PlaybackWaveView;

}).call(this);

});

require.define("/lib/client/client/account_merge/merge_successful_message.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var KeyCodes, SuccessfulMergePopup, ck, mergeSuccessfulPopupTmpl, renderPopup,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  ck = window.CoffeeKup;

  KeyCodes = require('../utils/key_codes').KeyCodes;

  mergeSuccessfulPopupTmpl = function() {
    return div(function() {
      div('.js-notification-overlay.notification-overlay.successful-merge', '');
      return div('.notification-block', function() {
        return div('.js-account-merge-form-container.account-merge-form-container.successful-merge', function() {
          div('.js-merge-close.merge-close', {
            title: 'Close'
          }, '');
          div('.merge-title', function() {
            img('.ok-image', {
              src: '/s/img/contacts-refreshed.png'
            });
            return text('Merging of accounts was successfully complete. Please reload all browser tabs with Rizzoma.com.');
          });
          return button('.js-merge-close.button', 'Close');
        });
      });
    });
  };

  renderPopup = ck.compile(mergeSuccessfulPopupTmpl);

  SuccessfulMergePopup = (function() {

    function SuccessfulMergePopup() {
      this._close = __bind(this._close, this);
      this._windowKeyHandler = __bind(this._windowKeyHandler, this);
    }

    SuccessfulMergePopup.prototype.show = function() {
      this._$container = $(renderPopup({
        email: this._email
      }));
      $(document.body).append(this._$container);
      return this._initClose();
    };

    SuccessfulMergePopup.prototype._initClose = function() {
      this._$container.find('.js-notification-overlay, .js-merge-close').click(this._close);
      return $(window).keydown(this._windowKeyHandler);
    };

    SuccessfulMergePopup.prototype._windowKeyHandler = function(e) {
      if (e.which === KeyCodes.KEY_ESCAPE) return this._close();
    };

    SuccessfulMergePopup.prototype._close = function() {
      $(window).off('keydown', this._windowKeyHandler);
      return this._$container.remove();
    };

    return SuccessfulMergePopup;

  })();

  module.exports = {
    SuccessfulMergePopup: SuccessfulMergePopup
  };

}).call(this);

});

require.define("/lib/client/client/collection/module.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BaseModule, Collection, CollectionPicker, History, LocalStorage, MicroEvent, Request, WaveError, WaveViewModel, WaveWarning, render,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  BaseModule = require('../../share/base_module').BaseModule;

  WaveViewModel = require('../wave/index').WaveViewModel;

  Request = require('../../share/communication').Request;

  History = require('../utils/history_navigation');

  WaveWarning = require('../wave/notification/warning').WaveWarning;

  WaveError = require('../wave/notification/error').WaveError;

  MicroEvent = require('../utils/microevent');

  CollectionPicker = require('./picker').CollectionPicker;

  LocalStorage = require('../utils/localStorage').LocalStorage;

  render = window.CoffeeKup.compile(function() {
    return div('.collection-container', function() {
      div('.js-collection-notifications.collection-notifications', '');
      div('.js-resizer.resizer', {
        title: "Resize panels"
      }, function() {
        return div('', '');
      });
      return div('.collection-topic-container', function() {
        return div('.js-collection-topic-container.collection-topic-container', '');
      });
    });
  });

  Collection = (function(_super) {

    __extends(Collection, _super);

    function Collection() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._onCurWaveRangeChange = __bind(this._onCurWaveRangeChange, this);
      this._showWave = __bind(this._showWave, this);
      this._openWave = __bind(this._openWave, this);
      Collection.__super__.constructor.apply(this, args);
      this._waveProcessor = require('../wave/processor').instance;
      this._createDOM();
      this._initLinkClick();
      this._initPicker();
      this._initCollectionList();
      this._$notificationsContainer = $('.js-collection-notifications');
    }

    Collection.prototype.getContainer = function() {
      return this._container;
    };

    Collection.prototype._createDOM = function() {
      return this._container = $(render())[0];
    };

    Collection.prototype._openWave = function(waveId) {
      var _this = this;
      return this._waveProcessor.getWaveWithBlips(waveId, function(err, waveData, waveBlips, socialSharingUrl) {
        if (err) return _this._processOpenWaveErrorResponse(err, waveId);
        return _this._showWave(waveData, waveBlips, socialSharingUrl);
      });
    };

    Collection.prototype._processOpenWaveErrorResponse = function(err, waveId) {
      return console.error("Could not open collection " + waveId, err);
    };

    Collection.prototype._closeCurWave = function() {
      var _ref;
      if (this._curWave != null) {
        this.emit('wave-close', this._curWave);
        this._curWave.getView().removeListener('range-change', this._onCurWaveRangeChange);
      }
      if ((_ref = this._curWave) != null) _ref.destroy();
      delete this._curWave;
      return this.emit('wave-change', null);
    };

    Collection.prototype._showWave = function(waveData, waveBlips, socialSharingUrl) {
      var listButtonWidth;
      this._closeCurWave();
      this._curWave = new WaveViewModel(this._waveProcessor, waveData, waveBlips, socialSharingUrl, this);
      listButtonWidth = $(this._picker.getTopicListButton()).outerWidth();
      this._curWave.getView().setReservedHeaderSpace(listButtonWidth + 30);
      this._curWave.getView().on('range-change', this._onCurWaveRangeChange);
      this._picker.getPanel().setActiveItem();
      return this.emit('wave-change', this._curWave);
    };

    Collection.prototype._onCurWaveRangeChange = function(range, blipView) {
      var blipId, rootBlipId, _ref, _ref2, _ref3;
      rootBlipId = (_ref = this._curWave.getModel()) != null ? _ref.getRootBlipId() : void 0;
      blipId = (_ref2 = blipView.getViewModel()) != null ? (_ref3 = _ref2.getModel()) != null ? _ref3.getServerId() : void 0 : void 0;
      if (rootBlipId && blipId && rootBlipId === blipId) {
        return this._picker.hideTopicsWarning();
      } else {
        return this._picker.showTopicsWarning();
      }
    };

    Collection.prototype.getWaveContainer = function() {
      return $(this._container).find('.js-collection-topic-container')[0];
    };

    Collection.prototype._initCollectionList = function() {
      var processTopicsLoaded,
        _this = this;
      processTopicsLoaded = function(haveCollectionTopics) {
        if (haveCollectionTopics) {
          _this._addToNavigationPanel();
          _this._picker.removeListener('collection-inited', processTopicsLoaded);
          return require('../account_setup_wizard/processor').instance.changeBusinessType(true);
        }
      };
      return this._picker.on('collection-inited', processTopicsLoaded);
    };

    Collection.prototype._addToNavigationPanel = function() {
      var request;
      request = new Request({
        container: this._container
      }, function() {});
      return this._rootRouter.handle('navigation.addCollection', request);
    };

    Collection.prototype._initLinkClick = function() {
      var $eventContainer;
      $eventContainer = $(this.getWaveContainer().parentNode);
      $eventContainer.on('mousedown', 'a', function(event) {
        return event.preventDefault();
      });
      $eventContainer.on('click', 'a', function(event) {
        var editorParent, urlParams, _ref;
        if ((_ref = event.which) !== 1 && _ref !== 2) return;
        editorParent = $(event.target).parent().parent('.js-editor');
        if (editorParent.length === 0) return;
        urlParams = History.getUrlParams(event.currentTarget.href);
        if (urlParams.host && urlParams.waveId) {
          History.navigateTo(urlParams.waveId, urlParams.serverBlipId);
        } else {
          window.open(event.currentTarget.href, '_blank');
        }
        event.preventDefault();
        return event.stopPropagation();
      });
      return $eventContainer.on('click', '.js-topic-url', function(event) {
        var urlParams;
        if (event.which !== 1 || event.ctrlKey || event.metaKey) return;
        urlParams = History.getUrlParams(event.currentTarget.href);
        History.navigateTo(urlParams.waveId, urlParams.serverBlipId);
        event.preventDefault();
        return event.stopPropagation();
      });
    };

    Collection.prototype._initPicker = function() {
      var _this = this;
      this._picker = new CollectionPicker(this);
      this._container.appendChild(this._picker.getTopicListButton());
      this._container.appendChild(this._picker.getTopicsWarning());
      this._container.appendChild(this._picker.getTopicListContainer());
      return this._picker.on('topic-change', function(topicId) {
        LocalStorage.setLastCollectionTopicId(topicId);
        return _this._openWave(topicId);
      });
    };

    Collection.prototype.showWaveWarning = function(message) {
      /*
              Показывает предупреждение, связанное с волной
              @param err: object
      */
      var warnings;
      warnings = this._$notificationsContainer.find('.js-wave-warning');
      if (warnings.length >= 5) $(warnings[0]).remove();
      this._$notificationsContainer.append(new WaveWarning(message).getContainer());
      console.warn('Wave warning occurred in collection');
      return console.warn(message);
    };

    Collection.prototype.showWaveError = function(err) {
      /*
              Показывает ошибку, связанную с волной
              @param err: object
      */
      var errors, waveError;
      waveError = new WaveError(err);
      errors = this._$notificationsContainer.find('.js-wave-error');
      if (errors.length >= 5) $(errors[0]).remove();
      this._$notificationsContainer.append(waveError.getContainer());
      console.error("Wave error occurred in collection");
      return console.error(err.stack);
    };

    Collection.prototype.load = function(request) {
      var lastTopicId;
      if (this._loaded) return;
      this._loaded = true;
      lastTopicId = LocalStorage.getLastCollectionTopicId();
      if (!lastTopicId || !this._picker.hasTopicIdInList(lastTopicId)) {
        lastTopicId = this._picker.getFirstTopicIdInList();
        LocalStorage.setLastCollectionTopicId(lastTopicId);
      }
      return this._openWave(lastTopicId);
    };

    Collection.prototype.getCurrentWave = function() {
      return this._curWave;
    };

    return Collection;

  })(BaseModule);

  MicroEvent.mixin(Collection);

  module.exports.Collection = Collection;

}).call(this);

});

require.define("/lib/client/client/wave/notification/warning.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var WaveNotification, WaveWarning, renderWarning,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  renderWarning = require('./template').renderWarning;

  WaveNotification = require('./notification').WaveNotification;

  WaveWarning = (function(_super) {

    __extends(WaveWarning, _super);

    /*
        Класс, представляющий предупреждение волны
    */

    function WaveWarning(_message) {
      this._message = _message;
      /*
              @param _message: String, сообщение
      */
      WaveWarning.__super__.constructor.call(this);
      this._container.addClass("wave-warning");
      this._container.addClass("js-wave-warning");
      this._createDOM();
      if (this._closeButton) $(this._closeButton).bind('click', this._hideError);
      setTimeout(this._hideError, 5000);
    }

    WaveWarning.prototype._createDOM = function() {
      /*
              Создает DOM для показа предупреждения
      */      this._container.append(renderWarning({
        message: this._message
      }));
      return this._closeButton = this._container.find('.js-warning-close-button')[0];
    };

    return WaveWarning;

  })(WaveNotification);

  module.exports.WaveWarning = WaveWarning;

}).call(this);

});

require.define("/lib/client/client/wave/notification/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var anonymousTmpl, ck, errorTmpl, warningTmpl;

  ck = window.CoffeeKup;

  errorTmpl = function() {
    /*
        Шаблон ошибки в волне
    */    div('.set-3d', '');
    img('', {
      src: '/s/img/error-icon.png',
      alt: 'Error'
    });
    div('.wave-error-text', function() {
      if (this.error.logId) {
        text(h("" + this.error.message));
        br('', '');
        return text(h("Code: " + this.error.logId));
      } else {
        return text(h("" + this.error.message));
      }
    });
    span('.js-error-close-button.error-close-icon', '');
    return div('.clearer', '');
  };

  warningTmpl = function() {
    /*
        Шаблон предупреждения в волне
    */    div('.set-3d', '');
    img('', {
      src: '/s/img/warning-icon.png',
      alt: 'Warning'
    });
    div('.wave-warning-text', function() {
      return text(h("" + this.message));
    });
    span('.js-warning-close-button.warning-close-icon', '');
    return div('.clearer', '');
  };

  anonymousTmpl = function() {
    /*
        Шаблон предупреждения о необходимости авторизоваться
    */    return div(".js-anonymous-notification-container.anonymous-notification-container", function() {
      div('.notification-overlay', '');
      return div('.js-notification-block.notification-block', function() {
        div('.sign-in-block', function() {
          var cta, _i, _len, _ref;
          _ref = this.callToAction;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            cta = _ref[_i];
            div('.call-to-action', cta);
          }
          div('.buttons-container', function() {
            a('.js-google-login-link.google-login-link', {
              href: "/auth/google/?url=" + (encodeURIComponent(this.redirectUrl)),
              title: 'Sign in with Google',
              onclick: "_gaq.push(['_trackEvent', 'Authorization', 'Authorize with Google click', 'Topic']); _gaq.push(['_trackPageview', '/authorization/google/']);"
            });
            return a('.js-facebook-login-link.facebook-login-link', {
              href: "/auth/facebook/?url=" + (encodeURIComponent(this.redirectUrl)),
              title: 'Sign in with Facebook',
              onclick: "_gaq.push(['_trackEvent', 'Authorization', 'Authorize with Facebook click', 'Topic']); _gaq.push(['_trackPageview', '/authorization/facebook/']);"
            });
          });
          return div('.bottom-corner', function() {
            return div('', '');
          });
        });
        return div('.bottom-caption', function() {
          div('.slogan', '"Build your group mind"');
          return div('.sign', 'Rizzoma Squad');
        });
      });
    });
  };

  exports.renderError = ck.compile(errorTmpl);

  exports.renderWarning = ck.compile(warningTmpl);

  exports.renderAnonymousNotification = ck.compile(anonymousTmpl);

}).call(this);

});

require.define("/lib/client/client/wave/notification/notification.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var WaveNotification,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  WaveNotification = (function() {
    /*
        Класс, представляющий любое уведомление волны
    */
    function WaveNotification() {
      this.getContainer = __bind(this.getContainer, this);
      this._hideError = __bind(this._hideError, this);      this._container = document.createElement('div');
      this._container = $(this._container);
    }

    WaveNotification.prototype._hideError = function() {
      /*
              Прячет показываемую ошибку
      */      this._container.remove();
      return $(window).trigger('resize');
    };

    WaveNotification.prototype.getContainer = function() {
      return this._container;
    };

    return WaveNotification;

  })();

  module.exports.WaveNotification = WaveNotification;

}).call(this);

});

require.define("/lib/client/client/wave/notification/error.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var History, WaveError, WaveNotification, renderError,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  renderError = require('./template').renderError;

  WaveNotification = require('./notification').WaveNotification;

  History = require('../../utils/history_navigation');

  WaveError = (function(_super) {

    __extends(WaveError, _super);

    /*
        Класс, представляющий ошибку волны
    */

    function WaveError(_error) {
      this._error = _error;
      /*
              @param _error: object, объект ошибки
      */
      WaveError.__super__.constructor.call(this);
      this._container.addClass("wave-error");
      this._container.addClass("js-wave-error");
      this._createDOM();
      if (this._closeButton) $(this._closeButton).bind('click', this._hideError);
    }

    WaveError.prototype._createDOM = function() {
      /*
              Создает DOM для показа ошибки
      */      if (window.loggedIn) {
        this._container.append(renderError({
          error: this._error
        }));
        return this._closeButton = this._container.find('.js-error-close-button')[0];
      } else {
        return window.AuthDialog.initAndShow(false, History.getLoginRedirectUrl());
      }
    };

    return WaveError;

  })(WaveNotification);

  module.exports.WaveError = WaveError;

}).call(this);

});

require.define("/lib/client/client/collection/picker.js",function(require,module,exports,__dirname,__filename,process,global){
/*
Компонент со списком топиков-collection
*/

(function() {
  var CollectionPanel, CollectionPicker, DomUtils, History, LIST_UPDATE_INTERVAL, MicroEvent, renderCollectionFooter, renderCollectionPickerTopicListButton, renderCollectionPickerTopicsWarning, renderCollectionTopic, renderer,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  History = require('../utils/history_navigation');

  renderer = require('../search_panel/topic/template');

  DomUtils = require('../utils/dom');

  MicroEvent = require('../utils/microevent');

  LIST_UPDATE_INTERVAL = require('../account_setup_wizard/processor').LIST_UPDATE_INTERVAL;

  renderCollectionPickerTopicListButton = window.CoffeeKup.compile(function() {
    return button('.collection-list-button.button', 'Team list');
  });

  renderCollectionPickerTopicsWarning = window.CoffeeKup.compile(function() {
    return div('.collection-list-warning', function() {
      span('', 'Unable to collect monthly payment. ');
      return a('', {
        href: '/settings/teams-menu/',
        target: '_blank'
      }, function() {
        return 'Details';
      });
    });
  });

  renderCollectionTopic = window.CoffeeKup.compile(function() {
    return a(".js-search-result.search-result-item", {
      id: this.item.id,
      href: "/topic/" + (h(this.item.url)) + "/"
    }, function() {
      div(".text-content", function() {
        return div('.wave-title', function() {
          span(h(this.item.title));
          br('', '');
          return span('.item-snippet', h(' ' + this.item.snippet));
        });
      });
      div('.js-wave-info.wave-info', function() {
        return div('.js-info.info', function() {
          var avatar, nameTitle;
          nameTitle = this.item.name || '';
          avatar = this.item.avatar || '/s/img/user/unknown.png';
          div('.last-editing.avatar', {
            style: "background-image: url(" + (h(avatar)) + ")",
            title: h(nameTitle)
          });
          return div('.last-changed', '');
        });
      });
      return div('.clearer', '');
    });
  });

  renderCollectionFooter = window.CoffeeKup.compile(function() {
    return div('.collection-footer', function() {
      return div('', function() {
        return button('.new-collection-button.button', 'Create new team');
      });
    });
  });

  CollectionPicker = (function() {

    function CollectionPicker(_parent) {
      this._parent = _parent;
      this._updateWaveInfo = __bind(this._updateWaveInfo, this);
      this._createDOM();
      this._waveModule = require('../modules/wave').instance;
      this._initTopicCloseEvents();
    }

    CollectionPicker.prototype._createDOM = function() {
      this._createTopicList();
      this._createTopicListButton();
      return this._createTopicWarning();
    };

    CollectionPicker.prototype._createTopicList = function() {
      var footer,
        _this = this;
      this._topicListContainer = $('<div class="topic-list-container"></div>')[0];
      this._panel = new CollectionPanel(this);
      this._topicListContainer.appendChild(this._panel.getContainer());
      this._topicListIsShown = false;
      this._panel.on('topic-change', function(waveId) {
        _this._hideTopicList();
        return _this.emit('topic-change', waveId);
      });
      this._panel.on('topics-loaded', function(searchResults) {
        var haveCollections;
        haveCollections = !!searchResults.length;
        return _this.emit('collection-inited', haveCollections);
      });
      footer = renderCollectionFooter();
      footer = DomUtils.parseFromString(footer);
      this._topicListContainer.appendChild(footer);
      return $(this._topicListContainer).find('.new-collection-button').click(function() {
        return _this._newTeamHandler();
      });
    };

    CollectionPicker.prototype._newTeamHandler = function() {
      this._hideTopicList();
      return window.open('/settings/teams-menu/new');
    };

    CollectionPicker.prototype._hideTopicList = function() {
      $(this._topicListContainer).removeClass('visible');
      return $(document.body).off('click.collection-topic-list-hide');
    };

    CollectionPicker.prototype._showTopicList = function() {
      var _this = this;
      this._updateOpenedWavesInfo();
      $(this._topicListContainer).addClass('visible');
      this._panel.setActiveItem();
      return $(document.body).on('click.collection-topic-list-hide', function(e) {
        if ($(e.target).closest($([_this._topicListContainer, _this._topicListButton])).length > 0) {
          return;
        }
        return _this._hideTopicList();
      });
    };

    CollectionPicker.prototype._createTopicListButton = function() {
      var $topicListButton,
        _this = this;
      $topicListButton = $(renderCollectionPickerTopicListButton());
      this._topicListButton = $topicListButton[0];
      return $topicListButton.click(function() {
        if ($(_this._topicListContainer).hasClass('visible')) {
          return _this._hideTopicList();
        } else {
          return _this._showTopicList();
        }
      });
    };

    CollectionPicker.prototype._createTopicWarning = function() {
      return this._topicWarning = $(renderCollectionPickerTopicsWarning())[0];
    };

    CollectionPicker.prototype.getTopicListButton = function() {
      return this._topicListButton;
    };

    CollectionPicker.prototype.getTopicsWarning = function() {
      return this._topicWarning;
    };

    CollectionPicker.prototype.hideTopicsWarning = function() {
      return $(this._topicWarning).hide();
    };

    CollectionPicker.prototype.showTopicsWarning = function() {
      return $(this._topicWarning).show();
    };

    CollectionPicker.prototype.getTopicListContainer = function() {
      return this._topicListContainer;
    };

    CollectionPicker.prototype.getFirstTopicIdInList = function() {
      return this._panel.getFirstTopicIdInList();
    };

    CollectionPicker.prototype.hasTopicIdInList = function(id) {
      return this._panel.hasTopicIdInList(id);
    };

    CollectionPicker.prototype.getActiveTopicId = function() {
      var _ref;
      return (_ref = this._parent.getCurrentWave()) != null ? _ref.getServerId() : void 0;
    };

    CollectionPicker.prototype.getPanel = function() {
      return this._panel;
    };

    CollectionPicker.prototype._updateWaveInfo = function(wave) {
      var rootBlipId, rootBlipModel, _ref, _ref2;
      rootBlipId = wave != null ? (_ref = wave.getModel()) != null ? _ref.getRootBlipId() : void 0 : void 0;
      if (!rootBlipId) return;
      rootBlipModel = (_ref2 = wave.getLoadedBlip(rootBlipId)) != null ? _ref2.getModel() : void 0;
      if (!rootBlipModel) return;
      return this._panel.updateSearchResultParams(wave.getServerId(), rootBlipModel.getTitle(), rootBlipModel.getSnippet());
    };

    CollectionPicker.prototype._updateOpenedWavesInfo = function() {
      /*
              Обновляет title и snippet из открытых топиков
      */      this._updateWaveInfo(this._waveModule.getCurrentWave());
      return this._updateWaveInfo(this._parent.getCurrentWave());
    };

    CollectionPicker.prototype._initTopicCloseEvents = function() {
      /*
              Следим за закрывающимися топиками, чтобы перед закрытием получить из них свежие title и snippet
      */      this._parent.on('wave-close', this._updateWaveInfo);
      return this._waveModule.on('wave-close', this._updateWaveInfo);
    };

    return CollectionPicker;

  })();

  MicroEvent.mixin(CollectionPicker);

  CollectionPanel = (function() {

    function CollectionPanel(_parent) {
      this._parent = _parent;
      this._linkClickHandler = __bind(this._linkClickHandler, this);
      this._initProcessor();
      this._createDOM();
      this._startTopicListUpdates();
      this._initVisibilityUpdate();
    }

    CollectionPanel.prototype.getContainer = function() {
      return this._container;
    };

    CollectionPanel.prototype._initProcessor = function() {
      var _this = this;
      this._processor = require('../account_setup_wizard/processor').instance;
      return this._processor.on('force-is-business-update', function() {
        _this._lastResultTime = 0;
        return _this._updateTopicList();
      });
    };

    CollectionPanel.prototype._createDOM = function() {
      this._container = $('<div class="collection-list"></div>')[0];
      return this._container.addEventListener('click', this._linkClickHandler, false);
    };

    CollectionPanel.prototype._startTopicListUpdates = function() {
      var _this = this;
      this._loadCachedTopicList();
      if (this._lastSearchResults) {
        this._renderTopicList();
        window.setTimeout(function() {
          return _this.emit('topics-loaded', _this._lastSearchResults);
        }, 0);
      }
      return this._updateTopicList();
    };

    CollectionPanel.prototype._updateTopicList = function() {
      var nextUpdateTime,
        _this = this;
      window.clearTimeout(this._updateHandler);
      nextUpdateTime = Math.max(this._lastResultTime + LIST_UPDATE_INTERVAL, Date.now());
      return this._updateHandler = window.setTimeout(function() {
        _this._loadTopicList();
        _this._lastResultTime = Date.now();
        return _this._updateTopicList();
      }, nextUpdateTime - Date.now());
    };

    CollectionPanel.prototype._loadCachedTopicResults = function() {
      var responseCache;
      responseCache = this._processor.getCachedTeamTopics();
      if (!responseCache || !responseCache.value || !responseCache.value.topics) {
        return;
      }
      return this._lastSearchResults = responseCache.value.topics;
    };

    CollectionPanel.prototype._loadCachedTopicList = function() {
      var responseCache;
      responseCache = this._processor.getCachedTeamTopics();
      if (!responseCache || !responseCache.value || !responseCache.value.topics) {
        return;
      }
      this._lastSearchResults = responseCache.value.topics;
      return this._lastResultTime = responseCache.savedTime;
    };

    CollectionPanel.prototype._loadTopicList = function() {
      var _this = this;
      return this._processor.getTeamTopics(function(err, res) {
        if (err) {
          return console.warn("Got an error for collection topic list request", err);
        }
        return _this._processTopicList(res);
      });
    };

    CollectionPanel.prototype._processTopicList = function(res) {
      this._parseTopicList(res);
      return this._renderTopicList();
    };

    CollectionPanel.prototype._getDOMTopicId = function(topicId) {
      return "collection-topic-" + topicId;
    };

    CollectionPanel.prototype._parseTopicList = function(response) {
      var item, _i, _len, _ref;
      _ref = response.topics;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        item.id = this._getDOMTopicId(item.url);
      }
      this._lastSearchResults = response.topics;
      this._processor.setCachedTeamTopics(this._lastSearchResults, response.hasDebt);
      return this.emit('topics-loaded', this._lastSearchResults);
    };

    CollectionPanel.prototype._renderTopicList = function() {
      var item, result, _i, _len, _ref;
      DomUtils.empty(this._container);
      result = '';
      _ref = this._lastSearchResults;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        result += renderCollectionTopic({
          item: item
        });
      }
      result = DomUtils.parseFromString(result);
      this._container.appendChild(result);
      return this.setActiveItem();
    };

    CollectionPanel.prototype._linkClickHandler = function(event) {
      var target, waveId;
      if (event.ctrlKey || event.metaKey || event.button) return;
      event.preventDefault();
      target = event.target;
      while (!DomUtils.isAnchorElement(target) && DomUtils.contains(this._container, target)) {
        target = target.parentNode;
      }
      if (!DomUtils.isAnchorElement(target)) return;
      waveId = History.parseUrlParams(target.href).waveId;
      return this.emit('topic-change', waveId);
    };

    CollectionPanel.prototype.getFirstTopicIdInList = function() {
      var _ref;
      return (_ref = this._lastSearchResults[0]) != null ? _ref.url : void 0;
    };

    CollectionPanel.prototype.hasTopicIdInList = function(id) {
      var item, _i, _len, _ref;
      _ref = this._lastSearchResults;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.url === id) return true;
      }
    };

    CollectionPanel.prototype.setActiveItem = function() {
      var activeItem, lastActiveItems, topicId;
      topicId = this._parent.getActiveTopicId();
      lastActiveItems = this._container.getElementsByClassName('active');
      if (lastActiveItems.length > 0) {
        DomUtils.removeClass(lastActiveItems[0], 'active');
      }
      activeItem = document.getElementById(this._getDOMTopicId(topicId));
      if (activeItem != null) return DomUtils.addClass(activeItem, 'active');
    };

    CollectionPanel.prototype.updateSearchResultParams = function(waveId, title, snippet) {
      var item, _i, _len, _ref;
      if (!this._lastSearchResults) return;
      _ref = this._lastSearchResults;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (!(item.url === waveId)) continue;
        item.title = title;
        item.snippet = snippet;
      }
      this._processor.setCachedTeamTopics(this._lastSearchResults);
      return this._renderTopicList();
    };

    CollectionPanel.prototype._initVisibilityUpdate = function() {
      var _this = this;
      return Visibility.change(function(e, state) {
        if (state !== 'visible') return;
        _this._loadCachedTopicResults();
        return _this._renderTopicList();
      });
    };

    return CollectionPanel;

  })();

  MicroEvent.mixin(CollectionPanel);

  module.exports = {
    CollectionPicker: CollectionPicker
  };

}).call(this);

});

require.define("/lib/client/client/search_panel/topic/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ck, searchPanelTmpl, tagListTmpl, topicTmpl;

  ck = window.CoffeeKup;

  searchPanelTmpl = function() {
    div('.js-search-header.search-header', function() {
      div('.search-query-container', function() {
        input('#js-search-query.search-query', {
          type: 'text'
        });
        div('js-clear-search-query clear-search-query-button hidden', '');
        div('js-show-search-menu show-search-menu-button', '');
        div('#js-run-search.search-icon', '');
        return span('js-topic-filter-label topic-filter-label', '');
      });
      return div('js-search-menu search-menu hidden', function() {
        div('tags-block', function() {
          return div('js-tags-block', function() {
            return span('You have no #tags');
          });
        });
        hr('');
        return div('js-topic-filter topic-filter', function() {
          var cl, first, tt, _i, _len, _ref, _results;
          first = true;
          _ref = this.topicTypes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            tt = _ref[_i];
            cl = first ? 'active' : '';
            a(cl, {
              href: '#',
              'data-value': tt.value,
              'data-text': tt.text
            }, tt.text);
            _results.push(first = false);
          }
          return _results;
        });
      });
    });
    return div('#js-search-results.search-results', '');
  };

  topicTmpl = function() {
    var unread, unreadCount, waveId;
    unreadCount = this.item.totalUnreadBlipCount;
    unread = '';
    if (unreadCount) unread = '.unread';
    waveId = h(this.item.waveId);
    return a(".js-search-result.search-result-item" + (h(unread)), {
      id: this.item.id,
      href: "" + (h(this.prefix)) + waveId + "/"
    }, function() {
      div('.js-unread-blips-indicator.unread-blips-indicator', function() {
        var len;
        len = this.item.unreadLineLen;
        return div('', {
          style: "height: " + (h(len)) + "%"
        }, '');
      });
      div(".js-text-content.text-content", function() {
        return div('.wave-title', function() {
          var snippet;
          span(h(this.item.title));
          snippet = ' ' + this.item.snippet;
          br('', '');
          return span('.item-snippet', h(snippet));
        });
      });
      div('.js-wave-info.wave-info', function() {
        button('.js-follow.follow.button', h(this.item.followButtonText));
        return div('.js-info.info', function() {
          var avatar, nameTitle;
          nameTitle = '';
          if (this.item.name != null) nameTitle = this.item.name;
          avatar = '/s/img/user/unknown.png';
          if ((this.item.avatar != null) && this.item.avatar !== '') {
            avatar = this.item.avatar;
          }
          div('.last-editing.avatar', {
            style: "background-image: url(" + (h(avatar)) + ")",
            title: h(nameTitle)
          }, h(this.item.initials));
          return div('.last-changed', {
            title: h(this.item.fullChangeDate)
          }, h(this.item.changeDate));
        });
      });
      return div('.clearer', '');
    });
  };

  tagListTmpl = function() {
    var hTag, tag, _i, _len, _ref, _results;
    _ref = this.tags;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      tag = _ref[_i];
      hTag = "#" + (h(tag));
      _results.push(a({
        href: '#',
        'data-tag': hTag
      }, "" + hTag + " "));
    }
    return _results;
  };

  exports.renderHeader = ck.compile(searchPanelTmpl);

  exports.renderResultItem = ck.compile(topicTmpl);

  exports.renderTagList = ck.compile(tagListTmpl);

}).call(this);

});

require.define("/lib/client/client/modules/wave.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var AccountSetupWizard, BrowserEvents, BrowserSupport, ChromeAppPopup, GOOGLE_CLIENT_ID, History, KeyCodes, LinkedinPopup, LocalStorage, MicroEvent, Request, TopicCreatingMaster, UrlUtil, WAVE_SHARED_STATE_PUBLIC, Wave, WaveBase, WaveError, WaveMessage, WaveViewModel, WaveWarning, getGDriveTopicCreationUrl, logOut, renderCommonCreateButton, renderDifferenceCreateButtons, renderGDriveCreateButton, renderLikesForAnonymousPublic, socialUtil, trackTopicCreatedAndUserAdded, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  WaveBase = require('./wave_base').WaveBase;

  WaveViewModel = require('../wave/index').WaveViewModel;

  WaveWarning = require('../wave/notification/warning').WaveWarning;

  WaveError = require('../wave/notification/error').WaveError;

  WaveMessage = require('../wave/message').WaveMessage;

  WAVE_SHARED_STATE_PUBLIC = require('../wave/model').WAVE_SHARED_STATE_PUBLIC;

  renderLikesForAnonymousPublic = require('../wave/template').renderLikesForAnonymousPublic;

  Request = require('../../share/communication').Request;

  MicroEvent = require('../utils/microevent');

  BrowserSupport = require('../utils/browser_support');

  BrowserEvents = require('../utils/browser_events');

  KeyCodes = require('../utils/key_codes').KeyCodes;

  History = require('../utils/history_navigation');

  UrlUtil = require('../utils/url');

  TopicCreatingMaster = require('../creating_topic_wizard').TopicCreatingMaster;

  _ref = require('../creating_topic_wizard/template'), renderDifferenceCreateButtons = _ref.renderDifferenceCreateButtons, renderCommonCreateButton = _ref.renderCommonCreateButton, renderGDriveCreateButton = _ref.renderGDriveCreateButton;

  ChromeAppPopup = require('../chrome_app_popup').ChromeAppPopup;

  LinkedinPopup = require('../linkedin_popup').LinkedinPopup;

  AccountSetupWizard = require('../account_setup_wizard').AccountSetupWizard;

  logOut = require('../wave/notification/log_out').logOut;

  LocalStorage = require('../utils/localStorage').LocalStorage;

  socialUtil = require('../utils/social');

  trackTopicCreatedAndUserAdded = require('../analytics/ping').trackTopicCreatedAndUserAdded;

  GOOGLE_CLIENT_ID = window.GOOGLE_CLIENT_ID;

  getGDriveTopicCreationUrl = function() {
    var origin, params, redirect, scopes, url;
    origin = "" + location.protocol + "//" + location.host;
    url = "https://accounts.google.com/o/oauth2/auth?";
    scopes = "scope=" + encodeURIComponent("https://www.googleapis.com/auth/drive.file " + "https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile");
    params = ("&client_id=" + GOOGLE_CLIENT_ID + "&response_type=code&access_type=offline") + "&state=" + encodeURIComponent('{"action":"create"}');
    redirect = "&redirect_uri=" + encodeURIComponent("" + origin + "/drive-create");
    return url + scopes + params + redirect;
  };

  Wave = (function(_super) {
    var HIDE_WIZARD_COOKIE;

    __extends(Wave, _super);

    HIDE_WIZARD_COOKIE = "h_w_c";

    function Wave(rootRouter) {
      this._updateViewSwitchButtonsState = __bind(this._updateViewSwitchButtonsState, this);
      this._processURLChange = __bind(this._processURLChange, this);
      this._processCreateWaveWithThisTeamResponse = __bind(this._processCreateWaveWithThisTeamResponse, this);
      this._processCreateWaveByWizardResponse = __bind(this._processCreateWaveByWizardResponse, this);
      this.__showWaveCreatingError = __bind(this.__showWaveCreatingError, this);
      this.__showWaveLoadingError = __bind(this.__showWaveLoadingError, this);
      this.__showWave = __bind(this.__showWave, this);
      this._updateLoginUrl = __bind(this._updateLoginUrl, this);
      this.__initCreateButtons = __bind(this.__initCreateButtons, this);
      this.__renderCreateButtons = __bind(this.__renderCreateButtons, this);
      this._createTopicMaster = __bind(this._createTopicMaster, this);
      this.openAndInitAccountWizard = __bind(this.openAndInitAccountWizard, this);
      this._getUserContacts = __bind(this._getUserContacts, this);      this._$waveContainer = $('.js-wave-container');
      this._addParticipantToPublicFlag = true;
      Wave.__super__.constructor.call(this, rootRouter, this._$waveContainer[0]);
      if (!module.exports.instance) module.exports.instance = this;
      this._waveProcessor = require('../wave/processor').instance;
      this._topicMaster = null;
      if (!BrowserSupport.isSupported() || !window.loggedIn) {
        $('.js-create-wave').attr('disabled', 'disabled');
      }
      this._welcomeTopicLoading = false;
      this._topicsCreatedByWizard = {};
      this._topicsCreatedWithThisTeam = {};
      this._createWaveButtons = $('.js-create-wave-buttons');
      this._tabsContainer = $(".js-tabs-container");
      this.__init();
    }

    Wave.prototype.__init = function() {
      this._initViewSwitchButtons();
      this._initTopicTips();
      this.__initLoadContacts();
      this.__renderCreateButtons();
      this.__initEvents();
      this.__initContactsUpdater();
      this._initHistory();
      this._initAnalytics();
      this._initAccountWizardOptions();
      this._openWelcomeWave();
      this._openTeamTopicWave();
      this._initLinkClick(this._$waveContainer);
      LocalStorage.increaseLoginCount();
      this._initChromeAppPopup();
      this._initLinkedinPopup();
      this._notificationsContainer = $('.js-wave-notifications')[0];
      return $('body').on('click', '.js-logout', function(e) {
        e.stopPropagation();
        e.preventDefault();
        return logOut();
      });
    };

    Wave.prototype._getUserContacts = function() {
      var _this = this;
      return this._waveProcessor.getUserContacts(function(err, users) {
        if (err || !users) return console.warn('Failed to load contacts', err);
      }, true);
    };

    Wave.prototype.__initLoadContacts = function() {
      this._getUserContacts();
      return setTimeout(this._getUserContacts, 120000);
    };

    Wave.prototype._initChromeAppPopup = function() {
      if (!(window.userInfo != null)) return;
      if (BrowserSupport.isDesktopChrome() && window.firstSessionLoggedIn && (LocalStorage.getLoginCount() === 3)) {
        return new ChromeAppPopup();
      }
    };

    Wave.prototype._initLinkedinPopup = function() {
      var loginCount;
      if (!(window.userInfo != null)) return;
      loginCount = LocalStorage.getLoginCount();
      if ((loginCount != null) && loginCount < 6) return;
      if (!window.firstSessionLoggedIn) return;
      if (!LocalStorage.getLinkedinPopupShowed()) return new LinkedinPopup();
    };

    Wave.prototype._initAccountWizardOptions = function() {
      var urlParams;
      window.showAccountSelectionBanner = window.showAccountSelectionWizard && window.loggedIn && !window.firstSessionLoggedIn;
      urlParams = History.getUrlParams(window.location.pathname);
      if (!window.showAccountSelectionWizard || !window.firstSessionLoggedIn || urlParams.waveId) {
        return;
      }
      return this.openAndInitAccountWizard();
    };

    Wave.prototype.openAndInitAccountWizard = function() {
      var _this = this;
      this._saw = new AccountSetupWizard(this._waveProcessor);
      return this._saw.on('closeAndOpenTopic', function(waveId) {
        _this._saw.destroy();
        if (waveId != null) return History.navigateTo(waveId);
      });
    };

    Wave.prototype._initAnalytics = function() {
      return $(document.body).delegate('.js-local-next-unread', 'click', function() {
        return _gaq.push(['_trackEvent', 'Topic content', 'Next unread click', 'Next unread message']);
      });
    };

    Wave.prototype._initLinkClick = function($container) {
      return $container.on('click', 'a', function(event) {
        var contenteditable, editorParent, inLinkPopup, urlParams;
        if (event.which !== 1 || event.ctrlKey || event.metaKey) return;
        inLinkPopup = $(event.target).closest('.js-link-anchor').length !== 0;
        editorParent = $(event.target).parent().parent('.js-editor');
        if (editorParent.length === 0 && !inLinkPopup) return;
        if (editorParent.attr('contenteditable') != null) {
          contenteditable = editorParent.attr('contenteditable');
        }
        if (contenteditable != null) contenteditable = contenteditable === 'true';
        if (!inLinkPopup && contenteditable) return;
        urlParams = History.getUrlParams(event.currentTarget.href);
        if (urlParams.host && urlParams.waveId) {
          History.navigateTo(urlParams.waveId, urlParams.serverBlipId);
          event.preventDefault();
        } else {
          $(event.currentTarget).attr('target', '_blank');
        }
        return event.stopPropagation();
      });
    };

    Wave.prototype._initHistory = function() {
      History.on('statechange', this._processURLChange);
      return History.init(this._processURLChange);
    };

    Wave.prototype.__initContactsUpdater = function() {
      var _this = this;
      return window.updateContacts = function(contacts) {
        contacts = JSON.parse(contacts);
        return _this._waveProcessor.updateUserContacts(contacts);
      };
    };

    Wave.prototype._createTopicMaster = function(e, analyticsProp) {
      if (analyticsProp == null) analyticsProp = 'other button';
      e.stopPropagation();
      if (this._topicMaster) {
        if (this._topicMaster.getContainer().is(':visible')) {
          return this._topicMaster.hide();
        } else {
          this._topicMaster.setPosition(e.currentTarget);
          this._topicMaster.show();
          return _gaq.push(['_trackEvent', 'Wizard usage', 'Show wizard', analyticsProp]);
        }
      } else {
        this._topicMaster = new TopicCreatingMaster($(document.body)[0], e.currentTarget, this, this._waveProcessor, this._processCreateWaveByWizardResponse, this.__initCreateButtons, this.__renderCreateButtons, HIDE_WIZARD_COOKIE);
        return _gaq.push(['_trackEvent', 'Wizard usage', 'Show wizard', analyticsProp]);
      }
    };

    Wave.prototype.__renderCreateButtons = function() {
      this._createWaveButtons.empty();
      if (History.isGDrive()) {
        return this._createWaveButtons.append(renderGDriveCreateButton({
          url: getGDriveTopicCreationUrl()
        }));
      }
      if ($.cookie(HIDE_WIZARD_COOKIE)) {
        return this._createWaveButtons.append(renderDifferenceCreateButtons());
      } else {
        return this._createWaveButtons.append(renderCommonCreateButton());
      }
    };

    Wave.prototype.__initEvents = function() {
      /*
              Подписывается на события, вызываемые в результате действий пользователя
      */      document.body.addEventListener(BrowserEvents.FOCUS_EVENT, function() {
        var selection;
        selection = window.getSelection();
        if (selection) return selection.removeAllRanges();
      }, false);
      if (BrowserSupport.isMozilla()) {
        document.addEventListener(BrowserEvents.KEY_DOWN_EVENT, function(event) {
          if (event.keyCode !== KeyCodes.KEY_ESCAPE) return;
          return event.preventDefault();
        }, false);
      }
      if (BrowserSupport.isSupported() && window.loggedIn) {
        this.__initCreateButtons();
      }
      document.body.spellcheck = false;
      return $(window).bind('load', this._updateLoginUrl);
    };

    Wave.prototype.__initCreateButtons = function() {
      var _this = this;
      this._tabsContainer.find(".js-create-wave").off("click");
      $(".js-create-wave-by-wizard").off("click");
      this._$waveContainer.off("click.createWave");
      if ($.cookie(HIDE_WIZARD_COOKIE)) {
        this._tabsContainer.find(".js-create-wave").on("click", function(e) {
          return _this.__createWaveButtonHandler(e, 'By common button');
        });
        this._$waveContainer.on("click.createWave", ".js-create-wave", function(e) {
          return _this.__createWaveButtonHandler(e, 'By button when empty');
        });
      } else {
        this._tabsContainer.find(".js-create-wave").on("click", function(event) {
          return $(".js-create-wave-by-wizard").trigger('click', 'common');
        });
        this._$waveContainer.on("click.createWave", ".js-create-wave", function(event) {
          return $(".js-create-wave-by-wizard").trigger('click', 'when empty');
        });
      }
      return $(".js-create-wave-by-wizard").on("click", this._createTopicMaster);
    };

    Wave.prototype._openAuthWindow = function(source, redirectUrl, e) {
      var contactsUpdateWindowParams, params;
      e.preventDefault();
      e.stopPropagation();
      contactsUpdateWindowParams = require('../wave/processor').contactsUpdateWindowParams;
      params = contactsUpdateWindowParams[source];
      return window.open("/auth/" + source + "/?url=" + (encodeURIComponent(redirectUrl)), 'Loading', "width=" + params.width + ",height=" + params.height);
    };

    Wave.prototype._updateLoginUrl = function() {
      /*
              Обновляет ссылку для входа,
      */
      var redirectUrl,
        _this = this;
      redirectUrl = History.getLoginRedirectUrl();
      if (History.isEmbedded()) {
        window.AuthDialog.setNext(location.pathname);
        $('.js-google-login-link').off('click').on('click', function(e) {
          return _this._openAuthWindow('google', redirectUrl, e);
        });
        return $('.js-facebook-login-link').off('click').on('click', function(e) {
          return _this._openAuthWindow('facebook', redirectUrl, e);
        });
      } else {
        return window.AuthDialog.setNext(redirectUrl);
      }
    };

    Wave.prototype.__showWave = function(waveData, waveBlips, socialSharingUrl) {
      /*
              Отображает волну
              @param err: object, ошибка
              @param waveData: object, данные, необходимые для работы волны
              @param socialSharingUrl: String для формирования урла публикации волны
      */
      var urlWaveId, _ref2, _ref3;
      urlWaveId = ((_ref2 = History.getUrlParams(location.href)) != null ? _ref2.waveId : void 0) || '';
      if (this.__curWave && ((_ref3 = this.__curWave.getModel()) != null ? _ref3.serverId : void 0) === urlWaveId) {
        return this.__curWave;
      }
      this.__closeCurWave();
      this.__curWave = new WaveViewModel(this._waveProcessor, waveData, waveBlips, socialSharingUrl, this);
      this._curView = this.__curWave.getView();
      this._showNextTip();
      this._$waveContainer.find('.js-wave-notifications .js-wave-error').remove();
      this._$waveContainer.find('.js-wave-notifications .js-wave-warning').remove();
      this._curView.on('wave-view-change', this._updateViewSwitchButtonsState);
      this.emit('wave-change', this.__curWave);
      return this.__curWave;
    };

    Wave.prototype.__showWaveLoadingError = function(err, waveId, serverBlipId) {
      var _this = this;
      this.__closeCurWave();
      this.__curMessage = new WaveMessage($('#wave')[0]);
      this.__curMessage.showLoadingError(err, waveId, function() {
        return _this.__openWave(waveId, serverBlipId);
      });
      return this._updateLoginUrl();
    };

    Wave.prototype.__showWaveCreatingError = function(err, retry) {
      this.__closeCurWave();
      this.__curMessage = new WaveMessage($('#wave')[0]);
      return this.__curMessage.showCreatingError(err, retry);
    };

    Wave.prototype.createWaveWithParticipants = function(request) {
      /*
              Создает волну с указанными участниками текущей открытой волны
              @param request.args.userIds: Array
      */
      var doCreate, topicServerId, userIds,
        _this = this;
      topicServerId = this.__curWave.getModel().serverId;
      userIds = request.args.userIds;
      doCreate = function() {
        _this._waveProcessor.createWaveWithParticipants(topicServerId, userIds, function(err, waveId) {
          return _this._processCreateWaveWithThisTeamResponse(err, waveId, doCreate);
        });
        return _this.__showTopicCreatingWait();
      };
      return doCreate();
    };

    Wave.prototype._processCreateWaveByWizardResponse = function(err, waveId, retry) {
      if (!err) this._topicsCreatedByWizard[waveId] = true;
      return this.__processCreateWaveResponse(err, waveId, retry);
    };

    Wave.prototype._processCreateWaveWithThisTeamResponse = function(err, waveId, retry) {
      if (!err) this._topicsCreatedWithThisTeam[waveId] = true;
      return this.__processCreateWaveResponse(err, waveId, retry);
    };

    Wave.prototype.__processCreateWaveSuccessResponse = function(waveId) {
      if (this._topicMaster) this._topicMaster.destroy();
      this._topicMaster = null;
      return Wave.__super__.__processCreateWaveSuccessResponse.call(this, waveId);
    };

    Wave.prototype._processURLChange = function(waveId, serverBlipId) {
      /*
              Обрабатывает изменение url'а
      */
      var _ref2;
      if (!waveId) {
        if (!this.__openCount) this.__openCount += 1;
        this.__closeCurWave();
        if (!window.loggedIn) {
          window.AuthDialog.initAndShow(false, History.getLoginRedirectUrl());
        } else {
          _gaq.push(['_trackPageview']);
          if (window.cleanupAnalytics && document.location.search) {
            _gaq.push(window.cleanupAnalytics);
          }
          this.__curMessage = new WaveMessage($('#wave')[0]);
          this.__curMessage.showCreateTopicButton();
        }
        this._addParticipantToPublicFlag = false;
        return;
      }
      if (((_ref2 = this.__curWave) != null ? _ref2.getModel().serverId : void 0) === waveId) {
        if (serverBlipId) return this.__activateBlip(this.__curWave, serverBlipId);
      } else {
        return this.__openWave(waveId, serverBlipId);
      }
    };

    Wave.prototype.__openWave = function(waveId, serverBlipId) {
      /*
              Открывает волну с указанным waveId и пролистывает к блипу
              с serverBlipId, если он указан
      */      this.__showTopicLoadingWait();
      return Wave.__super__.__openWave.call(this, waveId, serverBlipId);
    };

    Wave.prototype.__showLikeButtons = function() {
      var $publicLikesContainer, prevAI, _subscribe;
      socialUtil.addFacebookScript();
      $publicLikesContainer = $('.js-right-logo-public-likes');
      if ($publicLikesContainer.children().length >= 3) return;
      $publicLikesContainer.append(renderLikesForAnonymousPublic());
      _subscribe = function() {
        return FB.Event.subscribe('edge.create', function(targetUrl) {
          _gaq.push(['_trackSocial', 'facebook', 'Like', targetUrl, 'public anonymous']);
          return _gaq.push(['_trackEvent', 'Social', 'Like', 'public anonymous']);
        });
      };
      if (window.fbAsyncInit) {
        prevAI = window.fbAsyncInit;
        return window.fbAsyncInit = function() {
          prevAI();
          return _subscribe();
        };
      } else {
        return window.fbAsyncInit = function() {
          return _subscribe();
        };
      }
    };

    Wave.prototype.__processWaveLoadedEvent = function(curWave, waveId, serverBlipId) {
      var countExisting, countNew, reason, user, userType, users, _i, _len, _ref2;
      if (this.__newWave || UrlUtil.getQuery().enableEditMode === '1') {
        curWave.getView().setEditModeEnabled(true);
      }
      Wave.__super__.__processWaveLoadedEvent.call(this, curWave, waveId, serverBlipId);
      if (!window.loggedIn) $('.js-anonymous-notification-container').remove();
      if (this._welcomeTopicLoading && (window.ymId != null) && window.ymId) {
        window["yaCounter" + window.ymId].hit(window.History.getState().cleanUrl, null, null);
        this._welcomeTopicLoading = false;
      }
      if (this._topicsCreatedByWizard[waveId] || this._topicsCreatedWithThisTeam[waveId]) {
        users = this.__curWave.getParticipants();
        countNew = 0;
        countExisting = 0;
        for (_i = 0, _len = users.length; _i < _len; _i++) {
          user = users[_i];
          if (user.getId() !== ((_ref2 = window.userInfo) != null ? _ref2.id : void 0)) {
            if (user.isNewUser()) {
              countNew++;
            } else {
              countExisting++;
            }
          }
        }
        if (this._topicsCreatedByWizard[waveId]) {
          reason = 'By wizard';
        } else {
          reason = 'By create with this team';
        }
        if (countNew > 0) {
          _gaq.push(['_trackEvent', 'Topic participants', 'Add participant new', reason, countNew]);
        }
        if (countExisting > 0) {
          _gaq.push(['_trackEvent', 'Topic participants', 'Add participant existing', reason, countExisting]);
        }
        if (countNew * countExisting > 0) {
          userType = 'new and existing';
        } else if (countNew > 0) {
          userType = 'new';
        } else {
          userType = 'existing';
        }
        if (countNew + countExisting > 0) {
          mixpanel.track("Add participant", {
            "participant type": userType,
            "added via": reason,
            "count": countNew + countExisting,
            "count new": countNew,
            "count existing": countExisting
          });
        }
        if (countNew > 0) {
          trackTopicCreatedAndUserAdded(countNew, 0);
          LocalStorage.incUsersAdded(countNew);
        }
        delete this._topicsCreatedByWizard[waveId];
        delete this._topicsCreatedWithThisTeam[waveId];
      }
      this.__addParticipantToPublic(curWave);
      if (document.location.search && window.cleanupAnalytics) {
        _gaq.push(window.cleanupAnalytics);
      }
      return this._updateLoginUrl();
    };

    Wave.prototype.__addParticipantToPublic = function(curWave) {
      if (this._addParticipantToPublicFlag && window.justLoggedIn && (window.userInfo != null) && curWave.getModel().getSharedState() === WAVE_SHARED_STATE_PUBLIC && !curWave.getView().isExistParticipant(window.userInfo.email)) {
        this._waveProcessor.addParticipant(curWave.getModel().serverId, window.userInfo.email, curWave.getModel().getDefaultRole(), curWave.getView().processAddParticipantResponse);
      }
      return this._addParticipantToPublicFlag = false;
    };

    Wave.prototype._openWelcomeWave = function() {
      var urlParams;
      urlParams = History.getUrlParams(window.location.pathname);
      if (window.welcomeWaves && window.welcomeWaves.length && !urlParams.waveId) {
        _gaq.push(['_setCustomVar', 4, 'videowizard', 'notshowvideo', 2]);
        this._welcomeTopicLoading = true;
        return History.navigateTo(window.welcomeWaves[0].waveId);
      }
    };

    Wave.prototype._openTeamTopicWave = function() {
      var lastCollectionTopicId, topicUrl, urlParams;
      if (window.welcomeWaves && window.welcomeWaves.length) return;
      if (!window.userInfo) return;
      if (!window.userInfo.teamTopics) return;
      urlParams = History.getUrlParams(window.location.pathname);
      if (window.userInfo.teamTopics.topics && window.userInfo.teamTopics.topics.length !== 0 && !urlParams.waveId) {
        lastCollectionTopicId = LocalStorage.getLastCollectionTopicId();
        topicUrl = lastCollectionTopicId || window.userInfo.teamTopics.topics[0].url;
        return History.navigateTo(topicUrl);
      }
    };

    Wave.prototype._showNextTip = function(force) {
      if (force == null) force = false;
      if (!this._tips.length) return;
      if (!(this._curView.showTip != null)) return;
      this._curView.showTip(this._tips[this._tipNumToShow].text, this._lastTipDate, force);
      return this._tipNumToShow = (this._tipNumToShow + 1) % this._tips.length;
    };

    Wave.prototype.showNextTip = function(request) {
      return this._showNextTip(request.args.force);
    };

    Wave.prototype._initTopicTips = function() {
      var _ref2, _ref3;
      this._tips = [];
      if (!((_ref2 = window.tipList) != null ? (_ref3 = _ref2.tips) != null ? _ref3.length : void 0 : void 0)) {
        return;
      }
      this._tips = window.tipList.tips;
      this._tips.sort(function(a, b) {
        return b.creationDate - a.creationDate;
      });
      this._tipNumToShow = 0;
      return this._lastTipDate = this._tips[0].creationDate;
    };

    Wave.prototype._initViewSwitchButtons = function() {
      var _this = this;
      this._$rightToolsPanel = $('.js-right-tools-panel');
      this._$rightToolsPanel.find('.js-text-view').click(function() {
        var _ref2;
        return (_ref2 = _this.__curWave) != null ? _ref2.getView().setTextView() : void 0;
      });
      this._$rightToolsPanel.find('.js-mindmap-view').click(function() {
        var _ref2;
        return (_ref2 = _this.__curWave) != null ? _ref2.getView().setMindmapView() : void 0;
      });
      this._$rightToolsPanel.find('.js-mindmap-short-view').click(function() {
        var _ref2;
        _this._$mindmapSwitchButtonContainer.removeClass('long-mindmap-view');
        return (_ref2 = _this.__curWave) != null ? _ref2.getView().setShortMindmapView() : void 0;
      });
      this._$rightToolsPanel.find('.js-mindmap-long-view').click(function() {
        var _ref2;
        _this._$mindmapSwitchButtonContainer.addClass('long-mindmap-view');
        return (_ref2 = _this.__curWave) != null ? _ref2.getView().setLongMindmapView() : void 0;
      });
      return this._$mindmapSwitchButtonContainer = this._$rightToolsPanel.find('.js-mindmap-view-switch-buttons');
    };

    Wave.prototype._updateViewSwitchButtonsState = function() {
      var curView, _ref2;
      curView = (_ref2 = this.__curWave) != null ? _ref2.getView().getCurView() : void 0;
      if (curView === 'mindmap') {
        this._$rightToolsPanel.addClass('mindmap-view');
        this._$mindmapSwitchButtonContainer.removeClass('unvisible');
      } else {
        this._$rightToolsPanel.removeClass('mindmap-view');
        this._$mindmapSwitchButtonContainer.addClass('unvisible');
      }
      if (!(this.__curWave != null)) {
        return this._$mindmapSwitchButtonContainer.removeClass('long-mindmap-view');
      }
    };

    Wave.prototype.__closeCurWave = function() {
      if (this.__curWave != null) this.emit('wave-close', this.__curWave);
      Wave.__super__.__closeCurWave.call(this);
      this._updateViewSwitchButtonsState();
      return this.emit('wave-change', null);
    };

    Wave.prototype.showWaveWarning = function(message) {
      /*
              Показывает предупреждение, связанное с волной
              @param err: object
      */
      var warnings;
      warnings = $(this._notificationsContainer).find('.js-wave-warning');
      if (warnings.length >= 5) $(warnings[0]).remove();
      $(this._notificationsContainer).append(new WaveWarning(message).getContainer());
      $(window).trigger('resize');
      return console.warn(message);
    };

    Wave.prototype.showWaveError = function(err) {
      /*
              Показывает ошибку, связанную с волной
              @param err: object
      */
      var errors, waveError;
      waveError = new WaveError(err);
      errors = $(this._notificationsContainer).find('.js-wave-error');
      if (errors.length >= 5) $(errors[0]).remove();
      $(this._notificationsContainer).append(waveError.getContainer());
      $(window).trigger('resize');
      console.error("Wave error occurred");
      return console.error(err.stack);
    };

    Wave.prototype.__showTopicCreatingWait = function() {
      this.__closeCurWave();
      this.__curMessage = new WaveMessage($('#wave')[0]);
      return this.__curMessage.showCreatingWait();
    };

    Wave.prototype.__showTopicLoadingWait = function() {
      this.__closeCurWave();
      this.__curMessage = new WaveMessage($('#wave')[0]);
      return this.__curMessage.showLoadingWait();
    };

    return Wave;

  })(WaveBase);

  MicroEvent.mixin(Wave);

  module.exports.Wave = Wave;

}).call(this);

});

require.define("/lib/client/client/wave/message.js",function(require,module,exports,__dirname,__filename,process,global){
/*
Класс для отображения сообщений на месте топика
*/

(function() {
  var AccountMenu, AccountMergePopup, History, NEED_MERGE_ERROR_CODE, WAVE_ANONYMOUS_PERMISSION_DENIED_ERROR_CODE, WAVE_DOCUMENT_DOES_NOT_EXISTS_ERROR_CODE, WAVE_PERMISSION_DENIED_ERROR_CODE, WaveMessage, WaveMessageMobile, ck, renderAccessDeniedLoadingError, renderCommonLoadingError, renderCreateTopicMessage, renderCreatingError, renderCreatingWait, renderLoadingWait, renderMessage, renderMessageBodyMobile, renderNotFoundLoadingError, renderWaveHeaderMobile, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  History = require('../utils/history_navigation');

  AccountMergePopup = require('../account_merge').AccountMergePopup;

  AccountMenu = require('./account_menu').AccountMenu;

  renderWaveHeaderMobile = require('./template').renderWaveHeaderMobile;

  _ref = require('../../share/constants'), WAVE_PERMISSION_DENIED_ERROR_CODE = _ref.WAVE_PERMISSION_DENIED_ERROR_CODE, NEED_MERGE_ERROR_CODE = _ref.NEED_MERGE_ERROR_CODE, WAVE_DOCUMENT_DOES_NOT_EXISTS_ERROR_CODE = _ref.WAVE_DOCUMENT_DOES_NOT_EXISTS_ERROR_CODE, WAVE_ANONYMOUS_PERMISSION_DENIED_ERROR_CODE = _ref.WAVE_ANONYMOUS_PERMISSION_DENIED_ERROR_CODE;

  ck = window.CoffeeKup;

  renderMessage = ck.compile(function() {
    return div('.topic-message-container.js-topic-message-container', '');
  });

  renderCreatingWait = ck.compile(function() {
    return div('.message-container', function() {
      div('.wait-icon', {
        title: 'Creating topic'
      });
      return div('Creating topic');
    });
  });

  renderLoadingWait = ck.compile(function() {
    return div('.message-container', function() {
      div('.wait-icon', {
        title: 'Loading topic'
      });
      return div('Loading topic');
    });
  });

  renderCommonLoadingError = ck.compile(function() {
    return div('.message-container', function() {
      div('.reload-icon', {
        title: 'Reload topic'
      });
      div(h(this.error.message || 'Some error occurred while loading') + '.');
      return div('', function() {
        if (this.error.logId) text("Error code " + (h(this.error.logId)) + ". ");
        text('Please, ');
        button('.js-reload-topic-button', 'reload topic');
        return text('.');
      });
    });
  });

  renderAccessDeniedLoadingError = ck.compile(function() {
    return div('.message-container.js-access-denied-container', function() {
      div('.lock-icon', {
        title: 'Access denied'
      });
      div('You need permission to join this topic');
      button('.js-ask-for-access-button.ask-for-access-button', 'Ask for access');
      return div('.asked-for-access-container', function() {
        text('You asked for access. ');
        button('.js-reload-topic-button', 'Reload');
        return text('.');
      });
    });
  });

  renderNotFoundLoadingError = ck.compile(function() {
    return div('.message-container', function() {
      div('.attention-icon', {
        title: 'Topic not found'
      });
      return div('Requested topic not found');
    });
  });

  renderCreatingError = ck.compile(function() {
    return div('.message-container', function() {
      div('.attention-icon', {
        title: 'Topic was not created'
      });
      div(h(this.error.message || 'Some error occurred while creating topic') + '.');
      return div('', function() {
        if (this.error.logId) text("Error code " + (h(this.error.logId)) + ". ");
        button('.js-retry-create-button', 'Retry');
        return text('.');
      });
    });
  });

  renderCreateTopicMessage = ck.compile(function() {
    return div('.message-container', function() {
      div('Select topic from list or create new topic');
      return button('.js-create-wave.create-wave', {
        title: "Create new topic"
      }, 'Create new topic');
    });
  });

  renderMessageBodyMobile = ck.compile(function() {
    return section('.topic-message-container.js-topic-message-container', '');
  });

  WaveMessage = (function() {

    function WaveMessage(container) {
      this.container = container;
      this._createDOM();
      this._initAccountMenu();
    }

    WaveMessage.prototype._preprocessError = function(error) {
      if (error.type === 'InternalError') return delete error.message;
    };

    WaveMessage.prototype._createDOM = function() {
      var c;
      c = $(this.container);
      c.empty();
      c.append(renderMessage());
      return this._$messageContainer = c.find('.js-topic-message-container');
    };

    WaveMessage.prototype._initAccountMenu = function() {
      var menu;
      menu = new AccountMenu();
      return menu.render($('.js-account-container')[0]);
    };

    WaveMessage.prototype._replaceMessage = function(html) {
      this._$messageContainer.empty();
      return this._$messageContainer.html(html);
    };

    WaveMessage.prototype.showCreatingWait = function() {
      this._replaceMessage(renderCreatingWait());
      return this._$messageContainer.addClass('loading');
    };

    WaveMessage.prototype.showLoadingWait = function() {
      this._replaceMessage(renderLoadingWait());
      return this._$messageContainer.addClass('loading');
    };

    WaveMessage.prototype.showLoadingError = function(error, waveId, retry) {
      this._preprocessError(error);
      switch (error.code) {
        case WAVE_PERMISSION_DENIED_ERROR_CODE:
          this._showAccessDeniedLoadingError(waveId, retry);
          break;
        case WAVE_DOCUMENT_DOES_NOT_EXISTS_ERROR_CODE:
          this._showNotFoundLoadingError();
          break;
        case WAVE_ANONYMOUS_PERMISSION_DENIED_ERROR_CODE:
          this.__showAnonymousAccessDeniedLoadingError();
          break;
        case NEED_MERGE_ERROR_CODE:
          this.__showNeedMergeLoadingError(error, retry);
          break;
        default:
          return this._showCommonLoadingError(error, retry);
      }
    };

    WaveMessage.prototype.showCreatingError = function(error, retry) {
      this._preprocessError(error);
      this._replaceMessage(renderCreatingError({
        error: error
      }));
      return this._$messageContainer.find('.js-retry-create-button').click(retry);
    };

    WaveMessage.prototype.showCreateTopicButton = function() {
      return this._replaceMessage(renderCreateTopicMessage());
    };

    WaveMessage.prototype._showCommonLoadingError = function(error, retry) {
      this._replaceMessage(renderCommonLoadingError({
        error: error
      }));
      return this._$messageContainer.find('.js-reload-topic-button').click(retry);
    };

    WaveMessage.prototype._showAccessDeniedLoadingError = function(waveId, retry) {
      var $accessContainer,
        _this = this;
      this._replaceMessage(renderAccessDeniedLoadingError());
      $accessContainer = this._$messageContainer.find('.js-access-denied-container');
      return this._$messageContainer.find('.js-ask-for-access-button').click(function() {
        _gaq.push(['_trackEvent', 'Topic participants', 'Let me in']);
        return require('../processor').instance.sendAccessRequest(waveId, function(err) {
          if (_this._destroyed) return;
          $accessContainer.addClass('asked-for-access');
          _this._$messageContainer.find('.js-reload-topic-button').click(retry);
          if (err) return console.log("Access request failed");
        });
      });
    };

    WaveMessage.prototype._showNotFoundLoadingError = function() {
      return this._replaceMessage(renderNotFoundLoadingError());
    };

    WaveMessage.prototype.__showAnonymousAccessDeniedLoadingError = function() {
      return window.AuthDialog.initAndShow(false, History.getLoginRedirectUrl());
    };

    WaveMessage.prototype.__showNeedMergeLoadingError = function(error) {
      return (new AccountMergePopup(error.message)).show();
    };

    WaveMessage.prototype.destroy = function() {
      $(this.container).empty();
      return this._destroyed = true;
    };

    return WaveMessage;

  })();

  WaveMessageMobile = (function(_super) {

    __extends(WaveMessageMobile, _super);

    function WaveMessageMobile() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._hide = __bind(this._hide, this);
      WaveMessageMobile.__super__.constructor.apply(this, args);
      this._initHeader();
    }

    WaveMessageMobile.prototype._createDOM = function() {
      var c;
      c = $(this.container);
      c.empty();
      c.append(renderWaveHeaderMobile() + renderMessageBodyMobile());
      return this._$messageContainer = c.find('.js-topic-message-container');
    };

    WaveMessageMobile.prototype._initHeader = function() {
      var _ref2;
      this._backButton = this.container.getElementsByClassName('js-back-button')[0];
      return (_ref2 = this._backButton) != null ? _ref2.addEventListener('click', this._hide, false) : void 0;
    };

    WaveMessageMobile.prototype._hide = function() {
      var _base;
      if (window.androidJSInterface) {
        return typeof (_base = window.androidJSInterface).onTopicBackButtonClick === "function" ? _base.onTopicBackButtonClick() : void 0;
      }
      History.navigateTo('', '');
      return require('../modules/wave_mobile').instance.hideWavePanel();
    };

    WaveMessageMobile.prototype.__showAnonymousAccessDeniedLoadingError = function() {
      return require('../session/module').Session.setAsLoggedOut();
    };

    WaveMessageMobile.prototype.__showNeedMergeLoadingError = function(error, retry) {
      var targetEmail;
      targetEmail = error.message;
      error.message = "You need permission to join this topic. Sign in as " + targetEmail + ".";
      return this._showCommonLoadingError(error, retry);
    };

    WaveMessageMobile.prototype.destroy = function() {
      var _ref2;
      if ((_ref2 = this._backButton) != null) {
        _ref2.removeEventListener('click', this._hide, false);
      }
      return WaveMessageMobile.__super__.destroy.call(this);
    };

    return WaveMessageMobile;

  })(WaveMessage);

  module.exports = {
    WaveMessage: WaveMessage,
    WaveMessageMobile: WaveMessageMobile
  };

}).call(this);

});

require.define("/lib/client/share/constants.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BONUS_TYPES, PROFILE_FIELDS, STORE_ITEM_CATEGORY, STORE_ITEM_STATE, _;

  _ = require('underscore');

  PROFILE_FIELDS = {
    PROFILE_FIELD_EMAIL: 'email',
    PROFILE_FIELD_NAME: 'name',
    PROFILE_FIELD_AVATAR: 'avatar',
    PROFILE_FIELD_TIMEZONE: 'timezone',
    PROFILE_FIELD_SOURCE: 'source'
  };

  BONUS_TYPES = {
    BONUS_TYPE_LINKEDIN_LIKE: 1,
    BONUS_TYPE_TEAM: 2
  };

  STORE_ITEM_CATEGORY = {
    /*
        Категории позиций в магазине.
    */
    STORE_ITEM_CATEGORY_GADGET: 1,
    STORE_ITEM_CATEGORY_BROWSER_EXTENSION: 2
  };

  STORE_ITEM_STATE = {
    /*
        Статусы позиций.
    */
    STORE_ITEM_STATE_HIDDEN: 1,
    STORE_ITEM_STATE_VISIBLE: 2
  };

  module.exports = {
    PROFILE_FIELDS: _.values(PROFILE_FIELDS),
    BONUS_TYPES: _.values(BONUS_TYPES),
    STORE_ITEM_CATEGORY: STORE_ITEM_CATEGORY,
    STORE_ITEM_STATE: STORE_ITEM_STATE,
    NEED_MERGE_ERROR_CODE: 'need_merge',
    WAVE_PERMISSION_DENIED_ERROR_CODE: 'wave_permission_denied',
    WAVE_DOCUMENT_DOES_NOT_EXISTS_ERROR_CODE: 'wave_document_does_not_exists',
    WAVE_ANONYMOUS_PERMISSION_DENIED_ERROR_CODE: 'wave_anonymous_permission_denied'
  };

  _.extend(module.exports, PROFILE_FIELDS, BONUS_TYPES, STORE_ITEM_CATEGORY, STORE_ITEM_STATE);

}).call(this);

});

require.define("/lib/client/client/modules/wave_mobile.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BrowserSupport, History, Request, SessionView, Wave, WaveBase, WaveError, WaveMessageMobile, WaveViewModel, WaveWarning, logOut,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  WaveBase = require('./wave_base').WaveBase;

  WaveViewModel = require('../wave/index_mobile').WaveViewModel;

  Request = require('../../share/communication').Request;

  BrowserSupport = require('../utils/browser_support_mobile');

  History = require('../utils/history_navigation');

  SessionView = require('../session/view').SessionViewMobile;

  logOut = require('../wave/notification/log_out').logOut;

  WaveError = require('../wave/notification/error').WaveError;

  WaveWarning = require('../wave/notification/warning').WaveWarning;

  WaveMessageMobile = require('../wave/message').WaveMessageMobile;

  Wave = (function(_super) {

    __extends(Wave, _super);

    function Wave(rootRouter) {
      this._processURLChange = __bind(this._processURLChange, this);
      this.__processCreateWaveResponse = __bind(this.__processCreateWaveResponse, this);
      this.__createWaveButtonHandler = __bind(this.__createWaveButtonHandler, this);
      this.__showWaveCreatingError = __bind(this.__showWaveCreatingError, this);
      this.__showWaveLoadingError = __bind(this.__showWaveLoadingError, this);
      this.__showWave = __bind(this.__showWave, this);      this._waveContainer = $('.js-wave-container');
      Wave.__super__.constructor.call(this, rootRouter, this._waveContainer[0]);
      module.exports.instance = this;
      this._waveProcessor = require('../wave/processor').instance;
      this._createWaveButton = document.getElementsByClassName('js-create-wave-button')[0];
      if (!BrowserSupport.isSupported() || !window.loggedIn) {
        this._createWaveButton.disabled = true;
      } else {
        this._createWaveButton.addEventListener('click', this.__createWaveButtonHandler, false);
      }
      this._initEvents();
      this._initHistory();
      this._openWelcomeWave();
      this._initLinkClick();
      this._notificationsContainer = $('.js-wave-notifications')[0];
    }

    Wave.prototype._initLinkClick = function() {
      return this._waveContainer.on('click', '.js-link-anchor', function(event) {
        var currentUrl, urlParams;
        if (event.which !== 1 || event.ctrlKey || event.metaKey) return;
        currentUrl = event.currentTarget.hrefOriginal;
        urlParams = History.getUrlParams(currentUrl);
        if (urlParams.host && urlParams.waveId) {
          History.navigateTo(urlParams.waveId, urlParams.serverBlipId);
          event.preventDefault();
        }
        return event.stopPropagation();
      });
    };

    Wave.prototype._initHistory = function() {
      var serverBlipId, waveId, _ref;
      History.on('statechange', this._processURLChange);
      History.init(this._processURLChange);
      if (History.analyticsRemoved) {
        _ref = History.getCurrentParams(), waveId = _ref.waveId, serverBlipId = _ref.serverBlipId;
        return this._processURLChange(waveId, serverBlipId);
      }
    };

    Wave.prototype._initEvents = function() {
      /*
              Подписывается на события, вызываемые в результате действий пользователя
      */      return document.body.addEventListener('focus', function(event) {
        var selection;
        selection = window.getSelection();
        if (selection) return selection.removeAllRanges();
      }, false);
    };

    Wave.prototype.__showWave = function(waveData, waveBlips, socialSharingUrl) {
      /*
              Отображает волну
              @param err: object, ошибка
              @param waveData: object, данные, необходимые для работы волны
              @param socialSharingUrl: String для формирования урла публикации волны
      */      this.__closeCurWave();
      this.__curWave = new WaveViewModel(this._waveProcessor, waveData, waveBlips, socialSharingUrl, this);
      this._curView = this.__curWave.getView();
      this._waveContainer.find('.js-wave-notifications .js-wave-error').remove();
      this._waveContainer.find('.js-wave-notifications .js-wave-warning').remove();
      return this.__curWave;
    };

    Wave.prototype.__showWaveLoadingError = function(err, waveId, serverBlipId) {
      /*
              Отображает сообщение об ошибке, которое не относится к текущему открытому топику
              @param err: object, ошибка
              @param waveId: string
      */
      var _this = this;
      this.__closeCurWave();
      this.__curMessage = new WaveMessageMobile($('#wave')[0]);
      return this.__curMessage.showLoadingError(err, waveId, function() {
        return _this.__openWave(waveId, serverBlipId);
      });
    };

    Wave.prototype.__showWaveCreatingError = function(err, retry) {
      this.__closeCurWave();
      this.__curMessage = new WaveMessageMobile($('#wave')[0]);
      return this.__curMessage.showCreatingError(err, retry);
    };

    Wave.prototype.createWaveWithParticipants = function(request) {
      /*
              Создает волну с указанными участниками текущей открытой волны
              @param request.args.userIds: Array
      */      return this._waveProcessor.createWaveWithParticipants(this.__curWave.getModel().serverId, request.args.userIds, this._processCreateWaveResponse);
    };

    Wave.prototype.__createWaveButtonHandler = function(e) {
      this._createWaveButton.disabled = true;
      this.showWavePanel();
      return Wave.__super__.__createWaveButtonHandler.call(this, e, 'By common button');
    };

    Wave.prototype.__processCreateWaveResponse = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._createWaveButton.disabled = false;
      return Wave.__super__.__processCreateWaveResponse.apply(this, args);
    };

    Wave.prototype._processURLChange = function(waveId, serverBlipId) {
      /*
              Обрабатывает изменение url'а
      */
      var _ref;
      SessionView.updateLoginUrls();
      if (waveId) {
        this.showWavePanel();
        if (((_ref = this.__curWave) != null ? _ref.getModel().serverId : void 0) === waveId) {
          if (serverBlipId) {
            return this.__activateBlip(this.__curWave, serverBlipId);
          }
        } else {
          return this.__openWave(waveId, serverBlipId);
        }
      } else {
        if (!this.__openCount) this.__openCount += 1;
        return this.hideWavePanel();
      }
    };

    Wave.prototype.__openWave = function(waveId, serverBlipId) {
      /*
              Открывает волну с указанным waveId и пролистывает к блипу
              с serverBlipId, если он указан
      */      SessionView.hide();
      this.__showTopicLoadingWait();
      return Wave.__super__.__openWave.call(this, waveId, serverBlipId);
    };

    Wave.prototype.__processWaveLoadedEvent = function(curWave, waveId, serverBlipId) {
      var needEditMode;
      needEditMode = this.__newWave || /(\?|&)enableEditMode=1(&|$)/.test(location.search) ? true : false;
      Wave.__super__.__processWaveLoadedEvent.call(this, curWave, waveId, serverBlipId);
      SessionView.updateLoginUrls();
      this._waveProcessor.getUserContacts(function() {});
      if (document.location.search && window.cleanupAnalytics) {
        _gaq.push(window.cleanupAnalytics);
      }
      if (needEditMode) return curWave.enableEditing();
    };

    Wave.prototype._openWelcomeWave = function() {
      var urlParams;
      urlParams = History.getUrlParams(window.location.pathname);
      if (window.welcomeWaves && window.welcomeWaves.length && !urlParams.waveId) {
        return History.navigateTo(window.welcomeWaves[0].waveId);
      }
    };

    Wave.prototype.showWavePanel = function() {
      document.getElementById('wave-panel').style.display = 'block';
      return document.getElementById('navigation-panel').style.display = 'none';
    };

    Wave.prototype.hideWavePanel = function() {
      var _ref;
      document.getElementById('wave-panel').style.display = 'none';
      document.getElementById('navigation-panel').style.display = 'block';
      return (_ref = require('../navigation/mobile').instance) != null ? _ref.scrollToActiveItem() : void 0;
    };

    Wave.prototype.showWaveWarning = function(message) {
      /*
              Показывает предупреждение, связанное с волной
              @param err: object
      */
      var warnings;
      warnings = $(this._notificationsContainer).find('.js-wave-warning');
      if (warnings.length >= 5) $(warnings[0]).remove();
      $(this._notificationsContainer).append(new WaveWarning(message).getContainer());
      return console.warn(message);
    };

    Wave.prototype.showWaveError = function(err) {
      /*
              Показывает ошибку, связанную с волной
              @param err: object
      */
      var errors, waveError;
      waveError = new WaveError(err);
      errors = $(this._notificationsContainer).find('.js-wave-error');
      if (errors.length >= 5) $(errors[0]).remove();
      $(this._notificationsContainer).append(waveError.getContainer());
      console.error("Wave error occurred");
      return console.error(err.stack);
    };

    Wave.prototype.__showTopicCreatingWait = function() {
      this.__closeCurWave();
      this.__curMessage = new WaveMessageMobile($('#wave')[0]);
      return this.__curMessage.showCreatingWait();
    };

    Wave.prototype.__showTopicLoadingWait = function() {
      this.__closeCurWave();
      this.__curMessage = new WaveMessageMobile($('#wave')[0]);
      return this.__curMessage.showLoadingWait();
    };

    return Wave;

  })(WaveBase);

  module.exports.Wave = Wave;

}).call(this);

});

require.define("/lib/client/client/wave/index_mobile.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var STATE_LOADED, WaveView, WaveViewModel, WaveViewModelBase, _ref,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  _ref = require('./index_base'), WaveViewModelBase = _ref.WaveViewModelBase, STATE_LOADED = _ref.STATE_LOADED;

  WaveView = require('./view_mobile').WaveView;

  WaveViewModel = (function(_super) {

    __extends(WaveViewModel, _super);

    function WaveViewModel() {
      WaveViewModel.__super__.constructor.apply(this, arguments);
    }

    WaveViewModel.prototype.__initView = function(processor, participants, container) {
      var Session;
      this.__view = new WaveView(this, processor, participants, container);
      Session = require('../session/module').Session;
      return this.__view.on('sign-in-click', function() {
        return Session.setAsLoggedOut();
      });
    };

    WaveViewModel.prototype.__initBlipProcessor = function() {
      return this.__blipProcessor = require('../blip/processor_mobile').instance;
    };

    WaveViewModel.prototype.setBlipAsRead = function(serverBlipId) {
      var _ref2;
      if (!this._unreadBlips.hasOwnProperty(serverBlipId)) return;
      WaveViewModel.__super__.setBlipAsRead.call(this, serverBlipId);
      if ((_ref2 = window.androidJSInterface) != null) {
        if (typeof _ref2.onBlipReadStateChange === "function") {
          _ref2.onBlipReadStateChange(this._model.serverId, serverBlipId, true);
        }
      }
      return this._processor.updateBlipIsRead(this._model.serverId, serverBlipId, true);
    };

    WaveViewModel.prototype.setBlipAsUnread = function(serverBlipId) {
      var _ref2;
      if (this._unreadBlips.hasOwnProperty(serverBlipId)) return;
      WaveViewModel.__super__.setBlipAsUnread.call(this, serverBlipId);
      if ((_ref2 = window.androidJSInterface) != null) {
        if (typeof _ref2.onBlipReadStateChange === "function") {
          _ref2.onBlipReadStateChange(this._model.serverId, serverBlipId, false);
        }
      }
      return this._processor.updateBlipIsRead(this._model.serverId, serverBlipId, false);
    };

    WaveViewModel.prototype.__updateUnreadBlipsCount = function() {
      var _ref2;
      if (this._state !== STATE_LOADED) return;
      WaveViewModel.__super__.__updateUnreadBlipsCount.call(this);
      if ((_ref2 = window.androidJSInterface) != null) {
        if (typeof _ref2.onBlipReadOrAdded === "function") {
          _ref2.onBlipReadOrAdded(this._model.serverId, this.getUnreadBlipsCount(), this.getTotalUsableBlipsCount());
        }
      }
      return this._processor.updateSearchUnreadCount(this._model.serverId, this.getUnreadBlipsCount(), this.getTotalUsableBlipsCount());
    };

    WaveViewModel.prototype.__updateTotalBlipsCount = function() {
      var _ref2;
      if (this._state !== STATE_LOADED) return;
      if ((_ref2 = window.androidJSInterface) != null) {
        if (typeof _ref2.onBlipReadOrAdded === "function") {
          _ref2.onBlipReadOrAdded(this._model.serverId, this.getUnreadBlipsCount(), this.getTotalUsableBlipsCount());
        }
      }
      return this._processor.updateSearchUnreadCount(this._model.serverId, this.getUnreadBlipsCount(), this.getTotalUsableBlipsCount());
    };

    return WaveViewModel;

  })(WaveViewModelBase);

  exports.WaveViewModel = WaveViewModel;

}).call(this);

});

require.define("/lib/client/client/wave/view_mobile.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipThread, BrowserEvents, BrowserSupport, COMMENT_PERMISSION, DOM, EDIT_PERMISSION, History, KeyEventInteractor, LineLevelParams, PRESERVED_RANGE, Participants, ROLE_NO_ROLE, ROLE_READER, Request, SCROLL_HEADER_TIMER, TextLevelParams, WaveError, WaveMobileViewBase, WaveView, WaveViewBase, popup, randomString, renderWaveMobile, transitions, _ref, _ref2, _ref3,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  WaveViewBase = require('./view_base');

  History = require('../utils/history_navigation');

  Participants = require('./participants/mobile').Participants;

  WaveError = require('./notification/error').WaveError;

  renderWaveMobile = require('./template').renderWaveMobile;

  DOM = require('../utils/dom');

  Request = require('../../share/communication').Request;

  popup = require('../popup').popup;

  randomString = require('../utils/random_string').randomString;

  _ref = require('../editor/model'), TextLevelParams = _ref.TextLevelParams, LineLevelParams = _ref.LineLevelParams;

  BrowserSupport = require('../utils/browser_support_mobile');

  BrowserEvents = require('../utils/browser_events');

  BlipThread = require('../blip/blip_thread').BlipThread;

  _ref2 = require('../blip/model'), EDIT_PERMISSION = _ref2.EDIT_PERMISSION, COMMENT_PERMISSION = _ref2.COMMENT_PERMISSION;

  KeyEventInteractor = require('./event_interactor').KeyEventInteractor;

  _ref3 = require('./participants/constants'), ROLE_READER = _ref3.ROLE_READER, ROLE_NO_ROLE = _ref3.ROLE_NO_ROLE;

  SCROLL_HEADER_TIMER = 250;

  transitions = ['webkitTransition', 'mozTransition', 'transition'];

  WaveMobileViewBase = (function(_super) {

    __extends(WaveMobileViewBase, _super);

    function WaveMobileViewBase() {
      this.__hideWavePanel = __bind(this.__hideWavePanel, this);      WaveMobileViewBase.__super__.constructor.call(this);
      this._backButton = null;
    }

    WaveMobileViewBase.prototype.__init = function(__waveViewModel, participants) {
      this.__waveViewModel = __waveViewModel != null ? __waveViewModel : null;
      if (participants == null) participants = null;
      this._editable = BrowserSupport.isSupported();
      this.__render();
      return this.__initWaveHeader(this.__waveViewModel, participants);
    };

    WaveMobileViewBase.prototype.__render = function() {};

    WaveMobileViewBase.prototype.__initWaveHeader = function(waveViewModel, participants) {
      var _ref4;
      this._backButton = this.container.getElementsByClassName('js-back-button')[0];
      return (_ref4 = this._backButton) != null ? _ref4.addEventListener('click', this.__hideWavePanel, false) : void 0;
    };

    WaveMobileViewBase.prototype.__hideWavePanel = function() {
      var _base;
      if (window.androidJSInterface) {
        return typeof (_base = window.androidJSInterface).onTopicBackButtonClick === "function" ? _base.onTopicBackButtonClick() : void 0;
      }
      History.navigateTo('', '');
      return require('../modules/wave_mobile').instance.hideWavePanel();
    };

    WaveMobileViewBase.prototype.destroy = function() {
      var _ref4;
      WaveMobileViewBase.__super__.destroy.call(this);
      return (_ref4 = this._backButton) != null ? _ref4.removeEventListener('click', this.__hideWavePanel, false) : void 0;
    };

    return WaveMobileViewBase;

  })(WaveViewBase);

  PRESERVED_RANGE = null;

  WaveView = (function(_super) {

    __extends(WaveView, _super);

    function WaveView(_waveViewModel, _waveProcessor, participants, container) {
      this._waveViewModel = _waveViewModel;
      this._waveProcessor = _waveProcessor;
      this.container = container;
      this._updateUnreadBlipsCount = __bind(this._updateUnreadBlipsCount, this);
      this._goToUnread = __bind(this._goToUnread, this);
      this._insertMention = __bind(this._insertMention, this);
      this._insertBlipButtonClick = __bind(this._insertBlipButtonClick, this);
      this._changeEditMode = __bind(this._changeEditMode, this);
      this.markActiveBlip = __bind(this.markActiveBlip, this);
      this._handleMouseDownEvent = __bind(this._handleMouseDownEvent, this);
      this.runCheckRange = __bind(this.runCheckRange, this);
      this._checkRange = __bind(this._checkRange, this);
      this._checkChangedRange = __bind(this._checkChangedRange, this);
      this._processCBlipCreateEvent = __bind(this._processCBlipCreateEvent, this);
      this._processCActivateEvent = __bind(this._processCActivateEvent, this);
      this._nextUnreadHandler = __bind(this._nextUnreadHandler, this);
      this._doScroll = __bind(this._doScroll, this);
      this._handleScroll = __bind(this._handleScroll, this);
      /*
              @param waveViewModel: WaveViewModel
              @param _waveProcessor: WaveProcessor
              @param participants: array, часть ShareJS-документа, отвечающего за участников
              @param container: HTMLNode, нода, в которой отображаться сообщению
      */
      WaveView.__super__.constructor.call(this);
      this.__init(this._waveViewModel, participants);
    }

    WaveView.prototype.__init = function(waveViewModel, participants) {
      this._model = waveViewModel.getModel();
      WaveView.__super__.__init.call(this, waveViewModel, participants);
      this._initEditingButtons();
      this._initRootBlip(waveViewModel);
      if (BrowserSupport.isSupported()) this._initRootMenu();
      return waveViewModel.on('unread-blips-count', this._updateUnreadBlipsCount);
    };

    WaveView.prototype._initRootMenu = function() {
      var replyButton,
        _this = this;
      replyButton = $(this.container).find('.js-root-reply-button');
      replyButton.bind('click', function() {
        var _ref4, _ref5, _ref6;
        _gaq.push(['_trackEvent', 'Blip usage', 'Insert reply', 'Re in root menu']);
        return (_ref4 = _this._waveViewModel.getLoadedBlip((_ref5 = _this._waveViewModel.getModel()) != null ? _ref5.getRootBlipId() : void 0)) != null ? (_ref6 = _ref4.getView()) != null ? _ref6.insertReplyBlip() : void 0 : void 0;
      });
      return replyButton[0].disabled = false;
    };

    WaveView.prototype.updateContacts = function() {};

    WaveView.prototype.activateContacts = function() {};

    WaveView.prototype.__initWaveHeader = function(waveViewModel, participants) {
      /*
              Инициализирует заголовок волны
      */
      var _this = this;
      WaveView.__super__.__initWaveHeader.call(this, waveViewModel, participants);
      this._header = this.container.getElementsByClassName('js-wave-header')[0];
      window.addEventListener('scroll', this._handleScroll, false);
      this._nextUnreadBlipButton.setAttribute('disabled', 'disabled');
      this._nextUnreadBlipButton.addEventListener('mousedown', this._nextUnreadHandler, false);
      this._initParticipants(waveViewModel, participants);
      return $('.js-enter-rizzoma-btn').click(function(e) {
        _this.emit('sign-in-click');
        e.stopPropagation();
        return e.preventDefault();
      });
    };

    WaveView.prototype._handleScroll = function() {
      var hStyle, t, _i, _len;
      if (this._scrollHeaderTimer != null) {
        clearTimeout(this._scrollHeaderTimer);
      } else {
        hStyle = this._header.style;
        for (_i = 0, _len = transitions.length; _i < _len; _i++) {
          t = transitions[_i];
          hStyle[t] = '';
        }
        hStyle.top = '';
      }
      return this._scrollHeaderTimer = setTimeout(this._doScroll, SCROLL_HEADER_TIMER);
    };

    WaveView.prototype._doScroll = function() {
      var hStyle, scrollTop,
        _this = this;
      this._scrollHeaderTimer = null;
      scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
      if (!scrollTop) return;
      hStyle = this._header.style;
      hStyle.opacity = '0';
      return setTimeout(function() {
        var t, _i, _len;
        for (_i = 0, _len = transitions.length; _i < _len; _i++) {
          t = transitions[_i];
          hStyle[t] = 'opacity 0.2s linear';
        }
        hStyle.top = "" + scrollTop + "px";
        return hStyle.opacity = '1';
      }, 0);
    };

    WaveView.prototype.updatePublicState = function() {};

    WaveView.prototype.setSharedState = function() {};

    WaveView.prototype._initParticipants = function(waveViewModel, participants) {
      /*
              Инициализирует панель с участниками волны
              @param participants: array, часть ShareJS-документа, отвечающего за участников
      */      return this._participants = new Participants(waveViewModel, this._waveProcessor, this._model.serverId, participants, true);
    };

    WaveView.prototype._initEditingButtons = function() {
      /*
              Инициализирует меню редактирования волны
      */      if (!this._editable) return;
      this._initActiveBlipControls();
      return this._disableEditingButtons();
    };

    WaveView.prototype._initActiveBlipControls = function() {
      /*
              Инициализирует кнопки вставки реплая или меншена в активный блиб
      */
      var insertMention, insertReply;
      if (BrowserSupport.isIDevice()) {
        this._header.addEventListener(BrowserEvents.TOUCH_END_EVENT, function() {
          var s;
          s = getSelection();
          PRESERVED_RANGE = s && s.rangeCount ? s.getRangeAt(0) : null;
          if (!PRESERVED_RANGE) return;
          return setTimeout(function() {
            return PRESERVED_RANGE = null;
          }, 500);
        }, false);
      }
      insertReply = $(this.container).find('.active-blip-control.js-insert-reply');
      insertReply.mousedown(this._eventHandler(this._insertBlipButtonClick));
      insertMention = $(this.container).find('.active-blip-control.js-insert-mention');
      insertMention.mousedown(this._eventHandler(this._insertMention));
      this._$editBlipButton = $(this.container).find('.js-toggle-edit-mode');
      BrowserEvents.addBlocker(this._$editBlipButton[0], 'mousedown', false);
      this._$editBlipButton.click(this._changeEditMode);
      this._activeBlipControls = [];
      if (insertReply[0]) this._activeBlipControls.push(insertReply[0]);
      if (insertMention[0]) return this._activeBlipControls.push(insertMention[0]);
    };

    WaveView.prototype._nextUnreadHandler = function(event) {
      _gaq.push(['_trackEvent', 'Topic content', 'Next unread click', 'Next unread message']);
      this._goToUnread();
      event.preventDefault();
      return event.stopPropagation();
    };

    WaveView.prototype._initRootBlip = function(waveViewModel) {
      /*
              Инициализирует корневой блип
      */
      var blipNode, processor,
        _this = this;
      blipNode = $(this.container).find('.js-container-blip')[0];
      processor = require('../blip/processor_mobile').instance;
      processor.openBlip(waveViewModel, this._model.getContainerBlipId(), blipNode, null, function(err, rootBlip) {
        var hideRepliesButton, showRepliesButton;
        _this.rootBlip = rootBlip;
        if (err) {
          return _this._waveProcessor.showPageError(err);
        } else {
          _this._initRangeChangeEvent();
          hideRepliesButton = $(_this.container).find('.js-hide-replies-button');
          hideRepliesButton[0].disabled = false;
          hideRepliesButton.click(function() {
            _this.rootBlip.getView().foldAllChildBlips();
            return _gaq.push(['_trackEvent', 'Blip usage', 'Hide replies', 'Root menu']);
          });
          showRepliesButton = $(_this.container).find('.js-show-replies-button');
          showRepliesButton[0].disabled = false;
          return showRepliesButton.click(function() {
            _this.rootBlip.getView().unfoldAllChildBlips();
            return _gaq.push(['_trackEvent', 'Blip usage', 'Show replies', 'Root menu']);
          });
        }
      });
      this._keyInteractor = new KeyEventInteractor(blipNode);
      this._keyInteractor.on('blip', function() {
        var role;
        role = _this._waveViewModel.getRole();
        if (role === ROLE_NO_ROLE || role === ROLE_READER) return;
        return _this._insertBlip('Shortcut');
      });
      this.on('range-change', function(range, blip) {
        if (blip) return _this.markActiveBlip(blip);
      });
      this.container.addEventListener(BrowserEvents.C_FOCUS_EVENT, this._processCActivateEvent, false);
      return this.container.addEventListener(BrowserEvents.C_BLIP_CREATE_EVENT, this._processCBlipCreateEvent, false);
    };

    WaveView.prototype._processCActivateEvent = function(e) {
      if (!this._editingButtonsEnabled) this._enableEditingButtons();
      return this.markActiveBlip(e.blip);
    };

    WaveView.prototype._processCBlipCreateEvent = function() {
      return this._model.setEditable(true);
    };

    WaveView.prototype._disableEditingButtons = function() {
      var btn, _i, _len, _ref4, _results;
      this._editingButtonsEnabled = false;
      _ref4 = this._activeBlipControls;
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        btn = _ref4[_i];
        _results.push(btn.disabled = true);
      }
      return _results;
    };

    WaveView.prototype._enableEditingButtons = function() {
      var btn, _i, _len, _ref4, _results;
      if (!BrowserSupport.isSupported()) return;
      this._editingButtonsEnabled = true;
      _ref4 = this._activeBlipControls;
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        btn = _ref4[_i];
        _results.push(btn.disabled = false);
      }
      return _results;
    };

    WaveView.prototype._checkChangedRange = function(range, blip) {
      var _ref4;
      if (range && ((_ref4 = blip.getPermission()) === EDIT_PERMISSION || _ref4 === COMMENT_PERMISSION)) {
        if (!this._editingButtonsEnabled) this._enableEditingButtons();
      } else {
        if (this._editingButtonsEnabled) this._disableEditingButtons();
      }
      if (blip === this._lastBlip) {
        if (range === this._lastRange) return;
        if (range && this._lastRange && range.compareBoundaryPoints(Range.START_TO_START, this._lastRange) === 0 && range.compareBoundaryPoints(Range.END_TO_END, this._lastRange) === 0) {
          if ((blip != null ? blip.getEditor().getContainer() : void 0) === document.activeElement) {
            return;
          }
          range = null;
          blip = null;
        }
      }
      this._lastRange = range;
      if (this._lastRange) this._lastRange = this._lastRange.cloneRange();
      this._lastBlip = blip;
      return this.emit('range-change', this._lastRange, blip);
    };

    WaveView.prototype._checkRange = function() {
      /*
              Проверяет положение курсора и генерирует событие изменения положения
              курсора при необходимости
      */
      var params;
      params = this._getBlipAndRange();
      if (params) {
        return this._checkChangedRange(params[1], params[0]);
      } else {
        return this._checkChangedRange(null, null);
      }
    };

    WaveView.prototype.runCheckRange = function() {
      var _this = this;
      return window.setTimeout(function() {
        return _this._checkRange();
      }, 0);
    };

    WaveView.prototype._handleMouseDownEvent = function(e) {
      var _this = this;
      return window.setTimeout(function() {
        var blip, params;
        if (!_this.rootBlip) return;
        params = _this._getBlipAndRange();
        if (params) {
          return _this._checkChangedRange(params[1], params[0]);
        } else {
          blip = _this.rootBlip.getView().getBlipContainingElement(e.target);
          return _this._checkChangedRange(null, blip);
        }
      }, 0);
    };

    WaveView.prototype._initRangeChangeEvent = function() {
      /*
              Инициализирует событие "изменение курсора"
      */      this._lastRange = null;
      this._lastBlip = null;
      window.addEventListener('keydown', this.runCheckRange, false);
      if (BrowserSupport.isWebKit()) {
        return document.addEventListener('selectionchange', this.runCheckRange, false);
      } else {
        return document.addEventListener(BrowserEvents.C_EDITOR_MOUSE_DOWN_EVENT, this._handleMouseDownEvent, false);
      }
    };

    WaveView.prototype._eventHandler = function(func) {
      /*
              # TODO: remove it
              Возвращает функцию, которая остановит событие и вызовет переданную
              @param func: function
              @return: function
                  function(event)
      */      return function(event) {
        event.preventDefault();
        event.stopPropagation();
        return func();
      };
    };

    WaveView.prototype.__render = function() {
      /*
              Создает DOM для отображения документа
      */
      var c, params, _ref4;
      c = $(this.container);
      c.empty();
      params = {
        editable: this._editable,
        id: this._waveViewModel.getServerId(),
        isAnonymous: !(((_ref4 = window.userInfo) != null ? _ref4.id : void 0) != null)
      };
      c.append(renderWaveMobile(params));
      this._waveContent = $(this.container).find('.js-wave-content')[0];
      this._nextUnreadBlipButton = this.container.getElementsByClassName('js-next-unread-button')[0];
      return this._$activeBlipControls = $(this._waveContent).find('.js-active-blip-controls');
    };

    WaveView.prototype.__scrollToBlipContainer = function(blipContainer) {
      return DOM.scrollTargetIntoView(blipContainer, document.body, true, -75);
    };

    WaveView.prototype.markActiveBlip = function(blip) {
      /*
              @param blip: BlipView
      */
      var hasEditPermission, _ref4;
      if (this._activeBlip === blip) return;
      if (this._activeBlip) this._activeBlip.unmarkActive();
      hasEditPermission = blip && blip.hasEditPermission();
      if (this._model.getEditable()) {
        if ((_ref4 = this._activeBlip) != null) _ref4.setEditable(false);
        blip.setEditable(hasEditPermission);
        this._model.setEditable(hasEditPermission);
      }
      if (hasEditPermission) {
        this._$editBlipButton.removeAttr('disabled');
      } else {
        this._$editBlipButton.attr('disabled', 'disabled');
      }
      this._activeBlip = blip;
      this._model.setActiveBlip(blip.getViewModel());
      return this._activeBlip.markActive();
    };

    WaveView.prototype._expandCrossedBlipRange = function(range, blipViewStart, blipViewEnd, directionForward) {
      var commonView, el, end, endThread, endView, endViewContainer, start, startThread, startView, startViewContainer, _ref4;
      if (blipViewEnd) {
        start = [];
        end = [];
        startView = blipViewStart;
        while (startView) {
          start.push(startView);
          startView = startView.getParent();
        }
        endView = blipViewEnd;
        while (endView) {
          end.push(endView);
          endView = endView.getParent();
        }
        while ((startView = start.pop()) === (endView = end.pop())) {
          commonView = startView;
        }
        if (startView) {
          startThread = BlipThread.getBlipThread(startView.getContainer());
          startViewContainer = startThread.getContainer();
          range.setStartBefore(startViewContainer);
          if (this._lastRange) {
            if (range.compareBoundaryPoints(Range.START_TO_START, this._lastRange) > -1) {
              range.setStartAfter(startViewContainer);
            }
          }
        }
        if (endView) {
          endThread = BlipThread.getBlipThread(endView.getContainer());
          endViewContainer = endThread.getContainer();
          range.setEndAfter(endViewContainer);
          if (this._lastRange) {
            if (range.compareBoundaryPoints(Range.END_TO_END, this._lastRange) < 1) {
              range.setEndBefore(endViewContainer);
            }
          }
        }
      } else {
        el = (_ref4 = blipViewStart.getEditor()) != null ? _ref4.getContainer() : void 0;
        commonView = blipViewStart;
        if (el) range.setEnd(el, el.childNodes.length);
      }
      DOM.setRange(range, directionForward);
      return [commonView, range];
    };

    WaveView.prototype._getBlipAndRange = function() {
      /*
              Возвращает текущее выделение и блип, в котором оно сделано
              @return: [BlipView, DOM range]|null
      */
      var blipViewEnd, blipViewStart, cursor, directionForward, range, selection;
      if (!this.rootBlip) return null;
      selection = window.getSelection();
      if (selection && selection.rangeCount) {
        range = selection.getRangeAt(0);
      } else {
        range = PRESERVED_RANGE;
        if (range) DOM.setRange(range);
      }
      if (!range) return null;
      cursor = [range.startContainer, range.startOffset];
      directionForward = selection.anchorNode === range.startContainer && selection.anchorOffset === range.startOffset ? true : false;
      blipViewStart = this.rootBlip.getView().getBlipContainingCursor(cursor);
      if (!blipViewStart) return null;
      cursor = [range.endContainer, range.endOffset];
      blipViewEnd = range.collapsed ? blipViewStart : this.rootBlip.getView().getBlipContainingCursor(cursor);
      if (blipViewStart !== blipViewEnd) {
        return this._expandCrossedBlipRange(range, blipViewStart, blipViewEnd, directionForward);
      }
      return [blipViewStart, range];
    };

    WaveView.prototype._changeEditMode = function() {
      var editable;
      if (!this._activeBlip) return console.warn('no active blip');
      editable = this._model.getEditable();
      this._activeBlip.setEditable(!editable);
      return this._model.setEditable(!editable);
    };

    WaveView.prototype._insertBlip = function(analyticsLabel) {
      /*
              Обрабатывает нажатие на кнопку вставки комментария
      */
      var blip, blipViewModel, opParams, range,
        _this = this;
      opParams = this._getBlipAndRange();
      if (!opParams) return;
      _gaq.push(['_trackEvent', 'Blip usage', analyticsLabel]);
      blip = opParams[0], range = opParams[1];
      blipViewModel = blip.initInsertInlineBlip();
      blipViewModel.getView().focus();
      return window.setTimeout(function() {
        var params;
        params = _this._getBlipAndRange();
        if (!params) return;
        return _this._checkChangedRange(params[1], params[0]);
      }, 0);
    };

    WaveView.prototype._insertBlipButtonClick = function() {
      return this._insertBlip('Re in editing menu');
    };

    WaveView.prototype._insertMention = function() {
      var blip, params, range, recipientInput;
      params = this._getBlipAndRange();
      if (!params) return;
      blip = params[0], range = params[1];
      recipientInput = blip.getEditor().insertRecipient();
      return recipientInput != null ? recipientInput.insertionEventLabel = 'Menu button' : void 0;
    };

    WaveView.prototype._goToUnread = function() {
      /*
              Переводит фокус на первый непрочитаный блип,
              расположенный после блипа под фокусом
      */
      var _ref4;
      this.emit('goToNextUnread');
      this._activeBlip.markAsRead();
      if ((_ref4 = window.getSelection()) != null) _ref4.removeAllRanges();
      return this._checkRange();
    };

    WaveView.prototype.getActiveBlip = function() {
      return this._activeBlip.getViewModel();
    };

    WaveView.prototype.getRootBlip = function() {
      return this.rootBlip;
    };

    WaveView.prototype.processEditableChange = function(editable) {
      var text;
      text = editable ? 'Done' : 'Edit';
      return this._$editBlipButton.html("<span>" + text + "</span>");
    };

    WaveView.prototype.destroy = function() {
      WaveView.__super__.destroy.call(this);
      this._keyInteractor.destroy();
      delete this._keyInteractor;
      require('../editor/file/upload_form').removeInstance();
      this.removeAllListeners();
      this.container.removeEventListener(BrowserEvents.C_FOCUS_EVENT, this._processCActivateEvent, false);
      this.container.removeEventListener(BrowserEvents.C_BLIP_CREATE_EVENT, this._processCBlipCreateEvent, false);
      window.removeEventListener('keydown', this.runCheckRange, false);
      if (BrowserSupport.isWebKit()) {
        document.removeEventListener('selectionchange', this.runCheckRange, false);
      } else {
        document.removeEventListener(BrowserEvents.C_EDITOR_MOUSE_DOWN_EVENT, this._handleMouseDownEvent, false);
      }
      window.removeEventListener('scroll', this._handleScroll, false);
      if (this._scrollHeaderTimer != null) clearTimeout(this._scrollHeaderTimer);
      this._header = null;
      this._nextUnreadBlipButton.removeEventListener('mousedown', this._nextUnreadHandler, false);
      $(this.container).empty().unbind();
      delete this.rootBlip;
      if (this._activeBlip) delete this._activeBlip;
      if (this._lastBlip) delete this._lastBlip;
      delete this._$editBlipButton;
      this._participants.destroy();
      delete this._participants;
      return jQuery.fragments = {};
    };

    WaveView.prototype.applyParticipantOp = function(op) {
      var isMyOp, _ref4, _ref5;
      this._participants.applyOp(op);
      if (!window.loggedIn) return;
      isMyOp = ((_ref4 = op.ld) != null ? _ref4.id : void 0) === window.userInfo.id || ((_ref5 = op.li) != null ? _ref5.id : void 0) === window.userInfo.id;
      if (!isMyOp) return;
      return this.updateInterfaceAccordingToRole();
    };

    WaveView.prototype.updateInterfaceAccordingToRole = function() {
      this._waveViewModel.updateParticipants();
      return this.rootBlip.getView().recursivelyUpdatePermission();
    };

    WaveView.prototype.getParticipantIds = function() {
      return this._participants.all();
    };

    WaveView.prototype._updateUnreadBlipsCount = function(count) {
      /*
              Обновляет количество непрочитанных сообщений для волны
              и дизэблит кнопку Next если нет непрочитанных
              @param count: int
      */      if (count === 0) {
        return this._nextUnreadBlipButton.setAttribute('disabled', 'disabled');
      } else {
        if (this._nextUnreadBlipButton.hasAttribute('disabled')) {
          return this._nextUnreadBlipButton.removeAttribute('disabled', 0);
        }
      }
    };

    WaveView.prototype.getSocialSharingUrl = function() {};

    return WaveView;

  })(WaveMobileViewBase);

  module.exports = {
    WaveView: WaveView
  };

}).call(this);

});

require.define("/lib/client/client/wave/participants/mobile.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var Participants, ROLES, ROLE_EDITOR, ROLE_NO_ROLE, ROLE_OWNER, _ref,
    __slice = Array.prototype.slice;

  _ref = require('./constants'), ROLES = _ref.ROLES, ROLE_OWNER = _ref.ROLE_OWNER, ROLE_EDITOR = _ref.ROLE_EDITOR, ROLE_NO_ROLE = _ref.ROLE_NO_ROLE;

  Participants = (function() {

    function Participants() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._init.apply(this, args);
    }

    Participants.prototype._init = function(_waveViewModel, _processor, _modelId, _participants, _allowRemove, _changeCallback) {
      this._waveViewModel = _waveViewModel;
      this._processor = _processor;
      this._modelId = _modelId;
      this._participants = _participants;
      this._allowRemove = _allowRemove;
      this._changeCallback = _changeCallback;
      return this._waveViewModel.getUsers(this._getParticipantsIds());
    };

    Participants.prototype._getParticipantsIds = function(checkRole) {
      var participant, participantIds, _i, _len, _ref2;
      if (checkRole == null) checkRole = false;
      participantIds = [];
      _ref2 = this._participants;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        participant = _ref2[_i];
        if (checkRole && participant.role === ROLE_NO_ROLE) continue;
        participantIds.push(participant.id);
      }
      return participantIds;
    };

    Participants.prototype._add = function(participant, index) {
      var _ref2;
      return ([].splice.apply(this._participants, [index, index - index].concat(_ref2 = [participant])), _ref2);
    };

    Participants.prototype._remove = function(participant, index) {
      var _ref2;
      return ([].splice.apply(this._participants, [index, index - index + 1].concat(_ref2 = [])), _ref2);
    };

    Participants.prototype.all = function() {
      /*
              Возвращает массив идентификаторов текущих участников волны
      */      return this._getParticipantsIds(true);
    };

    Participants.prototype.applyOp = function(op) {
      var index;
      index = op.p.shift();
      if (op.ld) this._remove(op.ld, index);
      if (op.li) this._add(op.li, index);
      return typeof this._changeCallback === "function" ? this._changeCallback() : void 0;
    };

    Participants.prototype.destroy = function() {
      delete this._waveViewModel;
      delete this._processor;
      delete this._modelId;
      delete this._participants;
      delete this._allowRemove;
      if (this._changeCallback) return delete this._changeCallback;
    };

    return Participants;

  })();

  exports.Participants = Participants;

}).call(this);

});

require.define("/lib/client/client/utils/browser_support_mobile.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BrowserSupport, IDEVICE;

  IDEVICE = null;

  BrowserSupport = (function() {

    function BrowserSupport() {}

    BrowserSupport.isWebKit = function() {
      return !!$.browser.webkit;
    };

    BrowserSupport.isMozilla = function() {
      return !!$.browser.mozilla;
    };

    BrowserSupport.isDesktopChrome = function() {
      return window.navigator.userAgent.search("Chrome") !== -1 && window.navigator.userAgent.search("Mobile") === -1;
    };

    BrowserSupport.isIEMobile = function() {
      return !!navigator.userAgent.match(/IEMobile/i);
    };

    BrowserSupport.isContentEditableSupported = function() {
      var t;
      if (this._isContentEditableSupported != null) {
        return this._isContentEditableSupported;
      }
      t = document.createElement('div');
      return this._isContentEditableSupported = (t.contentEditable != null) && (($.browser.webkit && parseFloat($.browser.version) - 533 > 0.11) || ($.browser.mozilla && parseInt($.browser.version) >= 9));
    };

    BrowserSupport.isTouchSupported = function() {
      if (this._isTouchSupported != null) return this._isTouchSupported;
      return this._isTouchSupported = !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch);
    };

    BrowserSupport.isSupported = function() {
      /*
              Возвращает true если в браузере поддерживается редактирование текста.
              Изменяющий! При изменении условий скопируй их в wave.html (этот метод там использовать не получается,
              т.к. там код должен выполниться еще до подключения этого класса)!
      */      if (BrowserSupport.isContentEditableSupported()) return true;
      if (BrowserSupport.isTouchSupported()) return true;
      return false;
    };

    BrowserSupport.isIDevice = function() {
      return IDEVICE != null ? IDEVICE : IDEVICE = navigator.userAgent.search(/iPhone|iPod|iPad/i) > -1;
    };

    BrowserSupport.isWindows = function() {
      return navigator.appVersion.indexOf('Win') > -1;
    };

    BrowserSupport.isLinux = function() {
      return navigator.appVersion.indexOf('Linux') !== -1;
    };

    BrowserSupport.isUnix = function() {
      return navigator.appVersion.indexOf('X11') > -1;
    };

    BrowserSupport.isMac = function() {
      return navigator.appVersion.indexOf('Mac') > -1;
    };

    BrowserSupport.getOs = function() {
      var na;
      na = navigator.appVersion;
      if (na.indexOf("Linux") > -1) return 'Linux';
      if (na.indexOf('X11') > -1) return 'Unux';
      if (na.indexOf('Mac') > -1) return 'Mac';
      if (na.indexOf('Win') > -1) return 'Windows';
    };

    return BrowserSupport;

  })();

  module.exports = BrowserSupport;

}).call(this);

});

require.define("/lib/client/client/wave/event_interactor.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BE, EventInteractor, KeyCodes, KeyEventInteractor, MicroEvent,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  MicroEvent = require('../utils/microevent');

  BE = require('../utils/browser_events');

  KeyCodes = require('../utils/key_codes').KeyCodes;

  EventInteractor = (function() {

    function EventInteractor() {}

    EventInteractor.prototype.__dispatchInsertInlineBlipEvent = function() {
      try {
        return this.emit('blip');
      } catch (_error) {}
    };

    EventInteractor.prototype.destroy = function() {
      return this.removeAllListeners();
    };

    return EventInteractor;

  })();

  MicroEvent.mixin(EventInteractor);

  KeyEventInteractor = (function(_super) {

    __extends(KeyEventInteractor, _super);

    function KeyEventInteractor(_root) {
      this._root = _root;
      this._handleKeyDownEvent = __bind(this._handleKeyDownEvent, this);
      this._bindEvents();
    }

    KeyEventInteractor.prototype._bindEvents = function() {
      return this._root.addEventListener(BE.KEY_DOWN_EVENT, this._handleKeyDownEvent, true);
    };

    KeyEventInteractor.prototype._unbindEvents = function() {
      return this._root.removeEventListener(BE.KEY_DOWN_EVENT, this._handleKeyDownEvent, true);
    };

    KeyEventInteractor.prototype._handleKeyDownEvent = function(e) {
      if (e.shiftKey || e.altKey) return;
      if (!(e.ctrlKey || e.metaKey)) return;
      if (e.keyCode === KeyCodes.KEY_ENTER) {
        this.__dispatchInsertInlineBlipEvent();
        return BE.blockEvent(e);
      }
    };

    KeyEventInteractor.prototype.destroy = function() {
      KeyEventInteractor.__super__.destroy.call(this);
      this._unbindEvents();
      return delete this._root;
    };

    return KeyEventInteractor;

  })(EventInteractor);

  module.exports = {
    KeyEventInteractor: KeyEventInteractor
  };

}).call(this);

});

require.define("/lib/client/client/blip/processor_mobile.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipProcessor, BlipProcessorBase, BlipViewModel,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BlipProcessorBase = require('./processor_base').BlipProcessorBase;

  BlipViewModel = require('./index_mobile').BlipViewModel;

  BlipProcessor = (function(_super) {

    __extends(BlipProcessor, _super);

    function BlipProcessor() {
      BlipProcessor.__super__.constructor.apply(this, arguments);
    }

    BlipProcessor.prototype.__constructBlip = function(blipData, waveViewModel, container, parentBlip) {
      /*
              @override
      */      return BlipProcessor.__super__.__constructBlip.call(this, blipData, waveViewModel, container, parentBlip, BlipViewModel);
    };

    return BlipProcessor;

  })(BlipProcessorBase);

  module.exports.BlipProcessor = BlipProcessor;

  module.exports.instance = null;

}).call(this);

});

require.define("/lib/client/client/blip/index_mobile.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipView, BlipViewModel, BlipViewModelBase,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BlipViewModelBase = require('./index_base');

  BlipView = require('./view_mobile').BlipView;

  BlipViewModel = (function(_super) {

    __extends(BlipViewModel, _super);

    function BlipViewModel() {
      BlipViewModel.__super__.constructor.apply(this, arguments);
    }

    BlipViewModel.prototype.__initView = function(waveViewModel, blipProcessor, model, timestamp, container, parentBlip, isRead) {
      return this.__view = new BlipView(waveViewModel, blipProcessor, this, model, timestamp, container, parentBlip, isRead);
    };

    return BlipViewModel;

  })(BlipViewModelBase);

  exports.BlipViewModel = BlipViewModel;

}).call(this);

});

require.define("/lib/client/client/blip/view_mobile.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var Author, BlipMenu, BlipThread, BlipView, BlipViewBase, BrowserEvents, BrowserSupport, COMMENT_PERMISSION, Contributors, DOM, EDIT_PERMISSION, Editor, EditorConfig, MicroEvent, ModelField, ModelType, ParamsField, READ_PERMISSION, ROLE_COMMENTATOR, ROLE_EDITOR, ROLE_OWNER, Recipient, RecipientInput, TaskRecipient, TaskRecipientInput, blipTmpl, escapeHTML, formatDate, popup, renderBlip, _ref, _ref2, _ref3,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  DOM = require('../utils/dom');

  BlipViewBase = require('./view_base');

  BrowserSupport = require('../utils/browser_support_mobile');

  ModelType = require('../editor/model').ModelType;

  ModelField = require('../editor/model').ModelField;

  ParamsField = require('../editor/model').ParamsField;

  if (BrowserSupport.isContentEditableSupported()) {
    if (BrowserSupport.isWebKit() || BrowserSupport.isMozilla()) {
      Editor = require('../editor/editor_mobile_v2').Editor;
    } else {
      Editor = require('../editor/editor_mobile').Editor;
    }
  } else {
    Editor = require('../editor/editor_mobile_polyfill').Editor;
  }

  Contributors = require('./contributors').Contributors;

  Author = require('./contributors/author').Author;

  _ref = require('./recipient'), Recipient = _ref.Recipient, RecipientInput = _ref.RecipientInput;

  TaskRecipient = require('./task_recipient').TaskRecipient;

  TaskRecipientInput = require('./task_recipient/input').TaskRecipientInput;

  formatDate = require('../../share/utils/datetime').formatDate;

  popup = require('../popup').popup;

  BlipMenu = require('./menu/mobile').BlipMenu;

  MicroEvent = require('../utils/microevent');

  escapeHTML = require('../utils/string').escapeHTML;

  BrowserEvents = require('../utils/browser_events');

  BlipThread = require('./blip_thread').BlipThread;

  _ref2 = require('./model'), EDIT_PERMISSION = _ref2.EDIT_PERMISSION, COMMENT_PERMISSION = _ref2.COMMENT_PERMISSION, READ_PERMISSION = _ref2.READ_PERMISSION;

  _ref3 = require('../wave/participants/constants'), ROLE_OWNER = _ref3.ROLE_OWNER, ROLE_EDITOR = _ref3.ROLE_EDITOR, ROLE_COMMENTATOR = _ref3.ROLE_COMMENTATOR;

  blipTmpl = function() {
    if (!this.isRoot) {
      div('.js-blip-menu-container.blip-menu-container', '');
      div('.js-blip-info-container.blip-info', function() {
        span('.js-shown-contributor', function() {});
        return div(function() {
          return div('.edit-date', {
            title: h(this.fullDatetime)
          }, h(this.datetime));
        });
      });
    }
    div('.js-editor-container.editor-container', function() {
      if (!this.isRoot) {
        return div('.js-blip-unread-indicator.unread-indicator', {
          style: 'display: none;'
        }, function() {});
      }
    });
    if (!this.isRoot && this.isNotInRootThread && !this.isAnonymous) {
      return button('.js-blip-reply-button.blip-reply-button', {
        title: 'Add reply'
      }, function() {
        img('', {
          src: "/s/img/reply_icon.png"
        });
        return text('Reply');
      });
    }
  };

  renderBlip = window.CoffeeKup.compile(blipTmpl);

  EditorConfig = {
    lightbox: {
      containerMarginLeftRightSize: 0,
      containerBorderSize: 0,
      topOffset: 0,
      fixedNavigation: true,
      hideImageDataBox: true
    }
  };

  BlipView = (function(_super) {

    __extends(BlipView, _super);

    /*
        Класс для отображения одного сообщения в документе
    */

    function BlipView(_waveViewModel, _blipProcessor, _blipViewModel, _model, _ts, _blipContainer, _parent, isRead) {
      this._waveViewModel = _waveViewModel;
      this._blipProcessor = _blipProcessor;
      this._blipViewModel = _blipViewModel;
      this._model = _model;
      this._ts = _ts;
      this._blipContainer = _blipContainer;
      this._parent = _parent;
      this._setIsFoldedByDefault = __bind(this._setIsFoldedByDefault, this);
      this._remove = __bind(this._remove, this);
      this.unmarkActive = __bind(this.unmarkActive, this);
      this.markActive = __bind(this.markActive, this);
      this._getTaskRecipient = __bind(this._getTaskRecipient, this);
      this._updateTaskSearchInfo = __bind(this._updateTaskSearchInfo, this);
      this._getTaskRecipientInput = __bind(this._getTaskRecipientInput, this);
      this._getRecipientInput = __bind(this._getRecipientInput, this);
      this._getRecipient = __bind(this._getRecipient, this);
      this._removeInlineBlip = __bind(this._removeInlineBlip, this);
      this._addInlineBlip = __bind(this._addInlineBlip, this);
      this._processEditorChanges = __bind(this._processEditorChanges, this);
      this._processFocusOutEvent = __bind(this._processFocusOutEvent, this);
      this._processFocusInEvent = __bind(this._processFocusInEvent, this);
      this._getContent = __bind(this._getContent, this);
      this._handlePasteAfterBlipButton = __bind(this._handlePasteAfterBlipButton, this);
      this._handlePasteAtCursorButton = __bind(this._handlePasteAtCursorButton, this);
      this._handleCopyBlipButton = __bind(this._handleCopyBlipButton, this);
      this._addTaskRecipient = __bind(this._addTaskRecipient, this);
      this._insertRecipientByEmail = __bind(this._insertRecipientByEmail, this);
      /*
              Создает объект для отображения блипа
              @param _waveViewModel: WaveViewModel
              @param _blipProcessor: BlipProcessor
              @param _model: BlipModel
              @param snapshot: текущий снимок блипа
              @param ts: время последнего редактирования
              @param _blipContainer: HTMLNode, нода, в которой отображаться блипу
              @param _parent: BlipView, родитель, нужен для кнопки "удалить"
              @param isRead: boolean
      */
      BlipView.__super__.constructor.call(this);
      this.__blipContainer = this._blipContainer;
      this.__model = this._model;
      this._blipContainer['__rizzoma_id'] = this._model.id;
      this._requestedBlips = {};
      this._childBlips = this._model._childBlips;
      this._init(isRead);
      this._messagesProcessor = require('../search_panel/mention/processor').instance;
      this._tasksProcessor = require('../search_panel/task/processor').instance;
      if (this._model.getServerId() === this._waveViewModel.getModel().getRootBlipId()) {
        this._addRootBlipClasses();
      }
    }

    BlipView.prototype._addRootBlipClasses = function() {
      DOM.addClass(this._blipContainer, 'root-blip');
      DOM.addClass(this._blipContainer, 'increase-first-line');
      return DOM.addClass(this._blipContainer, 'with-reserved-menu-space');
    };

    BlipView.prototype._init = function(isRead) {
      /*
              Инициализирует объект
      */
      var _ref4;
      this._rendered = false;
      this.__isNotInRootThread = ((_ref4 = this._parent) != null ? _ref4.getParent() : void 0) != null;
      if (!this._parent) {
        this._render();
      } else {
        this.__unreadIndicatorHidden = true;
        if (BlipThread.getBlipThread(this._blipContainer)) {
          this.__initFold();
        } else {
          this._blipContainer.addEventListener(BrowserEvents.C_BLIP_INSERT_EVENT, this.__initFold, false);
        }
        $(this._blipContainer).on('focusin', this._processFocusInEvent).on('focusout', this._processFocusOutEvent);
        if (isRead != null) {
          this._focused = false;
          if (isRead) {
            this._markAsRead(false);
          } else {
            this._markAsUnread();
          }
        } else {
          this._focused = true;
        }
        this._initChildBlips(this._model.getSnapshotContent());
      }
      return this._waveViewModel.on('usersInfoUpdate', this._usersInfoUpdateHandler);
    };

    BlipView.prototype._render = function() {
      if (this._rendered) return;
      this._rendered = true;
      this._createDOM(this._ts);
      if (this._parent) {
        this._initBlipInfo(this._model.getContributors());
        this.__initUnreadIndicator();
      }
      this._initEditor(this._model.getSnapshotContent());
      return this.updateReadState();
    };

    BlipView.prototype.renderRecursively = function() {
      var blip, blipId, _ref4, _results;
      this._render();
      _ref4 = this._childBlips;
      _results = [];
      for (blipId in _ref4) {
        blip = _ref4[blipId];
        _results.push(blip.getView().renderRecursively());
      }
      return _results;
    };

    BlipView.prototype._initChildBlips = function(content) {
      var block, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = content.length; _i < _len; _i++) {
        block = content[_i];
        if (block[ModelField.PARAMS][ParamsField.TYPE] !== ModelType.BLIP) {
          continue;
        }
        _results.push(this._addInlineBlip(block[ModelField.PARAMS][ParamsField.ID]));
      }
      return _results;
    };

    BlipView.prototype._initBlipInfo = function(contributors) {
      /*
              Инициализирует элемент, отвечающий за информацию о блипе
      */
      var $shownContributorContainer, author, authors, c;
      c = $(this._blipContainer);
      $shownContributorContainer = c.find('.js-shown-contributor');
      authors = [contributors[0].id];
      if (contributors.length > 1) authors.push(contributors[1].id);
      author = new Author(this._waveViewModel, authors);
      this._contributors = new Contributors(this._waveViewModel, contributors, author);
      $shownContributorContainer.append(author.getContainer());
      return c.find('.js-blip-info-container').append(this._contributors.getContainer());
    };

    BlipView.prototype._initMenu = function() {
      /*
              Инициализирует меню блипа
      */
      var c, params,
        _this = this;
      c = $(this._menuContainer);
      params = {
        isFoldedByDefault: this._model.isFoldedByDefault(),
        hasServerId: this._model.serverId != null
      };
      this._blipMenu = new BlipMenu(params);
      $(this._menuContainer).append(this._blipMenu.getContainer());
      this._menu = c.find('.js-blip-menu')[0];
      this._deleteButton = c.find('.js-delete-blip')[0];
      $(this._deleteButton).bind('mousedown', this._remove);
      this._isFoldedByDefaultBox = c.find('.js-is-folded-by-default')[0];
      $(this._isFoldedByDefaultBox).bind('mousedown', this._setIsFoldedByDefault);
      c.find('.js-show-all-inlines').on('click', function() {
        _gaq.push(['_trackEvent', 'Blip usage', 'Show replies', 'Reply menu']);
        return _this.unfoldAllChildBlips();
      }).on('mousedown', function(e) {
        e.preventDefault();
        return e.stopPropagation();
      });
      c.find('.js-hide-all-inlines').on('click', function() {
        _gaq.push(['_trackEvent', 'Blip usage', 'Hide replies', 'Reply menu']);
        return _this.foldAllChildBlips();
      }).on('mousedown', function(e) {
        e.preventDefault();
        return e.stopPropagation();
      });
      this._copyBlipButton = c.find('.js-copy-blip-button')[0];
      this._pasteAtCursorButton = c.find('.js-paste-at-cursor-button')[0];
      this._pasteAfterBlipButton = c.find('.js-paste-after-blip-button')[0];
      this._showHideEditButtons();
      return this._initCopyPasteBlipButtons();
    };

    BlipView.prototype._initReplyButton = function() {
      var _this = this;
      this._replyButton = $(this._blipContainer).find('.js-blip-reply-button')[0];
      return $(this._replyButton).bind('click', function() {
        _gaq.push(['_trackEvent', 'Blip usage', 'Insert reply', 'Re in blip menu']);
        return _this.insertReplyBlip();
      });
    };

    BlipView.prototype.insertReplyBlip = function() {
      this._parent.initInsertInlineBlip(true, {}, BlipThread.getBlipThread(this._blipContainer));
      if (!BrowserSupport.isWebKit()) {
        return this._waveViewModel.getView().runCheckRange();
      }
    };

    BlipView.prototype._onServerId = function(callback) {
      /*
              Вызывает callback, когда у текущего блипа появится serverId. Вызывает сразу, если serverId уже есть.
      */      if (this._model.serverId) return callback();
      return this._blipViewModel.on('set-server-id', callback);
    };

    BlipView.prototype._insertRecipientByEmail = function(position, email, callback) {
      var _this = this;
      return this._onServerId(function() {
        return _this._messagesProcessor.addRecipientByEmail(_this._model.serverId, _this._model.getVersion(), position, email, function(err, user) {
          var message;
          callback();
          if (err) {
            message = "Could not add recipient " + email;
            if (err.logId) message += ": " + err.logId;
            _this._waveViewModel.showWarning(message);
            return console.error(err);
          }
          return _this._waveViewModel.updateUserInfo(user);
        });
      });
    };

    BlipView.prototype._addTaskRecipient = function(params, callback) {
      var _this = this;
      return this._onServerId(function() {
        params.blipId = _this._model.serverId;
        params.version = _this._model.getVersion();
        return _this._tasksProcessor.assign(params, function(err, user) {
          var message;
          callback();
          if (err) {
            message = "Could not add task recipient " + params.recipientEmail;
            if (err.logId) message += ": " + err.logId;
            _this._waveViewModel.showWarning(message);
            return console.error(err);
          }
          return _this._waveViewModel.updateUserInfo(user);
        });
      });
    };

    BlipView.prototype._initEditor = function(content) {
      /*
              Инициализирует редактор содержимого блипа
      */
      var c, editorContainer, functions, isRoot, lightBoxId,
        _this = this;
      c = $(this._blipContainer);
      this._editorNode = c.find('.js-editor-container')[0];
      isRoot = this._parent ? false : true;
      lightBoxId = escapeHTML(this._model.id);
      functions = {
        getChildBlip: function(id) {
          return _this._childBlips[id];
        },
        getSnapshot: this._getContent,
        addInlineBlip: this._addInlineBlip,
        removeInlineBlip: this._removeInlineBlip,
        getRecipientInput: this._getRecipientInput,
        getRecipient: this._getRecipient,
        addRecipientByEmail: this._insertRecipientByEmail,
        getTaskRecipientInput: this._getTaskRecipientInput,
        getTaskRecipient: this._getTaskRecipient,
        addTaskRecipient: this._addTaskRecipient,
        getNewChildBlip: function(insertInBlip, params, thread) {
          return _this.initInsertInlineBlip(insertInBlip, params, thread);
        },
        getScrollableElement: function() {}
      };
      this._editor = new Editor(lightBoxId, EditorConfig, functions, !isRoot);
      this._editor.on('focused', function() {
        var e;
        if (_this._isActive) return;
        e = BrowserEvents.createCustomEvent(BrowserEvents.C_FOCUS_EVENT, true, false);
        e.blip = _this;
        return _this._blipContainer.dispatchEvent(e);
      });
      this._editor.on('mousedown', function() {
        var e;
        e = BrowserEvents.createCustomEvent(BrowserEvents.C_EDITOR_MOUSE_DOWN_EVENT, true, false);
        e.target = _this._editorNode;
        return _this._blipContainer.dispatchEvent(e);
      });
      this._editor.on('ops', this._processEditorChanges);
      this._editor.on('error', function(e) {
        _this._editor.setEditable(false);
        _this._editor.removeListener('ops', _this._processEditorChanges);
        return _this._blipProcessor.showPageError(e);
      });
      this._editor.on('copy', function() {
        return _this.renderRecursively();
      });
      this._editor.initContent();
      this.updatePermission();
      editorContainer = this._editor.getContainer();
      this._editorNode.appendChild(editorContainer);
      if (!this._parent) {
        return DOM.addClass(editorContainer, 'container-blip-editor');
      }
    };

    BlipView.prototype._initCopyPasteBlipButtons = function() {
      this._copyBlipButton.addEventListener('click', this._handleCopyBlipButton, false);
      this._pasteAtCursorButton.addEventListener('mousedown', this._handlePasteAtCursorButton, false);
      return this._pasteAfterBlipButton.addEventListener('click', this._handlePasteAfterBlipButton, false);
    };

    BlipView.prototype._handleCopyBlipButton = function() {
      _gaq.push(['_trackEvent', 'Blip usage', 'Copy blip']);
      this.renderRecursively();
      return this._parent.getEditor().copyElementToBuffer(this._blipContainer);
    };

    BlipView.prototype._handlePasteAtCursorButton = function() {
      _gaq.push(['_trackEvent', 'Blip usage', 'Paste blip', 'At cursor']);
      return this._editor.pasteBlipFromBufferToCursor();
    };

    BlipView.prototype._handlePasteAfterBlipButton = function() {
      _gaq.push(['_trackEvent', 'Blip usage', 'Paste blip', 'After blip']);
      return this._parent.getEditor().pasteBlipFromBufferAfter(this._blipContainer);
    };

    BlipView.prototype._getContent = function() {
      return this._model.getSnapshotContent();
    };

    BlipView.prototype._createDOM = function(ts) {
      /*
              Создает все необходимые для отображения сообщения DOM-ноды
      */
      var c, params;
      c = $(this._blipContainer);
      params = {
        isNotInRootThread: this.__isNotInRootThread,
        isRoot: !this._parent,
        datetime: formatDate(ts),
        fullDatetime: formatDate(ts, true),
        isAnonymous: !window.loggedIn
      };
      c.addClass('blip-container');
      if (!this._parent) {
        c.prepend(renderBlip(params));
      } else {
        c.append(renderBlip(params));
      }
      this._editorNode = c.find('.js-editor-container')[0];
      this._menuContainer = c.find('.js-blip-menu-container')[0] || null;
      this._menu = c.find('.js-blip-menu')[0] || null;
      return this._initReplyButton();
    };

    BlipView.prototype.recursivelyUpdatePermission = function() {
      var blip, _, _ref4, _results;
      this.updatePermission();
      _ref4 = this._childBlips;
      _results = [];
      for (_ in _ref4) {
        blip = _ref4[_];
        _results.push(blip.getView().recursivelyUpdatePermission());
      }
      return _results;
    };

    BlipView.prototype.updatePermission = function() {
      var role;
      role = this._waveViewModel.getRole();
      switch (role) {
        case ROLE_OWNER:
          this._permission = EDIT_PERMISSION;
          break;
        case ROLE_EDITOR:
          this._permission = EDIT_PERMISSION;
          break;
        case ROLE_COMMENTATOR:
          if (this._model.getAuthorId() === window.userInfo.id) {
            this._permission = EDIT_PERMISSION;
          } else {
            this._permission = COMMENT_PERMISSION;
          }
          break;
        default:
          this._permission = READ_PERMISSION;
      }
      if (!this._rendered) return;
      this._editor.setPermission(this._permission);
      if (this._permission === EDIT_PERMISSION) {
        $(this._blipContainer).removeClass('non-editable');
      } else {
        $(this._blipContainer).addClass('non-editable');
      }
      return this._showHideEditButtons();
    };

    BlipView.prototype.getPermission = function() {
      return this._permission;
    };

    BlipView.prototype.hasEditPermission = function() {
      return this._permission === EDIT_PERMISSION;
    };

    BlipView.prototype._processFocusInEvent = function(event) {
      this._focused = true;
      this._markAsRead();
      return event.stopPropagation();
    };

    BlipView.prototype._processFocusOutEvent = function(event) {
      this._focused = false;
      this._markAsRead();
      return event.stopPropagation();
    };

    BlipView.prototype.addChildToUnreads = function(id) {
      var blipThread, _ref4;
      blipThread = BlipThread.getBlipThread(this._blipContainer);
      if (blipThread != null ? blipThread.blipIsUnread(id) : void 0) return;
      if (blipThread != null) blipThread.setUnreadBlip(id);
      return (_ref4 = this._parent) != null ? _ref4.addChildToUnreads(id) : void 0;
    };

    BlipView.prototype.removeChildFromUnreads = function(id) {
      var blipThread, _ref4;
      blipThread = BlipThread.getBlipThread(this._blipContainer);
      if (blipThread && (!blipThread.blipIsUnread(id))) return;
      if (blipThread != null) blipThread.removeUnreadBlip(id);
      return (_ref4 = this._parent) != null ? _ref4.removeChildFromUnreads(id) : void 0;
    };

    BlipView.prototype._markAsRead = function(update, sendToServer) {
      var modelVersion;
      if (update == null) update = true;
      if (sendToServer == null) sendToServer = true;
      this.__hideUnreadIndicator();
      if (this._model.serverId) {
        this._waveViewModel.setBlipAsRead(this._model.serverId);
      }
      modelVersion = this._model.getVersion();
      if (!update) return this._lastReadVersion = modelVersion;
      if (this._lastReadVersion === modelVersion) return;
      this._lastReadVersion = modelVersion;
      this._model.isRead = true;
      if (sendToServer) {
        this._blipProcessor.updateBlipReader(this._blipViewModel);
        if (this._model.serverId) {
          return this._waveViewModel.checkBlipSetAsRead(this._model.serverId);
        }
      }
    };

    BlipView.prototype.markAsRead = function(sendToServer) {
      if (sendToServer == null) sendToServer = true;
      return this._markAsRead(true, sendToServer);
    };

    BlipView.prototype._markAsUnread = function() {
      this.__showUnreadIndicator();
      this._model.isRead = false;
      if (this._model.serverId) {
        return this._waveViewModel.setBlipAsUnread(this._model.serverId);
      }
    };

    BlipView.prototype.initInsertInlineBlip = function(insertIntoEditor, params, thread) {
      var blipThread, blipViewModel, container, e,
        _this = this;
      if (insertIntoEditor == null) insertIntoEditor = true;
      if (params == null) params = {};
      if (thread == null) thread = null;
      /*
              Начинает вставку вложенного сообщения
              @param insertToEnd: boolean, нужно ли вставить дочерний блип в конец
              @return: blipViewModel
      */
      container = this._getChildBlipContainer();
      blipViewModel = require('./processor_mobile').instance.createBlip(this._waveViewModel, container, params, this._blipViewModel);
      if (insertIntoEditor) {
        if (thread) {
          thread.appendBlipElement(container);
        } else {
          blipThread = new BlipThread("" + (Math.random()), container);
          blipThread.unfold();
          this._editor.insertNodeAtCurrentPosition(blipThread.getContainer());
        }
      }
      this._childBlips[blipViewModel.getModel().id] = blipViewModel;
      blipViewModel.on('set-server-id', function(serverId) {
        if (!_this._editor.insertBlip(serverId, container, (thread || blipThread).getId(), !!thread)) {
          return blipViewModel.destroy();
        }
      });
      blipViewModel.getView().renderRecursively();
      blipViewModel.setEditable(true);
      blipViewModel.getView().focus();
      e = BrowserEvents.createCustomEvent(BrowserEvents.C_BLIP_CREATE_EVENT, true, true);
      e.blip = blipViewModel;
      this._blipContainer.dispatchEvent(e);
      return blipViewModel;
    };

    BlipView.prototype._processEditorChanges = function(ops) {
      return this.submitOps(ops);
    };

    BlipView.prototype._getChildBlipContainer = function() {
      var res;
      res = document.createElement('span');
      res.contentEditable = 'false';
      return res;
    };

    BlipView.prototype._addInlineBlip = function(serverBlipId) {
      /*
              Добавляет вложенный в текущий блип
              @param serverBlipId: string
              @return: HTMLElement, контейнер вставки
      */
      var childBlip, childBlipId, container,
        _this = this;
      container = this._getChildBlipContainer();
      childBlipId = this._getChildBlipId(serverBlipId);
      if (childBlipId) {
        childBlip = this._childBlips[childBlipId];
        return childBlip.getView().getContainer();
      }
      if (this._requestedBlips[serverBlipId]) {
        return this._requestedBlips[serverBlipId];
      }
      this._requestedBlips[serverBlipId] = container;
      this._newChildBlip(serverBlipId, container, function(err, blipViewModel) {
        if (!(_this._requestedBlips[serverBlipId] != null)) return;
        if (err) return _this._blipProcessor.showPageError(err);
        delete _this._requestedBlips[serverBlipId];
        if (_this._childBlips != null) {
          return _this._childBlips[blipViewModel.getModel().id] = blipViewModel;
        } else {
          return blipViewModel.close();
        }
      });
      return container;
    };

    BlipView.prototype._getChildBlipId = function(serverBlipId) {
      /*
              Возвращает идентификатор вложенного блипа по серверному id
              @param serverBlipId: string
              @return: string|null
      */
      var blip, blipId, _ref4;
      _ref4 = this._childBlips;
      for (blipId in _ref4) {
        blip = _ref4[blipId];
        if (blip.getModel().serverId === serverBlipId) return blipId;
      }
      return null;
    };

    BlipView.prototype._removeInlineBlip = function(serverBlipId) {
      /*
              Удаляет вложенный в текущий блип
              @param blipId: string
      */
      var blipId, childBlip, childContainer, childThread, secondBlipId, _ref4;
      if (this._requestedBlips[serverBlipId] != null) {
        delete this._requestedBlips[serverBlipId];
      }
      blipId = this._getChildBlipId(serverBlipId);
      if (blipId === null) return;
      childBlip = this._childBlips[blipId];
      childContainer = childBlip.getView().getContainer();
      childThread = BlipThread.getBlipThread(childContainer);
      if (childThread != null ? childThread.isFirstInThread(childContainer) : void 0) {
        secondBlipId = (_ref4 = childThread.getSecondBlipElement()) != null ? _ref4['__rizzoma_id'] : void 0;
        if (secondBlipId) {
          this._childBlips[secondBlipId].getView().setFoldedByDefault(childBlip.getModel().isFoldedByDefault());
        }
      }
      childBlip.destroy();
      return delete this._childBlips[blipId];
    };

    BlipView.prototype._getRecipient = function() {
      var args, canConvert, canDelete,
        _this = this;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      canDelete = function(id) {
        var _ref4;
        return _this._permission === EDIT_PERMISSION || id === ((_ref4 = window.userInfo) != null ? _ref4.id : void 0);
      };
      canConvert = function(id) {
        return _this._permission === EDIT_PERMISSION;
      };
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return typeof result === "object" ? result : child;
      })(Recipient, [this._waveViewModel, canDelete, canConvert].concat(__slice.call(args)), function() {});
    };

    BlipView.prototype._getRecipientInput = function() {
      return new RecipientInput(this._waveViewModel);
    };

    BlipView.prototype._getTaskRecipientInput = function() {
      return new TaskRecipientInput(this._waveViewModel, this._updateTaskSearchInfo);
    };

    BlipView.prototype._updateTaskSearchInfo = function(data) {
      var info, recipient, sender;
      info = {
        waveId: this._waveViewModel.getServerId(),
        blipId: this._model.serverId,
        changed: true,
        title: this._model.getTitle(),
        snippet: this._model.getSnippet(),
        isRead: true,
        status: data.status
      };
      if ((data.deadlineDate != null) || data.deadlineDatetime) {
        info.deadline = {
          date: data.deadlineDate,
          datetime: data.deadlineDatetime
        };
      }
      if (data.recipientId != null) {
        recipient = this._waveViewModel.getUser(data.recipientId);
        info.recipientName = recipient.getName();
        info.recipientEmail = recipient.getEmail();
        info.recipientAvatar = recipient.getAvatar();
      } else {
        info.recipientEmail = data.recipientEmail;
      }
      sender = this._waveViewModel.getUser(data.senderId);
      info.senderName = sender.getName();
      info.senderEmail = sender.getEmail();
      info.senderAvatar = sender.getAvatar();
      return this._tasksProcessor.updateTaskSearchInfo(info);
    };

    BlipView.prototype._getTaskRecipient = function() {
      var args, canEditBlip,
        _this = this;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      canEditBlip = function() {
        return _this._permission === EDIT_PERMISSION;
      };
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return typeof result === "object" ? result : child;
      })(TaskRecipient, [this._waveViewModel].concat(__slice.call(args), [this._updateTaskSearchInfo], [canEditBlip]), function() {});
    };

    BlipView.prototype.setEditable = function(_editable) {
      this._editable = _editable;
      /*
              Устанавливает режим редактирования
              @param editable: bool
      */
      if (!this._parent) this._editable = false;
      return this._editor.setEditable(this._editable);
    };

    BlipView.prototype.focus = function() {
      /*
              Устанавливает курсор в текущий редактор
      */
      var _ref4;
      this._markAsRead();
      return (_ref4 = this._editor) != null ? _ref4.focus() : void 0;
    };

    BlipView.prototype.markActive = function() {
      this._isActive = true;
      $(this._blipContainer).addClass('active');
      this._markAsRead();
      if (!this._blipMenu && this._parent) return this._initMenu();
    };

    BlipView.prototype.unmarkActive = function() {
      this._isActive = false;
      return $(this._blipContainer).removeClass('active');
    };

    BlipView.prototype.isActive = function() {
      return this._isActive;
    };

    BlipView.prototype.removeChild = function(id) {
      /*
              Удаляет дочерний блип
              @param id: string
      */
      var blip, _ref4;
      blip = this._childBlips[id];
      if (!blip) return;
      if (blip.getModel().serverId != null) {
        return this._editor.removeBlip(blip.getModel().serverId);
      }
      blip.destroy();
      if ((_ref4 = window.getSelection()) != null) _ref4.removeAllRanges();
      return delete this._childBlips[id];
    };

    BlipView.prototype._remove = function(event) {
      /*
              Удаляет это сообщение
      */      event.stopPropagation();
      if (window.confirm("Delete reply?")) {
        _gaq.push(['_trackEvent', 'Blip usage', 'Delete blip']);
        return this._parent.removeChild(this._model.id);
      }
    };

    BlipView.prototype._hideButton = function(button) {
      $(button).addClass('hidden');
      return $(button).prev().addClass('hidden');
    };

    BlipView.prototype._showButton = function(button) {
      $(button).removeClass('hidden');
      return $(button).prev().removeClass('hidden');
    };

    BlipView.prototype._showHideEditButtons = function() {
      var _ref4;
      if (this._permission === EDIT_PERMISSION) {
        this._showButton(this._deleteButton);
        this._showButton(this._isFoldedByDefaultBox);
      } else {
        this._hideButton(this._deleteButton);
        this._hideButton(this._isFoldedByDefaultBox);
      }
      if ((_ref4 = this._permission) === EDIT_PERMISSION || _ref4 === COMMENT_PERMISSION) {
        this._showButton(this._replyButton);
        this._showButton(this._pasteAtCursorButton);
        return this._showButton(this._pasteAfterBlipButton);
      } else {
        this._hideButton(this._replyButton);
        this._hideButton(this._pasteAtCursorButton);
        return this._hideButton(this._pasteAfterBlipButton);
      }
    };

    BlipView.prototype.getContainer = function() {
      /*
              Возвращает контейнер, в котором содержится сообщение
              @return: HTMLNode
      */      return this._blipContainer;
    };

    BlipView.prototype._newChildBlip = function(serverBlipId, container, callback) {
      /*
              Создает объект вложенного блипа
              @param serverBlipId: string, идентификатор блипа
              @param container: HTMLNode, нода, в которой будет сообщение
              @param callback: function
                  callback(BlipViewModel)
      */      return require('./processor_mobile').instance.openBlip(this._waveViewModel, serverBlipId, container, this._blipViewModel, callback);
    };

    BlipView.prototype.applyisFoldedByDefaultOp = function(op) {
      /*
              Обновляет пункт меню "Свернут по умолчанию" по чужой операции
      */      if (op.oi) {
        return $(this._isFoldedByDefaultBox).addClass('active');
      } else {
        return $(this._isFoldedByDefaultBox).removeClass('active');
      }
    };

    BlipView.prototype.applyParticipantOp = function(op) {
      var _ref4;
      if (!this._parent) return;
      return (_ref4 = this._contributors) != null ? _ref4.applyOp(op) : void 0;
    };

    BlipView.prototype._opSetsUnreadIndicator = function(op) {
      var blockType, param, paramName;
      if (op.paramsi || op.paramsd) {
        param = op.paramsi || op.paramsd;
        for (paramName in param) {
          if (paramName === 'lastSent' || paramName === 'lastSenderId') {
            return false;
          }
        }
      }
      if (!((op.ti != null) || (op.td != null))) return true;
      blockType = op[ModelField.PARAMS][ParamsField.TYPE];
      if (blockType === ModelType.BLIP) return false;
      if ((op.td != null) && (blockType === ModelType.RECIPIENT || blockType === ModelType.TASK_RECIPIENT)) {
        return false;
      }
      return true;
    };

    BlipView.prototype._opsSetUnreadIndicator = function(ops) {
      var op, _i, _len;
      for (_i = 0, _len = ops.length; _i < _len; _i++) {
        op = ops[_i];
        if (this._opSetsUnreadIndicator(op)) return true;
      }
    };

    BlipView.prototype._isMyMeta = function(meta) {
      var _ref4;
      if ((meta != null ? meta.user : void 0) != null) {
        if (meta.user === ((_ref4 = window.userInfo) != null ? _ref4.id : void 0)) {
          return true;
        }
      }
    };

    BlipView.prototype.applyOps = function(ops, shiftCursor, meta) {
      /*
              Применяет операции, сделанные другими пользователями
              @param ops: [ShareJS operation]
              @param shiftCursor: boolean, смещать ли курсор к выполненной операции
              @param meta: object, метаинформация к операциям, если они пришли с сервера
      */
      var name, u, user;
      if (!this._editor) {
        this._processBlipOps(ops);
      } else {
        user = null;
        if ((meta != null) && (meta.user != null) && !this._isMyMeta(meta)) {
          u = this._waveViewModel.getUser(meta.user);
          if (u.isLoaded() && (name = u.getRealName() || u.getEmail())) {
            user = {
              name: name,
              id: u.getId()
            };
          }
        }
        this._editor.applyOps(ops, shiftCursor, user);
      }
      if (this._focused) return;
      if ((meta != null) && this._isMyMeta(meta)) {
        return this._markAsRead();
      } else if (this._opsSetUnreadIndicator(ops)) {
        return this._markAsUnread();
      }
    };

    BlipView.prototype._processBlipOps = function(ops) {
      var blipId, block, changedBlipIds, haveChanged, haveChanges, id, op, opType, _i, _j, _len, _len2, _ref4, _results;
      changedBlipIds = {};
      haveChanged = false;
      for (_i = 0, _len = ops.length; _i < _len; _i++) {
        op = ops[_i];
        if ((!(op.ti != null)) && (!(op.td != null))) continue;
        opType = op[ModelField.PARAMS][ParamsField.TYPE];
        if (opType !== ModelType.BLIP) continue;
        blipId = op[ModelField.PARAMS][ParamsField.ID];
        changedBlipIds[blipId] = true;
        haveChanges = true;
      }
      if (!haveChanges) return;
      _ref4 = this._model.getSnapshotContent();
      for (_j = 0, _len2 = _ref4.length; _j < _len2; _j++) {
        block = _ref4[_j];
        id = block[ModelField.PARAMS][ParamsField.ID];
        if (!(id in changedBlipIds)) continue;
        delete changedBlipIds[id];
        this._addInlineBlip(id);
      }
      _results = [];
      for (id in changedBlipIds) {
        _results.push(this._removeInlineBlip(id));
      }
      return _results;
    };

    BlipView.prototype.submitOps = function(ops) {
      /*
              Отправляет операции пользователя на сервер
              @param ops: [ShareJS operation]
      */      if (!ops.length) return;
      try {
        this._model.submitOps(ops);
        return this.emit('ops', ops);
      } catch (e) {
        this._editor.removeListener('ops', this._processEditorChanges);
        this._editor.setEditable(false);
        return this._blipProcessor.showPageError(e);
      }
    };

    BlipView.prototype.isRead = function() {
      return this._model.isRead;
    };

    BlipView.prototype.getParent = function() {
      return this._parent;
    };

    BlipView.prototype._setIsFoldedByDefault = function() {
      /*
              Устанавливает поле "isFoldedByDefault" в модели равным галочке "Свернут по умолчанию"
      */
      var folded;
      folded = $(this._isFoldedByDefaultBox).hasClass('active');
      if (folded) {
        $(this._isFoldedByDefaultBox).removeClass('active');
      } else {
        _gaq.push(['_trackEvent', 'Blip usage', 'Set always hide']);
        $(this._isFoldedByDefaultBox).addClass('active');
      }
      return this._model.setIsFoldedByDefault(!folded);
    };

    BlipView.prototype.setFoldedByDefault = function(folded) {
      this._model.setIsFoldedByDefault(folded);
      if (folded) {
        return $(this._isFoldedByDefaultBox).addClass('active');
      } else {
        return $(this._isFoldedByDefaultBox).removeClass('active');
      }
    };

    BlipView.prototype.getChildBlipByServerId = function(serverBlipId) {
      /*
              Возвращает объект со вложенными блипами
              @return: BlipViewModel|null
      */
      var childBlipId;
      childBlipId = this._getChildBlipId(serverBlipId);
      if (!(childBlipId != null)) return null;
      return this._childBlips[childBlipId];
    };

    BlipView.prototype.destroy = function() {
      var _ref4, _ref5, _ref6, _ref7, _ref8;
      BlipView.__super__.destroy.call(this);
      if ((_ref4 = this._copyBlipButton) != null) {
        _ref4.removeEventListener('click', this._handleCopyBlipButton, false);
      }
      if ((_ref5 = this._pasteAtCursorButton) != null) {
        _ref5.removeEventListener('mousedown', this._handlePasteAtCursorButton, false);
      }
      if ((_ref6 = this._pasteAfterBlipButton) != null) {
        _ref6.removeEventListener('mousedown', this._handlePasteAfterBlipButton, false);
      }
      this.removeAllListeners();
      delete this._blipViewModel;
      if (this._model.serverId) {
        this._waveViewModel.setBlipAsRemoved(this._model.serverId);
      }
      delete this._waveViewModel;
      if (this._parent) {
        if ((_ref7 = this._contributors) != null) _ref7.destroy();
        delete this._contributors;
        delete this._parent;
      }
      if ((_ref8 = this._editor) != null) _ref8.destroy();
      delete this._model;
      return $(this._blipContainer).remove();
    };

    BlipView.prototype.getBlipContainingCursor = function(cursor) {
      /*
              Возвращает самый вложенный блип, который содержит в себе указанный курсор
              @param cursor: [HTMLElement, int]
              @return: BlipView|null
      */
      var blip, res, _, _ref4;
      if (!this._editor) return null;
      if (this._editor.getContainer() === cursor[0]) return this;
      if (!this._editor.containsNode(cursor[0])) return null;
      _ref4 = this._childBlips;
      for (_ in _ref4) {
        blip = _ref4[_];
        res = blip.getView().getBlipContainingCursor(cursor);
        if (res) return res;
        if (blip.getView().getBlipContainingElement(cursor[0])) return null;
      }
      return this;
    };

    BlipView.prototype.getBlipContainingElement = function(e) {
      /*
              Возвращает самый вложенный блип, который содержит в себе указанный элемент
              @param e: HTMLElement
              @return: BlipView|null
      */
      var blip, res, _, _ref4;
      if (!DOM.contains(this._blipContainer, e)) return null;
      _ref4 = this._childBlips;
      for (_ in _ref4) {
        blip = _ref4[_];
        res = blip.getView().getBlipContainingElement(e);
        if (res) return res;
      }
      return this;
    };

    BlipView.prototype.getEditor = function() {
      /*
              Возвращает редактор внутри этого блипа
              @return: Editor
      */      return this._editor;
    };

    BlipView.prototype.getViewModel = function() {
      return this._blipViewModel;
    };

    return BlipView;

  })(BlipViewBase);

  MicroEvent.mixin(BlipView);

  module.exports = {
    BlipView: BlipView
  };

}).call(this);

});

require.define("/lib/client/client/editor/editor_mobile_v2.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BrowserEvents, BrowserSupport, COMMENT_PERMISSION, CachedRange, Diff, DomUtils, EDIT_PERMISSION, Editor, EditorV2, EventType, LineLevelParams, ModelField, ModelType, ParamsField, SERIALIZED_INDEX, SERIALIZED_TYPES, SPECIAL_INPUT, SelectionHelper, StringUtil, TextLevelParams, editorTmpl, renderEditor, serializeElement, serializeNonTextElement, _ref, _ref2, _ref3,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  DomUtils = require('../utils/dom');

  SelectionHelper = require('./selection/html_selection_helper');

  EditorV2 = require('./editor_v2').Editor;

  BrowserSupport = require('../utils/browser_support_mobile');

  BrowserEvents = require('../utils/browser_events');

  CachedRange = require('./cached_range').CachedRange;

  _ref = require('./model'), TextLevelParams = _ref.TextLevelParams, LineLevelParams = _ref.LineLevelParams, ModelField = _ref.ModelField, ParamsField = _ref.ParamsField, ModelType = _ref.ModelType;

  _ref2 = require('./common'), EventType = _ref2.EventType, SPECIAL_INPUT = _ref2.SPECIAL_INPUT;

  StringUtil = require('../utils/string').StringUtil;

  Diff = require('./utils/diff');

  _ref3 = require('../blip/model'), EDIT_PERMISSION = _ref3.EDIT_PERMISSION, COMMENT_PERMISSION = _ref3.COMMENT_PERMISSION;

  editorTmpl = function() {
    return ul('js-editor editor', {
      contentEditable: 'false',
      spellcheck: 'false',
      tabIndex: '1'
    });
  };

  renderEditor = window.CoffeeKup.compile(editorTmpl);

  SERIALIZED_TYPES = {};

  SERIALIZED_INDEX = 1;

  serializeNonTextElement = function(elType) {
    if (SERIALIZED_TYPES[elType] != null) return SERIALIZED_TYPES[elType];
    return SERIALIZED_TYPES[elType] = SERIALIZED_INDEX++;
  };

  serializeElement = function(elType, el) {
    var text;
    if (elType === ModelType.TEXT) {
      if ((text = el.textContent) != null) {
        return text;
      } else {
        return el.innerText;
      }
    }
    return serializeNonTextElement(elType);
  };

  Editor = (function(_super) {

    __extends(Editor, _super);

    function Editor() {
      this._realSetCachedRange = __bind(this._realSetCachedRange, this);
      this._handleTargetBlur = __bind(this._handleTargetBlur, this);
      this._handleElementInput = __bind(this._handleElementInput, this);
      this._processMouseDownEvent = __bind(this._processMouseDownEvent, this);
      this._handleClickEvent = __bind(this._handleClickEvent, this);
      Editor.__super__.constructor.apply(this, arguments);
    }

    Editor.prototype._init = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      Editor.__super__._init.apply(this, args);
      return this._container.addEventListener(BrowserEvents.CLICK_EVENT, this._handleClickEvent, false);
    };

    Editor.prototype.initContent = function() {
      var content;
      content = this._getSnapshot();
      try {
        return this._renderer.renderContent(this._container, content);
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype.setEditable = function(editable) {
      if (!BrowserSupport.isSupported()) return;
      if (editable === this._editable) return;
      this._editable = editable;
      if (!this._editable) {
        if (this._editableElement) {
          return this._unbindFromEditableElement(this._editableElement);
        }
      }
    };

    Editor.prototype.focus = function() {
      var child;
      if (this._editableElement) return;
      if (this._editable && (child = this._container.firstChild) && !this._editableElement) {
        return this._setSelectionToElement(child, 0);
      }
    };

    Editor.prototype.applyOp = function() {
      var args, el;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((el = this._editableElement) && this._isTmpElement(el)) {
        this._unbindFromEditableElement(el);
      }
      Editor.__super__.applyOp.apply(this, args);
      return this._preserveState();
    };

    Editor.prototype.applyOps = function() {
      var args, el;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((el = this._editableElement) && this._isTmpElement(el)) {
        this._unbindFromEditableElement(el);
      }
      Editor.__super__.applyOps.apply(this, args);
      return this._preserveState();
    };

    Editor.prototype.destroy = function() {
      this._container.removeEventListener(BrowserEvents.CLICK_EVENT, this._handleClickEvent, false);
      return Editor.__super__.destroy.call(this);
    };

    Editor.prototype._createDom = function() {
      var tmpContainer;
      tmpContainer = document.createElement('span');
      $(tmpContainer).append(renderEditor({
        isEditable: this._editable
      }));
      return this._container = tmpContainer.firstChild;
    };

    Editor.prototype.__registerDomEventHandling = function() {
      this._container.addEventListener(BrowserEvents.MOUSE_DOWN_EVENT, this._processMouseDownEvent, false);
      this._container.addEventListener(BrowserEvents.KEY_DOWN_EVENT, this._processKeyEvent, false);
      this._container.addEventListener(BrowserEvents.KEY_PRESS_EVENT, this._processKeyEvent, false);
      this._container.addEventListener(BrowserEvents.COPY_EVENT, this._processCopyEvent, false);
      return this._container.addEventListener(BrowserEvents.PASTE_EVENT, this._processPasteEvent, false);
    };

    Editor.prototype.__unregisterDomEventHandling = function() {
      this._container.removeEventListener(BrowserEvents.MOUSE_DOWN_EVENT, this._processMouseDownEvent, false);
      this._container.removeEventListener(BrowserEvents.KEY_DOWN_EVENT, this._processKeyEvent, false);
      this._container.removeEventListener(BrowserEvents.KEY_PRESS_EVENT, this._processKeyEvent, false);
      this._container.removeEventListener(BrowserEvents.COPY_EVENT, this._processCopyEvent, false);
      return this._container.removeEventListener(BrowserEvents.PASTE_EVENT, this._processPasteEvent, false);
    };

    Editor.prototype._processCopyEvent = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      Editor.__super__._processCopyEvent.apply(this, args);
      return delete this._cachedRange;
    };

    Editor.prototype._getLineElements = function(line) {
      var el, elType, els, params, res, text;
      res = '';
      els = [];
      while ((el = this.__renderer.getNextElement(el)) && (params = this.__renderer.getElementParams(el)) && ((elType = params[ParamsField.TYPE]) !== ModelType.LINE)) {
        text = serializeElement(elType, el);
        res += text;
        els.push({
          params: params,
          text: text,
          length: text.length
        });
      }
      return els;
    };

    Editor.prototype._handleKeyEvent = function(event) {
      var eventType;
      eventType = this._getKeyEventType(event);
      this._clearCachedRange();
      switch (eventType) {
        case EventType.LINE:
          try {
            this._handleNewLine();
          } catch (e) {
            this.emit('error', e);
          }
          return true;
        case EventType.TAB:
          try {
            this._handleTab(event.shiftKey);
          } catch (e) {
            this.emit('error', e);
          }
          return true;
        case EventType.DELETE:
          try {
            this._handleDelete(event);
          } catch (e) {
            this.emit('error', e);
          }
          return true;
        default:
          return false;
      }
    };

    Editor.prototype._submitOp = function() {
      var args, el;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._clearState();
      if ((el = this._editableElement) && this._isTmpElement(el)) {
        this._unbindFromEditableElement(el);
      }
      Editor.__super__._submitOp.apply(this, args);
      return this._maybeSaveState();
    };

    Editor.prototype._submitOps = function() {
      var args, el;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._clearState();
      if ((el = this._editableElement) && this._isTmpElement(el)) {
        this._unbindFromEditableElement(el);
      }
      Editor.__super__._submitOps.apply(this, args);
      return this._maybeSaveState();
    };

    Editor.prototype._handleClickEvent = function(event) {
      if (event.processed) return;
      this._processCursor();
      return event.processed = true;
    };

    Editor.prototype._processMouseDownEvent = function(event) {
      var container, element, _ref4;
      this._clearCachedRange();
      if (event.button) return;
      event.stopPropagation();
      try {
        this.emit(event.type);
      } catch (_error) {}
      if (!this._editable) return;
      element = event.target;
      if (DomUtils.isButtonElement(element)) return;
      container = element;
      while (container && !DomUtils.hasClass(container, 'js-editor')) {
        if (DomUtils.hasClass(container, 'js-blips-container')) return;
        container = container.parentNode;
      }
      if (!container || container !== this._container) return;
      if (element === document.activeElement) return;
      if (document.activeElement !== element) {
        if ((_ref4 = document.activeElement) != null) _ref4.blur();
        return this._handleElementMouseDown(element);
      }
      return this._handleElementMouseDown(element);
    };

    Editor.prototype._handleElementMouseDown = function(element) {
      var _this = this;
      while (this._renderer.getElementType(element) !== ModelType.LINE) {
        element = this._renderer.getPreviousElement(element);
      }
      element.contentEditable = 'true';
      return setTimeout(function() {
        return _this._bindToEditableElement(element);
      }, 0);
    };

    Editor.prototype._getTmpElement = function() {
      var tmpEl;
      tmpEl = document.createElement('span');
      tmpEl.className = 'temporary-cursor-element';
      tmpEl.rzTmp = true;
      return tmpEl;
    };

    Editor.prototype._isTmpElement = function(el) {
      return el.rzTmp;
    };

    Editor.prototype._removeTmpElement = function() {
      if (!this._tmpElement) return;
      DomUtils.remove(this._tmpElement);
      return this._tmpElement = null;
    };

    Editor.prototype._insertTmpElementAfter = function(afterElement) {
      var tmpEl;
      this._removeTmpElement();
      tmpEl = this._getTmpElement();
      this._renderer.insertInlineElementAfter(tmpEl, afterElement);
      return this._tmpElement = tmpEl;
    };

    Editor.prototype._makePersistentElement = function(tmpEl) {
      var params;
      if (tmpEl !== this._tmpElement) throw new Error('Non tmp element provided');
      tmpEl.rzTmp = false;
      params = this._getElementTextParams();
      this._renderer.setParamsToElement(tmpEl, params);
      DomUtils.removeClass(tmpEl, 'temporary-cursor-element');
      return this._tmpElement = null;
    };

    Editor.prototype._setSelectionToElement = function(anchorNode, anchorOffset) {
      var e, element, elementLength, elementType, focusLine, line, newElement, newOffset, offset, _ref4,
        _this = this;
      console.log('setSelection', anchorNode, anchorOffset);
      _ref4 = this._getCurrentElement(anchorNode, anchorOffset), element = _ref4[0], offset = _ref4[1];
      elementType = this._renderer.getElementType(element);
      if (!(line = this._renderer.getParagraphNode(element))) return;
      if (line !== this._editableElement) {
        if (this._editableElement) {
          this._unbindFromEditableElement(this._editableElement);
        }
        line.contentEditable = "true";
        SelectionHelper.setCaret(anchorNode, anchorOffset);
        focusLine = function() {
          console.error('touchStart triggered');
          line.removeEventListener(BrowserEvents.TOUCH_START_EVENT, focusLine, false);
          line.focus();
          return _this._bindToEditableElement(line);
        };
        try {
          e = BrowserEvents.createTouchEvent(BrowserEvents.TOUCH_START_EVENT, true, true);
        } catch (_error) {}
        if (e) {
          line.addEventListener(BrowserEvents.TOUCH_START_EVENT, focusLine, false);
          line.dispatchEvent(e);
        } else {
          focusLine();
        }
        return;
      }
      switch (elementType) {
        case ModelType.TEXT:
          anchorNode = element.firstChild;
          anchorOffset = offset;
          break;
        default:
          elementLength = this._renderer.getElementLength(element);
          if (offset === elementLength) {
            newElement = this._renderer.getNextElement(element);
            newOffset = 0;
          } else if (!offset) {
            newElement = this._renderer.getPreviousElement(element);
            newOffset = this._renderer.getElementLength(newElement);
          }
          if (this._renderer.getElementType(newElement) === ModelType.TEXT) {
            anchorNode = newElement.firstChild;
            anchorOffset = newOffset;
            element = newElement;
            break;
          }
          if (!offset && newElement) element = newElement;
          anchorNode = this._insertTmpElementAfter(element);
          anchorOffset = 0;
          this._saveState();
          console.warn('insert tmp element');
      }
      return SelectionHelper.setCaret(anchorNode, anchorOffset);
    };

    Editor.prototype._getLineNodes = function(line) {
      var node, nodes, texts, _i, _len, _ref4;
      nodes = [];
      texts = [];
      _ref4 = line.childNodes;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        node = _ref4[_i];
        nodes.push(node);
        if (this.__renderer.getElementType(node) === ModelType.TEXT || this._isTmpElement(node)) {
          texts.push(node.textContent);
        } else {
          texts.push(' ');
        }
      }
      return [nodes, texts];
    };

    Editor.prototype._clearState = function() {
      this._oldEls = null;
      return this._oldTexts = null;
    };

    Editor.prototype._saveState = function() {
      var _ref4;
      return _ref4 = this._getLineNodes(this._editableElement), this._oldEls = _ref4[0], this._oldTexts = _ref4[1], _ref4;
    };

    Editor.prototype._maybeSaveState = function() {
      if (!this._oldEls && this._editableElement) return this._saveState();
    };

    Editor.prototype._preserveState = function() {
      if (!this._editableElement) return;
      this._maybeInsertTmpElement();
      return this._saveState();
    };

    Editor.prototype._maybeInsertTmpElement = function() {
      var range;
      range = SelectionHelper.getRangeInside(this._container);
      console.log('maybeInsertTmpEl', range);
      if (!range) return;
      if (!range.collapsed) return;
      return this._setSelectionToElement(range.startContainer, range.startOffset);
    };

    Editor.prototype._cleanLineElements = function(line) {
      var el, i, _ref4;
      _ref = line.childNodes;
      if (!_ref.length) return;
      for (i = _ref4 = _ref.length - 1; _ref4 <= 0 ? i <= 0 : i >= 0; _ref4 <= 0 ? i++ : i--) {
        el = _ref[i];
        if (DomUtils.isTextNode(el) && !el.data) {
          DomUtils.remove(el);
          continue;
        }
        if (DomUtils.isBrElement(el) && line.lastChild !== el) {
          DomUtils.remove(el);
          continue;
        }
      }
      if (!DomUtils.isBrElement(line.lastChild)) {
        return line.appendChild(document.createElement('br'));
      }
    };

    Editor.prototype._cleanLine = function(line) {
      var el, i, _ref4;
      _ref = line.childNodes;
      if (!_ref.length) return;
      this._removeTmpElement();
      for (i = _ref4 = _ref.length - 1; _ref4 <= 0 ? i <= 0 : i >= 0; _ref4 <= 0 ? i++ : i--) {
        el = _ref[i];
        if (DomUtils.isTextNode(el) && !el.data) {
          DomUtils.remove(el);
          continue;
        }
        if (this._renderer.getElementType(el) === ModelType.TEXT && !el.textContent) {
          DomUtils.remove(el);
        }
      }
      return this._cleanLineElements(line);
    };

    Editor.prototype._getLineNodes = function(line) {
      var node, nodes, texts, _i, _len, _ref4;
      nodes = [];
      texts = [];
      _ref4 = line.childNodes;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        node = _ref4[_i];
        nodes.push(node);
        if (this.__renderer.getElementType(node) === ModelType.TEXT || this._isTmpElement(node)) {
          texts.push(node.textContent);
        } else {
          texts.push(' ');
        }
      }
      return [nodes, texts];
    };

    Editor.prototype._clearState = function() {
      this._oldEls = null;
      return this._oldTexts = null;
    };

    Editor.prototype._saveState = function() {
      var _ref4;
      return _ref4 = this._getLineNodes(this._editableElement), this._oldEls = _ref4[0], this._oldTexts = _ref4[1], _ref4;
    };

    Editor.prototype._maybeSaveState = function() {
      if (!this._oldEls && this._editableElement) return this._saveState();
    };

    Editor.prototype._preserveState = function() {
      if (!this._editableElement) return;
      this._maybeInsertTmpElement();
      return this._saveState();
    };

    Editor.prototype._maybeInsertTmpElement = function() {
      var range;
      range = SelectionHelper.getRangeInside(this._container);
      console.log('maybeInsertTmpEl', range);
      if (!range) return;
      if (!range.collapsed) return;
      return this._setSelectionToElement(range.startContainer, range.startOffset);
    };

    Editor.prototype._cleanLineElements = function(line) {
      var el, i, _ref4;
      _ref = line.childNodes;
      for (i = _ref4 = _ref.length - 1; _ref4 <= 0 ? i <= 0 : i >= 0; _ref4 <= 0 ? i++ : i--) {
        el = _ref[i];
        if (DomUtils.isTextNode(el) && !el.data) {
          DomUtils.remove(el);
          continue;
        }
        if (DomUtils.isBrElement(el) && line.lastChild !== el) {
          DomUtils.remove(el);
          continue;
        }
      }
      if (!DomUtils.isBrElement(line.lastChild)) {
        return line.appendChild(document.createElement('br'));
      }
    };

    Editor.prototype._cleanLine = function(line) {
      var el, i, _ref4;
      _ref = line.childNodes;
      for (i = _ref4 = _ref.length - 1; _ref4 <= 0 ? i <= 0 : i >= 0; _ref4 <= 0 ? i++ : i--) {
        el = _ref[i];
        if (DomUtils.isTextNode(el) && !el.data || this._isTmpElement(el)) {
          DomUtils.remove(el);
          continue;
        }
        if (this._renderer.getElementType(el) === ModelType.TEXT && !el.textContent) {
          DomUtils.remove(el);
        }
      }
      return this._cleanLineElements(line);
    };

    Editor.prototype._bindToEditableElement = function(el) {
      if (el !== document.activeElement) {
        return this._unbindFromEditableElement(el);
      }
      console.log('_bindToEditableElement', el);
      try {
        this.emit('focused');
      } catch (_error) {}
      this._cleanLine(el);
      this._editableElement = el;
      this._preserveState();
      delete this._cachedRange;
      el.addEventListener(BrowserEvents.BLUR_EVENT, this._handleTargetBlur, false);
      return el.addEventListener(BrowserEvents.INPUT_EVENT, this._handleElementInput, false);
    };

    Editor.prototype._unbindFromEditableElement = function(el) {
      console.log('unbindFromEditableElement', el);
      el.contentEditable = 'false';
      el.removeAttribute('contentEditable', 0);
      el.removeEventListener(BrowserEvents.BLUR_EVENT, this._handleTargetBlur, false);
      el.removeEventListener(BrowserEvents.INPUT_EVENT, this._handleElementInput, false);
      this._cleanLine(el);
      if (this._editableElement === el) this._editableElement = null;
      if (this._cursor) return this.clearCursor();
    };

    Editor.prototype._getNewLineOp = function() {
      var params;
      params = {};
      params[ParamsField.TYPE] = ModelType.LINE;
      params[ParamsField.RANDOM] = Math.random();
      return {
        ti: ' ',
        params: params
      };
    };

    Editor.prototype.__applyTextModifiers = function(params) {
      var key, value, _ref4, _results;
      _ref4 = this._modifiers;
      _results = [];
      for (key in _ref4) {
        value = _ref4[key];
        if (value === null) {
          _results.push(delete params[key]);
        } else {
          _results.push(params[key] = value);
        }
      }
      return _results;
    };

    Editor.prototype._getTextParamsFromElements = function(els, offset, length) {
      var availableLength, el, index, res, text, wholeText;
      index = 0;
      res = [];
      el = els[index];
      while (offset && el) {
        if (el.length > offset) break;
        offset -= el.length;
        el = els[++index];
      }
      if (!el) return null;
      wholeText = '';
      while (length) {
        if (!el) return null;
        if (offset + length <= el.length) {
          text = el.text.substr(offset, length);
          wholeText += text;
          res.push({
            text: text,
            params: el.params
          });
          break;
        }
        availableLength = el.length - offset;
        text = el.text.substr(offset, availableLength);
        wholeText += text;
        res.push({
          text: text,
          params: el.params
        });
        length -= availableLength;
        offset = 0;
        el = els[++index];
      }
      if (res.length > 1) console.warn('text consist of several parts');
      res.wholeText = wholeText;
      return res;
    };

    Editor.prototype._traverseNodeTextContent = function(el) {
      var text;
      text = StringUtil.traverseString(el.textContent);
      if (text !== el.textContent) el.textContent = text;
      return text;
    };

    Editor.prototype._normalizeTextElement = function(el) {
      var normalizedText;
      normalizedText = StringUtil.traverseString(el.textContent);
      el.textContent = normalizedText;
      try {
        SelectionHelper.setCaret(el.firstChild, normalizedText.length);
      } catch (_error) {}
      return normalizedText;
    };

    Editor.prototype._compareLineElements = function(oldEls, oldTexts, newEls, offset) {
      var elIndex, insertNewTextElement, len, newEl, newElsLength, newIndex, newText, oldEl, oldIndex, oldText, ops, params, r, startContainer, startOffset, type, _len,
        _this = this;
      newIndex = 0;
      ops = [];
      newEl = newEls[newIndex];
      if (r = SelectionHelper.getRange()) {
        startContainer = r.startContainer;
        startOffset = r.startOffset;
      }
      insertNewTextElement = function(newEl) {
        var params, text, tmp;
        if (!DomUtils.isTextNode(newEl)) return;
        if (!(text = _this._traverseNodeTextContent(newEl))) {
          return DomUtils.remove(newEl);
        }
        console.log(text);
        tmp = _this._insertTmpElementAfter(newEl);
        tmp.appendChild(newEl);
        _this._makePersistentElement(tmp);
        params = _this._renderer.getElementParams(tmp);
        ops.push({
          p: offset,
          params: params,
          ti: text
        });
        offset += text.length;
        if (startContainer) {
          return SelectionHelper.setCaret(startContainer, startOffset);
        }
      };
      console.log('Comparing elements', oldEls, newEls);
      console.log('texts', oldTexts);
      for (oldIndex = 0, _len = oldEls.length; oldIndex < _len; oldIndex++) {
        oldEl = oldEls[oldIndex];
        if (oldEl === newEl) {
          if (this._isTmpElement(oldEl) && oldEl.textContent) {
            this._makePersistentElement(oldEl);
          }
          params = this.__renderer.getElementParams(oldEl);
          type = params[ParamsField.TYPE];
          console.warn(type);
          if (type !== ModelType.TEXT) {
            if (len = this._renderer.getElementLength(oldEl)) offset += len;
            newEl = newEls[++newIndex];
            continue;
          }
          oldText = oldTexts[oldIndex];
          if (oldEl.childNodes.length > 1) {
            newText = this._normalizeTextElement(oldEl);
          } else {
            newText = this._traverseNodeTextContent(oldEl);
          }
          ops = ops.concat(Diff.getOpsFromDiff(oldText, newText, params, offset));
          offset += newText.length;
          newEl = newEls[++newIndex];
          continue;
        }
        elIndex = newEls.indexOf(oldEl);
        if (elIndex === -1) {
          params = this.__renderer.getElementParams(oldEl);
          if (!params[ParamsField.TYPE]) continue;
          ops.push({
            p: offset,
            params: params,
            td: oldTexts[oldIndex]
          });
          continue;
        }
        while (newIndex < elIndex) {
          insertNewTextElement(newEl);
          newEl = newEls[++newIndex];
        }
      }
      newElsLength = newEls.length;
      while (newIndex < newElsLength) {
        newEl = newEls[newIndex];
        insertNewTextElement(newEl);
        newIndex += 1;
      }
      return ops;
    };

    Editor.prototype._handleElementInput = function(event) {
      var newEls, newTexts, ops, target, _ref4;
      event.stopPropagation();
      target = event.target;
      console.error(event.type);
      _ref4 = this._getLineNodes(target), newEls = _ref4[0], newTexts = _ref4[1];
      ops = this._compareLineElements(this._oldEls, this._oldTexts, newEls, this._getOffsetBefore(target) + 1);
      this._oldEls = newEls;
      this._oldTexts = newTexts;
      this._cleanLineElements(this._editableElement);
      this._saveState();
      console.log('handleElementInput ops', ops);
      try {
        this._maybeInsertTmpElement();
      } catch (_error) {}
      if (!ops.length) return;
      try {
        return this.emit('ops', ops);
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype._handleTargetBlur = function(event) {
      var el;
      el = event.target;
      el.removeEventListener(BrowserEvents.BLUR_EVENT, this._handleTargetBlur, false);
      return this._unbindFromEditableElement(el);
    };

    Editor.prototype._realSetCachedRange = function() {
      var endElement, r, startElement;
      if (this._setRangeTimeoutId != null) {
        this._setRangeTimeoutId = clearTimeout(this._setRangeTimeoutId);
      }
      if (!this._cachedRange) return;
      startElement = this._cachedRange.getStartElement();
      endElement = this._cachedRange.getEndElement();
      r = SelectionHelper.getRangeObject(startElement, this._renderer.getElementType(startElement), this._cachedRange.getStartOffset(), endElement, this._renderer.getElementType(endElement), this._cachedRange.getEndOffset());
      this._setSelectionToElement(r.startContainer, r.startOffset, this._editableElement);
      return delete this._cachedRange;
      try {
        SelectionHelper.setRangeObject(startElement, this._renderer.getElementType(startElement), this._cachedRange.getStartOffset(), endElement, this._renderer.getElementType(endElement), this._cachedRange.getEndOffset());
      } catch (e) {
        console.warn('failed to set range', e, startElement, this._renderer.getElementType(startElement), this._cachedRange.getStartOffset(), endElement, this._renderer.getElementType(endElement), this._cachedRange.getEndOffset());
      }
      return delete this._cachedRange;
    };

    Editor.prototype.setPermission = function(permission) {
      var gadget, _i, _len, _ref4, _results;
      Editor.__super__.setPermission.call(this, permission);
      _ref4 = this._gadgets;
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        gadget = _ref4[_i];
        _results.push(gadget.setMode(permission === EDIT_PERMISSION));
      }
      return _results;
    };

    Editor.prototype.print = function(text) {
      var d;
      d = document.createElement('div');
      d.textContent = text;
      return document.body.appendChild(d);
    };

    return Editor;

  })(EditorV2);

  exports.Editor = Editor;

}).call(this);

});

require.define("/lib/client/client/editor/utils/diff.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var dmp;

  dmp = new diff_match_patch();

  dmp.Diff_Timeout = 0.02;

  module.exports.getOpsFromDiff = function(oldText, newText, params, offset) {
    var d, diff, elOffset, ops, _i, _len;
    ops = [];
    elOffset = 0;
    diff = dmp.diff_main(oldText, newText);
    for (_i = 0, _len = diff.length; _i < _len; _i++) {
      d = diff[_i];
      switch (d[0]) {
        case DIFF_DELETE:
          ops.push({
            p: offset + elOffset,
            params: params,
            td: d[1]
          });
          continue;
        case DIFF_INSERT:
          ops.push({
            p: offset + elOffset,
            params: params,
            ti: d[1]
          });
          break;
      }
      elOffset += d[1].length;
    }
    return ops;
  };

}).call(this);

});

require.define("/lib/client/client/editor/editor_mobile.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BrowserEvents, BrowserSupport, COMMENT_PERMISSION, CachedRange, DomUtils, EDIT_PERMISSION, Editor, EditorV2, EventType, LineLevelParams, ModelField, ModelType, ParamsField, SPECIAL_INPUT, SelectionHelper, TextLevelParams, Utf16Util, dmp, editorTmpl, renderEditor, _ref, _ref2, _ref3,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  DomUtils = require('../utils/dom');

  SelectionHelper = require('./selection/html_selection_helper');

  EditorV2 = require('./editor_v2').Editor;

  BrowserSupport = require('../utils/browser_support_mobile');

  BrowserEvents = require('../utils/browser_events');

  CachedRange = require('./cached_range').CachedRange;

  _ref = require('./model'), TextLevelParams = _ref.TextLevelParams, LineLevelParams = _ref.LineLevelParams, ModelField = _ref.ModelField, ParamsField = _ref.ParamsField, ModelType = _ref.ModelType;

  _ref2 = require('./common'), EventType = _ref2.EventType, SPECIAL_INPUT = _ref2.SPECIAL_INPUT;

  Utf16Util = require('../utils/string').Utf16Util;

  _ref3 = require('../blip/model'), EDIT_PERMISSION = _ref3.EDIT_PERMISSION, COMMENT_PERMISSION = _ref3.COMMENT_PERMISSION;

  editorTmpl = function() {
    return ul('js-editor editor', {
      contentEditable: 'false',
      spellcheck: 'false',
      tabIndex: '1'
    });
  };

  renderEditor = window.CoffeeKup.compile(editorTmpl);

  dmp = new diff_match_patch();

  dmp.Diff_Timeout = 0.02;

  Editor = (function(_super) {

    __extends(Editor, _super);

    function Editor() {
      this._realSetCachedRange = __bind(this._realSetCachedRange, this);
      this._handleTargetBlur = __bind(this._handleTargetBlur, this);
      this._handleElementInput = __bind(this._handleElementInput, this);
      this._handleTextElementFocus = __bind(this._handleTextElementFocus, this);
      this._handleLineFocus = __bind(this._handleLineFocus, this);
      this._processMouseDownEvent = __bind(this._processMouseDownEvent, this);
      this._handleClickEvent = __bind(this._handleClickEvent, this);
      Editor.__super__.constructor.apply(this, arguments);
    }

    Editor.prototype._init = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      Editor.__super__._init.apply(this, args);
      return this._container.addEventListener(BrowserEvents.CLICK_EVENT, this._handleClickEvent, false);
    };

    Editor.prototype.initContent = function() {
      var content;
      content = this._getSnapshot();
      try {
        return this._renderer.renderContent(this._container, content);
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype.setEditable = function(editable) {
      if (!BrowserSupport.isSupported()) return;
      if (editable === this._editable) return;
      this._editable = editable;
      if (!this._editable) {
        if (this._editableElement) {
          return this._unbindFromEditableElement(this._editableElement);
        }
      }
    };

    Editor.prototype.focus = function() {
      var child;
      if (this._editable && (child = this._container.firstChild) && !this._editableElement) {
        return this._setSelectionToElement(child, 0);
      }
    };

    Editor.prototype.applyOp = function() {
      var args, el;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((el = this._editableElement) && el.rzTmp) {
        this._unbindFromEditableElement(el);
      }
      return Editor.__super__.applyOp.apply(this, args);
    };

    Editor.prototype.applyOps = function() {
      var args, el;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((el = this._editableElement) && el.rzTmp) {
        this._unbindFromEditableElement(el);
      }
      return Editor.__super__.applyOps.apply(this, args);
    };

    Editor.prototype.destroy = function() {
      this._container.removeEventListener(BrowserEvents.CLICK_EVENT, this._handleClickEvent, false);
      return Editor.__super__.destroy.call(this);
    };

    Editor.prototype._createDom = function() {
      var tmpContainer;
      tmpContainer = document.createElement('span');
      $(tmpContainer).append(renderEditor({
        isEditable: this._editable
      }));
      return this._container = tmpContainer.firstChild;
    };

    Editor.prototype.__registerDomEventHandling = function() {
      this._container.addEventListener(BrowserEvents.MOUSE_DOWN_EVENT, this._processMouseDownEvent, false);
      this._container.addEventListener(BrowserEvents.KEY_DOWN_EVENT, this._processKeyEvent, false);
      this._container.addEventListener(BrowserEvents.KEY_PRESS_EVENT, this._processKeyEvent, false);
      this._container.addEventListener(BrowserEvents.COPY_EVENT, this._processCopyEvent, false);
      return this._container.addEventListener(BrowserEvents.PASTE_EVENT, this._processPasteEvent, false);
    };

    Editor.prototype.__unregisterDomEventHandling = function() {
      this._container.removeEventListener(BrowserEvents.MOUSE_DOWN_EVENT, this._processMouseDownEvent, false);
      this._container.removeEventListener(BrowserEvents.KEY_DOWN_EVENT, this._processKeyEvent, false);
      this._container.removeEventListener(BrowserEvents.KEY_PRESS_EVENT, this._processKeyEvent, false);
      this._container.removeEventListener(BrowserEvents.COPY_EVENT, this._processCopyEvent, false);
      return this._container.removeEventListener(BrowserEvents.PASTE_EVENT, this._processPasteEvent, false);
    };

    Editor.prototype._processCopyEvent = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      Editor.__super__._processCopyEvent.apply(this, args);
      return delete this._cachedRange;
    };

    Editor.prototype._setStubbedRange = function() {
      return this._cachedRange = new CachedRange(this, this._container.firstChild, 1, 1, this._container.firstChild, 1, 1);
    };

    Editor.prototype._handleKeyEvent = function(event) {
      var eventType;
      eventType = this._getKeyEventType(event);
      switch (eventType) {
        case EventType.LINE:
          try {
            this._handleNewLine();
          } catch (e) {
            this.emit('error', e);
          }
          return true;
        case EventType.TAB:
          try {
            this._handleTab(event.shiftKey);
          } catch (e) {
            this.emit('error', e);
          }
          return true;
        case EventType.DELETE:
          try {
            this._handleDelete(event);
          } catch (e) {
            this.emit('error', e);
          }
          return true;
        default:
          return false;
      }
    };

    Editor.prototype._submitOp = function() {
      var args, el;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((el = this._editableElement) && el.rzTmp) {
        this._unbindFromEditableElement(el);
      }
      return Editor.__super__._submitOp.apply(this, args);
    };

    Editor.prototype._submitOps = function() {
      var args, el;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((el = this._editableElement) && el.rzTmp) {
        this._unbindFromEditableElement(el);
      }
      return Editor.__super__._submitOps.apply(this, args);
    };

    Editor.prototype._handleClickEvent = function(event) {
      if (event.processed) return;
      this._processCursor();
      return event.processed = true;
    };

    Editor.prototype._processMouseDownEvent = function(event) {
      var container, element, _ref4;
      this._clearCachedRange();
      if (event.button) return;
      event.stopPropagation();
      try {
        this.emit(event.type);
      } catch (_error) {}
      if (!this._editable) return;
      element = event.target;
      if (DomUtils.isButtonElement(element)) return;
      container = element;
      while (container && !DomUtils.hasClass(container, 'js-editor')) {
        if (DomUtils.hasClass(container, 'js-blips-container')) return;
        container = container.parentNode;
      }
      if (!container || container !== this._container) return;
      if (element === document.activeElement) return;
      if (document.activeElement !== element) {
        if ((_ref4 = document.activeElement) != null) _ref4.blur();
        return this._handleElementMouseDown(element);
      }
      return this._handleElementMouseDown(element);
    };

    Editor.prototype._handleElementMouseDown = function(element) {
      var elementType;
      elementType = this._renderer.getElementType(element);
      if (elementType === ModelType.TEXT) {
        element.contentEditable = 'true';
        element.addEventListener(BrowserEvents.FOCUS_EVENT, this._handleTextElementFocus, false);
        element.focus();
        return;
      }
      if (elementType !== ModelType.LINE) {
        while (this._renderer.getElementType(element) !== ModelType.LINE) {
          element = this._renderer.getPreviousElement(element);
        }
      }
      element.contentEditable = 'true';
      element.addEventListener(BrowserEvents.FOCUS_EVENT, this._handleLineFocus, false);
      return element.focus();
    };

    Editor.prototype._handleLineFocus = function(event) {
      var _this = this;
      event.target.removeEventListener(BrowserEvents.FOCUS_EVENT, this._handleLineFocus, false);
      return setTimeout(function() {
        return _this._extractSelectionFromLine(event.target);
      }, 0);
    };

    Editor.prototype._extractSelectionFromLine = function(line) {
      var s;
      if (line.parentNode !== this._container) return console.log('wrong editor');
      s = window.getSelection();
      if (!s || !s.anchorNode) {
        line.contentEditable = 'false';
        line.removeAttribute('contentEditable', 0);
        return;
      }
      return this._setSelectionToElement(s.anchorNode, s.anchorOffset, line);
    };

    Editor.prototype._setSelectionToElement = function(anchorNode, anchorOffset, prevSelected) {
      var element, elementLength, elementType, newElement, newOffset, offset, r, s, tmpEl, _ref4;
      if (prevSelected == null) prevSelected = null;
      _ref4 = this._getCurrentElement(anchorNode, anchorOffset), element = _ref4[0], offset = _ref4[1];
      elementType = this._renderer.getElementType(element);
      switch (elementType) {
        case ModelType.TEXT:
          anchorNode = element.firstChild;
          anchorOffset = offset;
          break;
        default:
          elementLength = this._renderer.getElementLength(element);
          if (offset === elementLength) {
            newElement = this._renderer.getNextElement(element);
            newOffset = 0;
          } else if (!offset) {
            newElement = this._renderer.getPreviousElement(element);
            newOffset = this._renderer.getElementLength(newElement);
          }
          if (this._renderer.getElementType(newElement) === ModelType.TEXT) {
            anchorNode = newElement.firstChild;
            anchorOffset = newOffset;
            element = newElement;
            break;
          }
          if (!offset && newElement) element = newElement;
          tmpEl = document.createElement('span');
          tmpEl.className = 'temporary-cursor-element';
          tmpEl.rzTmp = true;
          anchorNode = tmpEl;
          anchorOffset = 0;
          this._renderer.insertInlineElementAfter(tmpEl, element);
          element = tmpEl;
      }
      element.contentEditable = 'true';
      if (prevSelected) {
        prevSelected.contentEditable = 'false';
        prevSelected.removeAttribute('contentEditable', 0);
        prevSelected.blur();
      }
      element.focus();
      s = window.getSelection();
      r = document.createRange();
      r.setStart(anchorNode, anchorOffset);
      r.collapse(true);
      if (s != null) s.removeAllRanges();
      if (s != null) s.addRange(r);
      setTimeout(function() {
        if (s && s.anchorNode === r.startContainer && s.anchorOffset === r.startOffset) {
          s.removeAllRanges();
          return s.addRange(r);
        }
      }, 0);
      return this._bindToEditableElement(element);
    };

    Editor.prototype._handleTextElementFocus = function(event) {
      event.target.removeEventListener(BrowserEvents.FOCUS_EVENT, this._handleTextElementFocus, false);
      return this._bindToEditableElement(event.target);
    };

    Editor.prototype._bindToEditableElement = function(el) {
      var _base;
      if (el !== document.activeElement) {
        return this._unbindFromEditableElement(el);
      }
      try {
        this.emit('focused');
      } catch (_error) {}
      this._editableElement = el;
      this._oldText = el.textContent;
      delete this._cachedRange;
      if (window.androidJSInterface) {
        try {
          if (typeof (_base = window.androidJSInterface).showKeyboard === "function") {
            _base.showKeyboard();
          }
        } catch (_error) {}
      }
      el.addEventListener(BrowserEvents.BLUR_EVENT, this._handleTargetBlur, false);
      return el.addEventListener(BrowserEvents.INPUT_EVENT, this._handleElementInput, false);
    };

    Editor.prototype._unbindFromEditableElement = function(el) {
      el.contentEditable = 'false';
      el.removeAttribute('contentEditable', 0);
      el.removeEventListener(BrowserEvents.BLUR_EVENT, this._handleTargetBlur, false);
      el.removeEventListener(BrowserEvents.INPUT_EVENT, this._handleElementInput, false);
      if (el.rzTmp) DomUtils.remove(el);
      if (this._editableElement === el) this._editableElement = null;
      if (this._cursor) return this.clearCursor();
    };

    Editor.prototype._getNewLineOp = function() {
      var params;
      params = {};
      params[ParamsField.TYPE] = ModelType.LINE;
      params[ParamsField.RANDOM] = Math.random();
      return {
        ti: ' ',
        params: params
      };
    };

    Editor.prototype._handleElementInput = function(event) {
      var d, diff, newLine, newText, offset, op, ops, params, r, t, target, _i, _len,
        _this = this;
      event.stopPropagation();
      target = event.target;
      newLine = target.textContent.indexOf('\n');
      newText = Utf16Util.traverseString(target.textContent);
      if (target.textContent !== newText) target.textContent = newText;
      if (newLine !== -1) {
        this._cachedRange = new CachedRange(this, this._container.firstChild, 1, 1, this._container.firstChild, 1, 1);
        offset = this._getOffsetBefore(target);
        if (!target.rzTmp) offset += newLine;
        op = this._getNewLineOp();
        op.p = offset;
        try {
          this._submitOp(op);
        } catch (e) {
          this.emit('error', e);
        }
        return;
      }
      if (target.childNodes.length > 1) {
        console.error('integrity check failed');
        DomUtils.empty(target);
        if (this._oldText) {
          target.appendChild(document.createTextNode(this._oldText));
        }
        return;
      }
      t = Date.now();
      diff = dmp.diff_main(this._oldText, newText);
      if (!diff.length) return;
      offset = this._getOffsetBefore(target);
      ops = [];
      params = this._renderer.getElementParams(target) || {};
      if (!params[ParamsField.TYPE]) params[ParamsField.TYPE] = ModelType.TEXT;
      for (_i = 0, _len = diff.length; _i < _len; _i++) {
        d = diff[_i];
        switch (d[0]) {
          case DIFF_DELETE:
            ops.push({
              p: offset,
              params: params,
              td: d[1]
            });
            continue;
          case DIFF_INSERT:
            ops.push({
              p: offset,
              params: params,
              ti: d[1]
            });
        }
        offset += d[1].length;
      }
      if (this._permission === COMMENT_PERMISSION) {
        r = this._getCachedRange();
        offset = r.getEndOffset() || 0;
        target.textContent = this._oldText;
        if (offset > this._oldText.length) offset = this._oldText.length;
        r = document.createRange();
        r.setEnd(target.firstChild, offset);
        r.collapse(false);
        delete this._cachedRange;
        SelectionHelper.setRange(r);
        this._getCachedRange(false);
        return this._processInChildBlip(function(editor) {
          var newOps, op, _j, _len2;
          if (editor.getPermission() !== EDIT_PERMISSION) return;
          newOps = [_this._getNewLineOp()];
          for (_j = 0, _len2 = ops.length; _j < _len2; _j++) {
            op = ops[_j];
            if (op.ti) newOps.push(op);
          }
          return editor.setInitialOps(newOps);
        });
      }
      if (ops.length === 1 && ops[0].ti in SPECIAL_INPUT && (ops[0].ti !== '~' || require('../account_setup_wizard/processor').instance.isBusinessUser())) {
        r = document.createRange();
        r.setEnd(target.firstChild, this._oldText.length);
        r.collapse(false);
        SelectionHelper.setRange(r);
        this._getCachedRange();
        target.textContent = this._oldText;
        try {
          this[SPECIAL_INPUT[ops[0].ti]]();
        } catch (e) {
          this.emit('error', e);
        }
        return;
      }
      if (target.rzTmp) {
        delete target.rzTmp;
        target.className = '';
        this._renderer.setParamsToElement(target, params);
        try {
          this.emit('ops', ops);
        } catch (e) {
          this.emit('error', e);
        }
        this._oldText = newText;
        return;
      }
      if (this._cursor) this.clearCursor();
      try {
        this.emit('ops', ops);
      } catch (e) {
        this.emit('error', e);
      }
      if (!newText) {
        target.rzTmp = true;
        target.className = 'temporary-cursor-element';
        DomUtils.empty(target);
        this._renderer.removeParamsFromElement(target);
      }
      return this._oldText = newText;
    };

    Editor.prototype._handleTargetBlur = function(event) {
      var el;
      el = event.target;
      el.removeEventListener(BrowserEvents.BLUR_EVENT, this._handleTargetBlur, false);
      return this._unbindFromEditableElement(el);
    };

    Editor.prototype._realSetCachedRange = function() {
      var endElement, r, startElement;
      if (this._setRangeTimeoutId != null) {
        this._setRangeTimeoutId = clearTimeout(this._setRangeTimeoutId);
      }
      if (!this._cachedRange) return;
      startElement = this._cachedRange.getStartElement();
      endElement = this._cachedRange.getEndElement();
      if (startElement === this._editableElement) {
        this._oldText = this._editableElement.textContent;
      } else {
        r = SelectionHelper.getRangeObject(startElement, this._renderer.getElementType(startElement), this._cachedRange.getStartOffset(), endElement, this._renderer.getElementType(endElement), this._cachedRange.getEndOffset());
        this._setSelectionToElement(r.startContainer, r.startOffset, this._editableElement);
        return delete this._cachedRange;
      }
      try {
        SelectionHelper.setRangeObject(startElement, this._renderer.getElementType(startElement), this._cachedRange.getStartOffset(), endElement, this._renderer.getElementType(endElement), this._cachedRange.getEndOffset());
      } catch (e) {
        console.warn('failed to set range', e, startElement, this._renderer.getElementType(startElement), this._cachedRange.getStartOffset(), endElement, this._renderer.getElementType(endElement), this._cachedRange.getEndOffset());
      }
      return delete this._cachedRange;
    };

    Editor.prototype.setPermission = function(permission) {
      var gadget, _i, _len, _ref4, _results;
      Editor.__super__.setPermission.call(this, permission);
      _ref4 = this._gadgets;
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        gadget = _ref4[_i];
        _results.push(gadget.setMode(permission === EDIT_PERMISSION));
      }
      return _results;
    };

    Editor.prototype.print = function(text) {
      var d;
      d = document.createElement('div');
      d.textContent = text;
      return document.body.appendChild(d);
    };

    return Editor;

  })(EditorV2);

  exports.Editor = Editor;

}).call(this);

});

require.define("/lib/client/client/editor/editor_mobile_polyfill.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BrowserEvents, BrowserSupport, CLICK_OFFSET, COMMENT_PERMISSION, CachedRange, DomUtils, EDIT_PERMISSION, Editor, EditorMobile, EventType, LineLevelParams, ModelField, ModelType, ParamsField, SPECIAL_INPUT, SelectionHelper, TextBuffer, TextLevelParams, Utf16Util, dmp, polyfied, _ref, _ref2, _ref3,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  DomUtils = require('../utils/dom');

  SelectionHelper = require('./selection/html_selection_helper');

  EditorMobile = require('./editor_mobile').Editor;

  BrowserEvents = require('../utils/browser_events');

  BrowserSupport = require('../utils/browser_support_mobile');

  CachedRange = require('./cached_range').CachedRange;

  _ref = require('./model'), TextLevelParams = _ref.TextLevelParams, LineLevelParams = _ref.LineLevelParams, ModelField = _ref.ModelField, ParamsField = _ref.ParamsField, ModelType = _ref.ModelType;

  _ref2 = require('./common'), EventType = _ref2.EventType, SPECIAL_INPUT = _ref2.SPECIAL_INPUT;

  Utf16Util = require('../utils/string').Utf16Util;

  _ref3 = require('../blip/model'), EDIT_PERMISSION = _ref3.EDIT_PERMISSION, COMMENT_PERMISSION = _ref3.COMMENT_PERMISSION;

  TextBuffer = require('./buffer/text').TextBuffer;

  dmp = new diff_match_patch();

  dmp.Diff_Timeout = 0.02;

  CLICK_OFFSET = 10;

  polyfied = false;

  Editor = (function(_super) {

    __extends(Editor, _super);

    function Editor() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._realSetCachedRange = __bind(this._realSetCachedRange, this);
      this._handleElementInput = __bind(this._handleElementInput, this);
      this._handleTouchEndEvent = __bind(this._handleTouchEndEvent, this);
      this._handleTouchStartEvent = __bind(this._handleTouchStartEvent, this);
      Editor.__super__.constructor.apply(this, args);
      if (polyfied) return;
      DomUtils.addClass(document.body, 'editor-polyfill');
      polyfied = true;
    }

    Editor.prototype.setEditable = function(editable) {
      if (!BrowserSupport.isSupported()) return;
      if (editable === this._editable) return;
      return this._editable = editable;
    };

    Editor.prototype.focus = function() {
      var child;
      if (this._editable && (child = this._container.firstChild)) {
        this._attachBufferAfter(child);
      }
      return TextBuffer.get().getContainer().focus();
    };

    Editor.prototype.applyOps = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._cachedRange = this._getFakeRange();
      return Editor.__super__.applyOps.apply(this, args);
    };

    Editor.prototype.destroy = function() {
      if (this._isBufferAttached()) {
        TextBuffer.get().detach(true);
        this._editableElement = null;
        this._oldText = null;
      }
      return Editor.__super__.destroy.call(this);
    };

    Editor.prototype.insertRecipient = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      TextBuffer.get().detach(true);
      return Editor.__super__.insertRecipient.apply(this, args);
    };

    Editor.prototype.insertTaskRecipient = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      TextBuffer.get().detach(true);
      return Editor.__super__.insertTaskRecipient.apply(this, args);
    };

    Editor.prototype.insertTag = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      TextBuffer.get().detach(true);
      return Editor.__super__.insertTag.apply(this, args);
    };

    Editor.prototype._submitOp = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return Editor.__super__._submitOp.apply(this, args);
    };

    Editor.prototype._submitOps = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return Editor.__super__._submitOps.apply(this, args);
    };

    Editor.prototype.__registerDomEventHandling = function() {
      return this._container.addEventListener(BrowserEvents.TOUCH_START_EVENT, this._handleTouchStartEvent, false);
    };

    Editor.prototype.__unregisterDomEventHandling = function() {
      return this._container.removeEventListener(BrowserEvents.TOUCH_START_EVENT, this._handleTouchStartEvent, false);
    };

    Editor.prototype._isBufferAttached = function() {
      return TextBuffer.get().getContainer().parentNode === this._container.parentNode && this._editableElement;
    };

    Editor.prototype._getFakeRange = function() {
      var buffer, indexEnd, indexStart, offsetEnd, offsetStart;
      delete this._cachedRange;
      if (!this._isBufferAttached()) return;
      buffer = TextBuffer.get();
      indexStart = indexEnd = this._getOffsetBefore(this._editableElement);
      if (this._renderer.getElementType(this._editableElement) === ModelType.TEXT) {
        offsetStart = buffer.getSelectionStart();
        offsetEnd = buffer.getSelectionEnd();
      } else {
        offsetStart = 1;
        offsetEnd = 1;
      }
      indexStart += offsetStart;
      indexEnd += offsetEnd;
      return new CachedRange(this, this._editableElement, offsetStart, indexStart, this._editableElement, offsetEnd, indexEnd);
    };

    Editor.prototype._handleKeyEvent = function(event) {
      var eventType;
      eventType = this._getKeyEventType(event);
      switch (eventType) {
        case EventType.INPUT:
          this._cachedRange = this._getFakeRange();
          try {
            this.insertTextData(String.fromCharCode(event.charCode));
          } catch (e) {
            this.emit('error', e);
          }
          return true;
        case EventType.LINE:
          this._cachedRange = this._getFakeRange();
          try {
            this._handleNewLine();
          } catch (e) {
            this.emit('error', e);
          }
          return true;
        case EventType.TAB:
          this._cachedRange = this._getFakeRange();
          try {
            this._handleTab(event.shiftKey);
          } catch (e) {
            this.emit('error', e);
          }
          return true;
        case EventType.DELETE:
          this._cachedRange = this._getFakeRange();
          try {
            this._handleDelete(event);
          } catch (e) {
            this.emit('error', e);
          }
          return true;
        default:
          return false;
      }
    };

    Editor.prototype._handleTouchStartEvent = function(event) {
      var target, type;
      event.stopPropagation();
      target = event.target;
      if (!target) return;
      if (!this._editable) return;
      type = this._renderer.getElementType(target);
      if (type !== ModelType.TEXT) {
        return this._handleNonTextTouchEvent(target, event);
      } else {
        return this._handleTextTouchEvent(target, event);
      }
    };

    Editor.prototype._handleTouchEndEvent = function(e) {
      e.stopPropagation();
      if (!this._editableElement) {}
    };

    Editor.prototype._handleTextTouchEvent = function(target) {
      return this._attachBuffer(target, target.textContent);
    };

    Editor.prototype._handleNonTextTouchEvent = function(target, event) {
      var touch, type;
      if (!(touch = event.touches[0])) return;
      type = this._renderer.getElementType(target) || this._renderer.getElementType(target = this._renderer.getPreviousElement(target));
      if (!target || !type) return;
      switch (type) {
        case ModelType.LINE:
          return this._handleLineTouchEvent(target, touch.clientX, touch.clientY);
        default:
          return this._handleInlineTouchEvent(target, touch.clientX, touch.clientY);
      }
    };

    Editor.prototype._handleLineTouchEvent = function(line, x, y) {
      var b, bc, element, lastElement, rect, rects, type, w, width, _i, _len;
      element = this._renderer.getNextElement(line);
      while (element && (type = this._renderer.getElementType(element)) !== ModelType.LINE) {
        rects = element.getClientRects();
        for (_i = 0, _len = rects.length; _i < _len; _i++) {
          rect = rects[_i];
          if (rect.right >= x && rect.bottom >= y) {
            console.error('found correct element', type, element);
            switch (type) {
              case ModelType.TEXT:
                this._handleTextTouchEvent(element);
                break;
              default:
                console.warn('do nothing with inline element');
            }
            return;
          }
        }
        lastElement = element;
        element = this._renderer.getNextElement(element);
      }
      if (!lastElement) return this._attachBufferAfter(line);
      switch (this._renderer.getElementType(lastElement)) {
        case ModelType.TEXT:
          this._handleTextTouchEvent(lastElement);
          rect = lastElement.getBoundingClientRect();
          b = TextBuffer.get();
          bc = b.getContainer();
          if (parseInt(w = bc.style.width) < (width = x - rect.left + 5)) {
            bc.style.paddingRight = parseInt(bc.style.paddingRight) + width - w;
          }
          break;
        default:
          return this._attachBufferAfter(lastElement);
      }
    };

    Editor.prototype._handleInlineTouchEvent = function(element, x, y) {
      var bc, first, last, next, prev, rect, rects, w, width;
      rects = element.getClientRects();
      if (!rects.length) return;
      first = rects[0];
      last = rects[rects.length - 1];
      first = last = element.getBoundingClientRect();
      if (first.left + CLICK_OFFSET >= x && first.top <= y && first.bottom >= y) {
        prev = this._renderer.getPreviousElement(element);
        if (prev) {
          if (this._renderer.getElementType(prev) === ModelType.TEXT) {
            this._handleTextTouchEvent(prev);
            rect = prev.getBoundingClientRect();
            bc = TextBuffer.get().getContainer();
            if (parseInt(w = bc.style.width) < (width = x - rect.left + 5)) {
              bc.style.paddingRight = parseInt(bc.style.paddingRight) + width - w;
            }
            return;
          }
        }
        return this._attachBufferAfter(prev);
      }
      if (last.right - CLICK_OFFSET <= x && last.top <= y && last.bottom >= y) {
        next = this._renderer.getNextElement(element);
        if (next) {
          if (this._renderer.getElementType(next) === ModelType.TEXT) {
            this._handleTextTouchEvent(next);
            return;
          }
        }
        return this._attachBufferAfter(element);
      }
      return TextBuffer.get().detach(true);
    };

    Editor.prototype._attachBuffer = function(target, text, offset) {
      var buffer;
      buffer = TextBuffer.get();
      buffer.attachToTarget(this._container.parentNode, target, text, this._handleElementInput, this._processKeyEvent, offset);
      this._oldText = text;
      this._editableElement = target;
      try {
        return this.emit('focused');
      } catch (_error) {}
    };

    Editor.prototype._attachBufferAfter = function(target) {
      var buffer, prev, tmp;
      this._oldText = '';
      this._editableElement = target;
      tmp = document.createElement('span');
      tmp.textContent = '.';
      if (this._renderer.getElementType(target) === ModelType.LINE) {
        target.insertBefore(tmp, target.firstChild);
      } else {
        while (target && this._renderer.getElementType(target) !== ModelType.LINE) {
          prev = target;
          target = prev.parentNode;
        }
        DomUtils.insertNextTo(tmp, prev);
      }
      buffer = TextBuffer.get();
      buffer.attachToTarget(this._container.parentNode, tmp, '', this._handleElementInput, this._processKeyEvent, 0);
      DomUtils.remove(tmp);
      try {
        return this.emit('focused');
      } catch (_error) {}
    };

    Editor.prototype._handleElementInput = function(event) {
      var buffer, d, diff, editableType, newLine, newText, offset, op, ops, params, r, target, text, _i, _len;
      event.stopPropagation();
      target = event.target;
      buffer = TextBuffer.get();
      text = buffer.getValue();
      newLine = text.indexOf('\n');
      newText = Utf16Util.traverseString(target.value);
      if (target.value !== newText) target.value = newText;
      editableType = this._renderer.getElementType(this._editableElement);
      if (newLine !== -1) {
        this._cachedRange = new CachedRange(this, this._container.firstChild, 1, 1, this._container.firstChild, 1, 1);
        offset = this._getOffsetBefore(this._editableElement);
        if (editableType === ModelType.TEXT) {
          offset += newLine;
        } else {
          offset += this._renderer.getElementLength(this._editableElement);
        }
        op = this._getNewLineOp();
        op.p = offset;
        try {
          this._submitOp(op);
        } catch (e) {
          this.emit('error', e);
        }
        return;
      }
      diff = dmp.diff_main(this._oldText, newText);
      if (!diff.length) return;
      offset = this._getOffsetBefore(this._editableElement);
      ops = [];
      if (editableType === ModelType.TEXT) {
        params = this._renderer.getElementParams(this._editableElement);
      } else {
        offset += this._renderer.getElementLength(this._editableElement);
        params = {};
        params[ParamsField.TYPE] = ModelType.TEXT;
      }
      for (_i = 0, _len = diff.length; _i < _len; _i++) {
        d = diff[_i];
        switch (d[0]) {
          case DIFF_DELETE:
            ops.push({
              p: offset,
              params: params,
              td: d[1]
            });
            continue;
          case DIFF_INSERT:
            ops.push({
              p: offset,
              params: params,
              ti: d[1]
            });
        }
        offset += d[1].length;
      }
      if (this._permission === COMMENT_PERMISSION) {
        r = this._getCachedRange();
        offset = r.getEndOffset() || 0;
        target.value = this._oldText;
        if (offset > this._oldText.length) offset = this._oldText.length;
        r = document.createRange();
        r.setEnd(target.firstChild, offset);
        r.collapse(false);
        delete this._cachedRange;
        SelectionHelper.setRange(r);
        this._getCachedRange(false);
        return this._processInChildBlip(function(editor) {
          var newOps, op, _j, _len2;
          if (editor.getPermission() !== EDIT_PERMISSION) return;
          newOps = [this._getNewLineOp()];
          for (_j = 0, _len2 = ops.length; _j < _len2; _j++) {
            op = ops[_j];
            if (op.ti) newOps.push(op);
          }
          return editor.setInitialOps(newOps);
        });
      }
      if (this._cursor) this.clearCursor();
      try {
        this._cachedRange = new CachedRange(this, this._editableElement, 0, 0, this._ediableElement, 0, 0);
        return this._submitOps(ops);
      } catch (e) {
        return this.emit('error', e);
      }
    };

    Editor.prototype._realSetCachedRange = function() {
      var startElement, startOffset, startType;
      if (this._setRangeTimeoutId != null) {
        this._setRangeTimeoutId = clearTimeout(this._setRangeTimeoutId);
      }
      if (!this._cachedRange) return;
      startElement = this._cachedRange.getStartElement();
      startOffset = this._cachedRange.getStartOffset();
      startType = this._renderer.getElementType(startElement);
      if (startType !== ModelType.TEXT && !startOffset) {
        startElement = this._renderer.getPreviousElement(startElement);
        startOffset = this._renderer.getElementLength(startElement);
      }
      switch (startType) {
        case ModelType.TEXT:
          this._attachBuffer(startElement, startElement.textContent, startOffset);
          break;
        default:
          this._attachBufferAfter(startElement);
      }
      return delete this._cachedRange;
    };

    return Editor;

  })(EditorMobile);

  exports.Editor = Editor;

}).call(this);

});

require.define("/lib/client/client/editor/buffer/text.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BrowserEvents, DomUtils, TextBuffer, instance, styles;

  DomUtils = require('../../utils/dom');

  BrowserEvents = require('../../utils/browser_events');

  styles = ['color', 'direction', 'fontFamily', 'fontSize', 'fontStretch', 'fontStyle', 'fontWeight', 'kerning', 'letterSpacing', 'lineHeight', 'marginLeft', 'marginRight', 'marginTop', 'marginBottom', 'overflowWrap', 'paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop', 'textAlign', 'textAnchor', 'textDecoration', 'verticalAlign', 'whiteSpace', 'wordBreak', 'wordSpacing', 'wordWrap'];

  TextBuffer = (function() {

    function TextBuffer() {
      var s,
        _this = this;
      this._container = document.createElement('textarea');
      s = this._container.style;
      s.position = 'absolute';
      s.outline = '1px solid silver';
      s.outlineOffset = '1px';
      s.resize = 'none';
      s.overflow = 'hidden';
      s.border = 'none';
      s.backgroundColor = 'rgba(255, 255, 255, 0.6)';
      s.display = 'block';
      s.zIndex = '1';
      this._container.setAttribute('tabIndex', '1');
      this._inputEventHandler = null;
      this._container.addEventListener(BrowserEvents.TOUCH_START_EVENT, function(e) {
        e.stopPropagation();
        _this._selectionStart = null;
        return _this._selectionEnd = null;
      }, false);
    }

    TextBuffer.prototype.updateBox = function(left, top, width, height) {
      var style;
      style = this._container.style;
      if (left !== this._left) {
        style.left = "" + left + "px";
        this._left = left;
      }
      if (top !== this._top) {
        style.top = "" + top + "px";
        this._top = top;
      }
      if (width !== this._width) {
        style.width = "" + width + "px";
        this._width = width;
      }
      if (height !== this._height) {
        style.height = "" + height + "px";
        return this._height = height;
      }
    };

    TextBuffer.prototype.attachToTarget = function(parent, target, text, inputHandler, keyHandler, offset) {
      var diffLeft, firstRect, height, marginTop, parentRect, rect, rects, style, styleDecl, targetStyle, _i, _len;
      this.detach();
      if (!parent || !target) return;
      this._target = target;
      this._inputEventHandler = inputHandler;
      this._keyEventHandler = keyHandler;
      if (text) target.style.opacity = '0';
      parentRect = JSON.parse(JSON.stringify(target.parentNode.getBoundingClientRect()));
      styleDecl = window.getComputedStyle ? window.getComputedStyle(target) : target.currentStyle;
      targetStyle = this._container.style;
      rect = JSON.parse(JSON.stringify(target.getBoundingClientRect()));
      rects = target.getClientRects();
      firstRect = rects[0];
      diffLeft = firstRect.left - rect.left;
      height = firstRect.bottom - firstRect.top;
      DomUtils.convertWindowCoordsToRelative(parentRect, parent);
      DomUtils.convertWindowCoordsToRelative(rect, parent);
      for (_i = 0, _len = styles.length; _i < _len; _i++) {
        style = styles[_i];
        targetStyle[style] = styleDecl[style];
      }
      targetStyle.textIndent = diffLeft + 'px';
      marginTop = (height - parseInt(styleDecl.lineHeight)) / 2;
      targetStyle.marginTop = marginTop + 'px';
      targetStyle.top = rect.top + 'px';
      targetStyle.left = rect.left + 'px';
      targetStyle.width = rect.width + 'px';
      targetStyle.height = rect.height - marginTop + 'px';
      targetStyle.display = 'block';
      if (this._container.value !== text) this._container.value = text;
      if (offset != null) {
        this._container.selectionStart = this._container.selectionEnd = offset;
        this._selectionStart = this._selectionEnd = offset;
      }
      this._container.addEventListener(BrowserEvents.INPUT_EVENT, this._inputEventHandler, false);
      this._container.addEventListener(BrowserEvents.KEY_DOWN_EVENT, this._keyEventHandler, false);
      this._container.addEventListener(BrowserEvents.KEY_PRESS_EVENT, this._keyEventHandler, false);
      if (parent !== this._container.parentNode) {
        return parent.appendChild(this._container);
      }
    };

    TextBuffer.prototype.detach = function(remove) {
      if (remove == null) remove = false;
      if (!this._inputEventHandler) return;
      this._container.removeEventListener(BrowserEvents.INPUT_EVENT, this._inputEventHandler, false);
      this._container.removeEventListener(BrowserEvents.KEY_DOWN_EVENT, this._keyEventHandler, false);
      this._container.removeEventListener(BrowserEvents.KEY_PRESS_EVENT, this._keyEventHandler, false);
      this._selectionStart = null;
      this._selectionEnd = null;
      if (remove) {
        this._container.style.display = 'none';
        document.body.appendChild(this._container);
      }
      if (this._target) this._target.style.removeProperty('opacity');
      this._inputEventHandler = null;
      this._keyHandler = null;
      return this._target = null;
    };

    TextBuffer.prototype.getContainer = function() {
      return this._container;
    };

    TextBuffer.prototype.getValue = function() {
      return this._container.value;
    };

    TextBuffer.prototype.getSelectionStart = function() {
      return this._selectionStart || this._container.selectionStart || 0;
    };

    TextBuffer.prototype.getSelectionEnd = function() {
      return this._selectionEnd || this._container.selectionEnd || 0;
    };

    TextBuffer.prototype.setValue = function(text, params) {
      return this._container.value = text;
    };

    return TextBuffer;

  })();

  instance = null;

  exports.TextBuffer = {
    get: function() {
      return instance != null ? instance : instance = new TextBuffer();
    }
  };

}).call(this);

});

require.define("/lib/client/client/blip/menu/mobile.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipMenu, blipCommonMenuTmpl, renderBlipCommonMenu;

  blipCommonMenuTmpl = function() {
    return div('js-blip-menu blip-menu', function() {
      var disabled;
      if (this.hasServerId) {
        disabled = '';
      } else {
        disabled = true;
      }
      div('menu-item', function() {
        return button('js-hide-all-inlines hide-all-inlines blip-menu-item', {
          title: 'Hide replies (Ctrl+Shift+Up)'
        }, function() {
          return div('');
        });
      });
      div('menu-item', function() {
        div('blip-menu-delimiter', '');
        return button('js-show-all-inlines show-all-inlines blip-menu-item', {
          title: 'Show replies (Ctrl+Shift+Down)'
        }, function() {
          return div('');
        });
      });
      div('menu-item copy-paste-blip-item copy', function() {
        div('blip-menu-delimiter', '');
        return button('js-copy-blip-button blip-menu-item', {
          title: 'Copy reply',
          disabled: disabled
        }, 'Copy');
      });
      div('menu-item copy-paste-blip-item paste-at-cursor', function() {
        div('blip-menu-delimiter', '');
        return button('js-paste-at-cursor-button blip-menu-item', {
          title: 'Paste at cursor',
          disabled: disabled
        }, 'at cursor');
      });
      div('menu-item copy-paste-blip-item paste-as-reply', function() {
        div('blip-menu-delimiter', '');
        return button('js-paste-after-blip-button blip-menu-item', {
          title: 'Paste as reply',
          disabled: disabled
        }, 'as reply');
      });
      div('blip-menu-delimiter', '');
      return button('js-delete-blip blip-menu-item delete-blip', {
        title: 'Delete'
      }, function() {
        return div('', '');
      });
    });
  };

  renderBlipCommonMenu = window.CoffeeKup.compile(blipCommonMenuTmpl);

  BlipMenu = (function() {

    function BlipMenu(params) {
      this._container = document.createElement('span');
      this._render(params);
    }

    BlipMenu.prototype._render = function(params) {
      /*
              Рендерим блоки меню
      */      return $(this._container).append(renderBlipCommonMenu(params));
    };

    BlipMenu.prototype.getContainer = function() {
      return this._container;
    };

    BlipMenu.prototype.enableAllButtons = function() {
      return $(this._container).find('button').prop('disabled', false);
    };

    return BlipMenu;

  })();

  exports.BlipMenu = BlipMenu;

}).call(this);

});

require.define("/lib/client/client/session/module.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var Session, SessionView;

  SessionView = require('./view').SessionViewMobile;

  Session = (function() {

    function Session() {}

    Session.prototype.setAsLoggedIn = function() {
      return SessionView.hide();
    };

    Session.prototype.setAsLoggedOut = function() {
      return SessionView.show();
    };

    return Session;

  })();

  module.exports.Session = new Session();

}).call(this);

});

require.define("/lib/client/client/session/view.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var History, SessionViewBase, SessionViewMobile,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  History = require('../utils/history_navigation');

  SessionViewBase = (function() {

    function SessionViewBase() {}

    SessionViewBase.prototype.hide = function() {};

    SessionViewBase.prototype.show = function() {};

    return SessionViewBase;

  })();

  SessionViewMobile = (function(_super) {

    __extends(SessionViewMobile, _super);

    function SessionViewMobile() {
      this._mainContent = document.getElementById('main-content');
      this._sessionView = document.getElementById('session-view');
      window.AuthDialog.init(false, History.getLoginRedirectUrl());
    }

    SessionViewMobile.prototype._updateLoginRedirectUrls = function() {
      var redirectUrl, _ref;
      redirectUrl = History.getLoginRedirectUrl();
      return (_ref = window.AuthDialog) != null ? _ref.setNext(redirectUrl) : void 0;
    };

    SessionViewMobile.prototype.updateLoginUrls = function() {
      return this._updateLoginRedirectUrls();
    };

    SessionViewMobile.prototype.hide = function() {
      this._mainContent.style.display = 'block';
      return this._sessionView.style.display = 'none';
    };

    SessionViewMobile.prototype.show = function() {
      this._updateLoginRedirectUrls();
      window.AuthDialog.show();
      this._mainContent.style.display = 'none';
      return this._sessionView.style.display = 'block';
    };

    return SessionViewMobile;

  })(SessionViewBase);

  module.exports.SessionViewMobile = new SessionViewMobile();

}).call(this);

});

require.define("/lib/client/client/wave/notification/log_out.js",function(require,module,exports,__dirname,__filename,process,global){
/*
Сообщение о выходе из риззомы.
*/

(function() {
  var History, ck, localStorage, logOut, showMessage, showSuccessfullyLoggedOut, social, tmpl;

  ck = window.CoffeeKup;

  localStorage = require('../../utils/localStorage').LocalStorage;

  History = require('../../utils/history_navigation');

  social = require('../../utils/social');

  tmpl = function() {
    return div('.js-log-out-container.log-out-container', function() {
      div('.notification-overlay', '');
      return div('.notification-block', function() {
        return div('', function() {
          div('.main-block', function() {
            h3('.logging-out-caption', 'Signing out...');
            h3('.logged-out-caption', 'Successfully signed out');
            if (this.source === 'google') {
              a('.js-sign-out-from-social.sign-out-from-social', {
                href: 'https://accounts.google.com/Logout',
                target: '_blank'
              }, 'Sign out from Google account');
            } else if (this.source === 'facebook') {
              a('.js-sign-out-from-social.sign-out-from-social', {
                href: 'https://facebook.com/',
                target: '_blank'
              }, 'Sign out from Facebook account');
            }
            div('.delimiter', '');
            h3('.logged-out-caption.visit-again-caption', 'Visit us again');
            div('.buttons-container', function() {
              return a('.js-enter-rizzoma-btn.btn.sign-in-btn', {
                href: "/topic/",
                title: "Sign in"
              });
            });
            return div('.links-container', function() {
              a({
                href: '/?from=signout_form'
              }, 'Home page');
              a({
                href: 'http://blog.rizzoma.com/?from=signout_form'
              }, 'Blog');
              return a({
                href: 'https://rizzoma.com/help-center-faq.html?from=signout_form'
              }, 'Help');
            });
          });
          return div('.social-block', function() {
            div('.facebook-like', function() {
              return text('<fb:like href="http://facebook.com/rizzomacom" send="false" width="270" show_faces="true"></fb:like>');
            });
            return div('.google-plus-like', function() {
              return div('.g-plusone', {
                'data-href': 'http://rizzoma.com',
                'data-callback': 'logoutPlusoneCallback'
              }, '');
            });
          });
        });
      });
    });
  };

  showMessage = function() {
    var body, container, link, _ref;
    window.logoutPlusoneCallback = function(param) {
      if (param.state === "on") {
        return _gaq.push(['_trackEvent', 'Social', '+1', 'Signout form']);
      }
    };
    social.addPlusoneScript();
    window.fbAsyncInit = function() {
      return FB.Event.subscribe('edge.create', function(targetUrl) {
        _gaq.push(['_trackSocial', 'facebook', 'Like', targetUrl]);
        return _gaq.push(['_trackEvent', 'Social', 'Like', 'Signout form']);
      });
    };
    social.addFacebookScript();
    body = $(document.body).append(ck.render(tmpl, {
      source: typeof window !== "undefined" && window !== null ? (_ref = window.userInfo) != null ? _ref.authSource : void 0 : void 0,
      redirectUrl: History.getLoginRedirectUrl()
    }));
    container = body.find('.js-log-out-container');
    container.show();
    link = body.find('.js-sign-out-from-social');
    link.on('click', function(e) {
      return _gaq.push(['_trackEvent', 'Authorization', 'Sign out from social', link.text()]);
    });
    return body.find('.js-enter-rizzoma-btn').click(function(e) {
      _gaq.push(['_trackEvent', 'Authorization', 'Sign in again click', window.location.pathname]);
      window.AuthDialog.initAndShow(false, History.getLoginRedirectUrl());
      container.hide();
      e.stopPropagation();
      return e.preventDefault();
    });
  };

  showSuccessfullyLoggedOut = function() {
    return $('.js-log-out-container').addClass('logged-out');
  };

  logOut = function() {
    _gaq.push(['_trackEvent', 'Authorization', 'Sign out from Rizzoma']);
    localStorage.clear();
    if (window.androidJSInterface) return window.androidJSInterface.onLogout();
    showMessage();
    if (typeof FB !== "undefined" && FB !== null) {
      if (typeof FB !== "undefined" && FB !== null) {
        FB.init({
          appId: '267439770022011',
          status: true,
          cookie: true,
          xfbml: true
        });
      }
    }
    return $.ajax('/logout/', {
      complete: showSuccessfullyLoggedOut
    });
  };

  module.exports = {
    logOut: logOut
  };

}).call(this);

});

require.define("/lib/client/client/utils/social.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var self;

  self = module.exports;

  self.addPlusoneScript = function() {
    return (function() {
      var po, s;
      po = document.createElement('script');
      po.type = 'text/javascript';
      po.async = true;
      po.src = 'https://apis.google.com/js/plusone.js';
      s = document.getElementsByTagName('script')[0];
      return s.parentNode.insertBefore(po, s);
    })();
  };

  self.addFacebookScript = function() {
    return (function(document) {
      var fjs, js;
      if (window.navigator.userAgent.search("Chrome") === -1 && window.navigator.userAgent.search("Mobile") !== -1) {
        return;
      }
      fjs = document.getElementsByTagName("script")[0];
      if (document.getElementById("facebook-jssdk")) return;
      js = document.createElement("script");
      js.id = "facebook-jssdk";
      js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=267439770022011";
      return fjs.parentNode.insertBefore(js, fjs);
    })(document);
  };

}).call(this);

});

require.define("/lib/client/client/navigation/mobile.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var DomUtils, History, MentionsPanel, NavigationPanel, PublicTopicsPanel, TasksPanel, TopicsPanel,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  History = require('../utils/history_navigation');

  DomUtils = require('../utils/dom');

  TopicsPanel = require('../search_panel/topic/panel_mobile').TopicsPanel;

  MentionsPanel = require('../search_panel/mention/panel_mobile').MentionsPanel;

  TasksPanel = require('../search_panel/task/panel_mobile').TasksPanel;

  PublicTopicsPanel = require('../search_panel/public_topic/panel_mobile').PublicTopicsPanel;

  NavigationPanel = (function() {
    /*
        Навигационная панель, переключающая поиск и список сообщений
    */
    function NavigationPanel(_container) {
      this._container = _container;
      this._handleTasksCountChange = __bind(this._handleTasksCountChange, this);
      this._handleMentionsCountChange = __bind(this._handleMentionsCountChange, this);
      this._handleTopicsCountChange = __bind(this._handleTopicsCountChange, this);
      this.updateTopicsUnreadCount = __bind(this.updateTopicsUnreadCount, this);
      this.updateBlipIsRead = __bind(this.updateBlipIsRead, this);
      this._initTasksPanel = __bind(this._initTasksPanel, this);
      if (module.exports.instance != null) {
        throw new Error('Navigation panel should be inited once');
      }
      module.exports.instance = this;
      if (window.loggedIn) {
        this._initPanels();
        this._initTabs();
        this._initChangeFollow();
      }
    }

    NavigationPanel.prototype._initPanels = function() {
      var accountProcessor;
      this._topicsPanel = this._initPanel(TopicsPanel, 'tab-topics-content', this._handleTopicsCountChange);
      this._mentionsPanel = this._initPanel(MentionsPanel, 'tab-messages-content', this._handleMentionsCountChange);
      this._publicTopicsPanel = this._initPanel(PublicTopicsPanel, 'tab-public-topics-content', function() {});
      this._panels = [this._topicsPanel, this._mentionsPanel, this._publicTopicsPanel];
      accountProcessor = require('../account_setup_wizard/processor').instance;
      if (accountProcessor.isBusinessUser()) {
        return this._initTasksPanel(true);
      } else {
        return accountProcessor.on('is-business-change', this._initTasksPanel);
      }
    };

    NavigationPanel.prototype._initTasksPanel = function(isBusiness) {
      var tasksTab;
      if (!isBusiness) return;
      tasksTab = document.getElementById('tab-tasks');
      $(tasksTab).parent().removeClass('hidden').parent().removeClass('hidden-tasks');
      require('../account_setup_wizard/processor').instance.removeListener('is-business-change', this._initTasksPanel);
      this._tasksPanel = this._initPanel(TasksPanel, 'tab-tasks-content', this._handleTasksCountChange);
      return this._panels.push(this._tasksPanel);
    };

    NavigationPanel.prototype._initPanel = function(classObject, id, counterFunction) {
      var panel;
      panel = new classObject(id);
      panel.on('linkClick', this._handleLinkClick);
      return panel.on('countChanged', counterFunction);
    };

    NavigationPanel.prototype._initTabs = function() {
      var tab, tabs, __this, _i, _len;
      this._activeTab = null;
      tabs = document.getElementsByClassName('js-tab-selector');
      __this = this;
      for (_i = 0, _len = tabs.length; _i < _len; _i++) {
        tab = tabs[_i];
        tab.addEventListener('click', function() {
          return __this._activateTab(this, false);
        }, false);
      }
      return this._activateTab(tabs[0], true);
    };

    NavigationPanel.prototype._trackAnalytics = function(tab) {
      var event;
      if (tab instanceof TopicsPanel) {
        event = 'Switch to topics list';
      } else if (tab instanceof MentionsPanel) {
        event = 'Switch to mentions list';
      } else if (tab instanceof TasksPanel) {
        event = 'Switch to tasks list';
      } else if (tab instanceof PublicTopicsPanel) {
        event = 'Switch to publics list';
      } else {
        event = 'Switch to unknown';
      }
      return _gaq.push(['_trackEvent', 'Navigation', event]);
    };

    NavigationPanel.prototype._activateTab = function(tabEl, firstTime) {
      var panel, tabId, _i, _len, _ref;
      tabId = tabEl.id + '-content';
      _ref = this._panels;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        panel = _ref[_i];
        if (panel.getId() === tabId) {
          if (this._activeTab === panel) {
            this._activeTab.dispatchLinkClickOnNextBolded();
            return;
          }
          if (this._activeTab) this._activeTab.hide();
          if (!tabEl.checked) tabEl.checked = true;
          (this._activeTab = panel).show();
          if (!firstTime) this._trackAnalytics(panel);
          break;
        }
      }
    };

    NavigationPanel.prototype._initChangeFollow = function() {
      var activate, serverBlipId, waveId, _ref,
        _this = this;
      activate = function(waveId, blipId) {
        var _ref;
        if (!waveId) return;
        _this._topicsPanel.switchActiveItem(waveId);
        _this._publicTopicsPanel.switchActiveItem(waveId);
        if (!blipId) return;
        _this._mentionsPanel.switchActiveItem(waveId, blipId);
        return (_ref = _this._tasksPanel) != null ? _ref.switchActiveItem(waveId, blipId) : void 0;
      };
      History.on('statechange', activate);
      _ref = History.getCurrentParams(), waveId = _ref.waveId, serverBlipId = _ref.serverBlipId;
      return activate(waveId, serverBlipId);
    };

    NavigationPanel.prototype.updateBlipIsRead = function(waveId, blipId, isRead) {
      /*
              Обновление непрочитанных сообщений и задач
      */
      var _ref, _ref2;
      if ((_ref = this._mentionsPanel) != null) {
        _ref.updateBoldState(waveId, blipId, !isRead);
      }
      return (_ref2 = this._tasksPanel) != null ? _ref2.updateBoldState(waveId, blipId, !isRead) : void 0;
    };

    NavigationPanel.prototype.updateTopicsUnreadCount = function(waveId, unreadCount, totalCount) {
      /*
              Обновление непрочитанных топиков
      */
      var _ref, _ref2;
      if ((_ref = this._topicsPanel) != null) {
        _ref.updateTopicsUnreadCount(waveId, unreadCount, totalCount);
      }
      return (_ref2 = this._publicTopicsPanel) != null ? _ref2.updateTopicsUnreadCount(waveId, unreadCount, totalCount) : void 0;
    };

    NavigationPanel.prototype.getTasksPanel = function() {
      return this._tasksPanel;
    };

    NavigationPanel.prototype.scrollToActiveItem = function() {
      var _ref;
      return (_ref = this._activeTab) != null ? _ref.scrollToActiveItem() : void 0;
    };

    NavigationPanel.prototype._handleLinkClick = function(href) {
      var serverBlipId, waveId, _ref;
      _ref = History.parseUrlParams(href), waveId = _ref.waveId, serverBlipId = _ref.serverBlipId;
      return History.navigateTo(waveId, serverBlipId);
    };

    NavigationPanel.prototype._updateCounter = function(counter, count) {
      var text;
      if (count <= 0) {
        return counter.textContent = '';
      } else {
        text = count > 99 ? '99+' : count;
        return counter.textContent = text;
      }
    };

    NavigationPanel.prototype._handleTopicsCountChange = function(count) {
      return this._updateCounter(document.getElementById('topics-counter'), count);
    };

    NavigationPanel.prototype._handleMentionsCountChange = function(count) {
      return this._updateCounter(document.getElementById('messages-counter'), count);
    };

    NavigationPanel.prototype._handleTasksCountChange = function(count) {
      return this._updateCounter(document.getElementById('tasks-counter'), count);
    };

    return NavigationPanel;

  })();

  module.exports = {
    NavigationPanel: NavigationPanel,
    instance: null
  };

}).call(this);

});

require.define("/lib/client/client/search_panel/topic/panel_mobile.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var Renderer, TopicsPanel, TopicsPanelBase,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  TopicsPanelBase = require('../base_mobile').TopicsPanelBase;

  Renderer = require('../renderer_mobile').TopicsRenderer;

  TopicsPanel = (function(_super) {

    __extends(TopicsPanel, _super);

    function TopicsPanel() {
      TopicsPanel.__super__.constructor.apply(this, arguments);
    }

    TopicsPanel.prototype.__init = function() {
      var processor, refreshParams;
      processor = require('./processor').instance;
      refreshParams = {
        isVisible: false,
        visibleUpdateInterval: window.uiConf.search.refreshInterval.visible,
        hiddenUpdateInterval: null,
        unvisibleBrowserTabUpdateInterval: null
      };
      return TopicsPanel.__super__.__init.call(this, processor, refreshParams, Renderer);
    };

    TopicsPanel.prototype.__getAdditionalParams = function() {
      return {
        ptagNames: 'FOLLOW'
      };
    };

    TopicsPanel.prototype.__getSearchFunction = function() {
      return 'network.wave.searchBlipContent';
    };

    TopicsPanel.prototype.__getPanelName = function() {
      return 'topic';
    };

    return TopicsPanel;

  })(TopicsPanelBase);

  exports.TopicsPanel = TopicsPanel;

}).call(this);

});

require.define("/lib/client/client/search_panel/base_mobile.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipSearchPanel, DEFAULT_AVATAR, DomUtils, History, MicroEvent, PanelBase, PanelInt, SCROLL_OFFSET, TopicsPanelBase, VISIBILITY_CLASS, formatDate,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  PanelInt = require('./base').BaseSearchPanel;

  History = require('../utils/history_navigation');

  MicroEvent = require('../utils/microevent');

  DomUtils = require('../utils/dom');

  formatDate = require('../../share/utils/datetime').formatDate;

  DEFAULT_AVATAR = '/s/img/user/unknown.png';

  VISIBILITY_CLASS = 'shown-content-tab';

  SCROLL_OFFSET = -100;

  PanelBase = (function(_super) {

    __extends(PanelBase, _super);

    /*
        @interface
    */

    /* Block unimplemented functions
    */

    PanelBase.prototype.__getPanelName = function() {
      return PanelBase.__super__.__getPanelName.call(this);
    };

    PanelBase.prototype.__getAdditionalParams = function() {
      return PanelBase.__super__.__getAdditionalParams.call(this);
    };

    PanelBase.prototype.__processAfterResponse = function() {
      return PanelBase.__super__.__processAfterResponse.call(this);
    };

    PanelBase.prototype.__getSearchFunction = function() {
      return PanelBase.__super__.__getSearchFunction.call(this);
    };

    PanelBase.prototype.__parseResponseItem = function() {
      return PanelBase.__super__.__parseResponseItem.call(this);
    };

    /* EndBlock unimplemented functions
    */

    function PanelBase(_id) {
      this._id = _id;
      this.__linkClickHandler = __bind(this.__linkClickHandler, this);
      PanelBase.__super__.constructor.call(this, document.getElementById(this._id));
    }

    PanelBase.prototype.__init = function(processor, refreshParams, SearchItemRendererClass) {
      /*
              @param isVisible: boolean
              @param processor: instance /client/search_panel/base_processor.BaseSearchProcessor
              @param refreshInterval: int
              @param SearchItemRendererClass: class /client/search_panel/renderer_mobile.Renderer
      */
      var container, resultsContainer, searchButton, searchInput;
      container = this.getContainer();
      searchButton = container.getElementsByClassName('js-run-search-button')[0];
      searchInput = container.getElementsByClassName('js-search-query')[0];
      resultsContainer = container.getElementsByClassName('js-search-results')[0];
      this._searchItemRenderer = new SearchItemRendererClass();
      this._lastBoldedCount = 0;
      this._lastActiveItemId = null;
      return PanelBase.__super__.__init.call(this, processor, resultsContainer, searchInput, searchButton, refreshParams, null);
    };

    PanelBase.prototype.__getInterfaceMode = function() {
      return 'mobile';
    };

    PanelBase.prototype.hide = function() {
      var _ref;
      DomUtils.removeClass(this.getContainer(), VISIBILITY_CLASS);
      return (_ref = this.getTimer()) != null ? _ref.setTabAsHidden() : void 0;
    };

    PanelBase.prototype.show = function() {
      var _ref;
      DomUtils.addClass(this.getContainer(), VISIBILITY_CLASS);
      return (_ref = this.getTimer()) != null ? _ref.setTabAsVisible() : void 0;
    };

    PanelBase.prototype.getId = function() {
      return this._id;
    };

    PanelBase.prototype.switchActiveItem = function(waveId, blipId) {
      return this.__switchActiveItem(this.__getItemId(waveId, blipId));
    };

    PanelBase.prototype.dispatchLinkClickOnNextBolded = function() {
      var startIndex;
      if (!this.__lastSearchResults) return;
      startIndex = this._getActiveItemIndex();
      return this._dispatchClickOnNextBolded(startIndex);
    };

    PanelBase.prototype.__switchActiveItem = function(id) {
      var activeItem, domItem;
      if (!id) return;
      this._lastActiveItemId = id;
      domItem = this.__getDomItem(id);
      activeItem = this.__getResultsContainer().getElementsByClassName('active')[0];
      if (activeItem) DomUtils.removeClass(activeItem, 'active');
      if (domItem) return DomUtils.addClass(domItem, 'active');
    };

    PanelBase.prototype.__getCommonItem = function(id, title, snippet, date, dateTitle, name, avatar, isBolded, waveId, blipId) {
      var item, url;
      avatar || (avatar = DEFAULT_AVATAR);
      item = {
        id: id,
        title: title,
        snippet: snippet,
        date: date,
        dateTitle: dateTitle,
        name: name,
        avatar: avatar,
        isBolded: isBolded
      };
      url = "" + (History.getPrefix()) + waveId;
      if (blipId) url += "/" + blipId + "/";
      item.url = url;
      return item;
    };

    PanelBase.prototype.__getBoldedCount = function() {
      var count, id, item, _ref;
      count = 0;
      _ref = this.__lastSearchResults;
      for (id in _ref) {
        item = _ref[id];
        if (item.isBolded) count += 1;
      }
      return count;
    };

    PanelBase.prototype.__getRenderer = function() {
      return this._searchItemRenderer;
    };

    PanelBase.prototype.__processAfterResponse = function() {
      var count;
      count = this.__getBoldedCount();
      if (count !== this._lastBoldedCount) {
        this._lastBoldedCount = count;
        return this.emit('countChanged', this._lastBoldedCount);
      }
    };

    PanelBase.prototype.__renderError = function() {
      /*
              @override
      */      return this._searchItemRenderer.renderError(this.__getResultsContainer());
    };

    PanelBase.prototype.__renderLoading = function() {
      return this._searchItemRenderer.renderLoading(this.__getResultsContainer());
    };

    PanelBase.prototype.__renderEmptyResult = function() {
      return this._searchItemRenderer.renderEmptyResult(this.__getResultsContainer());
    };

    PanelBase.prototype.__renderItems = function() {
      var item, itemList, scrollTop, _, _ref;
      itemList = [];
      _ref = this.__lastSearchResults;
      for (_ in _ref) {
        item = _ref[_];
        itemList.push(item);
      }
      itemList.sort(function(a, b) {
        return a.num - b.num;
      });
      scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
      this._searchItemRenderer.renderItems(this.__getResultsContainer(), itemList);
      document.body.scrollTop = scrollTop;
      return document.documentElement.scrollTop = scrollTop;
    };

    PanelBase.prototype.__renderResponse = function() {
      var hasItems, _;
      hasItems = false;
      try {
        for (_ in this.__lastSearchResults) {
          hasItems = true;
          break;
        }
      } catch (e) {

      }
      if (hasItems) {
        this.__renderItems();
        return this.__switchActiveItem(this._lastActiveItemId);
      } else {
        return this.__renderEmptyResult();
      }
    };

    PanelBase.prototype.__getItemId = function(waveId, blipId) {
      var id;
      id = "" + (this.__getPanelName()) + "-" + waveId;
      if (blipId) id += "-" + blipId;
      return id;
    };

    PanelBase.prototype.__getItem = function(id) {
      return this.__lastSearchResults[id];
    };

    PanelBase.prototype.__setItem = function(id, item) {
      return this.__lastSearchResults[id] = item;
    };

    PanelBase.prototype.__getDomItem = function(id) {
      var resultsContainer;
      resultsContainer = this.__getResultsContainer();
      return document.getElementById(id);
    };

    PanelBase.prototype.scrollToActiveItem = function() {
      var item;
      if (!this._lastActiveItemId) return;
      item = this.__getDomItem(this._lastActiveItemId);
      if (!item) return;
      return DomUtils.scrollTargetIntoView(item, document.body, true, SCROLL_OFFSET);
    };

    PanelBase.prototype.__linkClickHandler = function(event) {
      /*
              @override
      */
      var resultsContainer, target;
      target = event.target;
      resultsContainer = this.__getResultsContainer();
      while (!DomUtils.isAnchorElement(target) && target !== resultsContainer) {
        target = target.parentNode;
      }
      if (!DomUtils.isAnchorElement(target)) return;
      event.preventDefault();
      event.stopPropagation();
      return this.emit('linkClick', target.href);
    };

    PanelBase.prototype.__updateDomItemBoldState = function(item, domItem) {
      if (item.isBolded) {
        return DomUtils.addClass(domItem, 'bold');
      } else {
        return DomUtils.removeClass(domItem, 'bold');
      }
    };

    PanelBase.prototype._dispatchClickOnNextBolded = function(startIndex) {
      var emitLinkClickOnBoldedItem, index, results, _ref, _this;
      results = this.__getResultsContainer().children;
      _this = this;
      emitLinkClickOnBoldedItem = function(index) {
        var item;
        item = results[index];
        if (DomUtils.hasClass(item, 'bold')) {
          _this.emit('linkClick', item.href);
          return true;
        }
        return false;
      };
      for (index = startIndex, _ref = results.length - 1; startIndex <= _ref ? index <= _ref : index >= _ref; startIndex <= _ref ? index++ : index--) {
        if (emitLinkClickOnBoldedItem(index)) return;
      }
      for (index = 0; 0 <= startIndex ? index < startIndex : index > startIndex; 0 <= startIndex ? index++ : index--) {
        if (emitLinkClickOnBoldedItem(index)) return;
      }
    };

    PanelBase.prototype._getActiveItemIndex = function() {
      var activeItem, index, item, _len, _ref;
      activeItem = this.__getDomItem(this._lastActiveItemId);
      if (!activeItem) return 0;
      _ref = this.__getResultsContainer().children;
      for (index = 0, _len = _ref.length; index < _len; index++) {
        item = _ref[index];
        if (item === activeItem) return index;
      }
      return 0;
    };

    return PanelBase;

  })(PanelInt);

  TopicsPanelBase = (function(_super) {
    var ALL_UNREAD, ONE_UNREAD;

    __extends(TopicsPanelBase, _super);

    function TopicsPanelBase() {
      this.__getUnreadLen = __bind(this.__getUnreadLen, this);
      this.updateTopicsUnreadCount = __bind(this.updateTopicsUnreadCount, this);
      TopicsPanelBase.__super__.constructor.apply(this, arguments);
    }

    ONE_UNREAD = 5;

    ALL_UNREAD = 100;

    TopicsPanelBase.prototype.updateTopicsUnreadCount = function(waveId, unreadCount, totalCount) {
      /*
              Обновляет количество непрочитанных сообщений волны в результатах поиска
              @param waveId: string
              @param unreadCount: int
              @param totalCount: int
      */
      var id, item;
      id = this.__getItemId(waveId);
      item = this.__getItem(id);
      if (!item) return;
      this._setItemUnreadLength(item, unreadCount, totalCount);
      this._setDomItemUnreadLength(item);
      return this.__processAfterResponse();
    };

    TopicsPanelBase.prototype.__getUnreadLen = function(unreadCount, totalBlips) {
      var a, a_dividend, b, b_dividend;
      if (unreadCount === 1) return ONE_UNREAD;
      if (unreadCount === totalBlips) return ALL_UNREAD;
      if (unreadCount === 0) return 0;
      a_dividend = Math.pow(ONE_UNREAD, 2) - Math.pow(ALL_UNREAD, 2);
      a = Math.sqrt(a_dividend / (1 - totalBlips));
      b_dividend = Math.pow(ALL_UNREAD, 2) - Math.pow(ONE_UNREAD, 2) * totalBlips;
      b = b_dividend / (Math.pow(ONE_UNREAD, 2) - Math.pow(ALL_UNREAD, 2));
      return a * Math.sqrt(unreadCount + b);
    };

    TopicsPanelBase.prototype.__parseResponseItem = function(item) {
      var id, parsedItem;
      id = this.__getItemId(item.waveId);
      if (!item.changed) return this.__getItem(id);
      parsedItem = this.__getCommonItem(id, item.title, item.snippet, formatDate(item.changeDate), formatDate(item.changeDate, true), item.name, item.avatar, !!item.totalUnreadBlipCount, item.waveId);
      return this._setItemUnreadLength(parsedItem, item.totalUnreadBlipCount, item.totalBlipCount);
    };

    TopicsPanelBase.prototype._setItemUnreadLength = function(item, unreadCount, totalCount) {
      item.unreadLength = this.__getUnreadLen(unreadCount, totalCount);
      item.isBolded = !!item.unreadLength;
      return item;
    };

    TopicsPanelBase.prototype._setDomItemUnreadLength = function(item) {
      var domItem, indicator;
      domItem = this.__getDomItem(item.id);
      indicator = domItem.getElementsByClassName('js-unread-blips-indicator')[0];
      indicator.style.height = "" + item.unreadLength + "%";
      return this.__updateDomItemBoldState(item, domItem);
    };

    return TopicsPanelBase;

  })(PanelBase);

  BlipSearchPanel = (function(_super) {

    __extends(BlipSearchPanel, _super);

    function BlipSearchPanel() {
      BlipSearchPanel.__super__.constructor.apply(this, arguments);
    }

    BlipSearchPanel.prototype.updateBoldState = function(waveId, blipId, isBolded) {
      var id, item;
      id = this.__getItemId(waveId, blipId);
      item = this.__getItem(id);
      if (!item) return;
      if (item.isBolded === isBolded) return;
      item.isBolded = isBolded;
      this.__updateDomItemBoldState(item, this.__getDomItem(item.id));
      return this.__processAfterResponse();
    };

    return BlipSearchPanel;

  })(PanelBase);

  MicroEvent.mixin(PanelBase);

  exports.PanelBase = PanelBase;

  exports.TopicsPanelBase = TopicsPanelBase;

  exports.BlipSearchPanel = BlipSearchPanel;

}).call(this);

});

require.define("/lib/client/client/search_panel/base.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BaseSearchPanel, BrowserEvents, DomUtils, History, RootRouter, SEARCH_TIMEOUT, SHOW_STATUSBAR_CLASS, Timer, commonRenderer, localStorage,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  DomUtils = require('../utils/dom');

  localStorage = require('../utils/localStorage').LocalStorage;

  History = require('../utils/history_navigation');

  RootRouter = require('../modules/root_router_base').instance;

  Timer = require('./timer').Timer;

  commonRenderer = require('./template');

  BrowserEvents = require('../utils/browser_events');

  SEARCH_TIMEOUT = 2000;

  SHOW_STATUSBAR_CLASS = 'show-status-bar';

  BaseSearchPanel = (function() {

    function BaseSearchPanel(_container) {
      this._container = _container;
      this.__linkClickHandler = __bind(this.__linkClickHandler, this);
      this.__renderResponse = __bind(this.__renderResponse, this);
      this.__processSearchStart = __bind(this.__processSearchStart, this);
      this.__init();
    }

    BaseSearchPanel.prototype.__init = function(_processor, _resultsContainer, _searchInput, _searchButton, refreshParams, _renderer) {
      var reRequestSearchResults, responseCache, showStatusBar, statusBar,
        _this = this;
      this._processor = _processor;
      this._resultsContainer = _resultsContainer;
      this._searchInput = _searchInput;
      this._searchButton = _searchButton;
      this._renderer = _renderer;
      this._canSearch = true;
      this._searchTimer = null;
      this._lastSearchDate = null;
      statusBar = DomUtils.parseFromString(commonRenderer.renderStatusBar());
      this._container.appendChild(statusBar);
      this._statusBar = this._container.getElementsByClassName('js-status-bar')[0];
      this._statusBarText = this._statusBar.getElementsByClassName('js-status-bar-text')[0];
      this._lastQueryString = '';
      this.__lastSearchFunction = '';
      this.__lastSearchResults = {};
      this.__initTimer(refreshParams);
      this._searchButton.addEventListener('click', function() {
        var _ref;
        if ((_ref = _this._timer) != null) _ref.resetTimeout();
        _this.__setStatusBarText('Searching...');
        return _this.__processSearchStart(true);
      }, false);
      this._searchInput.addEventListener('keypress', function(e) {
        var _ref;
        if (e.keyCode !== 13) return;
        if ((_ref = _this._timer) != null) _ref.resetTimeout();
        _this.__setStatusBarText('Searching...');
        return _this.__processSearchStart(true);
      }, false);
      this._resultsContainer.addEventListener('click', this.__linkClickHandler, false);
      showStatusBar = false;
      reRequestSearchResults = true;
      if (!window.openSearchQuery) {
        responseCache = localStorage.getSearchResults(this.__getSearchFunction(), this.__getInterfaceMode());
        if (responseCache && responseCache.value) {
          this.__lastSearchResults = responseCache.value;
          this.__renderResponse(true);
          if (responseCache.savedTime) {
            if (Date.now() - responseCache.savedTime < refreshParams.visibleUpdateInterval) {
              reRequestSearchResults = false;
            }
          }
        }
      } else {
        this.__setStatusBarText('Searching...');
        showStatusBar = true;
      }
      if (reRequestSearchResults) {
        return this.__processSearchStart(true, !showStatusBar);
      }
    };

    BaseSearchPanel.prototype.__getInterfaceMode = function() {
      return 'desktop';
    };

    BaseSearchPanel.prototype.__initTimer = function(refreshParams) {
      var _this = this;
      if (!refreshParams || !(refreshParams.isVisible != null) || !refreshParams.visibleUpdateInterval) {
        return console.warn("Variable refreshParams is wrong defined, updateTimer for " + (this.__getPanelName()) + " panel not inited");
      }
      this._timer = new Timer(refreshParams);
      return this._timer.on('intervalExpired', function(scrollIntoView) {
        if (RootRouter.isConnected()) {
          return _this.__processSearchStart(scrollIntoView, true);
        }
      });
    };

    BaseSearchPanel.prototype.__processSearchStart = function(scrollIntoView, autoSearch) {
      var _this = this;
      if (scrollIntoView == null) scrollIntoView = false;
      if (autoSearch == null) autoSearch = false;
      this._markSearchProcess(true, autoSearch);
      clearTimeout(this._searchTimer);
      scrollIntoView = !!scrollIntoView;
      if (this._canSearch) {
        this._makeSearch(scrollIntoView, autoSearch);
        return this._canSearch = false;
      } else {
        return this._searchTimer = setTimeout(function() {
          return _this._makeSearch(scrollIntoView, autoSearch);
        }, SEARCH_TIMEOUT);
      }
    };

    BaseSearchPanel.prototype._makeSearch = function(scrollIntoView, autoSearch) {
      var additionalParams, lastSearchFunction,
        _this = this;
      additionalParams = this.__getAdditionalParams();
      if (this._lastQueryString !== this._searchInput.value) {
        this._lastSearchDate = null;
      }
      this._lastQueryString = this._searchInput.value;
      lastSearchFunction = this.__getSearchFunction();
      this._processor.search(lastSearchFunction, this._lastQueryString, this._lastSearchDate, additionalParams, function(err, response) {
        _this._markSearchProcess(false, autoSearch);
        if (err) return _this.__processError(err, autoSearch);
        _this.__processResponse(response, scrollIntoView);
        return _this.__processAfterResponse();
      });
      return setTimeout(function() {
        return _this._canSearch = true;
      }, SEARCH_TIMEOUT);
    };

    BaseSearchPanel.prototype._markSearchProcess = function(isSearching, autoSearch) {
      if (isSearching) {
        if (autoSearch) return;
        DomUtils.addClass(this._searchButton, 'search-icon-wait');
        return DomUtils.addClass(this._statusBar, SHOW_STATUSBAR_CLASS);
      } else {
        if (autoSearch) return;
        DomUtils.removeClass(this._searchButton, 'search-icon-wait');
        return DomUtils.removeClass(this._statusBar, SHOW_STATUSBAR_CLASS);
      }
    };

    BaseSearchPanel.prototype.__setActiveItem = function(scrollIntoView) {
      var activeItem, lastActiveItems, serverBlipId, waveId, _ref;
      if (scrollIntoView == null) scrollIntoView = false;
      /*
              Говорит выделить активный элемент поискового списка
      */
      _ref = History.getCurrentParams(), waveId = _ref.waveId, serverBlipId = _ref.serverBlipId;
      lastActiveItems = this._resultsContainer.getElementsByClassName('active');
      if (lastActiveItems.length > 0) {
        DomUtils.removeClass(lastActiveItems[0], 'active');
      }
      activeItem = document.getElementById(this.__getActiveItemId(waveId, serverBlipId));
      if (activeItem != null) DomUtils.addClass(activeItem, 'active');
      if (scrollIntoView && activeItem) return activeItem.scrollIntoView();
    };

    BaseSearchPanel.prototype.__getActiveItemId = function() {
      throw new Error("Method '__getActiveItemId' not implemented");
    };

    BaseSearchPanel.prototype.__getAdditionalParams = function() {
      return {};
    };

    BaseSearchPanel.prototype.__processAfterResponse = function() {};

    BaseSearchPanel.prototype.__processError = function(error, autoSearch) {
      console.error("Got server error for " + (this.__getPanelName()) + " search", error);
      if (autoSearch) return;
      this.__clearLastSearchResults();
      return this.__renderError();
    };

    BaseSearchPanel.prototype.__parseResponse = function(response) {
      var item, itemNum, parsedItem, resultsById, _len, _ref;
      resultsById = {};
      _ref = response.searchResults;
      for (itemNum = 0, _len = _ref.length; itemNum < _len; itemNum++) {
        item = _ref[itemNum];
        parsedItem = this.__parseResponseItem(item);
        if (!parsedItem) {
          console.error("Invalid searchResult item in " + (this.__getPanelName()) + ", skipping item", item);
          continue;
        }
        parsedItem.num = itemNum;
        resultsById[parsedItem.id] = parsedItem;
      }
      this.__lastSearchResults = resultsById;
      if (this.__canCacheSearchResults()) {
        return localStorage.setSearchResults(this.__getSearchFunction(), this.__lastSearchResults, this.__getInterfaceMode());
      }
    };

    BaseSearchPanel.prototype.__canCacheSearchResults = function() {
      return this._lastQueryString === '';
    };

    BaseSearchPanel.prototype.__addItem = function(item, itemId, index) {
      var i, _, _ref;
      item.num = index;
      _ref = this.__lastSearchResults;
      for (_ in _ref) {
        i = _ref[_];
        if (i.num >= index) i.num += 1;
      }
      return this.__lastSearchResults[itemId] = item;
    };

    BaseSearchPanel.prototype.__removeItem = function(itemId) {
      return delete this.__lastSearchResults[itemId];
    };

    BaseSearchPanel.prototype.__setStatusBarText = function(text) {
      return this._statusBarText.textContent = text;
    };

    BaseSearchPanel.prototype.__renderResponse = function(scrollIntoView) {
      var item, itemList, result, _i, _len;
      DomUtils.empty(this._resultsContainer);
      itemList = this.getLastSearchResults();
      if (itemList.length === 0) {
        this.__clearLastSearchResults();
        this._resultsContainer.innerHTML = commonRenderer.renderEmptyResult();
      } else {
        result = '';
        for (_i = 0, _len = itemList.length; _i < _len; _i++) {
          item = itemList[_i];
          result += this._renderer.renderResultItem({
            item: item,
            prefix: History.getPrefix()
          });
        }
        result = DomUtils.parseFromString(result);
        this._resultsContainer.appendChild(result);
        return this.__setActiveItem(scrollIntoView);
      }
    };

    BaseSearchPanel.prototype.__processResponse = function(response, scrollIntoView) {
      try {
        this._lastSearchDate = response.lastSearchDate;
        this.__parseResponse(response);
        return this.__renderResponse(scrollIntoView);
      } catch (e) {
        console.error("Got unexpected result for " + (this.__getPanelName()) + " search:", response, e);
        this.__clearLastSearchResults();
        return this.__renderError();
      }
    };

    BaseSearchPanel.prototype.__clearLastSearchResults = function() {
      this._lastSearchDate = null;
      return this.__lastSearchResults = {};
    };

    BaseSearchPanel.prototype.__renderError = function() {
      _gaq.push(['_trackEvent', 'Error', 'Client error', 'Search error']);
      this.__setStatusBarText('Awaiting Rizzoma...');
      return DomUtils.addClass(this._statusBar, SHOW_STATUSBAR_CLASS);
    };

    BaseSearchPanel.prototype.__getSearchFunction = function() {
      throw new Error("Method '__getSearchFunction' not implemented");
    };

    BaseSearchPanel.prototype.__parseResponseItem = function() {
      throw new Error("Method '__parseResponseItem' not implemented");
    };

    BaseSearchPanel.prototype.__getPanelName = function() {
      throw new Error("Method '__getPanelName' not implemented");
    };

    BaseSearchPanel.prototype.__linkClickHandler = function(event) {
      var serverBlipId, target, waveId, _ref;
      if (event.ctrlKey || event.metaKey || event.button) return;
      event.preventDefault();
      target = event.target;
      while (!DomUtils.isAnchorElement(target) && DomUtils.contains(this._container, target)) {
        target = target.parentNode;
      }
      if (!DomUtils.isAnchorElement(target)) return;
      _ref = History.parseUrlParams(target.href), waveId = _ref.waveId, serverBlipId = _ref.serverBlipId;
      History.navigateTo(waveId, serverBlipId);
      return this.__setActiveItem();
    };

    BaseSearchPanel.prototype.__getResultsContainer = function() {
      return this._resultsContainer;
    };

    BaseSearchPanel.prototype.__getProcessor = function() {
      return this._processor;
    };

    BaseSearchPanel.prototype.__getLastQueryString = function() {
      return this._lastQueryString;
    };

    BaseSearchPanel.prototype.__triggerSearch = function() {
      var e;
      e = BrowserEvents.createCustomEvent(BrowserEvents.CLICK_EVENT, true, true);
      return this._searchButton.dispatchEvent(e);
    };

    BaseSearchPanel.prototype.__triggerQueryInputEvent = function() {
      var e;
      e = BrowserEvents.createCustomEvent(BrowserEvents.INPUT_EVENT, true, true);
      return this._searchInput.dispatchEvent(e);
    };

    BaseSearchPanel.prototype.__clearSearchInput = function() {
      this._searchInput.value = '';
      this.__triggerSearch();
      return this.__triggerQueryInputEvent();
    };

    BaseSearchPanel.prototype.getLastSearchResults = function() {
      var item, results, _, _ref;
      results = [];
      _ref = this.__lastSearchResults;
      for (_ in _ref) {
        item = _ref[_];
        results.push(item);
      }
      results.sort(function(a, b) {
        return a.num - b.num;
      });
      return results;
    };

    BaseSearchPanel.prototype.getContainer = function() {
      return this._container;
    };

    BaseSearchPanel.prototype.getTimer = function() {
      return this._timer;
    };

    BaseSearchPanel.prototype.setActiveItem = function(scrollIntoView) {
      if (scrollIntoView == null) scrollIntoView = false;
      return this.__setActiveItem(scrollIntoView);
    };

    return BaseSearchPanel;

  })();

  exports.BaseSearchPanel = BaseSearchPanel;

}).call(this);

});

require.define("/lib/client/client/search_panel/timer.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var MicroEvent, Timer,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  MicroEvent = require('../utils/microevent');

  Timer = (function() {
    /*
        Класс, объект которого следит за автообновлением вкладок
        со списками топиков/сообщений через @_refreshInterval
    */
    var VISIBILITY_STATE;

    VISIBILITY_STATE = {
      visible: 'visible',
      hidden: 'hidden'
    };

    function Timer(_params) {
      this._params = _params;
      this._processEvent = __bind(this._processEvent, this);
      this._lastEventTime = new Date().getTime();
      this._pageVisibilityState = Visibility.state();
      this._tabVisibilityState = this._params.isVisible ? VISIBILITY_STATE.visible : VISIBILITY_STATE.hidden;
      this._setVisibilityBrowserTabEvent();
      this._resetTimeout();
    }

    Timer.prototype._setTimeout = function(timeout) {
      if (timeout == null) timeout = null;
      /*
              @param timeout: количество миллисекунд, через которые выполнится функция _processEvent
              Задает таймаут выполнения function
      */
      if (!timeout) timeout = this._getUpdateInterval();
      if (!timeout) return this._clearTimeout();
      return this._eventTimeout = setTimeout(this._processEvent, timeout);
    };

    Timer.prototype._getUpdateInterval = function() {
      if (this._pageVisibilityState === VISIBILITY_STATE.visible) {
        if (this._tabVisibilityState === VISIBILITY_STATE.visible && this._params.visibleUpdateInterval) {
          return this._params.visibleUpdateInterval;
        }
        if (this._tabVisibilityState === VISIBILITY_STATE.hidden && this._params.hiddenUpdateInterval) {
          return this._params.hiddenUpdateInterval;
        }
      }
      if (this._pageVisibilityState === VISIBILITY_STATE.hidden && this._params.unvisibleBrowserTabUpdateInterval) {
        return this._params.unvisibleBrowserTabUpdateInterval;
      }
      return null;
    };

    Timer.prototype._clearTimeout = function() {
      return this._eventTimeout = clearTimeout(this._eventTimeout);
    };

    Timer.prototype._resetTimeout = function(timeout) {
      if (timeout == null) timeout = null;
      this._clearTimeout();
      return this._setTimeout(timeout);
    };

    Timer.prototype._processEvent = function(scrollIntoView) {
      var time_left, updateInterval;
      if (scrollIntoView == null) scrollIntoView = false;
      /*
              @param scrollIntoView: Boolean скроллировать ли к активной волне список
              Вызывает событие об истечении интервала (intervalExpired) если 
              со времени @_lastEventTime прошло @_refreshInterval
              иначе задает таймаут на оставшееся время
      */
      updateInterval = this._getUpdateInterval();
      if (!updateInterval) return;
      time_left = updateInterval - (new Date().getTime() - this._lastEventTime);
      if (time_left <= 0) {
        this.emit('intervalExpired', scrollIntoView);
        this._lastEventTime = new Date().getTime();
        return this._resetTimeout();
      } else {
        return this._resetTimeout(time_left);
      }
    };

    Timer.prototype._setVisibilityBrowserTabEvent = function() {
      /*
              Обрабатывает изменение состояния вкладки
              в браузере visible/hidden
      */
      var _this = this;
      return Visibility.change(function(e, state) {
        switch (state) {
          case 'visible':
            _this._pageVisibilityState = VISIBILITY_STATE.visible;
            return _this._processEvent(true);
          case 'hidden':
            _this._pageVisibilityState = VISIBILITY_STATE.hidden;
            return _this._resetTimeout();
        }
      });
    };

    Timer.prototype.resetTimeout = function() {
      /*
              Сбрасывает таймаут для начала отсчета от текущего момента
      */      this._lastEventTime = new Date().getTime();
      return this._resetTimeout();
    };

    Timer.prototype.setTabAsVisible = function() {
      this._tabVisibilityState = VISIBILITY_STATE.visible;
      return this._processEvent();
    };

    Timer.prototype.setTabAsHidden = function() {
      this._tabVisibilityState = VISIBILITY_STATE.hidden;
      return this._processEvent();
    };

    return Timer;

  })();

  MicroEvent.mixin(Timer);

  module.exports.Timer = Timer;

}).call(this);

});

require.define("/lib/client/client/search_panel/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ck, errorTmpl, noResultsTmpl, statusBarTmpl;

  ck = window.CoffeeKup;

  noResultsTmpl = function() {
    return div('.js-no-results.no-results', 'No results');
  };

  errorTmpl = function() {
    return div('.js-search-error.search-error', 'Error occurred');
  };

  statusBarTmpl = function() {
    return div('.js-status-bar.status-bar', function() {
      return div('.js-status-bar-text', '');
    });
  };

  exports.renderEmptyResult = ck.compile(noResultsTmpl);

  exports.renderError = ck.compile(errorTmpl);

  exports.renderStatusBar = ck.compile(statusBarTmpl);

}).call(this);

});

require.define("/lib/client/client/search_panel/renderer_mobile.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var DomUtils, Renderer, TasksRenderer, TopicsRenderer, ck, emptyResultsTmpl, errorTmpl, loadingTmpl, renderSearchList, renderTaskList, renderTopicList,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  ck = window.CoffeeKup;

  DomUtils = require('../utils/dom');

  emptyResultsTmpl = ck.render(function() {
    return div('js-no-results search-item raw-text', 'No results');
  });

  errorTmpl = ck.render(function() {
    return div('js-search-error search-item raw-text', 'Error occurred');
  });

  loadingTmpl = ck.render(function() {
    return div('search-item raw-text', 'Loading');
  });

  renderSearchList = ck.compile(function() {
    var bold, item, items, _i, _len, _results;
    items = this.itemList;
    _results = [];
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      bold = item.isBolded ? 'bold' : '';
      _results.push(a("search-item " + bold, {
        id: item.id,
        href: h(item.url)
      }, function() {
        div('search-item-text', function() {
          span('search-item-title', h(item.title));
          br();
          return span('search-item-snippet', h(item.snippet));
        });
        return div('search-item-user-info', function() {
          div('avatar search-item-avatar', {
            style: "background-image: url('" + (h(item.avatar)) + "')",
            title: "" + (h(item.name || ''))
          });
          return div('search-item-date', {
            title: "" + (h(item.dateTitle))
          }, h(item.date));
        });
      }));
    }
    return _results;
  });

  renderTaskList = ck.compile(function() {
    var detailParams, renderTasks;
    renderTasks = function(items) {
      var bold, item, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        bold = item.isBolded ? 'bold' : '';
        _results.push(a("search-item " + bold, {
          id: item.id,
          href: h(item.url)
        }, function() {
          div('search-item-text', function() {
            span('search-item-title', h(item.title));
            br();
            return span('search-item-snippet', h(item.snippet));
          });
          return div('search-item-user-info', function() {
            div('avatar search-item-avatar', {
              style: "background-image: url('" + (h(item.avatar)) + "')",
              title: "" + (h(item.name || ''))
            });
            return div('search-item-date', {
              title: "" + (h(item.dateTitle))
            }, h(item.date));
          });
        }));
      }
      return _results;
    };
    renderTasks(this.items);
    if (!this.completedItems || !this.completedItems.length) return;
    detailParams = {};
    if (this.opened) detailParams.open = true;
    return details('js-completed-tasks-block completed-tasks-block', detailParams, function() {
      summary('search-item completed-tasks-summary', "Completed tasks — " + this.completedItems.length);
      return div('.completed-task-list', function() {
        return renderTasks(this.completedItems);
      });
    });
  });

  renderTopicList = ck.compile(function() {
    var bold, topic, topics, _i, _len, _results;
    topics = this.itemList;
    _results = [];
    for (_i = 0, _len = topics.length; _i < _len; _i++) {
      topic = topics[_i];
      bold = topic.isBolded ? 'bold' : '';
      _results.push(a("search-item " + bold, {
        id: topic.id,
        href: h(topic.url)
      }, function() {
        div('unread-blips-indicator', function() {
          return div('js-unread-blips-indicator', {
            style: "height: " + (h(topic.unreadLength)) + "%;"
          });
        });
        div('search-item-text', function() {
          span('search-item-title', h(topic.title));
          br();
          return span('search-item-snippet', h(topic.snippet));
        });
        return div('search-item-user-info', function() {
          div('avatar search-item-avatar', {
            style: "background-image: url('" + (h(topic.avatar)) + "')",
            title: "" + (h(topic.name || ''))
          });
          return div('search-item-date', {
            title: "" + (h(topic.dateTitle))
          }, h(topic.date));
        });
      }));
    }
    return _results;
  });

  Renderer = (function() {

    function Renderer() {}

    Renderer.prototype.renderError = function(container) {
      var result;
      result = DomUtils.parseFromString(errorTmpl);
      return this.__fillContainer(container, result);
    };

    Renderer.prototype.renderEmptyResult = function(container) {
      var result;
      result = DomUtils.parseFromString(emptyResultsTmpl);
      return this.__fillContainer(container, result);
    };

    Renderer.prototype.renderLoading = function(container) {
      var result;
      result = DomUtils.parseFromString(loadingTmpl);
      return this.__fillContainer(container, result);
    };

    Renderer.prototype.renderItems = function(container, itemList) {
      var params, result;
      params = {
        itemList: itemList
      };
      result = DomUtils.parseFromString(renderSearchList(params));
      return this.__fillContainer(container, result);
    };

    Renderer.prototype.__fillContainer = function(container, content) {
      return DomUtils.empty(container).appendChild(content);
    };

    return Renderer;

  })();

  TopicsRenderer = (function(_super) {

    __extends(TopicsRenderer, _super);

    function TopicsRenderer() {
      TopicsRenderer.__super__.constructor.apply(this, arguments);
    }

    TopicsRenderer.prototype.renderItems = function(container, itemList) {
      var params, result;
      params = {
        itemList: itemList
      };
      result = DomUtils.parseFromString(renderTopicList(params));
      return this.__fillContainer(container, result);
    };

    return TopicsRenderer;

  })(Renderer);

  TasksRenderer = (function(_super) {

    __extends(TasksRenderer, _super);

    function TasksRenderer() {
      TasksRenderer.__super__.constructor.apply(this, arguments);
    }

    TasksRenderer.prototype.renderItems = function(container, items, completedItems) {
      var params, result, _ref;
      params = {
        items: items,
        completedItems: completedItems
      };
      params.opened = (_ref = container.getElementsByClassName('js-completed-tasks-block')[0]) != null ? _ref.hasAttribute('open') : void 0;
      result = DomUtils.parseFromString(renderTaskList(params));
      return this.__fillContainer(container, result);
    };

    return TasksRenderer;

  })(Renderer);

  module.exports = {
    Renderer: Renderer,
    TopicsRenderer: TopicsRenderer,
    TasksRenderer: TasksRenderer
  };

}).call(this);

});

require.define("/lib/client/client/search_panel/mention/panel_mobile.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipSearchPanel, MentionsPanel, Renderer, formatDate,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BlipSearchPanel = require('../base_mobile').BlipSearchPanel;

  Renderer = require('../renderer_mobile').Renderer;

  formatDate = require('../../../share/utils/datetime').formatDate;

  MentionsPanel = (function(_super) {

    __extends(MentionsPanel, _super);

    function MentionsPanel() {
      MentionsPanel.__super__.constructor.apply(this, arguments);
    }

    MentionsPanel.prototype.__init = function() {
      var mentionsProcessor, refreshParams;
      mentionsProcessor = require('./processor').instance;
      refreshParams = {
        isVisible: false,
        visibleUpdateInterval: window.uiConf.search.refreshInterval.visible,
        hiddenUpdateInterval: window.uiConf.search.refreshInterval.hidden,
        unvisibleBrowserTabUpdateInterval: null
      };
      return MentionsPanel.__super__.__init.call(this, mentionsProcessor, refreshParams, Renderer);
    };

    MentionsPanel.prototype.__parseResponseItem = function(item) {
      var id;
      id = this.__getItemId(item.waveId, item.blipId);
      if (!item.changed) return this.__getItem(id);
      return this.__getCommonItem(id, item.title, item.snippet, formatDate(item.lastSent), formatDate(item.lastSent, true), item.senderName || item.senderEmail, item.senderAvatar, !item.isRead, item.waveId, item.blipId);
    };

    MentionsPanel.prototype.__getSearchFunction = function() {
      return 'network.message.searchMessageContent';
    };

    MentionsPanel.prototype.__getPanelName = function() {
      return 'mentionsPanel';
    };

    return MentionsPanel;

  })(BlipSearchPanel);

  exports.MentionsPanel = MentionsPanel;

}).call(this);

});

require.define("/lib/client/client/search_panel/task/panel_mobile.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BlipSearchPanel, NOT_PERFORMED_TASK, PERFORMED_TASK, Renderer, TasksPanel, compareTasks, convertCalendricalDate, convertDate, convertDateTimeToServer, convertDatetime, formatAsShortDate, formatAsShortTime, formatDate, formatFullDate, _ref, _ref2, _ref3,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BlipSearchPanel = require('../base_mobile').BlipSearchPanel;

  Renderer = require('../renderer_mobile').TasksRenderer;

  _ref = require('../../../share/utils/datetime'), formatDate = _ref.formatDate, formatAsShortDate = _ref.formatAsShortDate, formatAsShortTime = _ref.formatAsShortTime, formatFullDate = _ref.formatFullDate;

  _ref2 = require('../../../share/utils/date_converter'), convertDate = _ref2.convertDate, convertDatetime = _ref2.convertDatetime, convertDateTimeToServer = _ref2.convertDateTimeToServer, convertCalendricalDate = _ref2.convertCalendricalDate;

  _ref3 = require('./constants'), NOT_PERFORMED_TASK = _ref3.NOT_PERFORMED_TASK, PERFORMED_TASK = _ref3.PERFORMED_TASK;

  compareTasks = require('./common').compareTasks;

  formatDate = require('../../../share/utils/datetime').formatDate;

  ({
    filter: function() {
      return true;
    }
  });

  TasksPanel = (function(_super) {

    __extends(TasksPanel, _super);

    function TasksPanel() {
      TasksPanel.__super__.constructor.apply(this, arguments);
    }

    TasksPanel.prototype.__init = function() {
      var processor, refreshParams;
      processor = require('./processor').instance;
      refreshParams = {
        isVisible: false,
        visibleUpdateInterval: window.uiConf.search.refreshInterval.visible,
        hiddenUpdateInterval: window.uiConf.search.refreshInterval.hidden,
        unvisibleBrowserTabUpdateInterval: null
      };
      return TasksPanel.__super__.__init.call(this, processor, refreshParams, Renderer);
    };

    TasksPanel.prototype.updateTaskInfo = function(task) {
      var emailToCheck, parsedTask, _ref4;
      emailToCheck = task.senderEmail;
      if (emailToCheck !== ((_ref4 = window.userInfo) != null ? _ref4.email : void 0)) {
        return;
      }
      parsedTask = this.__parseResponseItem(task);
      this.__lastSearchResults[parsedTask.id] = parsedTask;
      return this.__renderResponse();
    };

    TasksPanel.prototype.__parseResponseItem = function(item) {
      var id, itemDatetime, itemFullDatetime, resultItem, _ref4;
      id = this.__getItemId(item.waveId, item.blipId);
      if (!item.changed) return this.__getItem(id);
      _ref4 = this._getDates(item), itemDatetime = _ref4.itemDatetime, itemFullDatetime = _ref4.itemFullDatetime;
      resultItem = this.__getCommonItem(id, item.title, item.snippet, itemDatetime, itemFullDatetime, item.senderName || item.senderEmail, item.senderAvatar, !item.isRead, item.waveId, item.blipId);
      resultItem.status = item.status;
      resultItem.deadline = item.deadline;
      return resultItem;
    };

    TasksPanel.prototype.__renderItems = function() {
      var completedTasks, incompleteTasks, _ref4;
      _ref4 = this._filterItems(function() {
        return true;
      }), incompleteTasks = _ref4[0], completedTasks = _ref4[1];
      if (!incompleteTasks.length && !completedTasks.length) {
        return this.__renderEmptyResult();
      }
      incompleteTasks.sort(compareTasks);
      completedTasks.sort(compareTasks);
      return this.__getRenderer().renderItems(this.__getResultsContainer(), incompleteTasks, completedTasks);
    };

    TasksPanel.prototype.__getAdditionalParams = function() {
      /*
              @override
      */
    };

    TasksPanel.prototype.__getBoldedCount = function() {
      var count, id, item, _ref4;
      count = 0;
      _ref4 = this.__lastSearchResults;
      for (id in _ref4) {
        item = _ref4[id];
        if (item.isBolded && item.status !== PERFORMED_TASK) count += 1;
      }
      return count;
    };

    TasksPanel.prototype.__getSearchFunction = function() {
      return "network.task.searchByRecipient";
    };

    TasksPanel.prototype.__getPanelName = function() {
      return 'tasksPanel';
    };

    TasksPanel.prototype._filterItems = function(filter) {
      var completedTasks, incompleteTasks, task, _, _ref4;
      if (!this.__lastSearchResults) return [[], []];
      completedTasks = [];
      incompleteTasks = [];
      _ref4 = this.__lastSearchResults;
      for (_ in _ref4) {
        task = _ref4[_];
        if (filter(task)) {
          if (task.status === PERFORMED_TASK) {
            completedTasks.push(task);
          } else {
            incompleteTasks.push(task);
          }
        }
      }
      return [incompleteTasks, completedTasks];
    };

    TasksPanel.prototype._getDates = function(item) {
      var date, dateObj, datetime, itemDatetime, itemFullDate, itemFullDatetime, todayDate, _ref4;
      itemDatetime = '';
      itemFullDate = '';
      if (!item.deadline) {
        return {
          itemDatetime: itemDatetime,
          itemFullDatetime: itemFullDatetime
        };
      }
      _ref4 = item.deadline, datetime = _ref4.datetime, date = _ref4.date;
      if (datetime != null) {
        dateObj = convertDatetime(datetime);
        todayDate = formatAsShortDate(Date.today());
        date = formatAsShortDate(dateObj);
        itemDatetime = formatAsShortTime(dateObj) || '';
        if (todayDate !== date) itemDatetime += "\n" + (date || '');
        itemFullDatetime = formatDate(datetime, true) || '';
      } else if (date != null) {
        dateObj = convertDate(date);
        itemFullDatetime = formatFullDate(dateObj) || '';
        itemDatetime = formatAsShortDate(dateObj) || '';
      }
      return {
        itemDatetime: itemDatetime,
        itemFullDatetime: itemFullDatetime
      };
    };

    return TasksPanel;

  })(BlipSearchPanel);

  exports.TasksPanel = TasksPanel;

}).call(this);

});

require.define("/lib/client/client/search_panel/task/common.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var convertDate, convertDatetime, getComparableDateString, _ref;

  _ref = require('../../../share/utils/date_converter'), convertDate = _ref.convertDate, convertDatetime = _ref.convertDatetime;

  getComparableDateString = function(task) {
    var date, datetime, _ref2, _ref3;
    date = (_ref2 = task.deadline) != null ? _ref2.date : void 0;
    datetime = (_ref3 = task.deadline) != null ? _ref3.datetime : void 0;
    if (date != null) return (convertDate(date)).addDays(1).toISOString();
    if (datetime != null) return (convertDatetime(datetime)).toISOString();
    return '9999' + convertDatetime(task.changeDate);
  };

  exports.compareTasks = function(first, second) {
    first = getComparableDateString(first);
    second = getComparableDateString(second);
    if (first === second) return 0;
    if (first < second) {
      return -1;
    } else {
      return 1;
    }
  };

}).call(this);

});

require.define("/lib/client/client/search_panel/public_topic/panel_mobile.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var PublicTopicsPanel, Renderer, TopicsPanelBase,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  TopicsPanelBase = require('../base_mobile').TopicsPanelBase;

  Renderer = require('../renderer_mobile').TopicsRenderer;

  PublicTopicsPanel = (function(_super) {

    __extends(PublicTopicsPanel, _super);

    function PublicTopicsPanel() {
      PublicTopicsPanel.__super__.constructor.apply(this, arguments);
    }

    PublicTopicsPanel.prototype.__init = function() {
      var publicTopicsProcessor, refreshParams;
      publicTopicsProcessor = require('./processor').instance;
      refreshParams = {
        isVisible: false,
        visibleUpdateInterval: window.uiConf.search.refreshInterval.visible,
        hiddenUpdateInterval: null,
        unvisibleBrowserTabUpdateInterval: null
      };
      return PublicTopicsPanel.__super__.__init.call(this, publicTopicsProcessor, refreshParams, Renderer);
    };

    PublicTopicsPanel.prototype.__getBoldedCount = function() {
      /*
              @override
      */      return 0;
    };

    PublicTopicsPanel.prototype.__getSearchFunction = function() {
      return 'network.wave.searchBlipContentInPublicWaves';
    };

    PublicTopicsPanel.prototype.__getPanelName = function() {
      return 'publicPanel';
    };

    return PublicTopicsPanel;

  })(TopicsPanelBase);

  exports.PublicTopicsPanel = PublicTopicsPanel;

}).call(this);

});

require.define("/lib/client/client/creating_topic_wizard/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ContactPicker, KEY_DOWN_EVENT, KEY_ENTER, TopicCreatingMaster, renderCommonForm, renderDecorate, renderVideo, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = Array.prototype.slice;

  _ref = require('./template'), renderCommonForm = _ref.renderCommonForm, renderDecorate = _ref.renderDecorate, renderVideo = _ref.renderVideo;

  ContactPicker = require('../contact_picker').ContactPicker;

  KEY_DOWN_EVENT = require('../utils/browser_events').KEY_DOWN_EVENT;

  KEY_ENTER = require('../utils/key_codes').KeyCodes.KEY_ENTER;

  TopicCreatingMaster = (function() {
    var MAX_CONTACTS_HEIGHT, MIN_CONTACTS_HEIGHT;

    MIN_CONTACTS_HEIGHT = 132;

    MAX_CONTACTS_HEIGHT = 440;

    function TopicCreatingMaster() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.hide = __bind(this.hide, this);
      this._windowKeyHandler = __bind(this._windowKeyHandler, this);
      this._dontShowWizard = __bind(this._dontShowWizard, this);
      this._createTopic = __bind(this._createTopic, this);
      this._setHeight = __bind(this._setHeight, this);
      this._init.apply(this, args);
    }

    TopicCreatingMaster.prototype._init = function(_container, _sourceButton, _waveModule, _waveProcessor, _processCreateWaveResponse, _initCreateButtons, _renderCreateButtons, hide_wizard_cookie_name) {
      var contactPickerContainer, contactPickerParams;
      this._container = _container;
      this._sourceButton = _sourceButton;
      this._waveModule = _waveModule;
      this._waveProcessor = _waveProcessor;
      this._processCreateWaveResponse = _processCreateWaveResponse;
      this._initCreateButtons = _initCreateButtons;
      this._renderCreateButtons = _renderCreateButtons;
      this.hide_wizard_cookie_name = hide_wizard_cookie_name;
      $(this._container).append(renderCommonForm());
      this._form = $(this._container).find('.js-ctm');
      this._titleInput = this._form.find('.js-topic-title');
      this._initEvents();
      this.setPosition(this._sourceButton);
      this._initVideoBlock();
      contactPickerContainer = $(this._container).find('.js-ctm-contact-picker')[0];
      contactPickerParams = {
        contactsSyncStart: function(source) {
          return _gaq.push(['_trackEvent', 'Contacts synchronization', 'Synchronize contacts click', "wizard " + source]);
        },
        contactsSyncFinish: function(source) {
          return _gaq.push(['_trackEvent', 'Contacts synchronization', 'Successfull synchronization', "wizard " + source]);
        },
        notificationContainer: $('.js-wave-notifications')
      };
      this._contactPicker = new ContactPicker(contactPickerContainer, this._waveProcessor, contactPickerParams);
      this._contactPicker.updateContacts();
      this._createButtonsContainer = $('.js-create-wave-buttons');
      return this.show();
    };

    TopicCreatingMaster.prototype._initEvents = function() {
      var dontShowWizard,
        _this = this;
      this._form.find('.js-ctm-create-topic').click(this._createTopic);
      dontShowWizard = this._form.find('.js-ctm-dont-show');
      if ($.cookie(this.hide_wizard_cookie_name)) {
        dontShowWizard.attr('checked', 'checked');
      }
      dontShowWizard.on('change', this._dontShowWizard);
      return this._titleInput.on(KEY_DOWN_EVENT, function(e) {
        if (e.which !== KEY_ENTER) return;
        return _this._createTopic();
      });
    };

    TopicCreatingMaster.prototype._setHeight = function() {
      var contactsHeight;
      contactsHeight = $(window).height() - 480;
      if (contactsHeight < MIN_CONTACTS_HEIGHT) {
        contactsHeight = MIN_CONTACTS_HEIGHT;
      }
      if (contactsHeight > MAX_CONTACTS_HEIGHT) {
        contactsHeight = MAX_CONTACTS_HEIGHT;
      }
      return this._contactPicker.setContactsHeight(contactsHeight);
    };

    TopicCreatingMaster.prototype._initVideoBlock = function() {
      var _this = this;
      this._$videoBlock = this._form.find('.js-wizard-video');
      this._$toggleVideo = this._form.find('.js-toggle-video');
      this._$toggleVideoText = this._form.find('.js-toggle-video-text');
      return this._$toggleVideo.on('click', function() {
        if (_this._$videoBlock.is(':visible')) {
          _this._hideVideoBlock();
          return _gaq.push(['_trackEvent', 'Wizard usage', 'Toggle vide', 'Hide video block']);
        } else {
          _this._showVideoBlock();
          return _gaq.push(['_trackEvent', 'Wizard usage', 'Toggle vide', 'Show video block']);
        }
      });
    };

    TopicCreatingMaster.prototype._hideVideoBlock = function() {
      this._$videoBlock.empty();
      this._form.width(390);
      return this._$toggleVideoText.text('Show video');
    };

    TopicCreatingMaster.prototype._showVideoBlock = function() {
      this._$videoBlock.append(renderVideo());
      this._form.width(915);
      return this._$toggleVideoText.text('Hide video');
    };

    TopicCreatingMaster.prototype._createTopic = function() {
      var doCreate, participants, title,
        _this = this;
      participants = this._contactPicker.getEmails();
      title = this._titleInput.val();
      if (title !== '') {
        _gaq.push(['_trackEvent', 'Wizard usage', 'Set topic title']);
      }
      _gaq.push(['_trackEvent', 'Topic creation', 'Create topic', 'By wizard', participants.length]);
      doCreate = function() {
        _this._waveProcessor.createWaveByWizard(title, participants, function(err, waveId) {
          return _this._processCreateWaveResponse(err, waveId, doCreate);
        });
        return _this._waveModule.showTopicCreatingWait();
      };
      doCreate();
      return this.hide();
    };

    TopicCreatingMaster.prototype._dontShowWizard = function(e) {
      if ($(e.currentTarget).is(':checked')) {
        $.cookie(this.hide_wizard_cookie_name, true, {
          path: '/topic/',
          expires: 700
        });
        this._newTopicBtn.children().remove();
        this._newTopicBtn.addClass('hide-wizard');
        this._newTopicBtn.css('left', "" + (this._createButtonsContainer[0].getBoundingClientRect().left + 38) + "px");
        _gaq.push(['_trackEvent', 'Wizard usage', 'Not show wizard click', 'Not show wizard']);
      } else {
        $.cookie(this.hide_wizard_cookie_name, true, {
          path: '/topic/',
          expires: -1
        });
        this._newTopicBtn.append('<div>New</div>');
        this._newTopicBtn.removeClass('hide-wizard');
        this._newTopicBtn.css('left', "" + (this._createButtonsContainer[0].getBoundingClientRect().left) + "px");
        _gaq.push(['_trackEvent', 'Wizard usage', 'Not show wizard click', 'Show wizard']);
      }
      this._renderCreateButtons();
      return this._initCreateButtons();
    };

    TopicCreatingMaster.prototype.setPosition = function(_sourceButton) {
      var indent, offset;
      this._sourceButton = _sourceButton;
      offset = $(this._sourceButton).offset();
      if (this._form) {
        this._form.css('top', "" + (offset.top - 8) + "px");
        indent = -20;
        return this._form.css('left', "" + (offset.left + $(this._sourceButton).outerWidth() - indent) + "px");
      }
    };

    TopicCreatingMaster.prototype._windowKeyHandler = function(e) {
      if (e.which !== 27) return;
      return this.hide();
    };

    TopicCreatingMaster.prototype.getContainer = function() {
      return this._form;
    };

    TopicCreatingMaster.prototype.hide = function() {
      this._ctmOverlay.remove();
      this._newTopicBtn.remove();
      this._hideVideoBlock();
      $(window).off('keydown', this._windowKeyHandler);
      $(window).off('resize.wizardHeightRecalculate');
      return this._form.hide();
    };

    TopicCreatingMaster.prototype.show = function() {
      var leftOffset, offset,
        _this = this;
      $(document.body).append(renderDecorate({
        wizardDefault: !$.cookie(this.hide_wizard_cookie_name)
      }));
      this._ctmOverlay = $(document.body).find('.js-ctm-overlay');
      offset = $(this._sourceButton).offset();
      this._newTopicBtn = $(document.body).find('.js-ctm-create-button');
      this._newTopicBtn.css('top', "" + offset.top + "px");
      leftOffset = offset.left;
      if ($.cookie(this.hide_wizard_cookie_name)) leftOffset += 0.5;
      this._newTopicBtn.css('left', "" + leftOffset + "px");
      this._ctmOverlay.click(this.hide);
      this._newTopicBtn.click(this.hide);
      $(window).on('keydown', this._windowKeyHandler);
      $(window).on('resize.wizardHeightRecalculate', function() {
        return _this._setHeight();
      });
      this._setHeight();
      this._form.show();
      return this._titleInput.focus();
    };

    TopicCreatingMaster.prototype.destroy = function() {
      return this._form.remove();
    };

    return TopicCreatingMaster;

  })();

  exports.TopicCreatingMaster = TopicCreatingMaster;

}).call(this);

});

require.define("/lib/client/client/creating_topic_wizard/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ck, commonCreateButtonTmpl, commonFormTmpl, createGDriveWaveButtonTmpl, decorateTmpl, differenceCreateButtonsTmpl, wizardVideoTmpl;

  ck = window.CoffeeKup;

  commonFormTmpl = function() {
    return div('.js-ctm.ctm', function() {
      div(".ctm-left-arrow", function() {
        return div('', '');
      });
      return div('.internal-container', function() {
        div('.wizard-form', function() {
          div('.first-step', function() {
            div('.digit.digit1', '1');
            return div('.ctm-title', function() {
              div('.title', function() {
                text('Enter subject');
                return a('.js-toggle-video.toggle-video', function() {
                  span('.js-toggle-video-text', 'Show video');
                  return img({
                    src: '/s/img/play-icon.png'
                  });
                });
              });
              input('.js-topic-title', {
                type: "text",
                title: "Topic title"
              });
              return div('.clearer', '');
            });
          });
          div('.delimiter.d1', '');
          div('.second-step', function() {
            div('.digit.digit2', '2');
            div('.js-ctm-contact-picker.ctm-add-participant', function() {
              return div('.title', 'Add participants');
            });
            return div('.clearer', '');
          });
          div('.delimiter.d2', '');
          return div('.third-step', function() {
            div('.digit.digit3', '3');
            div('.create-button', function() {
              button(".js-ctm-create-topic.ctm-create-topic", "Create new topic");
              return div(".ctm-dont-show", function() {
                input('.js-ctm-dont-show', {
                  id: "ctm-dont-show",
                  type: "checkbox"
                });
                return label({
                  "for": "ctm-dont-show"
                }, "Don't show wizard");
              });
            });
            return div('.clearer', '');
          });
        });
        return div('.js-wizard-video.wizard-video', '');
      });
    });
  };

  wizardVideoTmpl = function() {
    return iframe({
      id: "js-wizard-videoplayer",
      width: "512",
      height: "384",
      src: "https://www.youtube.com/embed/I7whBwsGzM8?fs=1&hl=en_En&color1=0x2b405b&color2=0x6b8ab6&autoplay=1&autohide=1&wmode=transparent",
      frameborder: "0",
      allowfullscreen: 'true',
      webkitallowfullscreen: 'true',
      mozallowfullscreen: 'true'
    });
  };

  decorateTmpl = function() {
    var hideWizard;
    hideWizard = !this.wizardDefault ? '.hide-wizard' : '';
    div(".js-ctm-create-button.ctm-create-button" + hideWizard, function() {
      if (this.wizardDefault) return div('New');
    });
    return div('.js-ctm-overlay.ctm-overlay', '');
  };

  commonCreateButtonTmpl = function() {
    return button('.js-create-wave-by-wizard.common-create-wave-by-wizard', {
      title: "Create new topic with wizard",
      disabled: !window.loggedIn ? "disabled" : void 0
    }, function() {
      div('New');
      return div('.wizard-icon', '');
    });
  };

  differenceCreateButtonsTmpl = function() {
    button('.js-create-wave.js-common-create-wave.create-wave', {
      title: "Create new topic",
      disabled: !window.loggedIn ? "disabled" : void 0
    }, function() {
      return div('New');
    });
    return button('.js-create-wave-by-wizard.create-wave-by-wizard', {
      title: "Create new topic with wizard",
      disabled: !window.loggedIn ? "disabled" : void 0
    }, function() {
      return div('.wizard-icon', '');
    });
  };

  createGDriveWaveButtonTmpl = function() {
    var params;
    params = {
      title: 'Create new topic',
      href: h(this.url),
      target: '_blank'
    };
    if (!window.loggedIn) params.disabled = 'disabled';
    return a('create-gdrive-wave button', params, function() {
      div('New');
      return div('gdrive-icon16', '');
    });
  };

  exports.renderCommonForm = ck.compile(commonFormTmpl);

  exports.renderDecorate = ck.compile(decorateTmpl);

  exports.renderCommonCreateButton = ck.compile(commonCreateButtonTmpl);

  exports.renderDifferenceCreateButtons = ck.compile(differenceCreateButtonsTmpl);

  exports.renderGDriveCreateButton = ck.compile(createGDriveWaveButtonTmpl);

  exports.renderVideo = ck.compile(wizardVideoTmpl);

}).call(this);

});

require.define("/lib/client/client/contact_picker/index.js",function(require,module,exports,__dirname,__filename,process,global){
/*
Класс для выбора набора участников из списка контактов или вводом e-mail.
*/

(function() {
  var ContactPicker, DEFAULT_PARTICIPANTS_STRING_LENGTH, DomUtils, KeyCodes, MicroEvent, ParticipantPopup, SHOW_CONTACTS_BY_DEFAULT, UserPopup, WaveWarning, compareContactsByNameAndEmail, contactsConstants, getContactSources, isEmail, popup, renderBottomPopup, renderContactList, renderContactPicker, renderContactsSyncButton, renderParticipants, setUserPopupBehaviour, _ref, _ref2, _ref3,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ref = require('./template'), renderContactPicker = _ref.renderContactPicker, renderContactList = _ref.renderContactList, renderParticipants = _ref.renderParticipants;

  _ref2 = require('../user/utils'), compareContactsByNameAndEmail = _ref2.compareContactsByNameAndEmail, getContactSources = _ref2.getContactSources;

  DomUtils = require('../utils/dom');

  KeyCodes = require('../utils/key_codes').KeyCodes;

  WaveWarning = require('../wave/notification/warning').WaveWarning;

  isEmail = require('../utils/string').isEmail;

  contactsConstants = require('../../share/contacts/constants');

  renderContactsSyncButton = require('../wave/participants/add_form').renderContactsSyncButton;

  MicroEvent = require('../utils/microevent');

  popup = require('../popup').popup;

  _ref3 = require('../popup/user_popup'), UserPopup = _ref3.UserPopup, setUserPopupBehaviour = _ref3.setUserPopupBehaviour;

  renderBottomPopup = require('../wave/participants/template').renderBottomPopup;

  DEFAULT_PARTICIPANTS_STRING_LENGTH = 8;

  SHOW_CONTACTS_BY_DEFAULT = 100;

  ({
    compareContacts: function(a, b) {
      return compareContactsByNameAndEmail(a.data, b.data);
    }
  });

  ParticipantPopup = (function(_super) {

    __extends(ParticipantPopup, _super);

    function ParticipantPopup() {
      ParticipantPopup.__super__.constructor.apply(this, arguments);
    }

    ParticipantPopup.prototype._init = function(user, _removeParticipant) {
      this._removeParticipant = _removeParticipant;
      return ParticipantPopup.__super__._init.call(this, user);
    };

    ParticipantPopup.prototype.bottomBlockRender = function() {
      /*
              Рендерим блок с ссылкой на удаление
      */
      var bottomBlock, delLink,
        _this = this;
      bottomBlock = $(this.getContainer()).find('.js-user-popup-menu-remove-block');
      if (this._user.toObject().email !== window.userInfo.email) {
        bottomBlock.append(renderBottomPopup({
          canRemove: true
        }));
      }
      delLink = $(this.getContainer()).find('.js-delete-from-wave');
      return delLink.bind('click', function() {
        _this._removeParticipant(_this._user.toObject().email);
        return popup.hide();
      });
    };

    ParticipantPopup.prototype.destroy = function() {
      ParticipantPopup.__super__.destroy.call(this);
      return delete this._removeParticipant;
    };

    return ParticipantPopup;

  })(UserPopup);

  ContactPicker = (function() {
    var SCROLL_OFFSET;

    SCROLL_OFFSET = -90;

    function ContactPicker(_container, _waveProcessor, _params) {
      var user, _base;
      this._container = _container;
      this._waveProcessor = _waveProcessor;
      this._params = _params;
      this._filterContacts = __bind(this._filterContacts, this);
      this._participantInputKeyupHandler = __bind(this._participantInputKeyupHandler, this);
      this._participantInputKeydownHandler = __bind(this._participantInputKeydownHandler, this);
      this._getUserByEmail = __bind(this._getUserByEmail, this);
      this._removeParticipant = __bind(this._removeParticipant, this);
      this._processAddButtonClick = __bind(this._processAddButtonClick, this);
      this._handleAddParticipant = __bind(this._handleAddParticipant, this);
      this._userContacts = [];
      user = {
        toObject: function() {
          return {
            name: window.userInfo.name,
            email: window.userInfo.email,
            avatar: window.userInfo.avatar,
            initials: window.userInfo.initials
          };
        }
      };
      this._participants = [user];
      if ((_base = this._params).participantsStringLength == null) {
        _base.participantsStringLength = DEFAULT_PARTICIPANTS_STRING_LENGTH;
      }
      this.__createDOM();
      this._notificationsContainer = this._params.notificationContainer;
      this._initSyncButtons();
      this._initContactList();
      this._initParticipantInput();
      this.__renderParticipants('set');
    }

    ContactPicker.prototype.__createDOM = function() {
      var div, _base;
      $(this._container).append(renderContactPicker(this._params));
      if (typeof (_base = $(this._container).find('.js-contact-picker-email')).placeholder === "function") {
        _base.placeholder();
      }
      if (this._params.participantsContainer) {
        return this._$participantsContainer = $(this._params.participantsContainer);
      } else {
        div = document.createElement('div');
        div.className = 'js-contact-picker-participants contact-picker-participants';
        $(this._container).prepend(div);
        this._$participantsContainer = $(this._container).find('.js-contact-picker-participants');
        return this._$participantsContainer.show();
      }
    };

    ContactPicker.prototype._initSyncButtons = function() {
      var _this = this;
      this._$syncContactsContainer = $(this._container).find('.js-contact-picker-sync-contacts');
      this._renderSyncBlock();
      return this._$syncContactsContainer.on('click', 'button', function(e) {
        var source, _base;
        source = $(e.currentTarget).attr('source');
        if (typeof (_base = _this._params).contactsSyncStart === "function") {
          _base.contactsSyncStart(source);
        }
        return _this._waveProcessor.initContactsUpdate(source, e.screenX - 630, e.screenY, function() {
          var _base2;
          _this.updateContacts();
          return typeof (_base2 = _this._params).contactsSyncFinish === "function" ? _base2.contactsSyncFinish(source) : void 0;
        });
      });
    };

    ContactPicker.prototype._renderSyncBlock = function() {
      var contactSources;
      contactSources = getContactSources(this._userContacts);
      return this._$syncContactsContainer.empty().append(this._renderGoogleContactsSyncButton(contactSources)).append('<br/>').append(this._renderFacebookContactsSyncButton(contactSources));
    };

    ContactPicker.prototype._renderGoogleContactsSyncButton = function(contactSources) {
      var params;
      params = {
        source: 'google',
        hasContacts: contactSources.google,
        sourceConstant: contactsConstants.SOURCE_NAME_GOOGLE
      };
      return renderContactsSyncButton(params);
    };

    ContactPicker.prototype._renderFacebookContactsSyncButton = function(contactSources) {
      var params;
      params = {
        source: 'facebook',
        hasContacts: contactSources.facebook,
        sourceConstant: contactsConstants.SOURCE_NAME_FACEBOOK
      };
      return renderContactsSyncButton(params);
    };

    ContactPicker.prototype._initContactList = function() {
      var _this = this;
      this._$contactsContainer = $(this._container).find('.js-contact-picker-contacts');
      this._$contactsContainer.on('mouseover', '.js-contact-picker-contact-item', function(event) {
        _this._$contactsContainer.find('.js-contact-picker-contact-item').removeClass('active');
        return $(event.currentTarget).addClass('active');
      });
      this._$contactsContainer.on('click', '.js-contact-picker-contact-item', this._handleAddParticipant);
      return $(this._container).find('.js-contact-picker-add-participant').click(this._processAddButtonClick);
    };

    ContactPicker.prototype._updateContactList = function() {
      var c, headItem, _i, _len, _ref4;
      this._showedContacts = [];
      _ref4 = this._userContacts;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        c = _ref4[_i];
        if (c.showed) this._showedContacts.push(c);
      }
      this._initContactScroll();
      this._$contactsContainer.html(renderContactList({
        contacts: this._showedContacts.splice(0, SHOW_CONTACTS_BY_DEFAULT)
      }));
      headItem = this._$contactsContainer.find('.js-contact-picker-contact-item')[0];
      if (headItem) {
        $(headItem).addClass('active');
        return this._$contactsContainer.scrollTop(0);
      }
    };

    ContactPicker.prototype._initContactScroll = function() {
      var _this = this;
      this._$contactsContainer.off('scroll.renderContacts');
      return this._$contactsContainer.on('scroll.renderContacts', function() {
        _this._$contactsContainer.append(renderContactList({
          contacts: _this._showedContacts.splice(0, SHOW_CONTACTS_BY_DEFAULT)
        }));
        if (_this._showedContacts.length === 0) {
          return _this._$contactsContainer.off('scroll.renderContacts');
        }
      });
    };

    ContactPicker.prototype._handleAddParticipant = function() {
      /*
              Добавляет участника, если это возможно (введен верный e-mail либо выбран участник из списка).
              Если участник был добавлен, возвращает true.
      */
      var $activeElem, email;
      $activeElem = this._$contactsContainer.find('.active');
      if ($activeElem.length === 1) {
        email = $activeElem.find('.js-email').text().slice(1, -1);
      } else {
        email = this._participantInput.val();
      }
      if (isEmail(email)) {
        this._addParticipant(email);
        return true;
      }
      this.__showWarning('Enter valid e-mail');
      return false;
    };

    ContactPicker.prototype._processAddButtonClick = function() {
      if (this._handleAddParticipant()) {
        this._participantInput.val('');
        return this._filterContacts('');
      }
    };

    ContactPicker.prototype._addParticipant = function(email) {
      var p, user, _i, _len, _ref4;
      email = email.toLowerCase();
      user = this._getUserByEmail(email) || this._getUserStub(email);
      _ref4 = this._participants;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        p = _ref4[_i];
        if (p.toObject().email === user.data.email) return;
      }
      user.toObject = function() {
        return {
          name: user.data.name,
          email: user.data.email,
          avatar: user.data.avatar,
          initials: user.data.initials != null ? user.data.initials : ''
        };
      };
      this._participants.push(user);
      $(this._notificationsContainer).find('.js-wave-warning').remove();
      this.__renderParticipants('add');
      return this.emit('add-participant', email);
    };

    ContactPicker.prototype._removeParticipant = function(email) {
      var p, _i, _len, _ref4;
      _ref4 = this._participants;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        p = _ref4[_i];
        if (p.toObject().email === email) {
          this._participants.splice(this._participants.indexOf(p), 1);
          break;
        }
      }
      this.__renderParticipants('remove');
      return this.emit('remove-participant', email);
    };

    ContactPicker.prototype._getUserByEmail = function(email) {
      var c, _i, _len, _ref4;
      _ref4 = this._userContacts;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        c = _ref4[_i];
        if (c.data.email.toLowerCase() === email) return c;
      }
      return null;
    };

    ContactPicker.prototype._getUserStub = function(email) {
      return {
        searchString: email,
        data: {
          name: email,
          email: email,
          avatar: '/s/img/user/unknown.png'
        }
      };
    };

    ContactPicker.prototype.__renderParticipants = function(action) {
      /*
              Обновляет список участников
              @param action: string, действие, после которого происходит обновление
      */
      var p, params,
        _this = this;
      params = {
        participants: (function() {
          var _i, _len, _ref4, _results;
          _ref4 = this._participants;
          _results = [];
          for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
            p = _ref4[_i];
            _results.push(p.toObject());
          }
          return _results;
        }).call(this),
        participantsStringLength: this._params.participantsStringLength
      };
      this._$participantsContainer.html(renderParticipants(params));
      return $(this._$participantsContainer).find('.js-contact-picker-participant').each(function(index, element) {
        return setUserPopupBehaviour(element, ParticipantPopup, _this._participants[index], _this._removeParticipant);
      });
    };

    ContactPicker.prototype._initParticipantInput = function() {
      var _this = this;
      this._participantInput = $(this._container).find('.js-contact-picker-email');
      this._participantInput.on('keydown', this._participantInputKeydownHandler);
      this._participantInput.on('keyup', this._participantInputKeyupHandler);
      return this._participantInput.on('paste', function() {
        return _this._filterContacts(_this._participantInput.val().toLowerCase());
      });
    };

    ContactPicker.prototype._participantInputKeydownHandler = function(event) {
      if (event.ctrlKey || event.altKey) return;
      switch (event.keyCode) {
        case KeyCodes.KEY_UP:
          return this._focusPrev();
        case KeyCodes.KEY_DOWN:
          return this._focusNext();
        case KeyCodes.KEY_ENTER:
          return this._processAddButtonClick();
      }
    };

    ContactPicker.prototype._participantInputKeyupHandler = function(event) {
      var _ref4;
      if (event.ctrlKey || event.altKey || ((_ref4 = event.keyCode) === KeyCodes.KEY_UP || _ref4 === KeyCodes.KEY_DOWN)) {
        return;
      }
      return this._filterContacts(this._participantInput.val().toLowerCase());
    };

    ContactPicker.prototype._focusNext = function() {
      var $nextAfterSelectedItem, $selectedItem;
      $selectedItem = this._$contactsContainer.find('.js-contact-picker-contact-item.active');
      $nextAfterSelectedItem = $selectedItem.next('.js-contact-picker-contact-item');
      if ($nextAfterSelectedItem.length > 0) {
        $selectedItem.removeClass('active');
        $nextAfterSelectedItem.addClass('active');
        return DomUtils.scrollTargetIntoView($nextAfterSelectedItem[0], this._$contactsContainer[0], true, SCROLL_OFFSET);
      }
    };

    ContactPicker.prototype._focusPrev = function() {
      var $prevBeforeSelectedItem, $selectedItem;
      $selectedItem = this._$contactsContainer.find('.js-contact-picker-contact-item.active');
      $prevBeforeSelectedItem = $selectedItem.prev('.js-contact-picker-contact-item');
      if ($prevBeforeSelectedItem.length > 0) {
        $selectedItem.removeClass('active');
        $prevBeforeSelectedItem.addClass('active');
        return DomUtils.scrollTargetIntoView($prevBeforeSelectedItem[0], this._$contactsContainer[0], true, SCROLL_OFFSET);
      }
    };

    ContactPicker.prototype._filterContacts = function(currentString) {
      var user, _i, _len, _ref4;
      if (!this._userContacts.length) return;
      _ref4 = this._userContacts;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        user = _ref4[_i];
        if (user.searchString.search(currentString) === -1) {
          user.showed = false;
        } else {
          user.showed = true;
        }
      }
      return this._updateContactList();
    };

    ContactPicker.prototype.updateContacts = function() {
      var _this = this;
      return this._waveProcessor.getUserContacts(function(err, users) {
        var user;
        if (err || !users) return console.warn('Failed to load contacts', err);
        _this._userContacts = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = users.length; _i < _len; _i++) {
            user = users[_i];
            _results.push({
              searchString: user.getSearchString(),
              data: user.getDataForAutocomplete(),
              showed: true
            });
          }
          return _results;
        })();
        _this._renderSyncBlock();
        if (_this._userContacts.length > 0) _this._$contactsContainer.show();
        _this._userContacts.sort(_this._compareContacts);
        return _this._updateContactList();
      });
    };

    ContactPicker.prototype.__showWarning = function(message) {
      var warnings;
      warnings = $(this._notificationsContainer).find('.js-wave-warning');
      if (warnings.length >= 5) $(warnings[0]).remove();
      $(this._notificationsContainer).append((new WaveWarning(message)).getContainer());
      $(window).trigger('resize');
      return console.warn(message);
    };

    ContactPicker.prototype.setContactsHeight = function(height) {
      return this._$contactsContainer.height(height);
    };

    ContactPicker.prototype.getParticipants = function() {
      return this._participants;
    };

    ContactPicker.prototype.setParticipants = function(participants) {
      this._participants = participants;
      return this.__renderParticipants('set');
    };

    ContactPicker.prototype.getEmails = function() {
      var p, _i, _len, _ref4, _results;
      _ref4 = this._participants;
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        p = _ref4[_i];
        _results.push(p.toObject().email);
      }
      return _results;
    };

    return ContactPicker;

  })();

  MicroEvent.mixin(ContactPicker);

  module.exports = {
    ContactPicker: ContactPicker
  };

}).call(this);

});

require.define("/lib/client/client/contact_picker/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ck, contactListTmpl, participantsTmpl, template;

  ck = window.CoffeeKup;

  template = function() {
    return div(function() {
      input('.js-contact-picker-email.contact-picker-email', {
        type: "text",
        placeholder: "Enter email"
      });
      button('.js-contact-picker-add-participant.button.contact-picker-add-participant-button', "Add");
      div('.js-contact-picker-contacts.contact-picker-contacts', function() {
        if (this.syncContactsInContactsContainer) {
          return div('.js-contact-picker-sync-contacts.contact-picker-sync-contacts', '');
        } else {
          return div('.contact-list-empty-message', function() {
            return div(function() {
              text('Here you can pick your contacts');
              br('');
              return text('from Gmail or Facebook');
            });
          });
        }
      });
      if (!this.syncContactsInContactsContainer) {
        return div('.js-contact-picker-sync-contacts.contact-picker-sync-contacts', '');
      }
    });
  };

  participantsTmpl = function() {
    var i, numOfLines, _results;
    numOfLines = Math.ceil(this.participants.length / this.participantsStringLength);
    _results = [];
    for (i = 0; 0 <= numOfLines ? i < numOfLines : i > numOfLines; 0 <= numOfLines ? i++ : i--) {
      _results.push(div('.participants-line', function() {
        var end, index, nextStart, slotsLeft, start, _results2;
        start = i * this.participantsStringLength;
        nextStart = (i + 1) * this.participantsStringLength;
        end = Math.min(nextStart, this.participants.length);
        for (index = start; start <= end ? index < end : index > end; start <= end ? index++ : index--) {
          div('.js-contact-picker-participant.contact-picker-participant.avatar.clickable', {
            style: "background-image: url(" + (h(this.participants[index].avatar)) + ")"
          }, h(this.participants[index].initials));
        }
        if (i > 0) return;
        slotsLeft = Math.max(nextStart - end, 0);
        _results2 = [];
        for (index = 0; 0 <= slotsLeft ? index < slotsLeft : index > slotsLeft; 0 <= slotsLeft ? index++ : index--) {
          _results2.push(div('.contact-picker-participant', ''));
        }
        return _results2;
      }));
    }
    return _results;
  };

  contactListTmpl = function() {
    var i, _results;
    i = 0;
    _results = [];
    while (i < this.contacts.length) {
      if ((this.contacts[i] != null) && this.contacts[i].showed) {
        div('.js-contact-picker-contact-item.contact-picker-contact-item', {
          title: "" + (h(this.contacts[i].data.name)) + " " + (h(this.contacts[i].data.email))
        }, function() {
          div('.contact-picker-contact-info', function() {
            div('.name', h(this.contacts[i].data.name));
            return div('.js-email', "&#60;" + (h(this.contacts[i].data.email)) + "&#62;");
          });
          return div('.contact-picker-contact.avatar', {
            style: "background-image: url(" + (h(this.contacts[i].data.avatar)) + ")"
          }, h(this.contacts[i].data.initials));
        });
      }
      _results.push(i += 1);
    }
    return _results;
  };

  module.exports = {
    renderContactPicker: ck.compile(template),
    renderParticipants: ck.compile(participantsTmpl),
    renderContactList: ck.compile(contactListTmpl)
  };

}).call(this);

});

require.define("/lib/client/client/chrome_app_popup/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ChromeAppPopup, renderChromeAppPopup, social,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = Array.prototype.slice;

  renderChromeAppPopup = require('./template').renderChromeAppPopup;

  social = require('../utils/social');

  ChromeAppPopup = (function() {

    function ChromeAppPopup() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._close = __bind(this._close, this);
      this._windowKeyHandler = __bind(this._windowKeyHandler, this);
      this._init.apply(this, args);
    }

    ChromeAppPopup.prototype._init = function() {
      var prevAI, _subscribe;
      social.addFacebookScript();
      $(document.body).append(renderChromeAppPopup());
      this._$popup = $('.js-chrome-app-popup');
      this._setPosition();
      this._initCloseEvents();
      _subscribe = function() {
        return FB.Event.subscribe('edge.create', function(targetUrl) {
          _gaq.push(['_trackSocial', 'facebook', 'Like', targetUrl, 'Chrome app popup']);
          return _gaq.push(['_trackEvent', 'Social', 'Like', 'Chrome app popup']);
        });
      };
      if (typeof FB !== "undefined" && FB !== null) {
        return _subscribe();
      } else {
        if (window.fbAsyncInit) {
          prevAI = window.fbAsyncInit;
          return window.fbAsyncInit = function() {
            prevAI();
            return _subscribe();
          };
        } else {
          return window.fbAsyncInit = function() {
            return _subscribe();
          };
        }
      }
    };

    ChromeAppPopup.prototype._setPosition = function() {
      var left, popupWidth;
      popupWidth = this._$popup.width();
      left = (document.body.offsetWidth - popupWidth) / 2;
      return this._$popup.css('left', left + 'px');
    };

    ChromeAppPopup.prototype._initCloseEvents = function() {
      this._$overlay = $('.js-cap-overlay');
      this._$closeControl = $('.js-cap-close');
      this._$overlay.on('click', this._close);
      this._$closeControl.on('click', this._close);
      return $(window).on('keydown', this._windowKeyHandler);
    };

    ChromeAppPopup.prototype._windowKeyHandler = function(e) {
      if (e.which !== 27) return;
      return this._close();
    };

    ChromeAppPopup.prototype._close = function() {
      $(window).off('keydown', this._windowKeyHandler);
      this._$popup.remove();
      return this._$overlay.remove();
    };

    return ChromeAppPopup;

  })();

  exports.ChromeAppPopup = ChromeAppPopup;

}).call(this);

});

require.define("/lib/client/client/chrome_app_popup/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var chromeAppPopupTmpl, ck;

  ck = window.CoffeeKup;

  chromeAppPopupTmpl = function() {
    div('.js-cap-overlay.cap-overlay', '');
    return div('.js-chrome-app-popup.chrome-app-popup', function() {
      text('<script>(function(d, s, id) {\n    if (window.navigator.userAgent.search("Chrome") == -1 && window.navigator.userAgent.search("Mobile") != -1) return;\n    var js, fjs = d.getElementsByTagName(s)[0];\n    if (d.getElementById(id)) return;\n    js = d.createElement(s); js.id = id;\n    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=267439770022011";\n    fjs.parentNode.insertBefore(js, fjs);\n}(document, "script", "facebook-jssdk"));</script>');
      return div('.internal-container', function() {
        div('.js-cap-close.cap-close', {
          title: 'Close'
        }, '');
        div('.cap-title', 'Enjoy Rizzoma App on Chrome Web Store!');
        div('.cap-title', function() {
          text('Stay tuned for news and updates');
          return text('<fb:like href="http://facebook.com/rizzomacom" send="false" layout="button_count" width="450" show_faces="true" font="arial" style="margin-left: 10px;"></fb:like>');
        });
        a('.cap-link', {
          href: "https://chrome.google.com/webstore/detail/rizzoma-activity-stream/fnbgbbhkjiefjkpibiddeieeppnkjdgp?hl=en&gl=RU&from=enjoyrizzoma",
          target: '_blank'
        }, function() {
          return div('.cap-panel', function() {
            div('.logo', '');
            return div('.cap-link-info', function() {
              div('.title', 'Install Rizzoma app');
              return div('.via-web-store', function() {
                div('.cap-logo', '');
                return div('.cap-text', 'via Chrome Web Store');
              });
            });
          });
        });
        div('.cap-title', 'We support:');
        return div('.support-services', function() {
          div('.gmail', {
            title: "Email integration: @mentions and tasks in your inbox, reply by email"
          }, function() {
            return div('.logo', '');
          });
          div('.hangout', {
            title: "Discuss Rizzoma topic in Google+ Hangout. Select &quot;Start G+ Hangout&quot; from topic's Gear menu (right top corner)"
          }, function() {
            return a({
              href: 'https://plus.google.com/100419497458726670190/posts/X1hexck7UD1',
              target: '_blank'
            }, function() {
              return div('.logo', '');
            });
          });
          div('.gcal', {
            title: "Sync your Tasks with Google Calendar. Click for instructions"
          }, function() {
            return a({
              href: 'https://rizzoma.com/topic/c5e7d7138002d01e99467275792c61cb/',
              target: '_blank'
            }, function() {
              return div('.logo', '');
            });
          });
          return div('.gdrive', {
            title: "Google Drive integration (planned)"
          }, function() {
            div('.logo', '');
            return div('.date', 'Planned');
          });
        });
      });
    });
  };

  exports.renderChromeAppPopup = ck.compile(chromeAppPopupTmpl);

}).call(this);

});

require.define("/lib/client/client/linkedin_popup/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BONUS_TYPE_LINKEDIN_LIKE, LinkedinPopup, LocalStorage, Request, ck, linkedinPopupTmpl, renderLinkedinPopup;

  ck = window.CoffeeKup;

  BONUS_TYPE_LINKEDIN_LIKE = require('../../share/constants').BONUS_TYPE_LINKEDIN_LIKE;

  Request = require('../../share/communication').Request;

  LocalStorage = require('../utils/localStorage').LocalStorage;

  linkedinPopupTmpl = function() {
    div('.js-linkedin-popup-overlay.linkedin-popup-overlay', '');
    return div('.js-linkedin-popup-container.linkedin-popup-container', function() {
      return div('.js-linkedin-popup.linkedin-popup', function() {
        div('.js-close.close', '');
        return div('.content', function() {
          div('.title', 'Good news everyone!');
          div('.good-news', function() {
            text('Share us on Linkedin and get ');
            span('.bonus-color', '1Gb free');
            return text('.');
          });
          div('Rizzoma is a safe way to communicate');
          ul(function() {
            li('Secure Sockets Layer (SSL) crypto protocol');
            return li('Secure Amazon cloud hosting');
          });
          div(function() {
            a({
              href: '/about-security.html?from=linkedin_popup',
              target: '_blank'
            }, 'Click here');
            return text(' to learn more');
          });
          return div('.linkedin-share-button', function() {
            return script({
              type: "IN/Share",
              "data-counter": "top",
              "data-onsuccess": "onSuccessShare",
              "data-url": "http://rizzoma.com/"
            });
          });
        });
      });
    });
  };

  renderLinkedinPopup = ck.compile(linkedinPopupTmpl);

  LinkedinPopup = (function() {

    function LinkedinPopup() {
      var _this = this;
      $(document.body).append(renderLinkedinPopup());
      this._overlay = $('.js-linkedin-popup-overlay');
      this._container = $('.js-linkedin-popup');
      this._closeCtrl = this._container.find('.js-close');
      window.onSuccessShare = this._onSuccessShare;
      _gaq.push(['_trackEvent', 'LinkedIn popup', 'Open linkedin popup']);
      LocalStorage.setLinkedinPopupShowed();
      this._closeCtrl.on('click', function() {
        _this._overlay.remove();
        _this._container.remove();
        return delete window.onSuccessShare;
      });
    }

    LinkedinPopup.prototype._onSuccessShare = function() {
      var request,
        _this = this;
      _gaq.push(['_trackEvent', 'LinkedIn popup', 'Share on linkedin', 'linkedin popup']);
      request = new Request({
        bonusType: BONUS_TYPE_LINKEDIN_LIKE
      }, function(err) {
        return console.error(err);
        return _gaq.push(['_trackEvent', 'LinkedIn popup', 'Shared']);
      });
      return require('../modules/root_router').instance.handle('network.user.giveBonus', request);
    };

    return LinkedinPopup;

  })();

  exports.LinkedinPopup = LinkedinPopup;

}).call(this);

});

require.define("/lib/client/client/account_setup_wizard/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var AccountSetupWizard, AccountTypeSelect, BUSINESS_PANEL_TYPE, CreateTeam, ENTERPRISE_PANEL_TYPE, EnterpriseRequest, FREE_PANEL_TYPE, MicroEvent, renderAccountSetupWizard, _ref, _ref2,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  renderAccountSetupWizard = require('./template').renderAccountSetupWizard;

  AccountTypeSelect = require('./account_type_select').AccountTypeSelect;

  _ref = require('./create_team'), CreateTeam = _ref.CreateTeam, BUSINESS_PANEL_TYPE = _ref.BUSINESS_PANEL_TYPE, FREE_PANEL_TYPE = _ref.FREE_PANEL_TYPE;

  _ref2 = require('./enterprise_request'), EnterpriseRequest = _ref2.EnterpriseRequest, ENTERPRISE_PANEL_TYPE = _ref2.ENTERPRISE_PANEL_TYPE;

  MicroEvent = require('../utils/microevent');

  AccountSetupWizard = (function() {

    function AccountSetupWizard() {
      this._returnToAccountSelect = __bind(this._returnToAccountSelect, this);
      this._submitEnterpriseRequest = __bind(this._submitEnterpriseRequest, this);
      this._getOrCreateTeamAccountPanel = __bind(this._getOrCreateTeamAccountPanel, this);      this._accountSetupProcessor = require('./processor').instance;
      this._topicId = window.welcomeWaves.length > 0 ? window.welcomeWaves[0].waveId : null;
      this._createDom();
    }

    AccountSetupWizard.prototype._createDom = function() {
      var _this = this;
      $(document.body).append(renderAccountSetupWizard());
      this._$container = $('.js-account-setup-wizard-content');
      this._accountTypeSelect = new AccountTypeSelect(this._$container);
      this._panels = {};
      this._accountTypeSelect.on('freeAccountClick', function() {
        _gaq.push(['_trackEvent', 'Monetization', 'Select plan', 'Free']);
        _this._accountSetupProcessor.setAccountTypeSelected(function() {});
        if (_this._topicId && window.welcomeTopicJustCreated) {
          return _this._getOrCreateTeamAccountPanel(FREE_PANEL_TYPE).renderAndInit();
        } else {
          return _this.emit('closeAndOpenTopic');
        }
      });
      this._accountTypeSelect.on('businessAccountClick', function() {
        _gaq.push(['_trackEvent', 'Monetization', 'Select plan', 'Business']);
        _this._accountSetupProcessor.setAccountTypeSelected(function() {});
        return _this._getOrCreateTeamAccountPanel(BUSINESS_PANEL_TYPE).renderAndInit();
      });
      this._accountTypeSelect.on('enterpriseAccountClick', function() {
        _gaq.push(['_trackEvent', 'Monetization', 'Select plan', 'Enterprise']);
        _this._accountSetupProcessor.setAccountTypeSelected(function() {});
        return _this._getOrCreateTeamAccountPanel(ENTERPRISE_PANEL_TYPE).renderAndInit();
      });
      return _gaq.push(['_trackEvent', 'Monetization', 'Show plans']);
    };

    AccountSetupWizard.prototype._getOrCreateTeamAccountPanel = function(teamType) {
      if (!(teamType === BUSINESS_PANEL_TYPE || teamType === FREE_PANEL_TYPE || teamType === ENTERPRISE_PANEL_TYPE)) {
        return;
      }
      if (this._panels[teamType] != null) return this._panels[teamType];
      if (teamType === BUSINESS_PANEL_TYPE || teamType === FREE_PANEL_TYPE) {
        this._panels[teamType] = new CreateTeam(this._$container, teamType, this, this._topicId);
      }
      if (teamType === ENTERPRISE_PANEL_TYPE) {
        this._panels[teamType] = new EnterpriseRequest(this._$container);
        this._panels[teamType].on('submit', this._submitEnterpriseRequest);
      }
      this._panels[teamType].on('returnToAccountSelect', this._returnToAccountSelect);
      return this._panels[teamType];
    };

    AccountSetupWizard.prototype._submitEnterpriseRequest = function(companyName, email, comment) {
      var _this = this;
      return this._accountSetupProcessor.sendEnterpriseRequest(companyName, email, comment, function(err) {
        if (err) console.error(err);
        return _this._returnToAccountSelect(true);
      });
    };

    AccountSetupWizard.prototype._returnToAccountSelect = function(fromEnterprise) {
      this._$container.empty();
      return this._accountTypeSelect.renderAndInit(fromEnterprise);
    };

    AccountSetupWizard.prototype.destroy = function() {
      var panel, _, _ref3;
      _ref3 = this._panels;
      for (_ in _ref3) {
        panel = _ref3[_];
        if (panel != null) panel.destroy();
      }
      return $('.js-account-setup-wizard').remove();
    };

    return AccountSetupWizard;

  })();

  MicroEvent.mixin(AccountSetupWizard);

  exports.AccountSetupWizard = AccountSetupWizard;

}).call(this);

});

require.define("/lib/client/client/account_setup_wizard/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var accountSetupWizardTmpl, accountTypeSelectTmpl, businessCreateTeamTmpl, ck, createTeamTmpl, editTeamTmpl, enterpriseRequestTmpl, teamMemberTmpl;

  ck = window.CoffeeKup;

  accountSetupWizardTmpl = function() {
    return div('.js-account-setup-wizard.account-setup-wizard', function() {
      div('.steps-container', function() {
        div('.account-setup-wizard-header', function() {
          div('.logo', '');
          return div('.text', 'Basic settings');
        });
        return div('.js-account-setup-wizard-content.account-setup-wizard-content', function() {});
      });
      return div('.account-setup-wizard-footer', function() {
        return div('.footer-container', function() {
          a({
            target: '_blank',
            'href': '/about-terms.html'
          }, 'Terms of use');
          return a({
            target: '_blank',
            'href': '/about-privacy.html'
          }, 'Privacy policy');
        });
      });
    });
  };

  accountTypeSelectTmpl = function() {
    if (this.fromEnterprise) {
      div('.from-enterprice', function() {
        text("Thanks for submitting your request. We will contact you shortly.");
        br('', '');
        return text("Meanwhile, you can continue using Rizzoma with either Free or Business account.");
      });
    }
    ul('.setup-steps', function() {
      li('.active', function() {
        div('');
        return 'Account type';
      });
      return li('.disabled', function() {
        div('');
        return 'Team setup';
      });
    });
    return div('.content-block', function() {
      div('.account-type', function() {
        div('.top-description', function() {
          div('.header', function() {
            h2('Non-commercial');
            return h3('Personal, education');
          });
          ul(function() {
            li('50 MB upload space');
            return li('Regular support');
          });
          return div('.plan-note', function() {
            text('For commercial use or');
            br('', '');
            text('use at your place of business choose ');
            b('Business');
            return text(' plan');
          });
        });
        return div('.bottom-description', function() {
          div('.price', 'Free');
          return button('.js-free-button.button', 'Start using');
        });
      });
      div('.account-type', function() {
        div('.top-description', function() {
          div('.recommended', '');
          div('.header', function() {
            h2('Business');
            return h3('Small companies');
          });
          return ul(function() {
            li('10 GB upload space');
            li('Team topic collection');
            li('Team management');
            li('Tasks');
            return li('Personal support');
          });
        });
        return div('.bottom-description', function() {
          div('.price', '$5 user/month');
          return button('.js-business-button.button', 'Start 30-day Trial');
        });
      });
      return div('.account-type', function() {
        div('.top-description', function() {
          div('.header', function() {
            h2('Enterprise');
            return h3('Custom solution');
          });
          return ul(function() {
            li('On-premises version');
            return li('System integration');
          });
        });
        return div('.bottom-description', function() {
          div('.price', '$20 user/month');
          return button('.js-enterprise-button.button', 'Request');
        });
      });
    });
  };

  createTeamTmpl = function() {
    ul('.setup-steps', function() {
      li('.js-account-type-item.completed', function() {
        div('');
        text('Account type');
        br('');
        if (this.isBusinessTeamType) {
          return span('Business');
        } else {
          return span('Free');
        }
      });
      return li('.active', function() {
        div('');
        return 'Team setup';
      });
    });
    return div(".content-block." + (this.isBusinessTeamType ? 'business' : ''), function() {
      div('.company-block', function() {
        if (this.isBusinessTeamType) {
          div('.js-error-text.error-text', 'required field');
          input('.js-team-name', {
            type: 'text',
            placeholder: 'Team name (required)'
          });
        }
        return div('.js-team-members.team-members', function() {
          return div('.team-member', function() {});
        });
      });
      div('.js-account-wizard-contact-picker-container.contact-picker-block', '');
      return div('.js-submit-button.centered-button-block', function() {
        return button('.centered-button.button', this.isBusinessTeamType ? 'Continue' : 'Next');
      });
    });
  };

  editTeamTmpl = function() {
    return div(".content-block.business", function() {
      div('.company-block', function() {
        div('.js-error-text.error-text', 'required field');
        input('.js-team-name', {
          type: 'text',
          placeholder: 'Team name',
          disabled: 'disabled'
        });
        return div('.js-team-members.team-members', function() {
          return div('.team-member', function() {});
        });
      });
      return div('.js-account-wizard-contact-picker-container.contact-picker-block', '');
    });
  };

  businessCreateTeamTmpl = function() {
    return div(".content-block.business", function() {
      div('.company-block', function() {
        div('.js-error-text.error-text', 'required field');
        input('.js-team-name', {
          type: 'text',
          placeholder: 'Team name (required)'
        });
        return div('.js-team-members.team-members', function() {
          return div('.team-member', function() {});
        });
      });
      div('.js-account-wizard-contact-picker-container.contact-picker-block', '');
      return div('.js-submit-button.centered-button-block', function() {
        return button('.centered-button.button', 'Create');
      });
    });
  };

  enterpriseRequestTmpl = function() {
    ul('.setup-steps', function() {
      li('.js-account-type-item.completed', function() {
        div('');
        text('Account type');
        br('');
        return span('Enterprise');
      });
      return li('.active', function() {
        div('');
        return 'Request';
      });
    });
    return div('.content-block.enterprise', function() {
      div('.form-field', function() {
        input('.js-company-name', {
          type: 'text',
          placeholder: 'Company name',
          value: this.params.companyName ? this.params.companyName : ''
        });
        return span('required field');
      });
      div('.form-field', function() {
        input('.js-contact-email', {
          type: 'text',
          placeholder: 'Contact email',
          value: this.params.contactEmail ? this.params.contactEmail : ''
        });
        return span('required field');
      });
      textarea('.js-comment', {
        placeholder: 'Comment'
      }, this.params.comment ? this.params.comment : '');
      return div('.centered-button-block', function() {
        return button('.js-submit-form.centered-button.button', 'Submit form');
      });
    });
  };

  teamMemberTmpl = function() {
    return div('.team-member', function() {
      div('.avatar', {
        style: "background-image: url(" + (h(this.p.avatar)) + ")"
      }, h(this.p.initials));
      div('.info', function() {
        div('.name', {
          title: h(this.p.name)
        }, h(this.p.name));
        return div('.js-email.email', {
          title: h(this.p.email)
        }, h(this.p.email));
      });
      if (window.userInfo.email !== this.p.email) {
        return div('.js-remove-item.remove-item', '');
      }
    });
  };

  exports.renderAccountSetupWizard = ck.compile(accountSetupWizardTmpl);

  exports.renderAccountTypeSelect = ck.compile(accountTypeSelectTmpl);

  exports.renderCreateTeam = ck.compile(createTeamTmpl);

  exports.renderEditTeam = ck.compile(editTeamTmpl);

  exports.renderBusinessCreateTeam = ck.compile(businessCreateTeamTmpl);

  exports.renderTeamMember = ck.compile(teamMemberTmpl);

  exports.renderEnterpriseRequest = ck.compile(enterpriseRequestTmpl);

}).call(this);

});

require.define("/lib/client/client/account_setup_wizard/account_type_select.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var AccountTypeSelect, MicroEvent, renderAccountTypeSelect;

  renderAccountTypeSelect = require('./template').renderAccountTypeSelect;

  MicroEvent = require('../utils/microevent');

  AccountTypeSelect = (function() {

    function AccountTypeSelect(_$container) {
      this._$container = _$container;
      this.renderAndInit();
    }

    AccountTypeSelect.prototype._init = function() {
      var _this = this;
      this._$container.find('.js-business-button').on('click', function() {
        return _this.emit('businessAccountClick');
      });
      this._$container.find('.js-enterprise-button').on('click', function() {
        return _this.emit('enterpriseAccountClick');
      });
      return this._$container.find('.js-free-button').on('click', function() {
        return _this.emit('freeAccountClick');
      });
    };

    AccountTypeSelect.prototype.renderAndInit = function(fromEnterprise) {
      this._$container.append(renderAccountTypeSelect({
        fromEnterprise: fromEnterprise
      }));
      return this._init();
    };

    return AccountTypeSelect;

  })();

  MicroEvent.mixin(AccountTypeSelect);

  exports.AccountTypeSelect = AccountTypeSelect;

}).call(this);

});

require.define("/lib/client/client/account_setup_wizard/create_team.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var AccountSetupContactPicker, BUSINESS_PANEL_TYPE, BusinessCreateTeam, ContactPicker, CreateTeam, EditTeam, FREE_PANEL_TYPE, MicroEvent, ROLE_EDITOR, User, renderBusinessCreateTeam, renderCreateTeam, renderEditTeam, renderTeamMember, _ref,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  _ref = require('./template'), renderCreateTeam = _ref.renderCreateTeam, renderTeamMember = _ref.renderTeamMember, renderEditTeam = _ref.renderEditTeam, renderBusinessCreateTeam = _ref.renderBusinessCreateTeam;

  ContactPicker = require('../contact_picker').ContactPicker;

  ROLE_EDITOR = require('../wave/participants/constants').ROLE_EDITOR;

  MicroEvent = require('../utils/microevent');

  User = require('../user/models').User;

  BUSINESS_PANEL_TYPE = 'BUSINESS';

  FREE_PANEL_TYPE = 'FREE';

  CreateTeam = (function() {

    function CreateTeam(_$container, _teamType, _accountSetupWizard, _topicId) {
      this._$container = _$container;
      this._teamType = _teamType;
      this._accountSetupWizard = _accountSetupWizard;
      this._topicId = _topicId;
      this._waveProcessor = require('../wave/processor').instance;
      this._accountSetupProcessor = require('./processor').instance;
      this._participants = [];
    }

    CreateTeam.prototype.renderAndInit = function() {
      var _base,
        _this = this;
      this._$container.empty();
      if (this._contactPicker) {
        this._participants = this._contactPicker.getParticipants();
      }
      this._$container.append(renderCreateTeam({
        isBusinessTeamType: this._teamType === BUSINESS_PANEL_TYPE
      }));
      if (typeof (_base = this._$container.find('input')).placeholder === "function") {
        _base.placeholder();
      }
      window.setTimeout(function() {
        return _this._$container.find('.js-team-name').focus();
      }, 0);
      this._submitButton = this._$container.find('.js-submit-button button');
      return this._init();
    };

    CreateTeam.prototype._init = function() {
      var _this = this;
      this._initContactPicker();
      this._$container.find('.js-account-type-item').on('click', function() {
        _gaq.push(['_trackEvent', 'Monetization', 'Return to plan selection']);
        return _this.emit('returnToAccountSelect');
      });
      return this._submitButton.on('click', function() {
        var $errText, email, emails, newEmails, processor, teamName, waveProcessor, wizard;
        _this._$container.find('.js-error-text').hide();
        emails = _this._contactPicker.getEmails();
        _gaq.push(['_trackEvent', 'Monetization', 'Create team', _this._teamType, emails.length - 1]);
        if (_this._teamType === BUSINESS_PANEL_TYPE) {
          teamName = _this._$container.find('.js-team-name').val();
          if (teamName.length === 0) {
            $errText = _this._$container.find('.js-error-text');
            $errText.show();
            $errText.animate({
              opacity: 1
            }, 500, function() {
              return $errText.animate({
                opacity: 0.4
              }, 500);
            });
            return;
          }
          _this._submitButton.off();
          _this._submitButton.text('Creating...');
          processor = _this._accountSetupProcessor;
          wizard = _this._accountSetupWizard;
          waveProcessor = _this._waveProcessor;
          return processor.createTeamByWizard(emails, teamName, function(err, response) {
            var email, otherEmails;
            if (err) console.error(err);
            wizard.emit('closeAndOpenTopic', response.waveId);
            processor.forceIsBusinessUpdate();
            otherEmails = (function() {
              var _i, _len, _ref2, _results;
              _results = [];
              for (_i = 0, _len = emails.length; _i < _len; _i++) {
                email = emails[_i];
                if (email !== ((_ref2 = window.userInfo) != null ? _ref2.email : void 0)) {
                  _results.push(email);
                }
              }
              return _results;
            })();
            if (window.welcomeTopicJustCreated && otherEmails.length) {
              return waveProcessor.addParticipants(_this._topicId, otherEmails, ROLE_EDITOR, true, function() {});
            }
          });
        } else if (_this._teamType === FREE_PANEL_TYPE) {
          newEmails = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = emails.length; _i < _len; _i++) {
              email = emails[_i];
              if (email !== window.userInfo.email) _results.push(email);
            }
            return _results;
          })();
          _this._waveProcessor.addParticipants(_this._topicId, newEmails, ROLE_EDITOR, false, function(err, userDatas) {
            var countExisting, countNew, user, userData, userType, _i, _len;
            if (!userDatas) return;
            countNew = countExisting = 0;
            for (_i = 0, _len = userDatas.length; _i < _len; _i++) {
              userData = userDatas[_i];
              user = new User(null, userData.email, userData.name, userData.avatar);
              if (user.isNewUser()) {
                countNew++;
              } else {
                countExisting++;
              }
            }
            if (countNew > 0) {
              _gaq.push(['_trackEvent', 'Topic participants', 'Add participant new', 'By invite tool', countNew]);
            }
            if (countExisting > 0) {
              _gaq.push(['_trackEvent', 'Topic participants', 'Add participant existing', 'By invite tool', countExisting]);
            }
            _gaq.push(['_trackEvent', 'Invite tool', 'Invite Next click', '', countNew + countExisting]);
            if (countNew * countExisting > 0) {
              userType = 'new and existing';
            } else if (countNew > 0) {
              userType = 'new';
            } else {
              userType = 'existing';
            }
            if (countNew + countExisting > 0) {
              return mixpanel.track("Add participant", {
                "participant type": userType,
                "added via": 'By invite tool',
                "count": countNew + countExisting,
                "count new": countNew,
                "count existing": countExisting
              });
            }
          });
          return _this._accountSetupWizard.emit('closeAndOpenTopic', _this._topicId);
        }
      });
    };

    CreateTeam.prototype._initContactPicker = function() {
      var contactPickerContainer, params;
      contactPickerContainer = this._$container.find('.js-account-wizard-contact-picker-container')[0];
      params = {
        participantsStringLength: 1,
        contactsSyncStart: function(source) {
          return _gaq.push(['_trackEvent', 'Contacts synchronization', 'Synchronize contacts click', "invite tool " + source]);
        },
        contactsSyncFinish: function(source) {
          return _gaq.push(['_trackEvent', 'Contacts synchronization', 'Successfull synchronization', "invite tool " + source]);
        },
        notificationContainer: this._$container.find('.js-invite-tool-notifications'),
        participantsContainer: this._$container.find('.js-team-members')[0]
      };
      this._contactPicker = new AccountSetupContactPicker(contactPickerContainer, this._waveProcessor, params);
      this._contactPicker.updateContacts();
      if (this._participants.length > 0) {
        return this._contactPicker.setParticipants(this._participants);
      }
    };

    CreateTeam.prototype.destroy = function() {
      this._$container.empty();
      delete this._$container;
      delete this._contactPicker;
      delete this._participants;
      delete this._teamType;
      delete this._waveProcessor;
      delete this._accountSetupWizard;
      return delete this._accountSetupProcessor;
    };

    return CreateTeam;

  })();

  BusinessCreateTeam = (function() {

    function BusinessCreateTeam(_$container) {
      this._$container = _$container;
      this._waveProcessor = require('../wave/processor').instance;
    }

    BusinessCreateTeam.prototype.renderAndInit = function() {
      var _base;
      this._$container.empty();
      this._$container.append(renderBusinessCreateTeam());
      if (typeof (_base = this._$container.find('input')).placeholder === "function") {
        _base.placeholder();
      }
      this._submitButton = this._$container.find('.js-submit-button button');
      return this._init();
    };

    BusinessCreateTeam.prototype._init = function() {
      var _this = this;
      this._initContactPicker();
      window.setTimeout(function() {
        return _this._$container.find('.js-team-name').focus();
      }, 0);
      return this._submitButton.on('click', function() {
        var $errText, emails, teamName;
        _this._$container.find('.js-error-text').hide();
        emails = _this._contactPicker.getEmails();
        teamName = _this._$container.find('.js-team-name').val();
        if (teamName.length === 0) {
          $errText = _this._$container.find('.js-error-text');
          $errText.show();
          $errText.animate({
            opacity: 1
          }, 500, function() {
            return $errText.animate({
              opacity: 0.4
            }, 500);
          });
          return;
        }
        _this._submitButton.off();
        _this._submitButton.text('Creating...');
        return _this.emit('create-team', emails, teamName);
      });
    };

    BusinessCreateTeam.prototype._initContactPicker = function() {
      var contactPickerContainer, params;
      contactPickerContainer = this._$container.find('.js-account-wizard-contact-picker-container')[0];
      params = {
        participantsStringLength: 1,
        notificationContainer: this._$container.find('.js-invite-tool-notifications'),
        participantsContainer: this._$container.find('.js-team-members')[0]
      };
      this._contactPicker = new AccountSetupContactPicker(contactPickerContainer, this._waveProcessor, params);
      return this._contactPicker.updateContacts();
    };

    BusinessCreateTeam.prototype.destroy = function() {
      this._$container.empty();
      delete this._$container;
      delete this._contactPicker;
      return delete this._waveProcessor;
    };

    return BusinessCreateTeam;

  })();

  MicroEvent.mixin(BusinessCreateTeam);

  EditTeam = (function() {

    function EditTeam(_$container, _topicId, _teamName, _participants) {
      this._$container = _$container;
      this._topicId = _topicId;
      this._teamName = _teamName;
      this._participants = _participants;
      this._waveProcessor = require('../wave/processor').instance;
    }

    EditTeam.prototype.renderAndInit = function() {
      var _base;
      this._$container.empty();
      this._$container.append(renderEditTeam());
      if (typeof (_base = this._$container.find('input')).placeholder === "function") {
        _base.placeholder();
      }
      this._$container.find('.js-team-name').val(this._teamName);
      return this._initContactPicker();
    };

    EditTeam.prototype._initContactPicker = function() {
      var contactPickerContainer, params,
        _this = this;
      contactPickerContainer = this._$container.find('.js-account-wizard-contact-picker-container')[0];
      params = {
        participantsStringLength: 1,
        notificationContainer: this._$container.find('.js-invite-tool-notifications'),
        participantsContainer: this._$container.find('.js-team-members')[0]
      };
      this._contactPicker = new AccountSetupContactPicker(contactPickerContainer, this._waveProcessor, params);
      this._contactPicker.updateContacts();
      this._contactPicker.setParticipants(this._participants);
      this._contactPicker.on('add-participant', function(email) {
        return _this.emit('add-participant', email);
      });
      return this._contactPicker.on('remove-participant', function(email) {
        return _this.emit('remove-participant', email);
      });
    };

    EditTeam.prototype.destroy = function() {
      this._$container.empty();
      delete this._$container;
      delete this._contactPicker;
      delete this._participants;
      return delete this._waveProcessor;
    };

    return EditTeam;

  })();

  MicroEvent.mixin(EditTeam);

  AccountSetupContactPicker = (function(_super) {

    __extends(AccountSetupContactPicker, _super);

    function AccountSetupContactPicker() {
      AccountSetupContactPicker.__super__.constructor.apply(this, arguments);
    }

    AccountSetupContactPicker.prototype.__createDOM = function() {
      AccountSetupContactPicker.__super__.__createDOM.call(this);
      this._$emailError = $('<span class="error-text">Invalid email</span>');
      this._$emailError.hide();
      return $(this._container).find('.js-contact-picker-email').before(this._$emailError);
    };

    AccountSetupContactPicker.prototype.__renderParticipants = function(action) {
      /*
              Обновляет список участников
              @param action: string, действие, после которого происходит обновление
      */
      var p, res, _i, _len, _ref2,
        _this = this;
      res = '';
      _ref2 = this._participants;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        p = _ref2[_i];
        res += renderTeamMember({
          p: p.toObject()
        });
      }
      this._$participantsContainer.html(res);
      if (action === 'add') this._$participantsContainer.scrollTop(1000000);
      return $(this._$participantsContainer).find('.js-remove-item').on('click', function(e) {
        return _this._removeParticipant($(e.target).parent().find('.js-email').text());
      });
    };

    AccountSetupContactPicker.prototype.__showWarning = function() {
      /*
              Сообщение может быть только о том, что e-mail неверен
      */
      var _this = this;
      this._$emailError.css('display', 'block');
      return this._$emailError.animate({
        opacity: 1
      }, 500, function() {
        return _this._$emailError.animate({
          opacity: 0.4
        }, 500);
      });
    };

    return AccountSetupContactPicker;

  })(ContactPicker);

  MicroEvent.mixin(CreateTeam);

  module.exports = {
    CreateTeam: CreateTeam,
    EditTeam: EditTeam,
    BusinessCreateTeam: BusinessCreateTeam,
    BUSINESS_PANEL_TYPE: BUSINESS_PANEL_TYPE,
    FREE_PANEL_TYPE: FREE_PANEL_TYPE
  };

}).call(this);

});

require.define("/lib/client/client/account_setup_wizard/enterprise_request.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ENTERPRISE_PANEL_TYPE, EnterpriseRequest, MicroEvent, isEmail, renderEnterpriseRequest,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  renderEnterpriseRequest = require('./template').renderEnterpriseRequest;

  MicroEvent = require('../utils/microevent');

  isEmail = require('../../share/utils/string').isEmail;

  ENTERPRISE_PANEL_TYPE = 'ENTERPRISE';

  EnterpriseRequest = (function() {

    function EnterpriseRequest(_$container) {
      this._$container = _$container;
      this._validateAndSubmitForm = __bind(this._validateAndSubmitForm, this);
      this._params = {};
    }

    EnterpriseRequest.prototype._init = function() {
      var _this = this;
      this._$container.find('.js-account-type-item').on('click', function() {
        _this._saveState();
        return _this.emit('returnToAccountSelect');
      });
      this._$container.find('.js-submit-form').on('click', this._validateAndSubmitForm);
      this._$container.on('keydown', 'input', function(e) {
        if (e.keyCode !== 13) return;
        return _this._validateAndSubmitForm();
      });
      this._$companyNameField = this._$container.find('.js-company-name');
      window.setTimeout(function() {
        return _this._$companyNameField.focus();
      }, 0);
      this._$contactEmailField = this._$container.find('.js-contact-email');
      return this._$commentField = this._$container.find('.js-comment');
    };

    EnterpriseRequest.prototype._animateField = function($field) {
      return $field.animate({
        opacity: 1
      }, 500, function() {
        return $field.animate({
          opacity: 0.4
        }, 500);
      });
    };

    EnterpriseRequest.prototype._validateAndSubmitForm = function() {
      this._$companyNameField.parent().removeClass('error');
      this._$contactEmailField.parent().removeClass('error');
      this._$companyNameField.data('error', null);
      this._$contactEmailField.data('error', null);
      if (this._$companyNameField.val().length === 0) {
        this._$companyNameField.parent().addClass('error');
        this._$companyNameField.data('error', true);
        this._animateField(this._$companyNameField.parent().find('span'));
      }
      if (this._$contactEmailField.val().length === 0) {
        this._$contactEmailField.parent().addClass('error');
        this._$contactEmailField.data('error', true);
        this._animateField(this._$contactEmailField.parent().find('span'));
      }
      if (!this._$contactEmailField.data('error') && !isEmail(this._$contactEmailField.val())) {
        this._$contactEmailField.parent().find('span').text('Invalid email');
        this._$contactEmailField.data('error', true);
        this._$contactEmailField.parent().addClass('error');
        this._animateField(this._$contactEmailField.parent().find('span'));
      }
      if (this._$contactEmailField.data('error') || this._$companyNameField.data('error')) {
        return;
      }
      _gaq.push(['_trackEvent', 'Monetization', 'Submit enterprise request']);
      return this.emit('submit', this._$companyNameField.val(), this._$contactEmailField.val(), this._$commentField.val());
    };

    EnterpriseRequest.prototype.renderAndInit = function() {
      var _base;
      this._$container.empty();
      this._$container.append(renderEnterpriseRequest({
        params: this._params
      }));
      if (typeof (_base = this._$container.find('input, textarea')).placeholder === "function") {
        _base.placeholder();
      }
      return this._init();
    };

    EnterpriseRequest.prototype._saveState = function() {
      return this._params = {
        companyName: this._$companyNameField.val(),
        contactEmail: this._$contactEmailField.val(),
        comment: this._$commentField.val()
      };
    };

    EnterpriseRequest.prototype.destroy = function() {
      this._$container.empty();
      delete this._$container;
      return delete this._params;
    };

    return EnterpriseRequest;

  })();

  MicroEvent.mixin(EnterpriseRequest);

  module.exports = {
    EnterpriseRequest: EnterpriseRequest,
    ENTERPRISE_PANEL_TYPE: ENTERPRISE_PANEL_TYPE
  };

}).call(this);

});

require.define("/lib/client/client/active_topic_controls/module.js",function(require,module,exports,__dirname,__filename,process,global){
/*
Модуль отвечает за работу кнопок активного топика: следующий прочитанный, прочитать все, свернуть/развернуть все,
кнопки для вставки mention'ов, блипов, гаджетов и т.п.
Следит за текущим положением курсора, обновляет состояние меню в соотетствии с курсором, выбранное действие
применяет к тому топику, в котором стоит курсор. Если курсор не находится в топике, применяет действие к топику из
WaveModule.
Для работы опрашивает модули, у которых может находится топик, следит за изменением топиков в этих модулях через
событие wave-change.
Первый запрос топика делается методов getCurrentWave.
*/

(function() {
  var ActiveTopicControls, BaseModule, BrowserSupport, DEFAULT_TOPIC_NAME, DomUtils, History, InsertGadgetPopup, TOPIC_MODULES, preventElementsMousedown,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  BaseModule = require('../../share/base_module').BaseModule;

  InsertGadgetPopup = require('../wave/insert_gadget_popup').InsertGadgetPopup;

  History = require('../utils/history_navigation');

  BrowserSupport = require('../utils/browser_support');

  DomUtils = require('../utils/dom');

  TOPIC_MODULES = [
    {
      name: 'collection',
      path: '../collection/module'
    }, {
      name: 'topic',
      path: '../modules/wave'
    }
  ];

  DEFAULT_TOPIC_NAME = 'topic';

  preventElementsMousedown = function($elements) {
    var _this = this;
    return $elements.mousedown(function(e) {
      return e.preventDefault();
    });
  };

  ActiveTopicControls = (function(_super) {

    __extends(ActiveTopicControls, _super);

    function ActiveTopicControls() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._deactivateInsertMenu = __bind(this._deactivateInsertMenu, this);
      this._updateUnreadButtonsState = __bind(this._updateUnreadButtonsState, this);
      this._goToNextUnreadBlip = __bind(this._goToNextUnreadBlip, this);
      ActiveTopicControls.__super__.constructor.apply(this, args);
      this._waveProcessor = require('../wave/processor').instance;
      this._initRightToolsPanel();
      this._initTopics();
      $(document).click(this._updateUnreadButtonsState);
    }

    ActiveTopicControls.prototype._initTopics = function() {
      var module, name, path, _i, _len, _ref, _results,
        _this = this;
      this._topicInfo = {};
      _results = [];
      for (_i = 0, _len = TOPIC_MODULES.length; _i < _len; _i++) {
        _ref = TOPIC_MODULES[_i], name = _ref.name, path = _ref.path;
        module = require(path).instance;
        if (!module) continue;
        this._topicInfo[name] = {
          topic: null,
          unreadCount: 0
        };
        if (module.getCurrentWave() != null) {
          this._updateTopic(name, module.getCurrentWave());
        }
        _results.push(module.on('wave-change', (function(name) {
          return function(topic) {
            return _this._updateTopic(name, topic);
          };
        })(name)));
      }
      return _results;
    };

    ActiveTopicControls.prototype._updateTopic = function(name, topic) {
      var _this = this;
      this._topicInfo[name].topic = topic;
      this._topicInfo[name].unreadCount = topic != null ? topic.getUnreadBlipsCount() : void 0;
      this._updateUnreadButtonsState();
      if (!(this._getActiveTopicInfo().topic != null)) {
        this._deactivateInsertMenu();
      }
      if (!BrowserSupport.isSupported()) return;
      return topic != null ? topic.on('unread-blips-count', function(count) {
        _this._topicInfo[name].unreadCount = count;
        return _this._updateUnreadButtonsState();
      }) : void 0;
    };

    ActiveTopicControls.prototype._getActiveTopicInfo = function() {
      var name, topicInfo, _ref, _ref2;
      _ref = this._topicInfo;
      for (name in _ref) {
        topicInfo = _ref[name];
        if ((_ref2 = topicInfo.topic) != null ? _ref2.getView().hasCursor() : void 0) {
          return topicInfo;
        }
      }
      return this._topicInfo[DEFAULT_TOPIC_NAME];
    };

    ActiveTopicControls.prototype._initRightToolsPanel = function() {
      this._$rightToolsPanel = $('.js-right-tools-panel');
      this._initFoldButtons();
      this._initNextUnreadButton();
      this._initGadgetPopup();
      if (History.isEmbedded()) return this._initInsertMenu();
    };

    ActiveTopicControls.prototype._initFoldButtons = function() {
      var _this = this;
      preventElementsMousedown(this._$rightToolsPanel.find('.js-hide-replies, .js-show-replies'));
      this._$rightToolsPanel.find('.js-hide-replies').click(function() {
        var activeWave;
        activeWave = _this._getActiveTopicInfo().topic;
        if (!(activeWave != null)) return;
        activeWave.getView().foldAll().topic;
        return _gaq.push(['_trackEvent', 'Blip usage', 'Hide replies', 'Root menu']);
      });
      return this._$rightToolsPanel.find('.js-show-replies').click(function() {
        var activeWave;
        activeWave = _this._getActiveTopicInfo().topic;
        if (!(activeWave != null)) return;
        activeWave.getView().unfoldAll();
        return _gaq.push(['_trackEvent', 'Blip usage', 'Show replies', 'Root menu']);
      });
    };

    ActiveTopicControls.prototype._initNextUnreadButton = function() {
      this._$nextUnreadBlipButton = this._$rightToolsPanel.find('.js-next-unread-blip');
      this._$nextUnreadBlipButton.addClass('disabled');
      preventElementsMousedown(this._$nextUnreadBlipButton);
      return $(this._$nextUnreadBlipButton).click(this._goToNextUnreadBlip);
    };

    ActiveTopicControls.prototype._goToNextUnreadBlip = function() {
      var _ref;
      return (_ref = this._getActiveTopicInfo().topic) != null ? _ref.goToNextUnreadBlip() : void 0;
    };

    ActiveTopicControls.prototype._updateUnreadButtonsState = function(e) {
      var $globalNextUnread, count, handleMouseDown;
      count = this._getActiveTopicInfo().unreadCount;
      if (!count) {
        this._$nextUnreadBlipButton.addClass('disabled');
        if (History.isEmbedded()) return;
        if (!e || e.type !== 'click' || !(e.target === this._$nextUnreadBlipButton[0] || DomUtils.contains(this._$nextUnreadBlipButton[0], e.target))) {
          return;
        }
        $globalNextUnread = $('#global-next-unread');
        if ($globalNextUnread.hasClass('disabled')) return;
        $globalNextUnread.css('display', 'inline-block');
        handleMouseDown = function(e) {
          if (e.target === $globalNextUnread[0]) return;
          $(document).off('mousedown', handleMouseDown);
          return $globalNextUnread.css('display', 'none');
        };
        return $(document).on('mousedown', handleMouseDown);
      } else if (this._$nextUnreadBlipButton.hasClass('disabled')) {
        return this._$nextUnreadBlipButton.removeClass('disabled');
      }
    };

    ActiveTopicControls.prototype._initGadgetPopup = function() {
      var $insertGadgetButton, $insertGadgetContainer, _ref;
      $insertGadgetContainer = this._$rightToolsPanel.find('.js-insert-gadget-container');
      $insertGadgetButton = this._$rightToolsPanel.find('.js-insert-gadget');
      return (_ref = $insertGadgetButton[0]) != null ? _ref.insertGadgetPopup = new InsertGadgetPopup($insertGadgetContainer, $insertGadgetButton) : void 0;
    };

    ActiveTopicControls.prototype._initInsertMenu = function() {
      var _this = this;
      this._$insertMenuButton = this._$rightToolsPanel.find('.js-insert');
      preventElementsMousedown(this._$insertMenuButton);
      return this._$insertMenuButton.click(function(e) {
        var $group;
        $group = _this._$rightToolsPanel.find('.js-active-blip-controls-group');
        if ($group.hasClass('active')) {
          return _this._deactivateInsertMenu();
        } else {
          return _this._activateInsertMenu();
        }
      });
    };

    ActiveTopicControls.prototype._activateInsertMenu = function() {
      window.addEventListener('mousedown', this._deactivateInsertMenu, true);
      return this._$rightToolsPanel.find('.js-active-blip-controls-group').addClass('active');
    };

    ActiveTopicControls.prototype._deactivateInsertMenu = function(e) {
      if (e && (this._$insertMenuButton[0] === e.target || $.contains(this._$insertMenuButton[0], e.target))) {
        return;
      }
      window.removeEventListener('mousedown', this._deactivateInsertMenu, true);
      return this._$rightToolsPanel.find('.js-active-blip-controls-group').removeClass('active');
    };

    return ActiveTopicControls;

  })(BaseModule);

  module.exports = {
    ActiveTopicControls: ActiveTopicControls
  };

}).call(this);

});

require.define("/lib/client/client/wave/insert_gadget_popup.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var InsertGadgetPopup, ck, renderGadgetPopup, renderGadgetStub, renderInsertGadget;

  renderGadgetPopup = require('../popup/template').renderGadgetPopup;

  ck = window.CoffeeKup;

  renderInsertGadget = ck.compile(function() {
    var classString, style;
    if (this.gadget.cssClass != null) {
      classString = this.gadget.cssClass;
      style = '';
    } else {
      classString = "js-" + (h(this.gadget.id)) + "." + (h(this.gadget.id));
      style = "background: url(" + (h(this.gadget.icon)) + ") 0 0 no-repeat;";
    }
    return button(".js-gadget-button.gadget-icon." + classString, {
      gadgetUrl: h(this.gadget.url),
      title: h(this.gadget.title),
      trackId: h(this.gadget.title),
      style: style
    });
  });

  renderGadgetStub = ck.compile(function() {
    return button(".js-gadget-stub.gadget-stub", 'Add gadget');
  });

  InsertGadgetPopup = (function() {
    var GADGETS_IN_ROW;

    GADGETS_IN_ROW = 8;

    function InsertGadgetPopup(_$container, _$button) {
      var $gadgetStub,
        _this = this;
      this._$container = _$container;
      this._$button = _$button;
      $(this._$container).append(renderGadgetPopup());
      this._$popup = this._$container.find('.js-gadget-popup-menu-container');
      this._$popup.on('mousedown', function(e) {
        e.stopPropagation();
        return e.preventDefault();
      });
      this._$internalContainer = this._$container.find('.js-internal-container > *');
      this._$internalContainer.addClass('internal-container');
      this._$internalContainer.append(renderGadgetStub());
      this._gadgetsIndex = 1;
      this._$popup.on('click', '.js-gadget-button', function(e) {
        var button, gadgetClass;
        button = $(e.currentTarget);
        _this._activeBlip.insertGadget(button.attr('gadgetUrl'));
        gadgetClass = button.attr('trackid');
        _gaq.push(['_trackEvent', 'Store', 'Insert gadget', gadgetClass]);
        return _this.hide();
      });
      $gadgetStub = this._$popup.find('.js-gadget-stub');
      $gadgetStub.on('click', function(e) {
        _gaq.push(['_trackEvent', 'Store', 'Add gadget click']);
        return require('../navigation').instance.showMarketPanel();
      });
    }

    InsertGadgetPopup.prototype._initGadgets = function() {
      var gadget, installedGadgets, _i, _len, _results;
      if (this._gadgetsInited) return;
      this._gadgetsInited = true;
      installedGadgets = require('../market_panel').instance.getInstalledGadgets();
      _results = [];
      for (_i = 0, _len = installedGadgets.length; _i < _len; _i++) {
        gadget = installedGadgets[_i];
        _results.push(this._addGadget(gadget));
      }
      return _results;
    };

    InsertGadgetPopup.prototype._addGadget = function(gadget) {
      this._$internalContainer.append(renderInsertGadget({
        gadget: gadget
      }));
      this._gadgetsIndex += 1;
      if (this._gadgetsIndex % GADGETS_IN_ROW === 0) {
        return this._$internalContainer.append("<br>");
      }
    };

    InsertGadgetPopup.prototype.getContainer = function() {
      return this._container;
    };

    InsertGadgetPopup.prototype.show = function(_activeBlip) {
      var _this = this;
      this._activeBlip = _activeBlip;
      this._initGadgets();
      window.setTimeout(function() {
        return $(document).on('mousedown.selectGadgetBlock', function(e) {
          if ($(e.target).closest('.js-gadget-popup-menu-container').length !== 0) {
            return;
          }
          return _this.hide();
        });
      }, 0);
      this._$button.addClass('active');
      return this._$popup.show();
    };

    InsertGadgetPopup.prototype.hide = function() {
      $(document).off('mousedown.selectGadgetBlock');
      this._$button.removeClass('active');
      return this._$popup.hide();
    };

    InsertGadgetPopup.prototype.addGadget = function(gadget) {
      return this._addGadget(gadget);
    };

    InsertGadgetPopup.prototype.removeGadget = function(gadget) {
      var gadgetSelector;
      if (this._gadgetsIndex % GADGETS_IN_ROW === 0) {
        this._$internalContainer.find("br:last").remove();
      }
      gadgetSelector = ".js-" + gadget.id;
      this._$internalContainer.find(gadgetSelector).remove();
      return this._gadgetsIndex -= 1;
    };

    InsertGadgetPopup.prototype.isVisible = function() {
      return this._$popup.is(':visible');
    };

    InsertGadgetPopup.prototype.destroy = function() {
      this.hide();
      return this._$container.find('.js-gadget-popup-menu-container').remove();
    };

    return InsertGadgetPopup;

  })();

  module.exports = {
    InsertGadgetPopup: InsertGadgetPopup
  };

}).call(this);

});

require.define("/lib/client/client/navigation/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BrowserSupport, HelpMenu, History, MarketPanel, MentionsPanel, MicroEvent, NavigationPanel, PublicTopicsPanel, Resizer, TasksPanel, TipsVideoPopup, TopicsPanel, renderNavigationPanel, renderTipsBox, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  History = require('../utils/history_navigation');

  _ref = require('./template'), renderNavigationPanel = _ref.renderNavigationPanel, renderTipsBox = _ref.renderTipsBox;

  TopicsPanel = require('../search_panel/topic/panel_desktop').TopicsPanel;

  MentionsPanel = require('../search_panel/mention/panel_desktop').MentionsPanel;

  TasksPanel = require('../search_panel/task/panel_desktop').TasksPanel;

  PublicTopicsPanel = require('../search_panel/public_topic/panel_desktop').PublicTopicsPanel;

  MarketPanel = require('../market_panel').MarketPanel;

  TipsVideoPopup = require('../tips_video').TipsVideoPopup;

  BrowserSupport = require('../utils/browser_support');

  Resizer = require('./resizer').Resizer;

  HelpMenu = require('./help_menu').HelpMenu;

  MicroEvent = require('../utils/microevent');

  NavigationPanel = (function() {
    /*
        Навигационная панель, переключающая поиск и список сообщений
    */
    var HIDE_TIPS_COOKIE_NAME;

    HIDE_TIPS_COOKIE_NAME = 'hide_tips_box';

    function NavigationPanel(_container) {
      var accountProcessor, c;
      this._container = _container;
      this._activateCurrentTab = __bind(this._activateCurrentTab, this);
      this._deactivateTabs = __bind(this._deactivateTabs, this);
      this.updateTopicsUnreadCount = __bind(this.updateTopicsUnreadCount, this);
      this.updateBlipIsRead = __bind(this.updateBlipIsRead, this);
      this._onTeamDebtChange = __bind(this._onTeamDebtChange, this);
      this._initTasksPanel = __bind(this._initTasksPanel, this);
      c = $(this._container);
      this._$tabsContainer = $('.js-tabs-container');
      c.append(renderNavigationPanel({
        loggedIn: window.loggedIn
      }));
      this._initTipsBox();
      this._resizer = new Resizer();
      this._resizer.on('activateCurrentTab', this._activateCurrentTab);
      this._resizer.on('deactivateAllTabs', this._deactivateTabs);
      this._topicsPanelContainer = c.find('.js-search-container')[0];
      this._topicsPanel = new TopicsPanel(this._topicsPanelContainer);
      this._tabs = {
        '.js-topics': {
          container: this._topicsPanelContainer,
          panel: this._topicsPanel,
          name: 'topics list'
        }
      };
      this._currentTabClass = '.js-topics';
      if (window.loggedIn) {
        this._mentionsPanelContainer = c.find('.js-message-list-container')[0];
        this._mentionsPanel = new MentionsPanel(this._mentionsPanelContainer);
        this._tabs['.js-mentions'] = {
          container: this._mentionsPanelContainer,
          panel: this._mentionsPanel,
          name: 'mentions list'
        };
        this._publicTopicsPanelContainer = c.find('.js-public-search-container')[0];
        this._publicTopicsPanel = new PublicTopicsPanel(this._publicTopicsPanelContainer);
        this._tabs['.js-publics'] = {
          container: this._publicTopicsPanelContainer,
          panel: this._publicTopicsPanel,
          name: 'publics list'
        };
        this._marketPanelContainer = c.find('.js-market-panel-container')[0];
        require('../market_panel').instance = new MarketPanel(this._marketPanelContainer);
        this._marketPanel = require('../market_panel').instance;
        this._tabs['.js-market'] = {
          container: this._marketPanelContainer,
          panel: this._marketPanel,
          name: 'store list'
        };
        this._$tabsContainer.find('.js-tasks, .js-collection').click(this._showAccountWizard).prop('title', 'Business and Enterprise accounts only. Click for details');
        accountProcessor = require('../account_setup_wizard/processor').instance;
        accountProcessor.on('team-debt-change', this._onTeamDebtChange);
        if (accountProcessor.isBusinessUser()) {
          this._initTasksPanel(true);
        } else {
          accountProcessor.on('is-business-change', this._initTasksPanel);
        }
        this._initEvents();
        this._initHelpMenu();
        if (History.isGDrive()) this._resizer.foldNavPanel();
      }
    }

    NavigationPanel.prototype._showAccountWizard = function() {
      var url;
      if ($(this).hasClass('debt')) {
        url = '/settings/teams-menu/';
      } else {
        url = '/settings/account-menu/';
      }
      return window.open(url, '_blank');
    };

    NavigationPanel.prototype.addCollection = function(container) {
      var tab,
        _this = this;
      tab = this._$tabsContainer.find('.js-collection');
      tab.removeClass('locked');
      tab.off("click", this._showAccountWizard);
      tab.prop('title', '');
      tab.click(function() {
        return _this._showTab('.js-collection');
      });
      $(container).addClass('search').hide();
      $(this._container).find('.js-lists-container').append(container);
      return this._tabs['.js-collection'] = {
        container: container,
        name: 'collection'
      };
    };

    NavigationPanel.prototype.showPlaybackView = function(container) {
      this._deactivateTabs();
      $(this._container).find('.js-lists-container').append(container);
      return this._resizer.setHalfScreenWidth();
    };

    NavigationPanel.prototype.hidePlaybackView = function(containerClass) {
      $(this._container).find('.js-lists-container').find(containerClass).remove();
      return this._resizer.revertToPreviousWidth();
    };

    NavigationPanel.prototype._initTasksPanel = function(isBusiness) {
      var tab,
        _this = this;
      if (!isBusiness) return;
      require('../account_setup_wizard/processor').instance.removeListener('is-business-change', this._initTasksPanel);
      tab = this._$tabsContainer.find('.js-tasks');
      tab.removeClass('locked');
      tab.off("click", this._showAccountWizard);
      tab.prop('title', '');
      tab.click(function() {
        return _this._showTab('.js-tasks');
      });
      this._tasksPanelContainer = $(this._container).find('.js-task-list-container')[0];
      this._tasksPanel = new TasksPanel(this._tasksPanelContainer);
      return this._tabs['.js-tasks'] = {
        container: this._tasksPanelContainer,
        panel: this._tasksPanel,
        name: 'tasks list'
      };
    };

    NavigationPanel.prototype._onTeamDebtChange = function(value) {
      var tasksTab, teamTab;
      teamTab = this._$tabsContainer.find('.js-collection');
      tasksTab = this._$tabsContainer.find('.js-tasks');
      if (value) {
        teamTab.addClass('debt');
        tasksTab.addClass('debt');
        return $('#navigation-panel').addClass('debt');
      } else {
        teamTab.removeClass('debt');
        tasksTab.removeClass('debt');
        return $('#navigation-panel').removeClass('debt');
      }
    };

    NavigationPanel.prototype._initTipsBox = function() {
      var $panelContainer, toggleTips,
        _this = this;
      $panelContainer = $(this._container);
      $panelContainer.append(renderTipsBox({
        isDesktopChrome: BrowserSupport.isDesktopChrome()
      }));
      toggleTips = function() {
        var expires;
        $panelContainer.toggleClass('tips-hidden');
        expires = $panelContainer.hasClass('tips-hidden') ? 200 : -1;
        return $.cookie(HIDE_TIPS_COOKIE_NAME, true, {
          path: '/',
          expires: expires
        });
      };
      $('.js-tips-box .js-tips-toggle').bind('click', toggleTips);
      if ($.cookie(HIDE_TIPS_COOKIE_NAME)) toggleTips();
      return $('.js-tips-box .js-play-pict').on('click', function(e) {
        var source;
        source = e.target.nodeName === 'DIV' ? 'Image' : 'Button';
        _gaq.push(['_trackEvent', 'Tips block', 'Play tips video', source]);
        return new TipsVideoPopup;
      });
    };

    NavigationPanel.prototype._initEvents = function() {
      var searchClass, _results,
        _this = this;
      _results = [];
      for (searchClass in this._tabs) {
        _results.push(this._$tabsContainer.find(searchClass).click((function(searchClass) {
          return function() {
            return _this._showTab(searchClass);
          };
        })(searchClass)));
      }
      return _results;
    };

    NavigationPanel.prototype._initHelpMenu = function() {
      var menu;
      menu = new HelpMenu();
      return menu.render(this._$tabsContainer.find('.js-help')[0]);
    };

    NavigationPanel.prototype.updateBlipIsRead = function(waveId, blipId, isRead) {
      /*
              Обновление непрочитанных сообщений и задач
      */
      var _ref2, _ref3;
      if ((_ref2 = this._mentionsPanel) != null) {
        _ref2.updateMessageIsRead(waveId, blipId, isRead);
      }
      return (_ref3 = this._tasksPanel) != null ? _ref3.updateTaskIsRead(waveId, blipId, isRead) : void 0;
    };

    NavigationPanel.prototype.updateTopicsUnreadCount = function(waveId, unreadCount, totalCount) {
      /*
              Обновление непрочитанных топиков
      */
      var _ref2, _ref3;
      if ((_ref2 = this._topicsPanel) != null) {
        _ref2.updateTopicsUnreadCount(waveId, unreadCount, totalCount);
      }
      return (_ref3 = this._publicTopicsPanel) != null ? _ref3.updateTopicsUnreadCount(waveId, unreadCount, totalCount) : void 0;
    };

    NavigationPanel.prototype._deactivateTabs = function(excludingTabClass) {
      var searchClass, t, tab, _ref2, _ref3, _ref4, _results;
      if (excludingTabClass == null) excludingTabClass = null;
      _ref2 = this._tabs;
      _results = [];
      for (searchClass in _ref2) {
        tab = _ref2[searchClass];
        if (excludingTabClass && searchClass === excludingTabClass) continue;
        t = this._$tabsContainer.find(searchClass);
        if (t.hasClass('active') && !(excludingTabClass != null)) {
          _gaq.push(['_trackEvent', 'Navigation', 'Hide list', tab.name]);
        }
        t.removeClass('active');
        if ((_ref3 = tab.panel) != null) {
          if ((_ref4 = _ref3.getTimer()) != null) _ref4.setTabAsHidden();
        }
        _results.push($(tab.container).hide());
      }
      return _results;
    };

    NavigationPanel.prototype._activateCurrentTab = function() {
      var tab, _ref2, _ref3;
      this._$tabsContainer.find(this._currentTabClass).addClass('active');
      tab = this._tabs[this._currentTabClass];
      $(tab.container).show();
      if ((_ref2 = tab.panel) != null) {
        if ((_ref3 = _ref2.getTimer()) != null) _ref3.setTabAsVisible();
      }
      return this.emit('tab-show', this._currentTabClass);
    };

    NavigationPanel.prototype._showTab = function(targetClass) {
      var searchClass, tab, tabElem, _ref2;
      _ref2 = this._tabs;
      for (searchClass in _ref2) {
        tab = _ref2[searchClass];
        if (searchClass === targetClass) {
          tabElem = this._$tabsContainer.find(searchClass).addClass('active');
          this._currentTabClass = targetClass;
          break;
        }
      }
      if (this._resizer.getLastWidth() > 0) {
        if ($(tab.container).is(':visible')) {
          return this._resizer.foldNavPanel();
        } else {
          _gaq.push(['_trackEvent', 'Navigation', "Switch to " + tab.name]);
          this._activateCurrentTab();
          return this._deactivateTabs(targetClass);
        }
      } else {
        _gaq.push(['_trackEvent', 'Navigation', "Switch to " + tab.name]);
        return this._resizer.unfoldNavPanel();
      }
    };

    NavigationPanel.prototype.showTopicPanel = function() {
      var targetClass, val, _ref2;
      _ref2 = this._tabs;
      for (targetClass in _ref2) {
        val = _ref2[targetClass];
        if (val.panel instanceof TopicsPanel) break;
      }
      if ($(val.container).is(':visible')) return;
      return this._showTab(targetClass);
    };

    NavigationPanel.prototype.showPublicTopicPanel = function() {
      var targetClass, val, _ref2;
      _ref2 = this._tabs;
      for (targetClass in _ref2) {
        val = _ref2[targetClass];
        if (val.panel instanceof PublicTopicsPanel) break;
      }
      if ($(val.container).is(':visible')) return;
      return this._showTab(targetClass);
    };

    NavigationPanel.prototype.showMarketPanel = function() {
      var targetClass, val, _ref2;
      _ref2 = this._tabs;
      for (targetClass in _ref2) {
        val = _ref2[targetClass];
        if (val.panel instanceof MarketPanel) break;
      }
      if ($(val.container).is(':visible')) return;
      return this._showTab(targetClass);
    };

    NavigationPanel.prototype.getTopicsPanel = function() {
      return this._topicsPanel;
    };

    NavigationPanel.prototype.getPublicTopicsPanel = function() {
      return this._publicTopicsPanel;
    };

    NavigationPanel.prototype.getTasksPanel = function() {
      return this._tasksPanel;
    };

    return NavigationPanel;

  })();

  MicroEvent.mixin(NavigationPanel);

  exports.NavigationPanel = NavigationPanel;

  exports.instance = null;

}).call(this);

});

require.define("/lib/client/client/navigation/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ck, navigationPanelTmpl, tipsBoxTmpl;

  ck = window.CoffeeKup;

  navigationPanelTmpl = function() {
    /*
        Шаблон навигационной панели
    */    div('.js-resizer.resizer', {
      title: "Resize panels"
    }, function() {
      return div('', '');
    });
    return div('.js-lists-container.search-lists-container', function() {
      div('.js-search-container.search', '');
      if (!this.loggedIn) return;
      div('.js-message-list-container.message-list-container.search', '');
      div('.js-task-list-container.task-list-container.search', '');
      div('.js-public-search-container.public-search-container.search', '');
      return div('.js-market-panel-container.market-panel-container.search', '');
    });
  };

  tipsBoxTmpl = function() {
    /*
        Шаблон блока с подсказками
    */    return div(".js-tips-box.tips-box", function() {
      div('.tips-toggle-container', function() {
        div('.js-tips-toggle', function() {
          div('.diag-border', '');
          span('.tips-toggle-text-max', 'Minimize shortcuts');
          span('.tips-toggle-text-min', 'Maximize shortcuts');
          return div('.tips-toggle-status', '');
        });
        return div('.clearer', '');
      });
      div('.tips-delimiter', '');
      div('.clearer', '');
      table('.tips-head-container', {
        cellspacing: 0,
        cellpadding: 0
      }, function() {
        return tr(function() {
          td(function() {
            return a('', {
              href: "/?no_auth_redirect",
              title: "Rizzoma"
            }, function() {
              return img('.rizzoma-logo', {
                src: "/s/img/tips-rizzoma-logo.png"
              });
            });
          });
          return td('.actions', function() {
            if (this.isDesktopChrome) {
              a('', {
                href: "https://chrome.google.com/webstore/detail/rizzoma-research-sidebar/mfhnlfcipodclfgnfekflgapmnmkgnmc",
                title: "Install our Chrome Side Bar",
                target: "_blank"
              }, function() {
                div('.chrome-webstore-ico', '');
                return text('Side Bar');
              });
            } else {
              a('', {
                href: "http://blog.rizzoma.com/",
                title: "Go to our blog",
                target: "_blank"
              }, 'Blog');
              a('', {
                href: "http://blog.rizzoma.com/category/methodology/",
                title: "Go to user cases",
                target: "_blank"
              }, 'User cases');
            }
            return text('<script src="//platform.linkedin.com/in.js" type="text/javascript"></script><script type="IN/FollowCompany" data-id="2619456" data-counter="right"></script>');
          });
        });
      });
      return div('.tips-content', function() {
        if (window.firstVisit) {
          div('.js-tips-video.tips-video', function() {
            div('.js-play-pict.play-pict', '');
            return div('.video-name', function() {
              return div('Watch the video First Steps in Rizzoma');
            });
          });
        } else {
          div('.js-folded-tips-video.folded-tips-video', function() {
            span('.folded-video-name', 'First steps in Rizzoma:');
            return button('.js-play-pict.folded-play-pict.button', 'Play video');
          });
        }
        div(function() {
          div(function() {
            img('', {
              src: "/s/img/tips-reply-ico.png"
            });
            return text('Ctrl+Enter');
          });
          div(function() {
            img('', {
              src: "/s/img/tips-hide-ico.png"
            });
            return text('Ctrl+Shift+&uarr;');
          });
          return div(function() {
            img('', {
              src: "/s/img/tips-@.png"
            });
            return text('Mention');
          });
        });
        return div(function() {
          div(function() {
            img('', {
              src: "/s/img/tips-next-unread-ico.png"
            });
            return text('Ctrl+Space');
          });
          div(function() {
            img('', {
              src: "/s/img/tips-show-ico.png"
            });
            return text('Ctrl+Shift+&darr;');
          });
          return div(function() {
            img('', {
              src: "/s/img/tips-tilda.png"
            });
            return text('Task');
          });
        });
      });
    });
  };

  exports.renderNavigationPanel = ck.compile(navigationPanelTmpl);

  exports.renderTipsBox = ck.compile(tipsBoxTmpl);

}).call(this);

});

require.define("/lib/client/client/search_panel/topic/panel_desktop.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BaseTopicsPanel, BrowserEvents, CHANGE_TOPIC_LIST, DomUtils, History, LocalStorage, MicroEvent, TopicsPanel, formatDate, renderer, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  BaseTopicsPanel = require('../base_topic').BaseTopicsPanel;

  MicroEvent = require('../../utils/microevent');

  formatDate = require('../../../share/utils/datetime').formatDate;

  _ref = require('../../utils/localStorage'), LocalStorage = _ref.LocalStorage, CHANGE_TOPIC_LIST = _ref.CHANGE_TOPIC_LIST;

  DomUtils = require('../../utils/dom');

  History = require('../../utils/history_navigation');

  BrowserEvents = require('../../utils/browser_events');

  renderer = require('./template');

  TopicsPanel = (function(_super) {

    __extends(TopicsPanel, _super);

    function TopicsPanel() {
      this.updateTopicsUnreadCount = __bind(this.updateTopicsUnreadCount, this);
      this.__processAfterResponse = __bind(this.__processAfterResponse, this);
      this.__processSearchStart = __bind(this.__processSearchStart, this);
      this._topicFilterChangeHandler = __bind(this._topicFilterChangeHandler, this);
      this._handleQueryInputEvent = __bind(this._handleQueryInputEvent, this);
      this._handleTagClick = __bind(this._handleTagClick, this);
      this._changeListHandler = __bind(this._changeListHandler, this);
      this.__linkClickHandler = __bind(this.__linkClickHandler, this);
      this._handleSearchMenuMouseDownEvent = __bind(this._handleSearchMenuMouseDownEvent, this);
      TopicsPanel.__super__.constructor.apply(this, arguments);
    }

    /*
        Панель, отвечающая за работу поиска топиков
    */

    TopicsPanel.prototype.__init = function() {
      var $container, $searchMenu, hiddenTabRefreshInterval, lbound, refreshParams, searchButton, searchInput, ubound,
        _this = this;
      this._topicsType = 'FOLLOW';
      this._initTagRegexp();
      $container = $(this.getContainer());
      $container.append(renderer.renderHeader({
        topicTypes: this.__getTopicTypes()
      }));
      this._resultsContainer = $container.find('#js-search-results')[0];
      searchButton = $container.find('#js-run-search')[0];
      searchInput = $('#js-search-query')[0];
      searchInput.addEventListener(BrowserEvents.INPUT_EVENT, this._handleQueryInputEvent, false);
      if (window.openSearchQuery != null) {
        $(searchInput).val(window.openSearchQuery);
      }
      lbound = window.uiConf.search.refreshInterval.hiddenTab.lbound;
      ubound = window.uiConf.search.refreshInterval.hiddenTab.ubound;
      hiddenTabRefreshInterval = Math.floor(Math.random() * (ubound - lbound)) + lbound;
      refreshParams = {
        isVisible: true,
        visibleUpdateInterval: window.uiConf.search.refreshInterval.visible,
        hiddenUpdateInterval: window.uiConf.search.refreshInterval.hidden,
        unvisibleBrowserTabUpdateInterval: hiddenTabRefreshInterval
      };
      $searchMenu = $container.find('.js-search-menu');
      BrowserEvents.addBlocker($searchMenu[0], BrowserEvents.CLICK_EVENT);
      this._topicFilter = $container.find('.js-topic-filter');
      this._topicFilter.on(BrowserEvents.CLICK_EVENT, 'a', this._topicFilterChangeHandler);
      this._followButton = $container.find('.js-follow');
      this._$tagsBlock = $container.find('.js-tags-block');
      this._$tagsBlock.on(BrowserEvents.CLICK_EVENT, 'a', this._handleTagClick);
      $container.find('.js-show-search-menu').click(function() {
        if ($searchMenu.hasClass('hidden')) {
          document.addEventListener(BrowserEvents.MOUSE_DOWN_EVENT, _this._handleSearchMenuMouseDownEvent, true);
          return $searchMenu.removeClass('hidden');
        } else {
          return _this._hideSearchMenu();
        }
      });
      $container.find('.js-clear-search-query').click(function() {
        return _this.__clearSearchInput();
      });
      return TopicsPanel.__super__.__init.call(this, require('./processor').instance, this._resultsContainer, searchInput, searchButton, refreshParams, renderer);
    };

    TopicsPanel.prototype._handleSearchMenuMouseDownEvent = function(e) {
      if (DomUtils.contains($(this.getContainer()).find('.js-search-header')[0], e.target)) {
        return;
      }
      return this._hideSearchMenu();
    };

    TopicsPanel.prototype._hideSearchMenu = function() {
      document.removeEventListener(BrowserEvents.MOUSE_DOWN_EVENT, this._handleSearchMenuMouseDownEvent, true);
      return $(this.getContainer()).find('.js-search-menu').addClass('hidden');
    };

    TopicsPanel.prototype.__linkClickHandler = function(event) {
      _gaq.push(['_trackEvent', 'Navigation', 'Topics list click']);
      return TopicsPanel.__super__.__linkClickHandler.call(this, event);
    };

    TopicsPanel.prototype._changeListHandler = function(lastSearchResults) {
      var _ref2;
      if (!this.__canCacheSearchResults()) return;
      this.__lastSearchResults = lastSearchResults;
      if ((_ref2 = this.getTimer()) != null) _ref2.resetTimeout();
      this.__renderResponse();
      return this.__processAfterResponse();
    };

    TopicsPanel.prototype._initTagRegexp = function() {
      var badCharacters;
      badCharacters = require('../../tag/constants').badCharacters;
      return this._tagRegexp = new RegExp("#[^" + badCharacters + "]");
    };

    TopicsPanel.prototype._highlightTags = function(text) {
      var word, words, _i, _len, _results;
      words = text.split(' ');
      this._$tagsBlock.find('[data-tag]').removeClass('active');
      _results = [];
      for (_i = 0, _len = words.length; _i < _len; _i++) {
        word = words[_i];
        if (word[0] !== '#') continue;
        if (this._lastTags.indexOf(word.substr(1)) === -1) continue;
        _results.push(this._$tagsBlock.find("[data-tag='" + word + "']").addClass('active'));
      }
      return _results;
    };

    TopicsPanel.prototype._handleTagClick = function(e) {
      var $search, $target, _base, _base2;
      $target = $(e.target);
      $search = $('#js-search-query');
      if ($target.hasClass('active')) {
        $search.val(typeof (_base = $search.val().replace(new RegExp("" + ($target.data('tag')) + "(\\s|$)"), '')).trim === "function" ? _base.trim() : void 0);
      } else {
        $search.val(typeof (_base2 = $search.val() + ' ' + $target.data('tag')).trim === "function" ? _base2.trim() : void 0);
        this._hideSearchMenu();
      }
      this._lastSearchDate = null;
      this.__triggerSearch();
      return this.__triggerQueryInputEvent();
    };

    TopicsPanel.prototype._handleQueryInputEvent = function(e) {
      var $searchQuery, text;
      text = e.target.value;
      $searchQuery = $(this.getContainer()).find('.js-clear-search-query');
      this._highlightTags(text);
      if (!text) return $searchQuery.addClass('hidden');
      return $searchQuery.removeClass('hidden');
    };

    TopicsPanel.prototype._topicFilterChangeHandler = function(event) {
      var $container, $searchHeader, $target, $topicFilterLabel, followButtonText, topicTypes;
      $target = $(event.target);
      if ($target.hasClass('active')) return;
      this._topicFilter.find('.active').removeClass('active');
      $target.addClass('active');
      this._topicsType = $target.data('value') || $target.data('text');
      topicTypes = this.__getTopicTypes();
      $container = $(this.getContainer());
      $topicFilterLabel = $container.find('.js-topic-filter-label');
      $searchHeader = $container.find('.js-search-header');
      if (topicTypes[0].value === this._topicsType) {
        $searchHeader.removeClass('show-filter-label');
      } else {
        $searchHeader.addClass('show-filter-label');
        $topicFilterLabel.text($target.data('text'));
      }
      followButtonText = this.__getFollowButtonText();
      if (followButtonText) this._followButton.text(followButtonText);
      this._lastSearchDate = null;
      this.__triggerSearch();
      return this._hideSearchMenu();
    };

    TopicsPanel.prototype._getId = function(waveId) {
      return "topic-" + waveId;
    };

    TopicsPanel.prototype.__processSearchStart = function(scrollIntoView, autoSearch) {
      if (scrollIntoView == null) scrollIntoView = false;
      if (autoSearch == null) autoSearch = false;
      TopicsPanel.__super__.__processSearchStart.call(this, scrollIntoView, autoSearch);
      if (!this.__getLastQueryString().match(this._tagRegexp)) return;
      return _gaq.push(['_trackEvent', 'Tag', 'Tag search']);
    };

    TopicsPanel.prototype.__processAfterResponse = function() {
      this.emit('topicsLoaded');
      if (this._resultsContainer.children.length >= 10 && LocalStorage.getTopicsCount() < 10) {
        mixpanel.track('Over 10 topics', {
          'count': this._resultsContainer.children.length
        });
        LocalStorage.setTopicsCount(this._resultsContainer.children.length);
      }
      return this.__updateUnreadTopicsInTitle();
    };

    TopicsPanel.prototype.__parseResponse = function(response) {
      var topic, topicNum, _len, _ref2, _results;
      TopicsPanel.__super__.__parseResponse.call(this, response);
      if (!(window.welcomeWaves && window.welcomeWaves.length)) return;
      _ref2 = window.welcomeWaves;
      _results = [];
      for (topicNum = 0, _len = _ref2.length; topicNum < _len; topicNum++) {
        topic = _ref2[topicNum];
        if (this.__lastSearchResults[this._getId(topic.waveId)]) continue;
        topic.changeDate = Math.round(topic.changeDate / 1000);
        _results.push(this.__addItem(this.__parseResponseItem(topic), this._getId(topic.waveId), topicNum));
      }
      return _results;
    };

    TopicsPanel.prototype.__getAdditionalParams = function() {
      return {
        ptagNames: this._topicsType
      };
    };

    TopicsPanel.prototype.__getSearchFunction = function() {
      return 'network.wave.searchBlipContent';
    };

    TopicsPanel.prototype.__getPanelName = function() {
      return 'topics';
    };

    TopicsPanel.prototype.__canCacheSearchResults = function() {
      return this._lastQueryString === '' && this._topicsType === 'FOLLOW';
    };

    TopicsPanel.prototype.__updateUnreadTopicsInTitle = function() {
      window.title.unreadTopicsCount = $(this._resultsContainer).find('.unread').length;
      return History.setPageTitle();
    };

    TopicsPanel.prototype.findNextUnreadTopic = function() {
      var activeItemIndex, i, topicList;
      topicList = $(this._resultsContainer).find('.js-search-result');
      if (topicList.length === 0) return;
      activeItemIndex = $(this._resultsContainer).find('.active').index();
      if (activeItemIndex === -1) {
        if ($(topicList[0]).find('.js-unread-blips-indicator div').height() > 0) {
          return topicList[0];
        }
        activeItemIndex = 0;
      }
      i = activeItemIndex + 1;
      while (true) {
        if (i === activeItemIndex) return;
        if ($(topicList[i]).find('.js-unread-blips-indicator div').height() > 0) {
          return topicList[i];
        }
        if (i >= topicList.length - 1) {
          i = 0;
        } else {
          i += 1;
        }
      }
    };

    TopicsPanel.prototype.updateTopicsUnreadCount = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      TopicsPanel.__super__.updateTopicsUnreadCount.apply(this, args);
      return this.emit('unreadCountUpdate');
    };

    TopicsPanel.prototype.updateTagList = function(tags) {
      var $container;
      if (!tags.length) return;
      this._lastTags = tags;
      $container = this._$tagsBlock.empty();
      $container.append(renderer.renderTagList({
        tags: tags.sort()
      }));
      return this.__triggerQueryInputEvent();
    };

    return TopicsPanel;

  })(BaseTopicsPanel);

  MicroEvent.mixin(TopicsPanel);

  exports.TopicsPanel = TopicsPanel;

}).call(this);

});

require.define("/lib/client/client/search_panel/base_topic.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BaseSearchPanel, BaseTopicsPanel, formatDate, getUserInitials, renderer,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BaseSearchPanel = require('./base').BaseSearchPanel;

  formatDate = require('../../share/utils/datetime').formatDate;

  renderer = require('./template');

  getUserInitials = require('../../share/user/utils').getUserInitials;

  BaseTopicsPanel = (function(_super) {
    var SHOW_FOLLOW_BUTTON_TIMEOUT, TOPIC_TYPES;

    __extends(BaseTopicsPanel, _super);

    function BaseTopicsPanel() {
      this.updateTopicsUnreadCount = __bind(this.updateTopicsUnreadCount, this);
      this.__linkClickHandler = __bind(this.__linkClickHandler, this);
      this.__getTopicUnreadIndicatorLen = __bind(this.__getTopicUnreadIndicatorLen, this);
      this.__followButtonClickHandler = __bind(this.__followButtonClickHandler, this);
      this.__mouseleaveSearchListItem = __bind(this.__mouseleaveSearchListItem, this);
      this.__mouseenterSearchListItem = __bind(this.__mouseenterSearchListItem, this);
      BaseTopicsPanel.__super__.constructor.apply(this, arguments);
    }

    /*
        Базовый класс для панелей поиска топиков
    */

    TOPIC_TYPES = [
      {
        value: 'FOLLOW',
        text: 'Followed',
        buttonText: 'Follow'
      }, {
        value: 'UNFOLLOW',
        text: 'Unfollowed',
        buttonText: 'Unfollow'
      }, {
        value: null,
        text: 'All topics'
      }
    ];

    BaseTopicsPanel.prototype._getTopicTypes = function() {
      return TOPIC_TYPES;
    };

    SHOW_FOLLOW_BUTTON_TIMEOUT = 500;

    BaseTopicsPanel.prototype.__init = function(_processor, _resultsContainer, _searchInput, _searchButton, refreshParams, renderer) {
      this._processor = _processor;
      this._resultsContainer = _resultsContainer;
      this._searchInput = _searchInput;
      this._searchButton = _searchButton;
      $(this.getContainer()).on('click', '.js-follow', this.__followButtonClickHandler);
      $(this._resultsContainer).on('mouseenter', '.js-search-result:not(.active) .js-text-content', this.__mouseenterSearchListItem);
      $(this._resultsContainer).on('mouseleave', '.js-search-result', this.__mouseleaveSearchListItem);
      return BaseTopicsPanel.__super__.__init.call(this, this._processor, this._resultsContainer, this._searchInput, this._searchButton, refreshParams, renderer);
    };

    BaseTopicsPanel.prototype.__mouseenterSearchListItem = function(event) {
      var _this = this;
      return this._showFollowButtonTimeout = setTimeout(function() {
        return $(event.currentTarget).parent('.js-search-result').addClass('show-follow-button');
      }, SHOW_FOLLOW_BUTTON_TIMEOUT);
    };

    BaseTopicsPanel.prototype.__mouseleaveSearchListItem = function(event) {
      if (this._showFollowButtonTimeout != null) {
        clearTimeout(this._showFollowButtonTimeout);
        return $(event.currentTarget).removeClass('show-follow-button');
      }
    };

    BaseTopicsPanel.prototype.__followButtonClickHandler = function(event) {
      var callback, topic, tt, ttIndex, waveId, _i, _len, _ref, _results,
        _this = this;
      event.stopPropagation();
      event.preventDefault();
      topic = $(event.currentTarget).parent().parent();
      waveId = topic.attr('id').split('-')[1];
      _ref = this._getTopicTypes();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tt = _ref[_i];
        if ($(event.currentTarget).text() === tt.buttonText) {
          ttIndex = this._getTopicTypes().indexOf(tt);
          callback = function(error) {
            if (!error) {
              if (_this._getTopicTypes()[2].text === _this._topicsType) {
                return $(event.currentTarget).text(_this._getTopicTypes()[1 - ttIndex].buttonText);
              } else {
                return topic.remove();
              }
            } else {
              return console.error('Error while follow/unfollow: ', error);
            }
          };
          if (ttIndex === 0) this._processor.followTopic(waveId, callback);
          if (ttIndex === 1) this._processor.unfollowTopic(waveId, callback);
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    BaseTopicsPanel.prototype.__getFollowButtonText = function(wave) {
      var followButtonText;
      if (wave == null) wave = null;
      if (wave) {
        if (wave.follow != null) {
          followButtonText = this._getTopicTypes()[1].buttonText;
        } else {
          followButtonText = this._getTopicTypes()[0].buttonText;
        }
        return followButtonText;
      }
      switch (this._topicsType) {
        case this._getTopicTypes()[0].value:
          return this._getTopicTypes()[1].buttonText;
        case this._getTopicTypes()[1].value:
          return this._getTopicTypes()[0].buttonText;
        default:
          return null;
      }
    };

    BaseTopicsPanel.prototype.__getTopicUnreadIndicatorLen = function(unreadCount, totalBlips) {
      var ALL_UNREAD;
      ALL_UNREAD = 100;
      if (unreadCount === 0) return 0;
      if (totalBlips === 1) return ALL_UNREAD;
      unreadCount += 1;
      totalBlips += 1;
      return Math.log(unreadCount) * ALL_UNREAD / Math.log(totalBlips);
    };

    BaseTopicsPanel.prototype.__getActiveItemId = function(waveId) {
      return this._getId(waveId);
    };

    BaseTopicsPanel.prototype.__parseResponseItem = function(topic) {
      var id;
      id = this._getId(topic.waveId);
      if (!topic.changed) return this.__lastSearchResults[id];
      topic.id = id;
      topic.fullChangeDate = formatDate(topic.changeDate, true);
      topic.changeDate = formatDate(topic.changeDate);
      topic.unreadLineLen = this.__getTopicUnreadIndicatorLen(topic.totalUnreadBlipCount, topic.totalBlipCount);
      topic.followButtonText = this.__getFollowButtonText(this._getTopicTypes()[2].text === this._topicsType ? topic : void 0);
      topic.initials = getUserInitials(topic.avatar, topic.name);
      return topic;
    };

    BaseTopicsPanel.prototype.__linkClickHandler = function(event) {
      if (event.target.tagName === 'BUTTON') return;
      return BaseTopicsPanel.__super__.__linkClickHandler.call(this, event);
    };

    BaseTopicsPanel.prototype.__updateUnreadTopicsInTitle = function() {};

    BaseTopicsPanel.prototype.__getTopicTypes = function() {
      return this._getTopicTypes();
    };

    BaseTopicsPanel.prototype.updateTopicsUnreadCount = function(waveId, unreadCount, totalCount) {
      /*
              Обновляет количество непрочитанных сообщений волны в результатах поиска
              @param waveId: string
              @param unreadCount: int
              @param totalCount: int
      */
      var $activeTopic, topic, topicId;
      topicId = this._getId(waveId);
      if (!(topicId in this.__lastSearchResults)) return;
      topic = this.__lastSearchResults[topicId];
      topic.totalUnreadBlipCount = unreadCount;
      topic.totalBlipCount = totalCount;
      topic.unreadLineLen = this.__getTopicUnreadIndicatorLen(unreadCount, totalCount);
      $activeTopic = $(this.getContainer()).find("#" + topicId);
      if (topic.unreadLineLen > 0) {
        $activeTopic.find('.js-unread-blips-indicator > div').css('height', "" + topic.unreadLineLen + "%");
      } else {
        $activeTopic.find('.js-unread-blips-indicator > div').css('height', "0");
        $activeTopic.removeClass('unread');
      }
      return this.__updateUnreadTopicsInTitle();
    };

    BaseTopicsPanel.prototype.findTopicListByText = function(text) {
      this._searchInput.value = "#" + text;
      this.__triggerQueryInputEvent();
      return this.__triggerSearch();
    };

    return BaseTopicsPanel;

  })(BaseSearchPanel);

  exports.BaseTopicsPanel = BaseTopicsPanel;

}).call(this);

});

require.define("/lib/client/client/search_panel/mention/panel_desktop.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BaseSearchPanel, MentionsPanel, UNKNOWN_ICON_SRC, ck, formatDate, getUserInitials, renderer,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BaseSearchPanel = require('../base').BaseSearchPanel;

  formatDate = require('../../../share/utils/datetime').formatDate;

  UNKNOWN_ICON_SRC = require('../../user/models').UNKNOWN_ICON_SRC;

  getUserInitials = require('../../../share/user/utils').getUserInitials;

  renderer = require('./template');

  ck = window.CoffeeKup;

  MentionsPanel = (function(_super) {

    __extends(MentionsPanel, _super);

    function MentionsPanel() {
      this.updateMessageIsRead = __bind(this.updateMessageIsRead, this);
      this.__linkClickHandler = __bind(this.__linkClickHandler, this);
      this.__renderResponse = __bind(this.__renderResponse, this);
      this._setUnreadsInTab = __bind(this._setUnreadsInTab, this);
      this._getUnreadCount = __bind(this._getUnreadCount, this);
      MentionsPanel.__super__.constructor.apply(this, arguments);
    }

    /*
        Панель списка сообщений
    */

    MentionsPanel.prototype.__init = function() {
      var refreshParams;
      $(this.getContainer()).append(renderer.renderHeader());
      this._searchInput = $('#js-message-list-query')[0];
      this._searchButton = $('#js-run-message-list')[0];
      this._resultsContainer = $(this.getContainer()).find('.js-message-list-results')[0];
      refreshParams = {
        isVisible: false,
        visibleUpdateInterval: window.uiConf.search.refreshInterval.visible,
        hiddenUpdateInterval: window.uiConf.search.refreshInterval.hidden,
        unvisibleBrowserTabUpdateInterval: null
      };
      this._mentionsProcessor = require('./processor').instance;
      return MentionsPanel.__super__.__init.call(this, this._mentionsProcessor, this._resultsContainer, this._searchInput, this._searchButton, refreshParams, renderer);
    };

    MentionsPanel.prototype._getUnreadCount = function() {
      var id, r, unreads, _ref;
      unreads = 0;
      _ref = this.__lastSearchResults;
      for (id in _ref) {
        r = _ref[id];
        if (!r.isRead) unreads++;
      }
      return unreads;
    };

    MentionsPanel.prototype._setUnreadsInTab = function() {
      var tab, unreadCount, unreadCountText, unreadMentionsCount;
      unreadCount = this._getUnreadCount();
      tab = $('.js-mentions');
      if (unreadCount === 0) return tab.removeClass('has-unread');
      unreadMentionsCount = $('.js-unread-mentions-count');
      if (unreadCount > 99) {
        unreadCountText = '99+';
      } else {
        unreadCountText = unreadCount;
      }
      unreadMentionsCount.text(unreadCountText);
      return tab.addClass('has-unread');
    };

    MentionsPanel.prototype.__renderResponse = function(scrollIntoView) {
      MentionsPanel.__super__.__renderResponse.call(this, scrollIntoView);
      return this._setUnreadsInTab();
    };

    MentionsPanel.prototype._getId = function(waveId, blipId) {
      return "message-" + waveId + "-" + blipId;
    };

    MentionsPanel.prototype.__parseResponseItem = function(message) {
      var id;
      id = this._getId(message.waveId, message.blipId);
      if (!message.changed) return this.__lastSearchResults[id];
      message.id = id;
      message.strFullLastSent = formatDate(message.lastSent, true);
      message.strLastSent = formatDate(message.lastSent);
      message.initials = getUserInitials(message.senderAvatar, message.senderName);
      message.senderAvatar = message.senderAvatar || UNKNOWN_ICON_SRC;
      return message;
    };

    MentionsPanel.prototype.__getSearchFunction = function() {
      return 'network.message.searchMessageContent';
    };

    MentionsPanel.prototype.__linkClickHandler = function(event) {
      _gaq.push(['_trackEvent', 'Navigation', 'Mentions list click']);
      return MentionsPanel.__super__.__linkClickHandler.call(this, event);
    };

    MentionsPanel.prototype.__getActiveItemId = function(waveId, blipId) {
      return this._getId(waveId, blipId);
    };

    MentionsPanel.prototype.__getPanelName = function() {
      return 'mentions';
    };

    MentionsPanel.prototype.updateMessageIsRead = function(waveId, blipId, isRead) {
      /*
              @param waveId: String
              @param blipId: String
              @param isRead: Boolean
              Изменяет пометку прочитанности для указанного сообщения
      */
      var container, message, messageId;
      messageId = this._getId(waveId, blipId);
      if (!(messageId in this.__lastSearchResults)) return;
      message = this.__lastSearchResults[messageId];
      message.isRead = isRead;
      container = $(this.getContainer()).find("#" + messageId);
      if (isRead) {
        container.removeClass('unread');
      } else {
        container.addClass('unread');
      }
      return this._setUnreadsInTab();
    };

    return MentionsPanel;

  })(BaseSearchPanel);

  exports.MentionsPanel = MentionsPanel;

}).call(this);

});

require.define("/lib/client/client/search_panel/mention/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ck, messagePanelHeaderTmpl, messageTmpl;

  ck = window.CoffeeKup;

  messagePanelHeaderTmpl = function() {
    /*
        Отрисовывает хидер панели поиска сообщений
    */    div('.js-message-list-header.message-list-header', function() {
      return div('.message-list-query-container', function() {
        input('#js-message-list-query.message-list-query', {
          type: 'text'
        });
        return div('#js-run-message-list.search-icon', '');
      });
    });
    return div('.js-message-list-results.message-list-results', '');
  };

  messageTmpl = function() {
    /*
        Отрисовывает панель поиска сообщений
    */
    var messageLink, unread;
    unread = '';
    if (!this.item.isRead) unread = '.unread';
    messageLink = "" + (h(this.prefix)) + (h(this.item.waveId)) + "/" + (h(this.item.blipId)) + "/";
    return a(".js-message-list-result.search-result-item" + (h(unread)), {
      id: this.item.id,
      href: messageLink
    }, function() {
      div(".text-content", function() {
        return div('.message-title', function() {
          text(h(this.item.title + " "));
          return span('.item-snippet', h(this.item.snippet));
        });
      });
      div('.message-info', function() {
        var avatar, name;
        avatar = this.item.senderAvatar;
        name = this.item.senderName;
        div('.last-editing.avatar', {
          style: "background-image: url(" + (h(avatar)) + ")",
          title: h(name)
        }, h(this.item.initials));
        div('.last-changed', {
          title: h(this.item.strFullLastSent)
        }, h(this.item.strLastSent));
        return div('.clearer', '');
      });
      return div('.clearer', '');
    });
  };

  exports.renderHeader = ck.compile(messagePanelHeaderTmpl);

  exports.renderResultItem = ck.compile(messageTmpl);

}).call(this);

});

require.define("/lib/client/client/search_panel/task/panel_desktop.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BaseSearchPanel, History, NOT_PERFORMED_TASK, PERFORMED_TASK, TASK_TYPES, TasksPanel, UNKNOWN_ICON_SRC, compareTasks, convertCalendricalDate, convertDate, convertDateTimeToServer, convertDatetime, filterByDate, formatAsShortDate, formatAsShortTime, formatDate, formatFullDate, getUserInitials, hasDeadline, renderNoResults, renderTaskList, renderer, setTaskRenderedTimes, _ref, _ref2, _ref3,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  History = require('../../utils/history_navigation');

  UNKNOWN_ICON_SRC = require('../../user/models').UNKNOWN_ICON_SRC;

  getUserInitials = require('../../../share/user/utils').getUserInitials;

  BaseSearchPanel = require('../base').BaseSearchPanel;

  _ref = require('../../../share/utils/datetime'), formatDate = _ref.formatDate, formatAsShortDate = _ref.formatAsShortDate, formatAsShortTime = _ref.formatAsShortTime, formatFullDate = _ref.formatFullDate;

  _ref2 = require('../../../share/utils/date_converter'), convertDate = _ref2.convertDate, convertDatetime = _ref2.convertDatetime, convertDateTimeToServer = _ref2.convertDateTimeToServer, convertCalendricalDate = _ref2.convertCalendricalDate;

  _ref3 = require('./constants'), NOT_PERFORMED_TASK = _ref3.NOT_PERFORMED_TASK, PERFORMED_TASK = _ref3.PERFORMED_TASK;

  compareTasks = require('./common').compareTasks;

  renderer = require('./template');

  renderNoResults = require('../template').renderEmptyResult;

  TASK_TYPES = [
    {
      method: 'searchByRecipient',
      text: 'Inbox',
      trackLabel: 'inbox'
    }, {
      method: 'searchBySender',
      text: 'Outbox',
      trackLabel: 'outbox'
    }
  ];

  hasDeadline = function(task) {
    var _ref4, _ref5;
    return (((_ref4 = task.deadline) != null ? _ref4.date : void 0) != null) || (((_ref5 = task.deadline) != null ? _ref5.datetime : void 0) != null);
  };

  filterByDate = function(date, task) {
    var _ref4;
    if (!hasDeadline(task)) return false;
    if (task.deadline.datetime != null) {
      return (date <= (_ref4 = convertDatetime(task.deadline.datetime)) && _ref4 < new Date(date).addDays(1));
    }
    return date.toYMD() === task.deadline.date;
  };

  setTaskRenderedTimes = function(task, today) {
    var date, dateObj, datetime, todayDate, _ref4;
    if (today == null) today = false;
    if (!(task.deadline != null)) return;
    _ref4 = task.deadline, datetime = _ref4.datetime, date = _ref4.date;
    if (datetime != null) {
      dateObj = convertDatetime(datetime);
      if (today) {
        task.overdue = dateObj.getTime() < today.now;
        task.today = dateObj.getTime() >= today.beginDate.getTime() && dateObj.getTime() < today.endDate.getTime();
      }
      todayDate = formatAsShortDate(Date.today());
      date = formatAsShortDate(dateObj);
      if (todayDate === date) {
        delete task.strDeadlineDate;
      } else {
        task.strDeadlineDate = date;
      }
      task.strDeadlineTime = formatAsShortTime(dateObj);
      return task.fullStrDeadline = formatDate(datetime, true);
    } else if (date != null) {
      dateObj = convertDate(date);
      if (today) {
        task.overdue = dateObj.getTime() < today.beginDate.getTime();
        task.today = dateObj.getTime() === today.beginDate.getTime();
      }
      task.fullStrDeadline = formatFullDate(dateObj);
      return task.strDeadlineDate = formatAsShortDate(dateObj);
    }
  };

  renderTaskList = function(incompleteTasks, completedTasks) {
    var now, task, today, _i, _j, _len, _len2;
    now = new Date();
    today = {
      now: now.getTime(),
      beginDate: new Date(now.getFullYear(), now.getMonth(), now.getDate()),
      endDate: new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1)
    };
    for (_i = 0, _len = incompleteTasks.length; _i < _len; _i++) {
      task = incompleteTasks[_i];
      setTaskRenderedTimes(task, today);
    }
    for (_j = 0, _len2 = completedTasks.length; _j < _len2; _j++) {
      task = completedTasks[_j];
      setTaskRenderedTimes(task);
    }
    return renderer.renderResults({
      completedTasks: completedTasks,
      incompleteTasks: incompleteTasks,
      prefix: History.getPrefix()
    });
  };

  TasksPanel = (function(_super) {

    __extends(TasksPanel, _super);

    function TasksPanel() {
      this._taskFilterChangeHandler = __bind(this._taskFilterChangeHandler, this);
      this._taskTimeFilterShortcutChangeHandler = __bind(this._taskTimeFilterShortcutChangeHandler, this);
      this._activateDateFilterTask = __bind(this._activateDateFilterTask, this);
      this._setSelectBoxQuantity = __bind(this._setSelectBoxQuantity, this);
      this.__linkClickHandler = __bind(this.__linkClickHandler, this);
      TasksPanel.__super__.constructor.apply(this, arguments);
    }

    TasksPanel.prototype.__init = function() {
      var refreshParams;
      $(this.getContainer()).append(renderer.renderHeader({
        taskTypes: TASK_TYPES
      }));
      this._searchInput = $('#js-task-list-query')[0];
      this._searchButton = $('#js-run-task-list')[0];
      this._resultsContainer = $(this.getContainer()).find('.js-task-list-results')[0];
      refreshParams = {
        isVisible: false,
        visibleUpdateInterval: window.uiConf.search.refreshInterval.visible,
        hiddenUpdateInterval: window.uiConf.search.refreshInterval.hidden,
        unvisibleBrowserTabUpdateInterval: null
      };
      this._taskProcessor = require('./processor').instance;
      this._taskFilter = $(this.getContainer()).find('.js-task-filter')[0];
      $(this._taskFilter).selectBox().change(this._taskFilterChangeHandler);
      this._initTimeFilter();
      this._initCompletedTasksToggler();
      return TasksPanel.__super__.__init.call(this, this._taskProcessor, this._resultsContainer, this._searchInput, this._searchButton, refreshParams);
    };

    TasksPanel.prototype.__linkClickHandler = function(event) {
      _gaq.push(['_trackEvent', 'Navigation', 'Tasks list click']);
      return TasksPanel.__super__.__linkClickHandler.call(this, event);
    };

    TasksPanel.prototype._initCompletedTasksToggler = function() {
      var _this = this;
      return $(this.getContainer()).on('click', '.js-completed-tasks-header', function() {
        if ($(_this._resultsContainer).hasClass('completed-hidden')) {
          _gaq.push(['_trackEvent', 'Task', 'See completed tasks']);
        }
        return $(_this._resultsContainer).toggleClass('completed-hidden');
      });
    };

    TasksPanel.prototype._setSelectBoxQuantity = function(filterClass, q) {
      $(this.getContainer()).find(".js-close-date.selectBox-dropdown " + filterClass + " .js-task-filter-quantity").text(q);
      return $("ul.js-close-date-selectBox-dropdown-menu " + filterClass + " .js-task-filter-quantity").text(q);
    };

    TasksPanel.prototype._initTimeFilter = function() {
      var filterInfo, searchClass, setSelectBoxQuantity, _ref4,
        _this = this;
      this._timeFilterShortcut = $(this.getContainer()).find('.js-close-date')[0];
      $(this._timeFilterShortcut).selectBox().on('close', this._taskTimeFilterShortcutChangeHandler);
      $(this.getContainer()).find('.selectBox, .selectBox-label').width('auto');
      this._initSelectBoxQuantities();
      setSelectBoxQuantity = this._setSelectBoxQuantity;
      this._timeFilters = {
        '.js-all-tasks': {
          filter: function() {
            return true;
          },
          buttonClass: '.js-close-date',
          setQuantity: function(q) {
            return setSelectBoxQuantity('.js-all-tasks', q);
          },
          trackLabel: 'all'
        },
        '.js-yesterday-tasks': {
          filter: function(task) {
            return filterByDate(Date.yesterday(), task);
          },
          buttonClass: '.js-close-date',
          setQuantity: function(q) {
            return setSelectBoxQuantity('.js-yesterday-tasks', q);
          },
          trackLabel: 'yesterday'
        },
        '.js-today-tasks': {
          filter: function(task) {
            return filterByDate(Date.today(), task);
          },
          buttonClass: '.js-close-date',
          setQuantity: function(q) {
            return setSelectBoxQuantity('.js-today-tasks', q);
          },
          trackLabel: 'today'
        },
        '.js-tomorrow-tasks': {
          filter: function(task) {
            return filterByDate(Date.tomorrow(), task);
          },
          buttonClass: '.js-close-date',
          setQuantity: function(q) {
            return setSelectBoxQuantity('.js-tomorrow-tasks', q);
          },
          trackLabel: 'tomorrow'
        },
        '.js-no-date-tasks': {
          filter: function(task) {
            return !hasDeadline(task);
          },
          buttonClass: '.js-no-date-tasks',
          setQuantity: function(q) {
            return this.button.find('.js-task-filter-quantity').text(q);
          },
          trackLabel: 'no date'
        },
        '.js-with-date-tasks': {
          filter: function(task) {
            return hasDeadline(task);
          },
          buttonClass: '.js-with-date-tasks',
          setQuantity: function(q) {
            return this.button.find('.js-task-filter-quantity').text(q);
          },
          trackLabel: 'with date'
        }
      };
      _ref4 = this._timeFilters;
      for (searchClass in _ref4) {
        filterInfo = _ref4[searchClass];
        filterInfo.button = $(this.getContainer()).find(filterInfo.buttonClass);
      }
      this._timeFilters['.js-no-date-tasks'].button.click(function() {
        return _this._setTimeFilter('.js-no-date-tasks');
      });
      this._initDateFilter();
      return this._setTimeFilter('.js-all-tasks', false);
    };

    TasksPanel.prototype._initSelectBoxQuantities = function() {
      $('ul.js-close-date-selectBox-dropdown-menu li a').append('<span class="js-task-filter-quantity task-filter-quantity"></span>');
      return this._appendCloseDateFilterQuantity();
    };

    TasksPanel.prototype._initDateFilter = function() {
      var filter,
        _this = this;
      filter = this._timeFilters['.js-with-date-tasks'];
      filter.input = $('.js-tasks-with-date-filter-input')[0];
      $(filter.input).calendricalDate({
        positionInBody: true
      }).change(function() {
        var date;
        date = $(filter.input).val();
        date = convertCalendricalDate(date);
        filter.filter = function(task) {
          return filterByDate(date, task);
        };
        $(_this.getContainer()).find('.js-tasks-with-date-filter-label').text(formatAsShortDate(date));
        $(_this.getContainer()).find('.js-with-date-tasks').addClass('has-date');
        return _this._setTimeFilter('.js-with-date-tasks');
      });
      return filter.button.click(this._activateDateFilterTask);
    };

    TasksPanel.prototype._appendCloseDateFilterQuantity = function() {
      var label;
      label = $(this.getContainer()).find('.js-close-date.selectBox-dropdown .selectBox-label');
      if (label.find('.js-task-filter-quantity').length > 0) return;
      return label.append('<span class="js-task-filter-quantity task-filter-quantity"></span>');
    };

    TasksPanel.prototype._activateDateFilterTask = function() {
      $(this._timeFilters['.js-with-date-tasks'].input).focus();
      return window.getSelection().collapse();
    };

    TasksPanel.prototype._taskTimeFilterShortcutChangeHandler = function() {
      var _this = this;
      this._setTimeFilter($(this._timeFilterShortcut).val());
      return window.setTimeout(function() {
        _this._appendCloseDateFilterQuantity();
        return _this._updateFilterQuantities();
      }, 0);
    };

    TasksPanel.prototype._setTimeFilter = function(className, track) {
      var curFilter, filterClassName, info, label, neededButtonClass, _ref4;
      if (track == null) track = true;
      curFilter = this._timeFilters[className];
      neededButtonClass = curFilter.buttonClass;
      _ref4 = this._timeFilters;
      for (filterClassName in _ref4) {
        info = _ref4[filterClassName];
        if (info.buttonClass === neededButtonClass) {
          info.button.addClass('active');
        } else {
          info.button.removeClass('active');
        }
      }
      this._timeFilter = curFilter.filter;
      if (this.__lastSearchResults != null) this.__renderResponse();
      if (track) {
        label = "" + curFilter.trackLabel + " " + (this._getCurrentTypeFilter().trackLabel);
        return _gaq.push(['_trackEvent', 'Task', 'Filter', label]);
      }
    };

    TasksPanel.prototype._updateFilterQuantities = function() {
      var filterClass, info, quantity, _ref4, _results;
      _ref4 = this._timeFilters;
      _results = [];
      for (filterClass in _ref4) {
        info = _ref4[filterClass];
        quantity = this._getIncompleteResultsCountByFilter(info.filter);
        _results.push(info.setQuantity(quantity));
      }
      return _results;
    };

    TasksPanel.prototype._getIncompleteResultsCountByFilter = function(filter) {
      return this._filterResultsBy(filter)[0].length;
    };

    TasksPanel.prototype._filterResultsBy = function(filter) {
      var completedTasks, incompleteTasks, task, _, _ref4;
      if (!this.__lastSearchResults) return [[], []];
      completedTasks = [];
      incompleteTasks = [];
      _ref4 = this.__lastSearchResults;
      for (_ in _ref4) {
        task = _ref4[_];
        if (filter(task)) {
          if (task.status === PERFORMED_TASK) {
            completedTasks.push(task);
          } else {
            incompleteTasks.push(task);
          }
        }
      }
      return [incompleteTasks, completedTasks];
    };

    TasksPanel.prototype._getCurrentTypeFilter = function() {
      var filterIndex;
      filterIndex = $(this._taskFilter).val() || 1;
      filterIndex -= 1;
      return TASK_TYPES[filterIndex];
    };

    TasksPanel.prototype._updateTodayTasksInTab = function(count) {
      var counter, tab, text;
      tab = $('.js-tasks');
      if (count <= 0) return tab.removeClass('has-unread');
      counter = $('.js-unread-tasks-count');
      text = count > 99 ? '99+' : count;
      counter.text(text);
      return tab.addClass('has-unread');
    };

    TasksPanel.prototype._getId = function(waveId, blipId) {
      return "task-" + waveId + "-" + blipId;
    };

    TasksPanel.prototype.__renderResponse = function(scrollIntoView) {
      var completedTasks, container, incompleteTasks, _ref4;
      this._updateFilterQuantities();
      container = $(this._resultsContainer);
      container.empty();
      _ref4 = this._filterResultsBy(this._timeFilter), incompleteTasks = _ref4[0], completedTasks = _ref4[1];
      if (!incompleteTasks.length && !completedTasks.length) {
        return container.append(renderNoResults());
      }
      incompleteTasks.sort(compareTasks);
      completedTasks.sort(compareTasks);
      container.append(renderTaskList(incompleteTasks, completedTasks));
      return this.__setActiveItem(scrollIntoView);
    };

    TasksPanel.prototype._taskFilterChangeHandler = function() {
      if (this._getCurrentTypeFilter().method === 'searchBySender') {
        _gaq.push(['_trackEvent', 'Task', 'Show outgoing tasks']);
      }
      this.__clearLastSearchResults();
      this.__setStatusBarText('Synchronizing...');
      return this.__processSearchStart();
    };

    TasksPanel.prototype.__processAfterResponse = function() {
      var unreadCount;
      if (this._getCurrentTypeFilter().method !== 'searchByRecipient' || this._searchInput.value !== '') {
        return;
      }
      unreadCount = $(this.getContainer()).find('.js-task-list-results > .unread').length;
      return this._updateTodayTasksInTab(unreadCount);
    };

    TasksPanel.prototype.__getAdditionalParams = function() {
      return {
        status: this._getCurrentTypeFilter().status
      };
    };

    TasksPanel.prototype.__getSearchFunction = function() {
      return "network.task." + (this._getCurrentTypeFilter().method);
    };

    TasksPanel.prototype.__parseResponseItem = function(task) {
      var id;
      id = this._getId(task.waveId, task.blipId);
      if (!task.changed) return this.__lastSearchResults[id];
      task.initials = getUserInitials(task.senderAvatar, task.senderName);
      task.senderAvatar = task.senderAvatar || UNKNOWN_ICON_SRC;
      task.id = id;
      return task;
    };

    TasksPanel.prototype.__clearLastSearchResults = function() {
      TasksPanel.__super__.__clearLastSearchResults.call(this);
      return this._updateFilterQuantities();
    };

    TasksPanel.prototype.__renderError = function() {
      /*
              Создает DOM-элементы для сообщения об ошибке поиска
      */      TasksPanel.__super__.__renderError.call(this);
      return this._updateFilterQuantities();
    };

    TasksPanel.prototype.__getActiveItemId = function(waveId, blipId) {
      return this._getId(waveId, blipId);
    };

    TasksPanel.prototype.__getPanelName = function() {
      return 'tasks';
    };

    TasksPanel.prototype.__canCacheSearchResults = function() {
      return this._lastQueryString === '' && this._getCurrentTypeFilter().method === 'searchByRecipient';
    };

    TasksPanel.prototype.updateTaskIsRead = function(waveId, blipId, isRead) {
      /*
              @waveId: String
              @blipId: String
              @isRead: Boolean
              Меняет прочитанность, помечает в списке как прочитанное
      */
      var res, searchRes, taskId, todayCount, _ref4;
      _ref4 = this.__lastSearchResults;
      for (taskId in _ref4) {
        res = _ref4[taskId];
        if (res.waveId !== waveId || res.blipId !== blipId) continue;
        searchRes = res;
        break;
      }
      if (!(searchRes != null)) return;
      if (isRead === searchRes.isRead) return;
      searchRes.isRead = isRead;
      $(this.getContainer()).find("#" + (this._getId(waveId, blipId))).toggleClass('unread');
      todayCount = $(this.getContainer()).find('.unread').length;
      return this._updateTodayTasksInTab(todayCount);
    };

    TasksPanel.prototype.updateTaskInfo = function(task) {
      /*
              TODO если нигде не используется - снести
      */
      var emailToCheck, filter, parsedTask, unreadCount, _ref4;
      filter = this._getCurrentTypeFilter();
      if (filter.method === 'searchByRecipient') {
        emailToCheck = task.recipientEmail;
      } else {
        emailToCheck = task.senderEmail;
      }
      if (emailToCheck !== ((_ref4 = window.userInfo) != null ? _ref4.email : void 0)) {
        return;
      }
      parsedTask = this.__parseResponseItem(task);
      this.__lastSearchResults[parsedTask.id] = parsedTask;
      this.__renderResponse(false);
      if (filter.method !== 'searchByRecipient') return;
      unreadCount = $(this.getContainer()).find('.js-task-list-results > .unread').length;
      return this._updateTodayTasksInTab(unreadCount);
    };

    return TasksPanel;

  })(BaseSearchPanel);

  module.exports.TasksPanel = TasksPanel;

}).call(this);

});

require.define("/lib/client/client/search_panel/task/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ck, panelHeaderTmpl, panelTmpl;

  ck = window.CoffeeKup;

  panelHeaderTmpl = function() {
    div('.js-task-list-header.task-list-header', function() {
      return div('.task-list-query-container', function() {
        input('#js-task-list-query.task-list-query', {
          type: 'text'
        });
        div('#js-run-task-list.search-icon', '');
        return select('.js-task-filter.task-filter', function() {
          var index, tt, _len, _ref, _results;
          _ref = this.taskTypes;
          _results = [];
          for (index = 0, _len = _ref.length; index < _len; index++) {
            tt = _ref[index];
            _results.push(option({
              value: index + 1
            }, tt.text));
          }
          return _results;
        });
      });
    });
    div('.js-task-time-filters.task-time-filters', function() {
      select('.js-close-date.task-time-filter', function() {
        option('.js-all-tasks', {
          value: '.js-all-tasks',
          selected: true
        }, 'All tasks');
        option('.js-yesterday-tasks', {
          value: '.js-yesterday-tasks'
        }, 'Yesterday');
        option('.js-today-tasks', {
          value: '.js-today-tasks'
        }, 'Today');
        return option('.js-tomorrow-tasks', {
          value: '.js-tomorrow-tasks'
        }, 'Tomorrow');
      });
      button('.js-no-date-tasks.task-time-filter', function() {
        text('No date');
        return span('.js-task-filter-quantity.task-filter-quantity', '');
      });
      return div('.tasks-with-date-filter-container', function() {
        input('.js-tasks-with-date-filter-input.tasks-with-date-filter-input', {
          type: 'text'
        });
        return button('.js-with-date-tasks.tasks-with-date-filter.task-time-filter', function() {
          span('.js-tasks-with-date-filter-label.tasks-with-date-filter-label', 'With date');
          return span('.js-task-filter-quantity.task-filter-quantity', '');
        });
      });
    });
    return div('.js-task-list-results.task-list-results.completed-hidden', '');
  };

  panelTmpl = function() {
    var prefix, renderTasks;
    prefix = this.prefix;
    renderTasks = function(tasks) {
      var task, taskLink, unread, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = tasks.length; _i < _len; _i++) {
        task = tasks[_i];
        unread = !task.isRead ? '.unread' : '';
        taskLink = "" + (h(prefix)) + (h(task.waveId)) + "/" + (h(task.blipId)) + "/";
        _results.push(a(".js-task-list-result.search-result-item" + unread, {
          id: task.id,
          href: taskLink
        }, function() {
          div(".text-content", function() {
            return div('.task-title', function() {
              if ((task.strDeadlineTime != null) || (task.strDeadlineDate != null)) {
                span(".task-time-info" + (task.overdue ? '.overdue' : '') + (task.today ? '.today' : ''), "" + (task.strDeadlineDate != null ? h(task.strDeadlineDate) : '') + " " + (task.strDeadlineTime != null ? h(task.strDeadlineTime) : '') + " ");
              }
              text(h(task.title + " "));
              return span('.item-snippet', h(task.snippet));
            });
          });
          div(".task-info", function() {
            var avatar, name;
            avatar = task.senderAvatar;
            name = task.senderName;
            return div('.last-editing.avatar', {
              style: "background-image: url(" + (h(avatar)) + ")",
              title: h(name)
            }, h(task.initials));
          });
          return div('.clearer', '');
        }));
      }
      return _results;
    };
    renderTasks(this.incompleteTasks);
    if (!this.completedTasks.length) return;
    return div('.completed-tasks', function() {
      div('.js-completed-tasks-header.completed-tasks-header', function() {
        div('.completed-tasks-arrow', '');
        return text("Completed tasks — " + this.completedTasks.length);
      });
      return div('.completed-task-list', function() {
        return renderTasks(this.completedTasks);
      });
    });
  };

  exports.renderHeader = ck.compile(panelHeaderTmpl);

  exports.renderResults = ck.compile(panelTmpl);

}).call(this);

});

require.define("/lib/client/client/search_panel/public_topic/panel_desktop.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BaseTopicsPanel, BrowserEvents, History, PublicTopicsPanel, formatDate, renderer,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BaseTopicsPanel = require('../base_topic').BaseTopicsPanel;

  formatDate = require('../../../share/utils/datetime').formatDate;

  History = require('../../utils/history_navigation');

  renderer = require('./template');

  BrowserEvents = require('../../utils/browser_events');

  PublicTopicsPanel = (function(_super) {

    __extends(PublicTopicsPanel, _super);

    function PublicTopicsPanel() {
      this.__linkClickHandler = __bind(this.__linkClickHandler, this);
      this._handleTagClick = __bind(this._handleTagClick, this);
      PublicTopicsPanel.__super__.constructor.apply(this, arguments);
    }

    /*
        Панель, отвечающая за работу поиска публичных топиков
    */

    PublicTopicsPanel.prototype.__init = function() {
      var $container, refreshParams;
      this._topicsType = 'All topics';
      $(this.getContainer()).append(renderer.renderHeader());
      $container = $(this.getContainer());
      this._searchInput = $container.find('#js-public-search-query')[0];
      this._searchButton = $container.find('#js-run-public-search')[0];
      this._resultsContainer = $container.find('#js-public-search-results')[0];
      refreshParams = {
        isVisible: false,
        visibleUpdateInterval: window.uiConf.search.refreshInterval.visible,
        hiddenUpdateInterval: null,
        unvisibleBrowserTabUpdateInterval: null
      };
      this._$tagsBlock = $container.find('.js-tags-block');
      this._$tagsBlock.on(BrowserEvents.CLICK_EVENT, 'a', this._handleTagClick);
      return PublicTopicsPanel.__super__.__init.call(this, require('./processor').instance, this._resultsContainer, this._searchInput, this._searchButton, refreshParams, renderer);
    };

    PublicTopicsPanel.prototype._handleTagClick = function(e) {
      var $search, $target, _base;
      $target = $(e.target);
      $search = $('#js-public-search-query');
      console.log('1111', $search, $target, $target.data('tag'));
      $search.val(typeof (_base = $target.data('tag')).trim === "function" ? _base.trim() : void 0);
      this._lastSearchDate = null;
      this.__triggerSearch();
      return this.__triggerQueryInputEvent();
    };

    PublicTopicsPanel.prototype.__linkClickHandler = function(event) {
      _gaq.push(['_trackEvent', 'Navigation', 'Publics list click']);
      return PublicTopicsPanel.__super__.__linkClickHandler.call(this, event);
    };

    PublicTopicsPanel.prototype._getId = function(waveId) {
      return "public-" + waveId;
    };

    PublicTopicsPanel.prototype.__getSearchFunction = function() {
      return 'network.wave.searchBlipContentInPublicWaves';
    };

    PublicTopicsPanel.prototype.__getPanelName = function() {
      return 'public topics';
    };

    return PublicTopicsPanel;

  })(BaseTopicsPanel);

  exports.PublicTopicsPanel = PublicTopicsPanel;

}).call(this);

});

require.define("/lib/client/client/search_panel/public_topic/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ck, publicSearchPanelTmpl, publicSearchTopicTmpl;

  ck = window.CoffeeKup;

  publicSearchPanelTmpl = function() {
    div('.js-public-search-header.public-search-header', function() {
      return div('.public-search-query-container', function() {
        input('#js-public-search-query.public-search-query', {
          type: 'text'
        });
        div('#js-run-public-search.search-icon', '');
        return div('.js-tags-block tags-block', function() {
          a({
            href: '#',
            'data-tag': '#Education'
          }, "#Education");
          a({
            href: '#',
            'data-tag': '#Rizzoma'
          }, "#Rizzoma");
          a({
            href: '#',
            'data-tag': '#Velocar'
          }, "#Velocar");
          return a({
            href: '#',
            'data-tag': '#Ukraine'
          }, "#Ukraine");
        });
      });
    });
    return div('#js-public-search-results.search-results', '');
  };

  publicSearchTopicTmpl = function() {
    var unread, unreadCount, waveId;
    unreadCount = this.item.totalUnreadBlipCount;
    unread = '';
    if (unreadCount) unread = '.unread';
    waveId = h(this.item.waveId);
    return a(".js-search-result.search-result-item" + (h(unread)), {
      id: this.item.id,
      href: "" + (h(this.prefix)) + waveId + "/"
    }, function() {
      div(".js-text-content.text-content", function() {
        return div('.wave-title', function() {
          var snippet;
          text(h(this.item.title));
          snippet = ' ' + this.item.snippet;
          return span('.item-snippet', h(snippet));
        });
      });
      div('.js-wave-info.wave-info', function() {
        button('.js-follow.follow.button', h(this.item.followButtonText));
        return div('.js-info.info', function() {
          var avatar, nameTitle;
          nameTitle = '';
          if (this.item.name != null) nameTitle = this.item.name;
          avatar = '/s/img/user/unknown.png';
          if ((this.item.avatar != null) && this.item.avatar !== '') {
            avatar = this.item.avatar;
          }
          div('.last-editing.avatar', {
            style: "background-image: url(" + (h(avatar)) + ")",
            title: h(nameTitle)
          }, h(this.item.initials));
          div('.last-changed', {
            title: h(this.item.fullChangeDate)
          }, h(this.item.changeDate));
          return div('.clearer', '');
        });
      });
      div('.clearer', '');
      return div('.js-unread-blips-indicator.unread-blips-indicator', function() {
        var len;
        len = this.item.unreadLineLen;
        return div('', {
          style: "height: " + (h(len)) + "%"
        }, '');
      });
    });
  };

  exports.renderHeader = ck.compile(publicSearchPanelTmpl);

  exports.renderResultItem = ck.compile(publicSearchTopicTmpl);

}).call(this);

});

require.define("/lib/client/client/market_panel/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BaseSearchPanel, DomUtils, History, MarketPanel, renderer,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __indexOf = Array.prototype.indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  History = require('../utils/history_navigation');

  BaseSearchPanel = require('../search_panel/base').BaseSearchPanel;

  DomUtils = require('../utils/dom');

  renderer = require('./template');

  MarketPanel = (function(_super) {
    var CHANGE_ITEM_STATE_DELAY, RELOAD_LIST_INTERVAL;

    __extends(MarketPanel, _super);

    function MarketPanel() {
      this._loadAndInitItemList = __bind(this._loadAndInitItemList, this);
      this.__linkClickHandler = __bind(this.__linkClickHandler, this);
      MarketPanel.__super__.constructor.apply(this, arguments);
    }

    CHANGE_ITEM_STATE_DELAY = 500;

    RELOAD_LIST_INTERVAL = 3600000;

    MarketPanel.prototype.__init = function() {
      var $buttons,
        _this = this;
      this._marketProcessor = require('./processor').instance;
      this._currentSearchCategory = null;
      this._createContainerDom();
      this._resultsContainer.addEventListener('click', this.__linkClickHandler, false);
      $buttons = $(this._container).find('.js-market-items-filter');
      $buttons.on('click', function(e) {
        $buttons.removeClass('pressed');
        $(e.target).addClass('pressed');
        _this._currentSearchCategory = parseInt($(e.target).attr('searchParam'));
        _this._renderByCategory();
        return _this.__setActiveItem(true);
      });
      this._loadAndInitItemList();
      return setInterval(this._loadAndInitItemList, RELOAD_LIST_INTERVAL);
    };

    MarketPanel.prototype.__linkClickHandler = function(event) {
      if ($(event.target).hasClass('js-market-panel-result')) {
        _gaq.push(['_trackEvent', 'Store', 'Store list click', $(event.target).attr('title')]);
      } else {
        _gaq.push(['_trackEvent', 'Store', 'Store list click', $(event.target).parents('.js-market-panel-result').attr('title')]);
      }
      return MarketPanel.__super__.__linkClickHandler.call(this, event);
    };

    MarketPanel.prototype._loadAndInitItemList = function() {
      var _this = this;
      this._storeItems = [];
      return this._marketProcessor.getVisibleItemList(function(error, response) {
        var item, _i, _len, _ref;
        if (error) return console.error(error);
        for (_i = 0, _len = response.length; _i < _len; _i++) {
          item = response[_i];
          if (_ref = item.id, __indexOf.call(window.userInfo.installedStoreItems, _ref) >= 0) {
            item.state = 2;
          } else {
            item.state = 1;
          }
          item.htmlId = _this._getId(item.topicUrl);
          _this._storeItems.push(item);
        }
        _this._renderByCategory();
        return _this.__setActiveItem(true);
      });
    };

    MarketPanel.prototype._renderByCategory = function() {
      var item, result, _i, _len, _ref;
      DomUtils.empty(this._resultsContainer);
      result = '';
      _ref = this._storeItems;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (this._currentSearchCategory && item.category !== this._currentSearchCategory) {
          continue;
        }
        result += renderer.renderResultItem({
          item: item,
          prefix: History.getPrefix()
        });
      }
      result = DomUtils.parseFromString(result);
      this._resultsContainer.appendChild(result);
      if (this._currentSearchCategory !== 2) return this._initSwitches();
    };

    MarketPanel.prototype._initSwitches = function() {
      var $labels,
        _this = this;
      $labels = $(this._container).find('.js-gadget-checkbox-label');
      return $labels.on('mousedown mouseup', function(e) {
        e.stopPropagation();
        return e.preventDefault();
      }).on('click', function(e) {
        var $checkbox, gadgetId, item, s;
        e.preventDefault();
        e.stopPropagation();
        $checkbox = $(e.target).prev();
        gadgetId = $checkbox.attr('id');
        item = _this._getItemById(gadgetId);
        if ($checkbox.attr('checked')) {
          s = 'off';
        } else {
          s = 'on';
        }
        _gaq.push(['_trackEvent', 'Store', 'Switch gadget ' + s, $(e.target).parents('.js-market-panel-result').attr('title')]);
        return _this._processCheckboxClick(item, $checkbox);
      });
    };

    MarketPanel.prototype._createContainerDom = function() {
      var $resultsContainer;
      $(this._container).append(renderer.renderPanelTmpl());
      $resultsContainer = $(this._container).find('.js-market-panel-results');
      return this._resultsContainer = $resultsContainer[0];
    };

    MarketPanel.prototype._getId = function(waveId) {
      return "market-" + waveId;
    };

    MarketPanel.prototype.__getActiveItemId = function(waveId, blipId) {
      return this._getId(waveId);
    };

    MarketPanel.prototype._getItemById = function(id) {
      var item, _i, _len, _ref;
      _ref = this._storeItems;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.id === id) return item;
      }
    };

    MarketPanel.prototype._processCheckboxClick = function(item, $checkbox) {
      var _this = this;
      if (this._waitResponse) return;
      return this._marketProcessor.getCurrentWave(function(currentWave) {
        var currentWaveView, insertGadgetPopup, startTime;
        _this._waitResponse = true;
        if (currentWave) {
          currentWaveView = currentWave.getView();
          currentWaveView.enableActiveBlipControls();
          insertGadgetPopup = currentWaveView.getInsertGadgetPopup();
          if (!insertGadgetPopup.isVisible()) {
            insertGadgetPopup.show(currentWaveView.getActiveBlip());
          }
          startTime = Date.now();
        }
        if (item.state !== 1) {
          $checkbox.removeAttr('checked');
          return _this._marketProcessor.uninstallStoreItem(item.id, function(err, response) {
            var finishTime;
            _this._waitResponse = false;
            if (err) return console.error(err);
            item.state = 1;
            window.userInfo.installedStoreItems.splice(window.userInfo.installedStoreItems.indexOf(item.id), 1);
            if (currentWave) {
              finishTime = Date.now();
              if (finishTime - startTime >= CHANGE_ITEM_STATE_DELAY) {
                return insertGadgetPopup.removeGadget(item);
              } else {
                return setTimeout(function() {
                  return insertGadgetPopup.removeGadget(item);
                }, CHANGE_ITEM_STATE_DELAY - finishTime + startTime);
              }
            }
          });
        } else {
          $checkbox.attr('checked', 'checked');
          return _this._marketProcessor.installStoreItem(item.id, function(err, response) {
            var finishTime;
            _this._waitResponse = false;
            if (err) return console.error(err);
            item.state = 2;
            window.userInfo.installedStoreItems.push(item.id);
            if (currentWave) {
              finishTime = Date.now();
              if (finishTime - startTime >= CHANGE_ITEM_STATE_DELAY) {
                return insertGadgetPopup.addGadget(item);
              } else {
                return setTimeout(function() {
                  return insertGadgetPopup.addGadget(item);
                }, CHANGE_ITEM_STATE_DELAY - finishTime + startTime);
              }
            }
          });
        }
      });
    };

    MarketPanel.prototype.getInstalledGadgets = function() {
      var gadget, installedGadgets, _i, _len, _ref;
      installedGadgets = [];
      _ref = this._storeItems;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        gadget = _ref[_i];
        if (gadget.state === 2) installedGadgets.push(gadget);
      }
      return installedGadgets;
    };

    MarketPanel.prototype.getTimer = function() {};

    return MarketPanel;

  })(BaseSearchPanel);

  exports.MarketPanel = MarketPanel;

  exports.instance = null;

}).call(this);

});

require.define("/lib/client/client/market_panel/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ck, marketItem, marketPanelTmpl;

  ck = window.CoffeeKup;

  marketPanelTmpl = function() {
    /*
        Отрисовывает хидер и контейнер панели маркета
    */    div('.js-market-panel-header.market-panel-header', function() {
      button('.js-market-items-filter.market-items-filter.pressed', {
        searchParam: 'All'
      }, 'All');
      button('.js-market-items-filter.market-items-filter', {
        searchParam: '1'
      }, 'Gadgets');
      return button('.js-market-items-filter.market-items-filter', {
        searchParam: '2'
      }, 'Extensions');
    });
    return div('.js-market-panel-results.market-panel-results', '');
  };

  marketItem = function() {
    /*
        Отрисовывает элемент панели маркета
    */    return a(".js-market-panel-result.market-panel-result", {
      href: "" + (h(this.prefix)) + (h(this.item.topicUrl)),
      id: h(this.item.htmlId),
      title: h(this.item.title)
    }, function() {
      div(".item-logo", {
        style: "background: url('" + this.item.icon + "') 0 0 no-repeat"
      }, '');
      div(".item-description" + (this.item.category === 2 ? '.extension' : ''), function() {
        span('title', {
          title: h(this.item.title)
        }, h(this.item.title));
        br('');
        return span('.snippet', {
          title: h(this.item.description)
        }, h(this.item.description));
      });
      if (this.item.category === 1) {
        div('.market-chechbox', function() {
          var checked;
          checked = this.item.state === 2 ? 'checked' : '';
          input({
            type: 'checkbox',
            id: "" + (h(this.item.id)),
            checked: checked
          });
          return label('.js-gadget-checkbox-label', {
            "for": "" + (h(this.item.id))
          });
        });
      }
      return div('.clearer', '');
    });
  };

  exports.renderPanelTmpl = ck.compile(marketPanelTmpl);

  exports.renderResultItem = ck.compile(marketItem);

}).call(this);

});

require.define("/lib/client/client/tips_video/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var TipsVideoPopup, ck, tipsVideoTmpl,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = Array.prototype.slice;

  ck = window.CoffeeKup;

  tipsVideoTmpl = function() {
    div('.js-tips-video-overlay.tips-video-overlay', '');
    return div('.js-tips-video-popup.tips-video-popup', function() {
      return div('.internal-container', function() {
        div('.js-tips-video-close.tips-video-close', {
          title: 'Close'
        }, '');
        div('.tips-video-title', 'First Steps in Rizzoma');
        return iframe('', {
          width: "640",
          height: "480",
          src: "https://www.youtube.com/embed/I7whBwsGzM8?fs=1&hl=en_En&color1=0x2b405b&color2=0x6b8ab6&autoplay=1&autohide=1&wmode=transparent",
          frameborder: "0",
          allowfullscreen: 'true',
          webkitallowfullscreen: 'true',
          mozallowfullscreen: 'true'
        });
      });
    });
  };

  TipsVideoPopup = (function() {
    /*
        Попап с видео из панели подсказок
    */
    function TipsVideoPopup() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._close = __bind(this._close, this);
      this._windowKeyHandler = __bind(this._windowKeyHandler, this);
      this._init.apply(this, args);
    }

    TipsVideoPopup.prototype._init = function() {
      $(document.body).append(ck.render(tipsVideoTmpl));
      this._$popup = $('.js-tips-video-popup');
      this._setPosition();
      return this._initCloseEvents();
    };

    TipsVideoPopup.prototype._setPosition = function() {
      var left, popupWidth;
      popupWidth = this._$popup.width();
      left = (document.body.offsetWidth - popupWidth) / 2;
      return this._$popup.css('left', left + 'px');
    };

    TipsVideoPopup.prototype._initCloseEvents = function() {
      this._$overlay = $('.js-tips-video-overlay');
      this._$closeControl = $('.js-tips-video-close');
      this._$overlay.on('click', this._close);
      this._$closeControl.on('click', this._close);
      return $(window).on('keydown', this._windowKeyHandler);
    };

    TipsVideoPopup.prototype._windowKeyHandler = function(e) {
      if (e.which !== 27) return;
      return this._close();
    };

    TipsVideoPopup.prototype._close = function() {
      $(window).off('keydown', this._windowKeyHandler);
      this._$popup.remove();
      return this._$overlay.remove();
    };

    return TipsVideoPopup;

  })();

  exports.TipsVideoPopup = TipsVideoPopup;

}).call(this);

});

require.define("/lib/client/client/navigation/resizer.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var MicroEvent, Resizer,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  MicroEvent = require('../utils/microevent');

  Resizer = (function() {
    var CURRENT_WIDTH_COOKIE_NAME, LAST_WIDTH_COOKIE_NAME, MIN_NAVIGATION_WIDTH;

    MIN_NAVIGATION_WIDTH = 317;

    CURRENT_WIDTH_COOKIE_NAME = 'navigation-container-width';

    LAST_WIDTH_COOKIE_NAME = 'comfort-navigation-container-width';

    function Resizer() {
      this._toggleNavPanel = __bind(this._toggleNavPanel, this);
      this._setDefaultWidth = __bind(this._setDefaultWidth, this);
      this._endResize = __bind(this._endResize, this);
      this._resize = __bind(this._resize, this);
      this._beginResize = __bind(this._beginResize, this);
      var _this = this;
      this._$tabsContainer = $('.js-tabs-container');
      this._tabsContainerWidth = this._$tabsContainer.width();
      this._toolsPanelWidth = $('.js-right-tools-panel').width();
      this._$wc = $('.js-wave-container');
      this._$nc = $('.js-navigation-container');
      this._$resizer = this._$nc.find('.js-resizer');
      this._$navPanel = this._$nc.find('.js-navigation-panel');
      this._$listsContainer = this._$nc.find('.js-lists-container');
      this._$tipsBox = this._$nc.find('.js-tips-box');
      this._minWaveWidth = parseInt($(document.body).css('min-width')) - MIN_NAVIGATION_WIDTH - this._tabsContainerWidth - this._toolsPanelWidth;
      this._resizing = false;
      this._startX = null;
      this._startWidth = null;
      this._lastWidth = null;
      setTimeout(function() {
        return _this._loadWidth();
      }, 100);
      this._register();
    }

    Resizer.prototype._beginResize = function(event) {
      if (event.which !== 1) return;
      event.preventDefault();
      this._resizing = true;
      this._startX = event.pageX;
      return this._startWidth = this._$nc.width();
    };

    Resizer.prototype._resize = function(event) {
      var ncw;
      if (event.which !== 1) return;
      if (this._resizing) {
        ncw = this._startWidth + event.pageX - this._startX;
        return this._resizeTo(ncw);
      }
    };

    Resizer.prototype._endResize = function(event) {
      if (event.which !== 1) return;
      if (this._resizing) this._saveWidth();
      this._resizing = false;
      return true;
    };

    Resizer.prototype._resizeTo = function(width) {
      var fullWidth;
      fullWidth = this._$nc.width() + this._$wc.width();
      if (width < MIN_NAVIGATION_WIDTH / 2) {
        width = 0;
      } else if (width >= MIN_NAVIGATION_WIDTH / 2 && width < MIN_NAVIGATION_WIDTH) {
        width = MIN_NAVIGATION_WIDTH;
      } else if (fullWidth - width < this._minWaveWidth) {
        width = fullWidth - this._minWaveWidth;
      }
      return this._setWidth(width);
    };

    Resizer.prototype._hideNavPanel = function() {
      this._$resizer.hide();
      this._$listsContainer.hide();
      this._$tipsBox.hide();
      return this.emit('deactivateAllTabs');
    };

    Resizer.prototype._showNavPanel = function() {
      this._$listsContainer.show();
      this._$tipsBox.show();
      this._$resizer.show();
      return this.emit('activateCurrentTab');
    };

    Resizer.prototype.setHalfScreenWidth = function() {
      var ncw;
      ncw = (this._$wc.width() + this._$nc.width()) / 2;
      return this._applyNewWidth(ncw);
    };

    Resizer.prototype.revertToPreviousWidth = function() {
      return this._applyNewWidth(this._lastWidth);
    };

    Resizer.prototype._setWidth = function(ncw) {
      if (ncw === 0 && this._lastWidth > 0) {
        this._hideNavPanel();
      } else if (ncw >= MIN_NAVIGATION_WIDTH && this._lastWidth <= 0) {
        this._showNavPanel();
      }
      if (ncw === this._lastWidth) return;
      this._applyNewWidth(ncw);
      return this._lastWidth = ncw;
    };

    Resizer.prototype._applyNewWidth = function(ncw) {
      this._$nc.width(ncw);
      this._$navPanel.width(ncw);
      this._setTaskTimeFiltersWidth(ncw);
      this._$wc.css('margin-left', "" + (ncw + this._tabsContainerWidth) + "px");
      return $(window).trigger('resizeTopicByResizer');
    };

    Resizer.prototype._saveWidth = function() {
      return $.cookie(CURRENT_WIDTH_COOKIE_NAME, this._lastWidth, {
        path: '/',
        expires: 7
      });
    };

    Resizer.prototype._loadWidth = function() {
      var width;
      width = parseInt($.cookie(CURRENT_WIDTH_COOKIE_NAME));
      if (document.location.pathname === "/topic/" || isNaN(width)) {
        if (width === 0 || isNaN(width)) width = MIN_NAVIGATION_WIDTH;
      }
      if (width === 0) {
        this._lastWidth = MIN_NAVIGATION_WIDTH;
      } else {
        this._lastWidth = 0;
      }
      return this._resizeTo(width);
    };

    Resizer.prototype._setDefaultWidth = function(event) {
      var difference, limitWidth, ncw, wndWidth;
      if (!event.isTrigger && this._lastWidth > 0) {
        ncw = this._$nc.width();
        wndWidth = $(window).width();
        limitWidth = this._minWaveWidth + ncw + this._tabsContainerWidth + this._toolsPanelWidth;
        difference = limitWidth - wndWidth;
        if (difference > 0) {
          ncw = ncw - difference;
          if (ncw < MIN_NAVIGATION_WIDTH) ncw = MIN_NAVIGATION_WIDTH;
        }
        this._setWidth(ncw);
        return this._saveWidth();
      }
    };

    Resizer.prototype._register = function() {
      this._$nc.on('mousedown', '.js-resizer', this._beginResize);
      this._$nc.on('dblclick', '.js-resizer', this._toggleNavPanel);
      $(window).on('mousemove', this._resize);
      $(window).on('mouseup', this._endResize);
      return $(window).on('resize', this._setDefaultWidth);
    };

    Resizer.prototype._unregister = function() {
      this._$nc.off('mousedown', '.js-resizer', this._beginResize);
      this._$nc.off('dblclick', '.js-resizer', this._toggleNavPanel);
      $(window).off('mousemove', this._resize);
      $(window).off('mouseup', this._endResize);
      return $(window).off('resize', this._setDefaultWidth);
    };

    Resizer.prototype._setTaskTimeFiltersWidth = function(width) {
      if (width < 364) {
        return $('.js-task-time-filters').addClass('minimal');
      } else {
        return $('.js-task-time-filters').removeClass('minimal');
      }
    };

    Resizer.prototype._toggleNavPanel = function() {
      if (this._lastWidth > 0) {
        return this.foldNavPanel();
      } else if (this._lastWidth === 0) {
        return this.unfoldNavPanel();
      }
    };

    Resizer.prototype.unfoldNavPanel = function() {
      var width;
      width = parseInt($.cookie(LAST_WIDTH_COOKIE_NAME));
      if (isNaN(width)) width = MIN_NAVIGATION_WIDTH;
      this._resizeTo(width);
      return this._saveWidth();
    };

    Resizer.prototype.foldNavPanel = function() {
      $.cookie(LAST_WIDTH_COOKIE_NAME, this._lastWidth, {
        path: '/',
        expires: 7
      });
      this._resizeTo(0);
      return this._saveWidth();
    };

    Resizer.prototype.getLastWidth = function() {
      return this._lastWidth;
    };

    return Resizer;

  })();

  MicroEvent.mixin(Resizer);

  exports.Resizer = Resizer;

}).call(this);

});

require.define("/lib/client/client/navigation/help_menu.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BrowserSupport, ChromeAppPopup, CrowdPopup, HelpMenu, HelpPopup, Introduce, PopupContent, buttonTmpl, ck, popup, popupTmpl, renderButton, renderPopup, zenboxInitialized, _ref,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  BrowserSupport = require('../utils/browser_support');

  ChromeAppPopup = require('../chrome_app_popup').ChromeAppPopup;

  CrowdPopup = require('../crowd_popup').CrowdPopup;

  Introduce = require('../introduce').Introduce;

  _ref = require('../popup'), popup = _ref.popup, PopupContent = _ref.PopupContent;

  ck = window.CoffeeKup;

  buttonTmpl = function() {
    return div('.js-help-button.help-button', function() {
      div('.pict.help-pict', '');
      text('Help');
      return div('.js-help-placeholder', '');
    });
  };

  popupTmpl = function() {
    return div('.js-help-menu.help-menu', function() {
      a({
        href: 'https://rizzoma.zendesk.com',
        onclick: 'try {Zenbox.show(); return false;} catch(e){}',
        target: '_blank'
      }, 'Support');
      a('.js-reopen-help-page', {
        href: '#'
      }, 'Guide');
      a({
        href: '/help-center-video.html?from=helpblock',
        target: '_blank'
      }, 'Video');
      a({
        href: '/help-center-faq.html?from=helpblock',
        target: '_blank'
      }, 'FAQ');
      a({
        href: 'http://blog.rizzoma.com/?from=helpblock',
        target: '_blank'
      }, 'Blog');
      if (this.isDesktopChrome) {
        a('.js-chrome-app', {
          href: '#',
          title: 'Install our Chrome application'
        }, 'Apps');
      }
      a('.js-open-crowd-popup', {
        href: '#'
      }, 'Crowd');
      a('.js-show-topic-tip.show-topic-tip', {
        href: '#',
        title: 'Show random tips in opened topic'
      }, 'Show tips');
      return a({
        href: '/about-security.html?from=help_menu',
        title: 'Security - updated 30 April 2013',
        target: '_blank'
      }, 'Security');
    });
  };

  renderButton = ck.compile(buttonTmpl);

  renderPopup = ck.compile(popupTmpl);

  zenboxInitialized = false;

  HelpPopup = (function(_super) {

    __extends(HelpPopup, _super);

    function HelpPopup() {
      var container;
      container = $(renderPopup({
        isDesktopChrome: BrowserSupport.isDesktopChrome()
      }));
      this._container = container[0];
      this._initMenu(container);
      this._initZenboxWidget(container);
      this._initChromeAppPopup(container);
      this._initGuidePopup(container);
      this._initCrowdPopup(container);
      this._initShowTipsButton(container);
    }

    HelpPopup.prototype._initMenu = function(container) {
      return container.on('click', 'a', function(e) {
        _gaq.push(['_trackEvent', 'Help block', 'Link click', e.target.textContent]);
        return popup.hide();
      });
    };

    HelpPopup.prototype._initZenboxWidget = function(container) {
      if ((typeof Zenbox !== "undefined" && Zenbox !== null) && !zenboxInitialized) {
        Zenbox.init({
          dropboxID: "20194027",
          url: "https://rizzoma.zendesk.com",
          tabTooltip: "Ask Us",
          tabImageURL: "https://assets.zendesk.com/external/zenbox/images/tab_ask_us.png",
          tabColor: "#40E0D0",
          tabPosition: "Left",
          hide_tab: "true"
        });
      }
      return zenboxInitialized = true;
    };

    HelpPopup.prototype._initChromeAppPopup = function(container) {
      var button;
      if (!BrowserSupport.isDesktopChrome()) return;
      button = container.find('.js-chrome-app');
      return button.click(function(e) {
        e.preventDefault();
        return new ChromeAppPopup();
      });
    };

    HelpPopup.prototype._initGuidePopup = function(container) {
      var button;
      button = container.find('.js-reopen-help-page');
      return button.click(function(e) {
        e.preventDefault();
        _gaq.push(['_trackEvent', 'Introduce page', 'Reopen introduce page']);
        return setTimeout(function() {
          return new Introduce();
        }, 200);
      });
    };

    HelpPopup.prototype._initCrowdPopup = function(container) {
      var button;
      button = container.find('.js-open-crowd-popup');
      return button.click(function(e) {
        _gaq.push(['_trackEvent', 'Crowd popup', 'show', 'help block']);
        e.preventDefault();
        return new CrowdPopup();
      });
    };

    HelpPopup.prototype._initShowTipsButton = function(container) {
      var button, processor;
      button = container.find('.js-show-topic-tip');
      processor = require('../wave/processor').instance;
      if (!processor) {
        button.addClass('hidden');
        return;
      }
      return button.click(function(e) {
        var _ref2;
        e.preventDefault();
        if ((_ref2 = window.getSelection()) != null) _ref2.removeAllRanges();
        return processor.showTips();
      });
    };

    HelpPopup.prototype.destroy = function() {};

    HelpPopup.prototype.getContainer = function() {
      return this._container;
    };

    return HelpPopup;

  })(PopupContent);

  HelpMenu = (function() {

    function HelpMenu() {}

    HelpMenu.prototype._initButton = function(container) {
      var button;
      button = container.find('.js-help-button');
      return button.click(function() {
        _gaq.push(['_trackEvent', 'Help block', 'Open help block']);
        popup.hide();
        popup.render(new HelpPopup(), button.find('.js-help-placeholder')[0]);
        popup.addExtendedClass('help-menu-popup');
        return popup.show();
      });
    };

    HelpMenu.prototype.render = function(container) {
      var content;
      content = renderButton();
      container = $(container);
      container.empty().append(content);
      return this._initButton(container);
    };

    return HelpMenu;

  })();

  module.exports = {
    HelpMenu: HelpMenu
  };

}).call(this);

});

require.define("/lib/client/client/crowd_popup/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var CrowdPopup, LocalStorage, SHOW_CROWD_POPUP, renderCrowdPopup,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = Array.prototype.slice;

  renderCrowdPopup = require('./template').renderCrowdPopup;

  LocalStorage = require('../utils/localStorage').LocalStorage;

  SHOW_CROWD_POPUP = 'scp';

  CrowdPopup = (function() {

    function CrowdPopup() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._close = __bind(this._close, this);
      this._windowKeyHandler = __bind(this._windowKeyHandler, this);
      this._init.apply(this, args);
    }

    CrowdPopup.prototype._init = function(setCookie) {
      if (setCookie == null) setCookie = false;
      if (setCookie) {
        $.cookie(SHOW_CROWD_POPUP, 1, {
          path: '/topic/',
          expires: 100
        });
      }
      $(document.body).append(renderCrowdPopup({
        scpCookie: parseInt($.cookie(SHOW_CROWD_POPUP)) === 1
      }));
      this._$popup = $('.js-crowd-popup');
      this._$checkbox = this._$popup.find('#js-show-crowd-popup');
      this._$checkbox.on('change', function(e) {
        if ($(e.currentTarget).is(':checked')) {
          return $.cookie(SHOW_CROWD_POPUP, 1, {
            path: '/topic/',
            expires: 100
          });
        } else {
          return $.cookie(SHOW_CROWD_POPUP, 0, {
            path: '/topic/',
            expires: 100
          });
        }
      });
      this._setPosition();
      return this._initCloseEvents();
    };

    CrowdPopup.prototype._setPosition = function() {
      var left, popupWidth;
      popupWidth = this._$popup.width();
      left = (document.body.offsetWidth - popupWidth) / 2;
      return this._$popup.css('left', left + 'px');
    };

    CrowdPopup.prototype._initCloseEvents = function() {
      this._$overlay = $('.js-crowd-overlay');
      this._$closeControl = $('.js-crowd-close');
      this._$overlay.on('click', this._close);
      this._$closeControl.on('click', this._close);
      return $(window).on('keydown', this._windowKeyHandler);
    };

    CrowdPopup.prototype._windowKeyHandler = function(e) {
      if (e.which !== 27) return;
      return this._close();
    };

    CrowdPopup.prototype._close = function() {
      if (this._$checkbox.is(':checked')) {
        _gaq.push(['_trackEvent', 'Crowd popup', 'close', 'with show later']);
      } else {
        _gaq.push(['_trackEvent', 'Crowd popup', 'close', 'forever']);
      }
      $(window).off('keydown', this._windowKeyHandler);
      this._$popup.remove();
      return this._$overlay.remove();
    };

    return CrowdPopup;

  })();

  CrowdPopup.canShowPopup = function() {
    if (window.firstSessionLoggedIn) {
      if (LocalStorage.getLoginCount() > 6) {
        if ($.cookie(SHOW_CROWD_POPUP) && parseInt($.cookie(SHOW_CROWD_POPUP)) === 1) {
          return true;
        }
        if (!$.cookie(SHOW_CROWD_POPUP)) return true;
      }
      if (window.userInfo.daysAfterFirstVisit >= 22) {
        if ($.cookie(SHOW_CROWD_POPUP) && parseInt($.cookie(SHOW_CROWD_POPUP)) === 1) {
          return true;
        }
        if (!$.cookie(SHOW_CROWD_POPUP)) return true;
      }
    }
  };

  exports.CrowdPopup = CrowdPopup;

}).call(this);

});

require.define("/lib/client/client/crowd_popup/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ck, crowdPopupTmpl;

  ck = window.CoffeeKup;

  crowdPopupTmpl = function() {
    div('.js-crowd-overlay.crowd-overlay', '');
    return div('.js-crowd-popup.crowd-popup', function() {
      return div('.internal-container', function() {
        div('.js-crowd-close.crowd-close', {
          title: 'Close'
        }, '');
        div('.crowd-title', 'Rizzoma Blesses the Crowd for help!');
        div('.crowd-text', function() {
          span("Want to get in on Rizzoma's growth?");
          br('');
          return a('.crowd-link', {
            href: "https://rizzoma.com/topic/fafc9e77439da06f0675983a026ad892/?from=crowd_popup",
            onClick: "_gaq.push(['_trackEvent', 'Crowd popup', 'link click', 'how to help'])",
            target: '_blank'
          }, "Go to How You Can Help the Rizzoma");
        });
        div('.crowd-text', function() {
          span("Want to get Crowd for Your Project?");
          br('');
          return a('.crowd-link', {
            href: "https://rizzoma.com/topic/bb306e65888a84bc3164615ca66ec37d/?from=crowd_popup",
            onClick: "_gaq.push(['_trackEvent', 'Crowd popup', 'link click', 'how to use'])",
            target: '_blank'
          }, "Go to How to use Wisdom of the Crowd with Rizzoma");
        });
        return div('.crowd-text', function() {
          input({
            type: "checkbox",
            id: "js-show-crowd-popup",
            checked: "" + (this.scpCookie ? 'checked' : '')
          });
          return label({
            "for": "js-show-crowd-popup"
          }, 'Ask me later');
        });
      });
    });
  };

  exports.renderCrowdPopup = ck.compile(crowdPopupTmpl);

}).call(this);

});

require.define("/lib/client/client/introduce/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var Introduce, renderIntro, renderVideo,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  renderIntro = require('./template').renderIntro;

  renderVideo = require('./template').renderVideo;

  Introduce = (function() {
    /*
        Панель ознакомления с функционалом
    */
    var CALLOUT_SLIDE_CLASS_PREFIX, MODES, SLIDES_COUNT;

    CALLOUT_SLIDE_CLASS_PREFIX = 'slide';

    SLIDES_COUNT = 4;

    MODES = {
      image: 'image',
      video: 'video'
    };

    function Introduce() {
      this._closeAndUnbind = __bind(this._closeAndUnbind, this);
      this._windowKeyHandler = __bind(this._windowKeyHandler, this);
      this._windowClickHandler = __bind(this._windowClickHandler, this);      this._createDom();
      this._initEvents();
      _gaq.push(['_trackEvent', 'Introduce page', "Show 1 tip"]);
      _gaq.push(['_trackEvent', 'Introduce page', "Show introduce page"]);
    }

    Introduce.prototype._createDom = function() {
      var lang, slides;
      $(document.body).append(renderIntro({
        slidesCount: SLIDES_COUNT
      }));
      slides = $('.js-slides');
      this._container = $('.js-introduce');
      this._slidesContainer = this._container.find('.js-slides-container');
      this._close = this._container.find('.js-closer');
      this._prev = this._container.find('.js-prev');
      this._next = this._container.find('.js-next');
      this._sliderNav = this._container.find('.js-navigation');
      this._video = this._container.find('.js-video');
      this._slides = this._container.find('.js-slides');
      this._callout = this._container.find('.js-callout');
      lang = window.navigator.userLanguage || window.navigator.language;
      if (lang.search('ru') === -1) {
        this._callout.addClass('callout');
      } else {
        this._callout.addClass('callout-ru');
      }
      this._currentSlideIndex = 0;
      this._buttons = this._container.find('button');
      this._progressbarDivs = this._container.find('.js-progressbar').find('div');
      this._switchButton = this._container.find('.js-switch-link');
      return this._mode = MODES.image;
    };

    Introduce.prototype._initEvents = function() {
      var _this = this;
      $(window).bind('click', this._windowClickHandler);
      $(window).bind('keydown', this._windowKeyHandler);
      this._close.click(function() {
        return _this._closeAndUnbind();
      });
      this._switchButton.click(function(e) {
        if (e.which !== 1) return;
        switch (_this._mode) {
          case MODES.image:
            _gaq.push(['_trackEvent', 'Introduce page', 'Switch to video']);
            _this._video.width(_this._slides.outerWidth());
            _this._video.height(_this._slides.outerHeight());
            _this._slides.hide();
            if (!_this._video.html()) {
              _this._video.append(renderVideo({
                videoUrl: "I7whBwsGzM8"
              }));
            }
            _this._video.show();
            _this._video.find('iframe').show();
            _this._sliderNav.hide();
            _this._switchButton.find('div').text('Show picture');
            return _this._mode = MODES.video;
          case MODES.video:
            _gaq.push(['_trackEvent', 'Introduce page', 'Switch to picture']);
            _this._video.find('iframe').hide();
            _this._video.hide();
            _this._slides.show();
            _this._sliderNav.show();
            _this._switchButton.find('div').text('Play video');
            return _this._mode = MODES.image;
        }
      });
      this._next.click(function(e) {
        if (e.which !== 1 || _this._currentSlideIndex === SLIDES_COUNT - 1) return;
        return _this._changeSlide(_this._currentSlideIndex, _this._currentSlideIndex + 1);
      });
      this._prev.click(function(e) {
        if (e.which !== 1 || _this._currentSlideIndex === 0) return;
        return _this._changeSlide(_this._currentSlideIndex, _this._currentSlideIndex - 1);
      });
      return this._progressbarDivs.click(function(e) {
        return _this._changeSlide(_this._currentSlideIndex, _this._progressbarDivs.index(e.target));
      });
    };

    Introduce.prototype._changeSlide = function(currentIndex, newIndex) {
      if (newIndex === 0) {
        this._prev.attr('disabled', 'disabled');
      } else {
        this._prev.removeAttr('disabled');
      }
      if (newIndex === SLIDES_COUNT - 1) {
        this._next.attr('disabled', 'disabled');
      } else {
        this._next.removeAttr('disabled');
      }
      this._callout.removeClass("" + CALLOUT_SLIDE_CLASS_PREFIX + currentIndex);
      this._callout.addClass("" + CALLOUT_SLIDE_CLASS_PREFIX + newIndex);
      this._currentSlideIndex = newIndex;
      _gaq.push(['_trackEvent', 'Introduce page', "Show " + (this._currentSlideIndex + 1) + " tip"]);
      this._progressbarDivs.removeClass('active');
      return $(this._progressbarDivs[this._currentSlideIndex]).addClass('active');
    };

    Introduce.prototype._windowClickHandler = function(e) {
      if (e.which !== 1) return;
      if (!$.contains(this._slidesContainer[0], e.target)) {
        return this._closeAndUnbind();
      }
    };

    Introduce.prototype._windowKeyHandler = function(e) {
      if (e.which !== 27) return;
      return this._closeAndUnbind();
    };

    Introduce.prototype._closeAndUnbind = function() {
      $(window).unbind('click', this._windowClickHandler);
      $(window).unbind('keydown', this._windowKeyHandler);
      this._container.remove();
      return delete this;
    };

    return Introduce;

  })();

  exports.Introduce = Introduce;

}).call(this);

});

require.define("/lib/client/client/introduce/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ck, introduceTmpl, videoTmpl;

  ck = window.CoffeeKup;

  introduceTmpl = function() {
    return div('.js-introduce.introduce', function() {
      div('.background', '');
      return div('.js-slides-container.slides-container', function() {
        div('.js-slider-header.slider-header', function() {
          div('.switch-to-video', function() {
            return a('.switch-link.js-switch-link', function() {
              div('', 'Play video');
              return img('', {
                src: "/s/img/introduce/pv.png"
              });
            });
          });
          div('.js-navigation.navigation', function() {
            button('.js-prev.prev', {
              disabled: "disabled"
            }, function() {
              return div('', 'Prev tip');
            });
            div('.js-progressbar.progressbar', function() {
              var i, _ref, _results;
              div('.progressbar-round.active', '');
              _results = [];
              for (i = 2, _ref = this.slidesCount; 2 <= _ref ? i <= _ref : i >= _ref; 2 <= _ref ? i++ : i--) {
                _results.push(div('.progressbar-round', ''));
              }
              return _results;
            });
            button('.js-next.next', function() {
              return div('', 'Next tip');
            });
            return div('.clearer', '');
          });
          button('.js-closer.closer', function() {
            div('.close-txt', 'Check it later');
            img('.close-img', {
              src: '/s/img/introduce/close.png'
            });
            return div('.clearer', '');
          });
          return div('.clearer', '');
        });
        div(".js-slides.slide", function() {
          return div('.js-callout.callout.slide0', '');
        });
        return div(".js-video.video", '');
      });
    });
  };

  videoTmpl = function() {
    return iframe('', {
      width: "640",
      height: "480",
      src: "https://www.youtube.com/embed/" + this.videoUrl + "?fs=1&hl=en_En&color1=0x2b405b&color2=0x6b8ab6&autoplay=1&autohide=1&wmode=transparent",
      frameborder: "0",
      allowfullscreen: 'true',
      webkitallowfullscreen: 'true',
      mozallowfullscreen: 'true'
    });
  };

  exports.renderIntro = ck.compile(introduceTmpl);

  exports.renderVideo = ck.compile(videoTmpl);

}).call(this);

});

require.define("/lib/client/client/error_logger/module.js",function(require,module,exports,__dirname,__filename,process,global){
/*
Модуль для отправки ошибок, возникших на клиенте, на сервер
*/

(function() {
  var BaseModule, ErrorLogger, MAX_ERROR_LOGS, MAX_ERROR_LOGS_PERIOD, sendToServer,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  BaseModule = require('../../share/base_module').BaseModule;

  MAX_ERROR_LOGS = 10;

  MAX_ERROR_LOGS_PERIOD = 10 * 60 * 1000;

  sendToServer = function(data) {
    var settings;
    settings = {
      type: 'POST',
      contentType: 'application/json',
      data: JSON.stringify(data),
      processData: false
    };
    return $.ajax('/client-log/', settings);
  };

  ErrorLogger = (function(_super) {

    __extends(ErrorLogger, _super);

    function ErrorLogger() {
      var args,
        _this = this;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      ErrorLogger.__super__.constructor.apply(this, args);
      this._errorsLogged = 0;
      this._lastErrorLoggedRefreshTime = Date.now();
      window.onerror = function(message, url, line) {
        var data;
        data = _this._getErrorData(message);
        if (!(data != null)) return;
        data.isUncaught = true;
        if ((url != null) || (line != null)) {
          data.source = (url || '') + ':' + (line || '0');
        }
        _this._logData(data);
        try {
          console.error("Uncaught error:", message, url, line);
        } catch (_error) {}
        return false;
      };
    }

    ErrorLogger.prototype.logError = function(e) {
      var data;
      data = this._getErrorData(e);
      if (!(data != null)) return;
      return this._logData(data);
    };

    ErrorLogger.prototype._logData = function(data) {
      if (Date.now() - this._lastErrorLoggedRefreshTime > MAX_ERROR_LOGS_PERIOD) {
        this._errorsLogged = 0;
        this._lastErrorLoggedRefreshTime = Date.now();
      }
      if (this._errorsLogged >= MAX_ERROR_LOGS) return;
      this._errorsLogged++;
      return sendToServer(data);
    };

    ErrorLogger.prototype._getErrorData = function(e) {
      var data;
      if (e instanceof Error) {
        data = {
          code: e.code,
          message: e.message,
          stacktrace: e.stack
        };
      } else if (typeof e === 'string') {
        data = {
          message: e
        };
      }
      if (!(data != null)) return null;
      data.codeVersion = window.versionString;
      return data;
    };

    return ErrorLogger;

  })(BaseModule);

  module.exports = {
    ErrorLogger: ErrorLogger
  };

}).call(this);

});

require.define("/lib/client/client/playback/module.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BaseModule, Playback, PlaybackWaveViewModel, Request, render,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  BaseModule = require('../../share/base_module').BaseModule;

  Request = require('../../share/communication').Request;

  PlaybackWaveViewModel = require('./wave_view_model').PlaybackWaveViewModel;

  render = window.CoffeeKup.compile(function() {
    return div('.playback-container js-playback-container search', function() {
      div('.message-container js-message-container', function() {
        div('Loading playback date');
        return div('.wait-icon', {
          title: 'Loading topic'
        });
      });
      return div('.js-playback-topic-container.playback-topic-container', function() {});
    });
  });

  Playback = (function(_super) {

    __extends(Playback, _super);

    function Playback() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      Playback.__super__.constructor.apply(this, args);
      this._waveProcessor = require('../wave/processor').instance;
      this._createDOM();
    }

    Playback.prototype._createDOM = function() {
      this._$container = $(render());
      this._$messageContainer = this._$container.find('.js-message-container');
      this._container = this._$container[0];
      return this._$resizer = $('.js-resizer');
    };

    Playback.prototype.showPlaybackView = function(request) {
      var blipId, waveId, waveViewModel,
        _this = this;
      waveId = request.args.waveId;
      blipId = request.args.blipId;
      waveViewModel = request.args.waveViewModel;
      request = new Request({
        container: this._container
      });
      this.hidePlaybackView();
      this._rootRouter.handle('navigation.showPlaybackView', request);
      this._$resizer.hide(null, true);
      this._$messageContainer.show();
      return this._waveProcessor.getPlaybackData(waveId, blipId, function(err, waveData, waveBlips) {
        _this._$messageContainer.hide();
        _this._$resizer.show().addClass('playback');
        if (err) return console.log(err);
        return _this._viewModel = new PlaybackWaveViewModel(_this._waveProcessor, waveData, waveBlips, false, _this, waveViewModel, blipId);
      });
    };

    Playback.prototype.hidePlaybackView = function(request, destroyOnly) {
      var _ref;
      if ((_ref = this._viewModel) != null) _ref.destroy();
      delete this._viewModel;
      if (destroyOnly) return;
      $('.js-resizer').removeClass('playback');
      request = new Request({
        containerClass: '.js-playback-container'
      });
      return this._rootRouter.handle('navigation.hidePlaybackView', request);
    };

    Playback.prototype.getWaveContainer = function() {
      return $(this._container).find('.js-playback-topic-container')[0];
    };

    return Playback;

  })(BaseModule);

  module.exports.Playback = Playback;

}).call(this);

});

require.define("/lib/client/client/modules/navigation.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var BLIP_READ_STATE, BaseModule, History, LocalStorage, Navigation, NavigationPanel, Request, WAVE_SHARED_STATE_PUBLIC, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  BaseModule = require('../../share/base_module').BaseModule;

  NavigationPanel = require('../navigation').NavigationPanel;

  History = require('../utils/history_navigation');

  _ref = require('../utils/localStorage'), LocalStorage = _ref.LocalStorage, BLIP_READ_STATE = _ref.BLIP_READ_STATE;

  WAVE_SHARED_STATE_PUBLIC = require('../wave/model').WAVE_SHARED_STATE_PUBLIC;

  Request = require('../../share/communication').Request;

  Navigation = (function(_super) {

    __extends(Navigation, _super);

    function Navigation() {
      var args,
        _this = this;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._processTabShow = __bind(this._processTabShow, this);
      this._initGlobalNextUnread = __bind(this._initGlobalNextUnread, this);
      this._processReadStateChange = __bind(this._processReadStateChange, this);
      Navigation.__super__.constructor.apply(this, args);
      this._panelContainer = $('#navigation-panel')[0];
      this._panel = require('../navigation').instance = new NavigationPanel(this._panelContainer);
      this._panel.on('tab-show', this._processTabShow);
      this._$globalNextUnread = $('#global-next-unread');
      this._$globalNextUnread.on('mousedown', function() {
        return _gaq.push(['_trackEvent', 'Topic content', 'Next unread click', 'Next unread through topic']);
      });
      this._panel.getTopicsPanel().on('topicsLoaded', this._initGlobalNextUnread);
      this._panel.getTopicsPanel().on('unreadCountUpdate', this._initGlobalNextUnread);
      LocalStorage.on(BLIP_READ_STATE, this._processReadStateChange);
    }

    Navigation.prototype._processReadStateChange = function(changeInfo) {
      var blipId, isRead, totalBlipsCount, unreadBlipsCount, waveId;
      waveId = changeInfo.waveId, blipId = changeInfo.blipId, isRead = changeInfo.isRead, unreadBlipsCount = changeInfo.unreadBlipsCount, totalBlipsCount = changeInfo.totalBlipsCount;
      this._panel.updateBlipIsRead(waveId, blipId, isRead);
      return this._panel.updateTopicsUnreadCount(waveId, unreadBlipsCount, totalBlipsCount);
    };

    Navigation.prototype._initGlobalNextUnread = function() {
      var nextUnread,
        _this = this;
      nextUnread = this._panel.getTopicsPanel().findNextUnreadTopic();
      if (nextUnread) {
        this._$globalNextUnread.on('mousedown.globalNextUnread', function() {
          _this._disableGlobalNextUnreadButton();
          History.navigateTo(History.parseUrlParams(nextUnread.href).waveId);
          _this._panel.getTopicsPanel().setActiveItem(true);
          return _this._$globalNextUnread.hide();
        });
        return this._enableGlobalNextUnreadButton();
      } else {
        return this._disableGlobalNextUnreadButton();
      }
    };

    Navigation.prototype._disableGlobalNextUnreadButton = function() {
      this._$globalNextUnread.addClass('disabled');
      return this._$globalNextUnread.attr('disabled', 'disabled');
    };

    Navigation.prototype._enableGlobalNextUnreadButton = function() {
      this._$globalNextUnread.removeClass('disabled');
      return this._$globalNextUnread.removeAttr('disabled');
    };

    Navigation.prototype.updateTagList = function(request) {
      return this._panel.getTopicsPanel().updateTagList(request.args.tags);
    };

    Navigation.prototype.updateTaskInfo = function(request) {
      var _ref2;
      return (_ref2 = this._panel.getTasksPanel()) != null ? _ref2.updateTaskInfo(request.args.taskInfo) : void 0;
    };

    Navigation.prototype.loadTopicList = function(request) {
      var topics;
      topics = this._panel.getTopicsPanel().getLastSearchResults();
      return request.callback(null, topics);
    };

    Navigation.prototype.findTopicListByTagText = function(request) {
      if (request.args.sharedState === WAVE_SHARED_STATE_PUBLIC) {
        this._panel.showPublicTopicPanel();
        return this._panel.getPublicTopicsPanel().findTopicListByText(request.args.text);
      } else {
        this._panel.showTopicPanel();
        return this._panel.getTopicsPanel().findTopicListByText(request.args.text);
      }
    };

    Navigation.prototype.addCollection = function(request) {
      return this._panel.addCollection(request.args.container);
    };

    Navigation.prototype.showPlaybackView = function(request) {
      return this._panel.showPlaybackView(request.args.container);
    };

    Navigation.prototype.hidePlaybackView = function(request) {
      return this._panel.hidePlaybackView(request.args.containerClass);
    };

    Navigation.prototype._processTabShow = function(tabClass) {
      this._rootRouter.handle('playback.hidePlaybackView', new Request());
      if (tabClass !== '.js-collection') return;
      return this._rootRouter.handle('collection.load', new Request());
    };

    return Navigation;

  })(BaseModule);

  module.exports.Navigation = Navigation;

}).call(this);

});

require.define("/lib/client/client/modules/page_error/index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var AccountMergePopup, AnonymousNotification, BaseModule, History, NEED_MERGE_ERROR_CODE, PageError, renderError,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = Array.prototype.slice;

  BaseModule = require('../../../share/base_module').BaseModule;

  renderError = require('./template').renderError;

  AnonymousNotification = require('../../wave/notification/anonymous_notification').AnonymousNotification;

  NEED_MERGE_ERROR_CODE = require('../../../share/constants').NEED_MERGE_ERROR_CODE;

  AccountMergePopup = require('../../account_merge').AccountMergePopup;

  History = require('../../utils/history_navigation');

  PageError = (function(_super) {

    __extends(PageError, _super);

    /*
        Модуль для отображения ошибок страницы, которые требуют перезагрузки страницы
    */

    function PageError() {
      var args,
        _this = this;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._processRefreshLinkClick = __bind(this._processRefreshLinkClick, this);
      PageError.__super__.constructor.apply(this, args);
      this._errorShown = false;
      $(document).ready(function() {
        return _this._createDOM();
      });
    }

    PageError.prototype._createDOM = function() {
      /*
              Создает необходимые элементы для отображения ошибки
      */      this._container = $('.js-page-error-container')[0];
      this._text = $('.js-page-error')[0];
      if (this._errorShown) return this.showError();
    };

    PageError.prototype._updateRefreshLink = function() {
      /*
              Обновляет ссылку "Обновить" для того, чтобы пользователь попал на ту же
              страницу после ее нажатия
      */      if (!this._refreshLink) return;
      return this._refreshLink.href = location.href;
    };

    PageError.prototype._processRefreshLinkClick = function(event) {
      /*
              Обрабатывает нажатие на ссылку "Обновить". Сам браузер не перезагружает страницу
              при клике на эту ссылку.
      */      event.preventDefault();
      return location.reload();
    };

    PageError.prototype.showError = function(request, args, callback) {
      /*
              Показывает ошибку на странице, предлагает пользователю обновить страницу
      */
      var c, msg;
      if (request.args.error.code === 'wave_anonymous_permission_denied') {
        window.AuthDialog.initAndShow(false, History.getLoginRedirectUrl());
        return;
      }
      if (request.args.error.code === NEED_MERGE_ERROR_CODE) {
        (new AccountMergePopup(request.args.error.message)).show();
        return;
      }
      this._errorShown = true;
      if (!this._container) return;
      if (!request.args.error.code) {
        if (typeof request.args.error === 'string') {
          msg = request.args.error;
        } else if (request.args.error.msg != null) {
          msg = request.args.error.msg;
        } else if (request.args.error.message != null) {
          msg = request.args.error.message;
        } else {
          msg = 'showError (I)';
        }
        if (/Deleted text .+ is not equal to text in operation/.test(msg)) {
          msg = 'Deleteted text is not equal to text in operation';
        } else if (/Text block params .+ do not equal to op params/.test(msg)) {
          msg = 'Text block params do not equal to op params';
        } else if (/Expected version .+ but got/.test(msg)) {
          msg = 'Expected version X but got Y';
        } else if (/Specified position .+ is more then text length/.test(msg)) {
          msg = 'Specified position X is more then text length N';
        }
        _gaq.push(['_trackEvent', 'Error', 'Client error', msg]);
      }
      this.__logError(request.args.error);
      c = $(this._text);
      c.empty();
      c.append(renderError(request.args));
      $(this._container).addClass('error-shown');
      this._refreshLink = c.find('.js-refresh-link')[0];
      $(window).bind('hashchange', this._updateRefreshLink);
      $(this._refreshLink).bind('click', this._processRefreshLinkClick);
      return this._updateRefreshLink();
    };

    PageError.prototype.__logError = function(error) {
      return require('../../error_logger/module').instance.logError(error);
    };

    return PageError;

  })(BaseModule);

  module.exports.PageError = PageError;

}).call(this);

});

require.define("/lib/client/client/modules/page_error/template.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var ck, errorTmpl;

  ck = window.CoffeeKup;

  errorTmpl = function() {
    /*
        Шаблон ошибки на странице
    */
    var code;
    if (this.error && this.error.logId) {
      code = ' with the code: ' + this.error.logId;
    } else {
      code = '';
    }
    text(h("An unknown error occurred" + code + "."));
    br('', '');
    text(h("Please "));
    return a('.js-refresh-link', 'refresh page');
  };

  exports.renderError = ck.compile(errorTmpl);

}).call(this);

});

require.define("/lib/client/client/wave/notification/anonymous_notification.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var AnonymousNotification, CALL_TO_ACTION_VARIANT_A, CALL_TO_ACTION_VARIANT_B, History, renderAnonymousNotification;

  renderAnonymousNotification = require('./template').renderAnonymousNotification;

  History = require('../../utils/history_navigation');

  CALL_TO_ACTION_VARIANT_A = ['Sign in to view and comment'];

  CALL_TO_ACTION_VARIANT_B = ['Anonymous access is disabled', 'Sign in to view the discussion'];

  AnonymousNotification = (function() {
    /*
        Класс, выдающий уведомление о необходимости авторизоваться
    */
    function AnonymousNotification() {
      /*
              @param _error: object, объект ошибки
      */      this._$container = $(document.body);
      this._$container.find('.js-anonymous-notification-container').remove();
      this._$container.find('.js-log-out-container').remove();
      this._createDOM();
    }

    AnonymousNotification.prototype._createDOM = function() {
      /*
              Создает DOM для показа уведомления
      */
      var callToAction, redirectUrl, urlParams, varStr, variant;
      urlParams = History.getCurrentParams();
      variant = Math.round(Math.random()) === 1;
      if (variant) {
        varStr = '"Anonymous access" slogan';
        callToAction = CALL_TO_ACTION_VARIANT_B;
      } else {
        varStr = '"sign in" slogan';
        callToAction = CALL_TO_ACTION_VARIANT_A;
      }
      _gaq.push(['_setCustomVar', 5, 'topic landing', varStr, 2]);
      _gaq.push(['_trackPageview', '/unauthorized' + document.location.pathname + document.location.search]);
      if (window.cleanupAnalytics && document.location.search) {
        _gaq.push(window.cleanupAnalytics);
      }
      redirectUrl = History.getLoginRedirectUrl();
      return this._$container.append(renderAnonymousNotification({
        callToAction: callToAction,
        redirectUrl: redirectUrl,
        variant: variant
      }));
    };

    return AnonymousNotification;

  })();

  module.exports.AnonymousNotification = AnonymousNotification;

}).call(this);

});

require.define("/lib/client/client_index.js",function(require,module,exports,__dirname,__filename,process,global){(function() {

  window.cleanupAnalytics = function() {
    try {
      return require('./client/utils/history_navigation').removeAnalytics();
    } catch (e) {

    }
  };

  require('./client/app');

}).call(this);

});
require("/lib/client/client_index.js");
})();
